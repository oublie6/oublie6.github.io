<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>Python-第三方库-mininet-Mininet简介 - Oublie的Hugo博客</title><meta name="Description" content="Oublie的Hugo博客"><meta property="og:title" content="Python-第三方库-mininet-Mininet简介" />
<meta property="og:description" content="mininet简介 github 什么是迷你网？ Mininet 是一个网络仿真器，或者更准确地说是一个 网络仿真编排系统。它在单个 Linux 内核上运行终端主机、交换机、路由器和链" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://oublie6.github.io/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/" /><meta property="og:image" content="https://oublie6.github.io/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-29T11:18:06+08:00" />
<meta property="article:modified_time" content="2022-11-29T11:18:06+08:00" /><meta property="og:site_name" content="我的网站" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://oublie6.github.io/logo.png"/>

<meta name="twitter:title" content="Python-第三方库-mininet-Mininet简介"/>
<meta name="twitter:description" content="mininet简介 github 什么是迷你网？ Mininet 是一个网络仿真器，或者更准确地说是一个 网络仿真编排系统。它在单个 Linux 内核上运行终端主机、交换机、路由器和链"/>
<meta name="application-name" content="LoveIt">
<meta name="apple-mobile-web-app-title" content="LoveIt"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="icon" href="/images/%e5%a4%b4%e5%83%8f.jpeg"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://oublie6.github.io/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/" /><link rel="prev" href="https://oublie6.github.io/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/" /><link rel="next" href="https://oublie6.github.io/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/git%E4%B8%A2%E5%BC%83%E5%8E%86%E5%8F%B2commit/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"></noscript><link rel="preload" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Python-第三方库-mininet-Mininet简介",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/oublie6.github.io\/posts\/python\/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93\/mininet\/mininet%E7%AE%80%E4%BB%8B\/"
        },"genre": "posts","keywords": "mininet","wordcount":  12637 ,
        "url": "https:\/\/oublie6.github.io\/posts\/python\/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93\/mininet\/mininet%E7%AE%80%E4%BB%8B\/","datePublished": "2022-11-29T11:18:06+08:00","dateModified": "2022-11-29T11:18:06+08:00","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "oublie"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('light' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'light' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Oublie的Hugo博客">Oublie的Hugo博客</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/about/"> 关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="Search">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="Clear">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Oublie的Hugo博客">Oublie的Hugo博客</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="Search">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="Clear">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        Cancel
                    </a>
                </div><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/about/" title="">关于</a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><div class="search-dropdown desktop">
        <div id="search-dropdown-desktop"></div>
    </div>
    <div class="search-dropdown mobile">
        <div id="search-dropdown-mobile"></div>
    </div><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Python-第三方库-mininet-Mininet简介</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://oublie6.github.io/" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>oublie</a></span>&nbsp;<span class="post-category">included in <a href="/categories/python/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>Python</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2022-11-29">2022-11-29</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;12637 words&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;26 minutes&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="true">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#什么是迷你网">什么是迷你网？</a></li>
    <li><a href="#为什么-mininet-很酷">为什么 Mininet 很酷？</a></li>
    <li><a href="#mininet-的局限性是什么">Mininet 的局限性是什么？</a></li>
    <li><a href="#使用-mininet">使用 Mininet</a>
      <ul>
        <li><a href="#创建拓扑">创建拓扑</a></li>
        <li><a href="#注意mininet和构造函数">注意：Mininet()和构造函数</a></li>
        <li><a href="#仅限早期-mininet-版本10-和-20的拓扑说明">仅限早期 Mininet 版本（1.0 和 2.0）的拓扑说明</a></li>
        <li><a href="#脚本输出">脚本输出</a></li>
        <li><a href="#设置性能参数">设置性能参数</a></li>
        <li><a href="#在主机中运行程序">在主机中运行程序</a></li>
        <li><a href="#新popenpexec界面">新：popen()/pexec()界面</a></li>
        <li><a href="#重要共享文件系统">重要：共享文件系统！</a></li>
        <li><a href="#主机配置方法">主机配置方法</a></li>
        <li><a href="#在-mininet-中命名">在 Mininet 中命名</a></li>
        <li><a href="#命令行界面">命令行界面</a></li>
        <li><a href="#mn使用--custom文件自定义">mn使用&ndash;custom文件自定义</a>
          <ul>
            <li><a href="#--custom在文件中添加新的-cli-命令">&ndash;custom在文件中添加新的 CLI 命令</a></li>
          </ul>
        </li>
        <li><a href="#其他示例">其他示例</a></li>
        <li><a href="#了解-mininet-api">了解 Mininet API</a>
          <ul>
            <li><a href="#低级-api节点和链接">低级 API：节点和链接</a></li>
            <li><a href="#中级-api网络对象">中级 API：网络对象</a></li>
            <li><a href="#高级-api拓扑模板">高级 API：拓扑模板</a></li>
            <li><a href="#mininet-api-文档">Mininet API 文档</a></li>
            <li><a href="#测试性能">测试性能</a></li>
          </ul>
        </li>
        <li><a href="#openflow-和自定义路由">OpenFlow 和自定义路由</a>
          <ul>
            <li><a href="#openflow控制器">OpenFlow控制器</a></li>
            <li><a href="#外部-openflow-控制器">外部 OpenFlow 控制器</a></li>
            <li><a href="#通过传入控制器对象滥用-api">通过传入控制器对象滥用 API</a></li>
            <li><a href="#多路径路由">多路径路由</a></li>
          </ul>
        </li>
        <li><a href="#更新-mininet">更新 Mininet</a></li>
        <li><a href="#学习python">学习Python</a></li>
        <li><a href="#使用-mininet-的有用背景">使用 Mininet 的有用背景</a></li>
        <li><a href="#有用的-python-资源">有用的 Python 资源</a></li>
        <li><a href="#它是如何工作的可选出于好奇">它是如何工作的？（可选：出于好奇）</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><p><a href="https://github.com/mininet/mininet/wiki/Introduction-to-Mininet" target="_blank" rel="noopener noreffer ">mininet简介 github</a></p>
<h2 id="什么是迷你网">什么是迷你网？</h2>
<p>Mininet 是一个网络仿真器，或者更准确地说是一个 网络仿真编排系统。它在单个 Linux 内核上运行终端主机、交换机、路由器和链路的集合。它使用轻量级虚拟化使单个系统看起来像一个完整的网络，运行相同的内核、系统和用户代码。Mininet 主机的行为就像一台真实的机器；你可以ssh进入它（如果你启动 sshd并将网络桥接到您的主机）并运行任意程序（包括安装在底层 Linux 系统上的任何程序。）您运行的程序可以通过看似真实的以太网接口发送数据包，具有给定的链接速度和延迟。数据包由看起来像真正的以太网交换机、路由器或中间盒的东西处理，并进行一定数量的排队。当两个程序（如 iperf客户端和服务器）通过 Mininet 进行通信时，测得的性能应该与两台（较慢的）本地机器的性能相匹配。</p>
<p>简而言之，Mininet 的虚拟主机、交换机、链路和控制器是真实存在的——它们只是使用软件而不是硬件创建的——并且在大多数情况下，它们的行为类似于离散的硬件元素。通常可以创建类似于硬件网络的 Mininet 网络，或类似于 Mininet 网络的硬件网络，并在任一平台上运行相同的二进制代码和应用程​​序。</p>
<h2 id="为什么-mininet-很酷">为什么 Mininet 很酷？</h2>
<ol>
<li>它很快——启动一个简单的网络只需几秒钟。这意味着您的运行-编辑-调试循环可以非常快。</li>
<li>您可以创建自定义拓扑：单个交换机、更大的类似 Internet 的拓扑、斯坦福骨干网、数据中心或其他任何东西。</li>
<li>您可以运行真正的程序：任何在 Linux 上运行的程序都可以运行，从 Web 服务器到 TCP 窗口监控工具再到 Wireshark。</li>
<li>您可以自定义数据包转发：Mininet 的交换机可以使用 OpenFlow 协议进行编程。在 Mininet 中运行的自定义软件定义网络设计可以轻松转移到硬件 OpenFlow 交换机以进行线速数据包转发。</li>
<li>您可以在笔记本电脑、服务器、虚拟机、本地 Linux 机器（Ubuntu 12.10+ 中包含 Mininet！）或云（例如 Amazon EC2）上运行 Mininet。</li>
<li>您可以共享和复制结果：一旦您将代码打包，任何拥有计算机的人都可以运行您的代码。</li>
<li>您可以轻松使用它：您可以通过编写简单（或必要时复杂）Python 脚本来创建和运行 Mininet 实验。</li>
<li>Mininet 是一个开源项目，因此我们鼓励您在https://github.com/mininet上检查其源代码、修改它、修复错误、文件问题/功能请求以及提交补丁/拉取请求。您还可以编辑此文档以修复任何错误或添加说明或其他信息。</li>
<li>Mininet正在积极开发中。所以，如果它很糟糕，没有意义，或者由于某种原因不起作用，请告诉我们mininet-discuss ，Mininet 用户和开发人员社区可以尝试解释、修复或帮助您修复它。:-) 如果您发现错误，我们鼓励您提交补丁来修复它们，或者至少在 github 上提交一个问题，包括一个可重现的测试用例。</li>
</ol>
<h2 id="mininet-的局限性是什么">Mininet 的局限性是什么？</h2>
<p>尽管我们认为 Mininet 很棒，但它确实有一些局限性。例如，</p>
<ul>
<li>在单个系统上运行很方便，但它施加了资源限制：如果您的服务器有 3 GHz 的 CPU 并且可以交换大约 10 Gbps 的模拟流量，那么这些资源将需要在您的虚拟主机和交换机之间进行平衡和共享。</li>
<li>Mininet 为所有虚拟主机使用单个 Linux 内核；这意味着您不能运行依赖于 BSD、Windows 或其他操作系统内核的软件。（尽管您可以将 VM 附加到 Mininet。）</li>
<li>Mininet 不会为您编写 OpenFlow 控制器；如果您需要自定义路由器或交换机行为，则需要查找或开发具有所需功能的控制器。</li>
<li>默认情况下，您的 Mininet 网络与您的 LAN 和 Internet 隔离 - 这通常是一件好事！但是，您可以使用该 NAT对象和/或&ndash;nat选项通过网络地址转换将您的 Mininet 网络连接到您的 LAN。您还可以将真实（或虚拟）硬件接口附加到您的 Mininet 网络（有关详细信息，请参阅 examples/hwintf.py。）</li>
<li>默认情况下，所有 Mininet 主机共享主机文件系统和 PID 空间；这意味着如果您正在运行需要在 /etc 中配置的守护进程，您可能必须小心，并且您需要小心不要错误地杀死错误的进程。（请注意该bind.py 示例演示了如何拥有每个主机的私有目录。）</li>
<li>与模拟器不同，Mininet 没有强烈的虚拟时间概念；这意味着时序测量将基于实时，并且无法轻易模拟比实时更快的结果（例如 100 Gbps 网络）。</li>
</ul>
<p>关于性能的旁白：对于网络受限的实验，您必须牢记的主要事情是您可能需要使用较慢的链接，例如 10 或 100 Mb/秒而不是 10 Gb/秒，因为数据包由一组共享 CPU 和内存资源的软件交换机（例如 Open vSwitch）转发，通常性能低于专用交换硬件。对于 CPU 限制的实验，您还需要确保仔细限制 Mininet 主机的 CPU 带宽。如果您主要关心功能的正确性，则可以在没有特定带宽限制的情况下运行 Mininet - 这是运行 Mininet 的快速简便的方法，并且它还以牺牲负载下的计时精度为代价提供最高的性能。</p>
<p>除了少数例外，您可能遇到的许多限制都不是 Mininet 固有的；消除它们可能只是代码问题，我们鼓励您贡献您可能开发的任何增强功能！</p>
<h2 id="使用-mininet">使用 Mininet</h2>
<p>以下部分描述了 Mininet（及其 Python API）的几个功能，您可能会发现这些功能很有用。</p>
<h3 id="创建拓扑">创建拓扑</h3>
<p>Mininet 支持参数化拓扑。使用几行 Python 代码，您可以创建一个灵活的拓扑结构，该拓扑结构可以根据您传递给它的参数进行配置，并可重复用于多个实验。</p>
<p>例如，这是一个简单的网络拓扑（基于mininet/topo.py:SingleSwitchTopo），它由连接到单个交换机（s1）的指定数量的主机（h1通过hN）组成。</p>
<p>请注意，这是 Mininet 2.2 中引入的推荐（简化）拓扑语法：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">30
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">31
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#aaa;font-style:italic">#!/usr/bin/python                                                                            </span>
</span></span><span style="display:flex;"><span>                                                                                             
</span></span><span style="display:flex;"><span><span style="color:#00a">from</span> <span style="color:#0aa;text-decoration:underline">mininet.topo</span> <span style="color:#00a">import</span> Topo
</span></span><span style="display:flex;"><span><span style="color:#00a">from</span> <span style="color:#0aa;text-decoration:underline">mininet.net</span> <span style="color:#00a">import</span> Mininet
</span></span><span style="display:flex;"><span><span style="color:#00a">from</span> <span style="color:#0aa;text-decoration:underline">mininet.util</span> <span style="color:#00a">import</span> dumpNodeConnections
</span></span><span style="display:flex;"><span><span style="color:#00a">from</span> <span style="color:#0aa;text-decoration:underline">mininet.log</span> <span style="color:#00a">import</span> setLogLevel
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00a">class</span> <span style="color:#0a0;text-decoration:underline">SingleSwitchTopo</span>(Topo):
</span></span><span style="display:flex;"><span>    <span style="color:#a50">&#34;Single switch connected to n hosts.&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00a">def</span> <span style="color:#0a0">build</span>(self, n=<span style="color:#099">2</span>):
</span></span><span style="display:flex;"><span>        switch = self.addSwitch(<span style="color:#a50">&#39;s1&#39;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#aaa;font-style:italic"># Python&#39;s range(N) generates 0..N-1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#00a">for</span> h <span style="color:#00a">in</span> <span style="color:#0aa">range</span>(n):
</span></span><span style="display:flex;"><span>            host = self.addHost(<span style="color:#a50">&#39;h</span><span style="color:#a50">%s</span><span style="color:#a50">&#39;</span> % (h + <span style="color:#099">1</span>))
</span></span><span style="display:flex;"><span>            self.addLink(host, switch)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00a">def</span> <span style="color:#0a0">simpleTest</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#a50">&#34;Create and test a simple network&#34;</span>
</span></span><span style="display:flex;"><span>    topo = SingleSwitchTopo(n=<span style="color:#099">4</span>)
</span></span><span style="display:flex;"><span>    net = Mininet(topo)
</span></span><span style="display:flex;"><span>    net.start()
</span></span><span style="display:flex;"><span>    <span style="color:#0aa">print</span>( <span style="color:#a50">&#34;Dumping host connections&#34;</span> )
</span></span><span style="display:flex;"><span>    dumpNodeConnections(net.hosts)
</span></span><span style="display:flex;"><span>    <span style="color:#0aa">print</span>( <span style="color:#a50">&#34;Testing network connectivity&#34;</span> )
</span></span><span style="display:flex;"><span>    net.pingAll()
</span></span><span style="display:flex;"><span>    net.stop()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00a">if</span> __name__ == <span style="color:#a50">&#39;__main__&#39;</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#aaa;font-style:italic"># Tell mininet to print useful information</span>
</span></span><span style="display:flex;"><span>    setLogLevel(<span style="color:#a50">&#39;info&#39;</span>)
</span></span><span style="display:flex;"><span>    simpleTest()
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述代码中重要的类、方法、函数和变量包括：</p>
<ul>
<li>Topo: Mininet 拓扑的基类</li>
<li>build(): 在拓扑类中重写的方法。构造函数参数 (n) 将由Topo.<strong>init</strong>()自动传递给它。此方法创建一个模板（基本上是一个节点名称图和一个配置信息数据库），然后使用它来创建Mininet实际拓扑。</li>
<li>addSwitch(): 添加一个交换机到拓扑并返回交换机名称</li>
<li>addHost(): 将主机添加到拓扑并返回主机名</li>
<li>addLink()：添加双向链接到拓扑（并返回链接键，但这并不重要）。除非另有说明，否则 Mininet 中的链接是双向的。</li>
<li>Mininet: 创建和管理网络的主类</li>
<li>start(): 启动你的网络</li>
<li>pingAll()：通过尝试让所有节点相互 ping 来测试连通性</li>
<li>stop(): 停止你的网络</li>
<li>net.hosts：网络中的所有主机</li>
<li>dumpNodeConnections()：将连接转储到/来自一组节点。</li>
<li>setLogLevel( &lsquo;info&rsquo; | &lsquo;debug&rsquo; | &lsquo;output&rsquo; ): 设置 Mininet 的默认输出电平；建议使用“info”，因为它提供了有用的信息。</li>
</ul>
<p>可以在mininet/examples中找到其他示例代码。</p>
<h3 id="注意mininet和构造函数">注意：Mininet()和构造函数</h3>
<p>如果您是 Python 新手，这可能会造成混淆，但区分 构造函数（返回对象的函数）和对象（实际对象实例）很重要。</p>
<p>Mininet()是创建并返回网络对象的构造函数。Mininet它需要一些配置参数，特别是：</p>
<ul>
<li>topo：拓扑对象（不是构造函数或模板 - 实际对象！）</li>
<li>host：用于在拓扑中创建Host元素的构造函数</li>
<li>switch：用于在拓扑中创建Switch元素的构造函数</li>
<li>controller：用于在拓扑中创建Controller元素的构造函数</li>
<li>link: 用于在拓扑中创建 Link s 的构造函数、</li>
</ul>
<p>请注意，由于host、switch、controller和link是构造函数，因此不应直接调用它们。</p>
<p>例如，这是错误的：</p>
<pre tabindex="0"><code>net = Mininet( topo=SingleSwitchTopo(), switch=OVSSwitch(protocols=&#39;OpenFlow10&#39;) ... )
                                               ^ ERROR! Not a constructor function
</code></pre><p>但是，构造函数可能专门使用functools.partial：</p>
<pre tabindex="0"><code>from functools import partial

net = Mininet( topo=SingleSwitchTopo(), link=partial(TCLink,delay=&#39;30ms&#39;, bw=100) ... )
</code></pre><p>您还可以创建自己的构造函数或子类。请记住，将为拓扑中的每个网络元素调用构造函数。</p>
<p>请注意，Mininet 开发人员最终让步并允许您传入一个controller 对象或对象列表。这对于使用多个控制器的网络来说还算可以。控制器列表将传递给switch 构造函数。</p>
<h3 id="仅限早期-mininet-版本10-和-20的拓扑说明">仅限早期 Mininet 版本（1.0 和 2.0）的拓扑说明</h3>
<p>见官网</p>
<h3 id="脚本输出">脚本输出</h3>
<p>运行此脚本应该会产生类似于以下内容的结果：</p>
<pre tabindex="0"><code>$ sudo python simpletest.py
*** Creating network
*** Adding controller
*** Adding hosts:
h1 h2 h3 h4 
*** Adding switches:
s1 
*** Adding links:
(h1, s1) (h2, s1) (h3, s1) (h4, s1) 
*** Configuring hosts
h1 h2 h3 h4 
*** Starting controller
c0 
*** Starting 1 switches
s1 ...
Dumping host connections
h1 h1-eth0:s1-eth1
h2 h2-eth0:s1-eth2
h3 h3-eth0:s1-eth3
h4 h4-eth0:s1-eth4
Testing network connectivity
*** Ping: testing ping reachability
h1 -&gt; h2 h3 h4 
h2 -&gt; h1 h3 h4 
h3 -&gt; h1 h2 h4 
h4 -&gt; h1 h2 h3 
*** Results: 0% dropped (12/12 received)
*** Stopping 1 controllers
c0 
*** Stopping 4 links
....
*** Stopping 1 switches
s1 
*** Stopping 4 hosts
h1 h2 h3 h4 
*** Done
</code></pre><h3 id="设置性能参数">设置性能参数</h3>
<p>除了基本的行为网络之外，Mininet 还通过CPULimitedHost和TCLink 类提供性能限制和隔离功能。</p>
<p>这些类有多种使用方式，但一种简单的方法是将它们指定为默认宿主并将类/构造函数链接到Mininet()，然后在拓扑中指定适当的参数。（您还可以在拓扑本身中指定自定义类，或创建自定义节点和链接构造函数和/或子类。）</p>
<pre tabindex="0"><code>#!/usr/bin/python

from mininet.topo import Topo
from mininet.net import Mininet
from mininet.node import CPULimitedHost
from mininet.link import TCLink
from mininet.util import dumpNodeConnections
from mininet.log import setLogLevel

class SingleSwitchTopo( Topo ):
    &#34;Single switch connected to n hosts.&#34;
    def build( self, n=2 ):
	switch = self.addSwitch( &#39;s1&#39; )
	for h in range(n):
	    # Each host gets 50%/n of system CPU
	    host = self.addHost( &#39;h%s&#39; % (h + 1),
		                 cpu=.5/n )
	    # 10 Mbps, 5ms delay, 2% loss, 1000 packet queue
	    self.addLink( host, switch, bw=10, delay=&#39;5ms&#39;, loss=2,
                          max_queue_size=1000, use_htb=True )

def perfTest():
    &#34;Create network and run simple performance test&#34;
    topo = SingleSwitchTopo( n=4 )
    net = Mininet( topo=topo,
	           host=CPULimitedHost, link=TCLink )
    net.start()
    print( &#34;Dumping host connections&#34; )
    dumpNodeConnections( net.hosts )
    print( &#34;Testing network connectivity&#34; )
    net.pingAll()
    print( &#34;Testing bandwidth between h1 and h4&#34; )
    h1, h4 = net.get( &#39;h1&#39;, &#39;h4&#39; )
    net.iperf( (h1, h4) )
    net.stop()

if __name__ == &#39;__main__&#39;:
    setLogLevel( &#39;info&#39; )
    perfTest()
</code></pre><p>重要方法和参数：</p>
<p>self.addHost(name, cpu=f):这允许您指定将分配给虚拟主机的整个系统 CPU 资源的一部分。</p>
<p>self.addLink( node1, node2, bw=10, delay=&lsquo;5ms&rsquo;, max_queue_size=1000, loss=10, use_htb=True)：添加具有带宽、延迟和丢失特性的双向链接，使用分层令牌桶速率限制器和 netem 延迟/丢失模拟器，最大队列大小为 1000 个数据包。该参数bw以Mbit为单位的数字表示；delay表示为带有单位的字符串（例如“5ms”、“100us”、“1s”）；loss以百分比表示（介于 0 和 100 之间）；max_queue_size以数据包表示。</p>
<p>您可能会发现创建Python 字典非常有用，这样可以轻松地将相同的参数传递给多个方法调用，例如：</p>
<pre tabindex="0"><code>     linkopts = dict(bw=10, delay=&#39;5ms&#39;, loss=10, max_queue_size=1000, use_htb=True)
     # (or you can use brace syntax: linkopts = {&#39;bw&#39;:10, &#39;delay&#39;:&#39;5ms&#39;, ... } )
     self.addLink(node1, node2, **linkopts)
</code></pre><p>同样的技术(**dict)对于将选项传递给 Matplotlib 和其他库很有用。</p>
<p>net.get()：按名称检索节点（主机或交换机）对象。如果您想向主机发送命令（例如使用 host.cmd()）并获取其输出，这一点很重要。</p>
<p>注意：在 Mininet 的当前 master 分支中，您可以简单地使用大括号（例如net[&lsquo;h1&rsquo;]）按名称检索给定的节点。</p>
<h3 id="在主机中运行程序">在主机中运行程序</h3>
<p>在你的实验中你需要做的最重要的事情之一是在主机上运行程序，这样你就可以运行比 Mininet 本身提供的简单测试pingAll()和iperf()测试更多的测试。</p>
<p>每个 Mininet 主机本质上是一个附加到一个或多个网络接口的 bash shell 进程，因此与其交互的最简单方法是使用 cmd() 方法将输入发送到 shell。</p>
<p>要在主机中运行命令并获取输出，请使用cmd()方法。</p>
<pre tabindex="0"><code>    h1 = net.get(&#39;h1&#39;)	
    result = h1.cmd(&#39;ifconfig&#39;)
    print( result )
</code></pre><p>在许多情况下，您会希望在后台运行命令一段时间，然后停止该命令，并将其输出保存到一个文件中：</p>
<pre tabindex="0"><code>from time import sleep
...
print( &#34;Starting test...&#34; )
h1.cmd(&#39;while true; do date; sleep 1; done &gt; /tmp/date.out &amp;&#39;)
sleep(10)
print( &#34;Stopping test&#34; )
h1.cmd(&#39;kill %while&#39;)
print( &#34;Reading output&#34; )
f = open(&#39;/tmp/date.out&#39;)
lineno = 1
for line in f.readlines():
    print( &#34;%d: %s&#34; % ( lineno, line.strip() ) )
    lineno += 1
f.close()
</code></pre><p>请注意，我们使用 shell 的输出重定向功能将输出发送到/tmp/date.out，使用 shell 的后台执行功能在后台&amp;运行命令，并使用作业控制kill %while关闭在后台运行的程序。不幸的是，如果你让作业在后台运行，它们不能保证在 Mininet 退出时停止（无论是有意还是由于错误），所以你需要确保你完全停止所有作业。您可能希望定期使用 ps 命令来确保没有僵尸作业在无意识地向前推进并减慢您的 EC2 实例。</p>
<p>（注意：Python 字符串可以使用单引号或双引号分隔。上面的示例在 print 语句中使用双引号，在函数参数中使用单引号，但您可以随心所欲。Python 2 的print语句 [和 Python 3 的print()函数] 存在于方便，并可能帮助 BASIC 程序员感觉更自在。）</p>
<p>拥有一个 shell 进程可以让您轻松执行其他任务。例如，您可以使用以下命令找出后台命令的 PID</p>
<pre tabindex="0"><code>pid = int( h1.cmd(&#39;echo $!&#39;) )
</code></pre><p>然后你可以使用 wait 等待特定进程完成执行，例如：</p>
<pre tabindex="0"><code>h1.cmd(&#39;wait&#39;, pid)
</code></pre><p>请注意，这仅适用于 UNIX 命令，不适用于内置于 bash shell 本身（并且没有单独的 pid！）的命令（例如while，cd）。还要注意，这些命令中的每一个都在前台执行（没有&amp;）而不是后台 (&amp;)，因为我们想要获得输出。</p>
<p>除了使用 shell 的等待机制之外，Mininet 本身还允许您使用以下命令启动前台命令sendCmd()，然后等待它在稍后的某个时间完成waitOutput()：</p>
<pre tabindex="0"><code>for h in hosts:
    h.sendCmd(&#39;sleep 20&#39;)
…
results = {}
for h in hosts:
    results[h.name] = h.waitOutput()
</code></pre><p>如果将输出发送到文件，您可能希望在测试运行时以交互方式监视该文件的内容。该 examples/multipoll.py 示例提供了一个函数，该函数monitorFiles()实现了一种可能的机制来监视多个输出文件。这简化了交互式监视来自多个主机的输出的测试的实现：</p>
<pre tabindex="0"><code>def monitorTest( N=3, seconds=3 ):
    &#34;Run pings and monitor multiple hosts&#34;
    topo = SingleSwitchTopo( N )
    net = Mininet( topo )
    net.start()
    hosts = net.hosts
    print( &#34;Starting test...&#34; )
    server = hosts[ 0 ]
    outfiles, errfiles = {}, {}
    for h in hosts:
        # Create and/or erase output files
        outfiles[ h ] = &#39;/tmp/%s.out&#39; % h.name
        errfiles[ h ] = &#39;/tmp/%s.err&#39; % h.name
        h.cmd( &#39;echo &gt;&#39;, outfiles[ h ] )
        h.cmd( &#39;echo &gt;&#39;, errfiles[ h ] )
        # Start pings
        h.cmdPrint(&#39;ping&#39;, server.IP(),
                   &#39;&gt;&#39;, outfiles[ h ],
                   &#39;2&gt;&#39;, errfiles[ h ],
                   &#39;&amp;&#39; )
    print( &#34;Monitoring output for&#34;, seconds, &#34;seconds&#34; )
    for h, line in monitorFiles( outfiles, seconds, timeoutms=500 ):
        if h:
            print( &#39;%s: %s&#39; % ( h.name, line ) )
    for h in hosts:
        h.cmd(&#39;kill %ping&#39;)
    net.stop()
</code></pre><p>您可能希望运行multipoll.py并查看其输出。</p>
<p>另一个示例examples/multiping.py 演示了一种不同的（可能更简单但不太灵活）方法来监视来自主机的标准输出，使用Node.monitor()方法，因此您可能也希望查看它。</p>
<h3 id="新popenpexec界面">新：popen()/pexec()界面</h3>
<p>除了cmd()/sendCmd()的基于 shell 的机制之外，Mininet 现在还支持返回标准 Python Popen()对象的基于管道的接口（有关详细信息，请参阅 Python 的 subprocess 模块。）该机制较新且没有经过充分测试cmd()，但您可能会发现在后台运行多个进程并监视它们的输出很方便。提供了一个pmonitor()功能，Popen()可以更轻松地监视多个对象。</p>
<p>examples/popenpoll.py中的代码使用popen()接口和pmonitor()辅助函数实现与上述类似的功能：</p>
<pre tabindex="0"><code>def pmonitorTest( N=3, seconds=10 ):
    &#34;Run pings and monitor multiple hosts using pmonitor&#34;
    topo = SingleSwitchTopo( N )
    net = Mininet( topo )
    net.start()
    hosts = net.hosts
    print( &#34;Starting test...&#34; )
    server = hosts[ 0 ]
    popens = {}
    for h in hosts:
        popens[ h ] = h.popen(&#39;ping&#39;, server.IP() )
        print( &#34;Monitoring output for&#34;, seconds, &#34;seconds&#34; )
        endTime = time() + seconds
        for h, line in pmonitor( popens, timeoutms=500 ):
            if h:
                print( &#39;%s: %s&#39; % ( h.name, line ), )
                if time() &gt;= endTime:
                    for p in popens.values():
                        p.send_signal( SIGINT )
        net.stop()
</code></pre><p>请注意，此实现略有不同，因为它将时间管理从pmonitor()辅助函数中提取出来，但这使得ping能够在它被中断后捕获它的输出。</p>
<p>当然，您不必使用pmonitor()- 您可以使用 Popen.communicate()（只要您没有太多文件描述符）或select.poll()以及任何其他有效的机制。</p>
<h3 id="重要共享文件系统">重要：共享文件系统！</h3>
<p>要记住的一件事是，默认情况下 Mininet 主机共享底层服务器的根文件系统。通常这是一件非常好的事情，因为为每个 Mininet 主机创建一个单独的文件系统是一件非常痛苦的事情（而且很慢）（如果你愿意，你可以这样做，然后 chroot 进去！）</p>
<p>共享根文件系统还意味着您几乎不需要在 Mininet 主机之间复制数据，因为它已经存在。</p>
<p>然而，这样做的一个副作用是主机共享 Mininet 服务器的 /etc目录。这意味着如果您需要对程序进行特定配置（例如httpd），那么您可能需要为每个 Mininet 主机创建不同的配置文件，并将它们指定为您正在运行的程序的启动选项。</p>
<p>另一个副作用是，如果您尝试在多个主机上的同一目录中创建同一文件，则可能会发生文件冲突。</p>
<p>如果您需要每个主机的私有目录，您可以将它们指定为Host的选项，例如：</p>
<pre tabindex="0"><code>h = Host( &#39;h1&#39;, privateDirs=[ &#39;/some/directory&#39; ] )
</code></pre><p>有关详细信息，请参阅examples/bind.py。</p>
<h3 id="主机配置方法">主机配置方法</h3>
<p>Mininet hosts 提供了一些方便的网络配置方法：</p>
<ol>
<li>IP(): 返回主机或特定接口的 IP 地址。</li>
<li>MAC()：返回主机或特定接口的 MAC 地址。</li>
<li>setARP(): 将静态 ARP 条目添加到主机的 ARP 缓存中。</li>
<li>setIP()：设置主机或特定接口的 IP 地址。</li>
<li>setMAC()：设置主机或特定接口的MAC地址</li>
</ol>
<p>例如：</p>
<pre tabindex="0"><code>    print( &#34;Host&#34;, h1.name, &#34;has IP address&#34;, h1.IP(), &#34;and MAC address&#34;, h1.MAC() )
</code></pre><p>在任何情况下，如果您不提供特定接口（例如h1-eth0 或接口对象），该方法将使用主机的默认接口。以上函数定义在 mininet/node.py 中。</p>
<h3 id="在-mininet-中命名">在 Mininet 中命名</h3>
<p>为了有效地使用 Mininet，了解其主机、交换机和接口的命名方案非常重要。通常，主机被称为h1..hN，交换机被称为s1..sN。我们建议您遵循此约定或类似约定。为清楚起见，属于节点的接口以节点名称开头命名，例如h1-eth0是主机h1的默认接口，s1-eth1是交换机s1的第一个数据端口。主机接口仅在主机内部可见，但交换机数据端口在“根”命名空间中可见（您可以ip link show在 Mininet 运行时通过在另一个窗口中键入来查看它们。）因此，很容易检查交换机接口，但检查主机接口有点棘手（主要使用host.cmd())。</p>
<h3 id="命令行界面">命令行界面</h3>
<p>Mininet 包括一个可以在网络上调用的命令行界面 (CLI)，并提供各种有用的命令，以及显示 xterm 窗口和在网络中的各个节点上运行命令的能力。您可以通过将网络对象传递给CLI()构造函数来在网络上调用 CLI：</p>
<pre tabindex="0"><code>from mininet.topo import SingleSwitchTopo
from mininet.net import Mininet
from mininet.cli import CLI

net = Mininet(SingleSwitchTopo(2))
net.start()
CLI(net)
net.stop()
</code></pre><p>启动 CLI 可用于调试网络，因为它允许您查看网络拓扑（使用net命令）、测试连接性（使用pingall命令）以及向各个主机发送命令。</p>
<pre tabindex="0"><code>*** Starting CLI:
mininet&gt; net
c0
s1 lo:  s1-eth1:h1-eth0 s1-eth2:h2-eth0
h1 h1-eth0:s1-eth1
h2 h2-eth0:s1-eth2
mininet&gt; pingall
*** Ping: testing ping reachability
h1 -&gt; h2
h2 -&gt; h1
*** Results: 0% dropped (0/2 lost)
mininet&gt; h1 ip link show
746: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 16436 qdisc noqueue state UNKNOWN
	link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
749: h1-eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
	link/ether d6:13:2d:6f:98:95 brd ff:ff:ff:ff:ff:ff
</code></pre><h3 id="mn使用--custom文件自定义">mn使用&ndash;custom文件自定义</h3>
<p>除了用 Python 编写完整的 Mininet 脚本外，您还可以使用&ndash;custom选项扩展mn命令行工具。该选项允许您使用mn来调用您自己的自定义拓扑、交换机、主机、控制器或链接类。您还可以定义和调用自己的系统测试，并添加新的 Mininet CLI 命令。</p>
<p>要添加可以使用mn命令调用的新功能，您需要根据选项类型在&ndash;custom文件中定义一个字典。DICT的键是将其短名称传递给了适当的选项，并且值是相应的子类，构造函数或函数：</p>
<p><a href="https://github.com/mininet/mininet/wiki/Introduction-to-Mininet#customizing-mn-using---custom-files" target="_blank" rel="noopener noreffer ">图表</a></p>
<p>例如：</p>
<pre tabindex="0"><code>class MyTopo( Topo ):
   def build( self, ...):
def myTest( net ):
...
topos = { &#39;mytopo&#39;: MyTopo }
tests = { &#39;mytest&#39;: myTest }
</code></pre><p>这会将 MyTopo 类（或构造函数）添加到 topos 字典中，允许它与&ndash;topo选项以及新测试一起使用mytest。请注意，测试函数是使用顶级Mininet对象调用的，您可以将字符串或数字参数传递给MyTopo：</p>
<pre tabindex="0"><code>sudo mn --custom mytopo.py --topo mytopo,3
</code></pre><p>您还可以指定多个自定义文件：</p>
<pre tabindex="0"><code>sudo mn --custom mytopo.py,mytest.py --topo mytopo,3 --test mytest
</code></pre><p>这将mytopo用作默认拓扑并调用mytest测试。</p>
<p>这是启动 Mininet、运行端到端系统测试（或多个测试）以及关闭 Mininet 的非常方便的单行命令。如果发生异常，标准的 Mininet 清理代码将被调用，就像mn通常在这种情况下所做的那样。</p>
<h4 id="--custom在文件中添加新的-cli-命令">&ndash;custom在文件中添加新的 CLI 命令</h4>
<p>在文件中添加新的 CLI 命令很容易&ndash;custom：</p>
<pre tabindex="0"><code>def mycmd( self, line ):
    &#34;mycmd is an example command to extend the Mininet CLI&#34;
    net = self.mn
    output( &#39;mycmd invoked for&#39;, net, &#39;with line&#39;, line, &#39;\n&#39;  )
CLI.do_mycmd = mycmd
</code></pre><p>mycmd会向 Mininet CLI 添加一个命令：</p>
<pre tabindex="0"><code>sudo mn --custom mycmd.py -v output
mininet&gt; help mycmd
mycmd is an example command to extend the Mininet CLI
mininet&gt; mycmd foo
mycmd invoked for &lt;mininet.net.Mininet object at 0x7fd7235fb9d0&gt; with line foo
</code></pre><p>请注意，您添加到 CLI 的命令函数名称应该有do_前缀。</p>
<h3 id="其他示例">其他示例</h3>
<p>Mininet 脚本的其他示例可以在mininet/examples.</p>
<p>这些示例旨在提供教育意义，因为它们展示了可以使用 Mininet API 的不同方式。我们鼓励您尝试阅读Python 代码并自己运行示例。如果它们由于某种原因不起作用，看看您是否能找出原因！</p>
<p>您可能会发现其中一些（例如consoles.py）是您可以构建的有趣演示。</p>
<p>特别是，您可能会发现 ( miniedit.py) 对于 Mininet 的简单实验来说是一个特别有用的 GUI。</p>
<p>注意：这些示例旨在作为阅读和理解的指导材料，而不是针对您可能遇到的任何问题的完整、开箱即用的解决方案。您也许可以使用一些经过修改的代码，但能够检查和理解代码很重要。</p>
<h3 id="了解-mininet-api">了解 Mininet API</h3>
<p>在本介绍过程中，您已经接触到许多构成 Mininet API 的 Python 类，包括Topo、Mininet、Host、Switch等Link类及其子类。将这些类划分为级别（或层）很方便，因为一般来说，高级 API 是使用低级 API 构建的。</p>
<p>Mininet 的 API 构建在三个主要级别：</p>
<ul>
<li>低级 API：低级 API 由基本节点和链接类（例如Host、Switch和Link及其子类）组成，它们实际上可以单独实例化并用于创建网络，但有点笨拙。</li>
<li>中级API：中级API 添加Mininet对象作为节点和链接的容器。它提供了多种方法（例如addHost()、addSwitch()和addLink()）用于向网络添加节点和链接，以及网络配置、启动和关闭（特别是start()和stop()。）</li>
<li>高级 API：高级 API 添加拓扑模板抽象Topo类，它提供创建可重用的参数化拓扑模板的能力。这些模板可以传递给mn命令（通过&ndash;custom选项）并从命令行使用。</li>
</ul>
<p>了解每个 API 级别很有价值。一般来说，当你想直接控制节点和交换机时，你会使用低级 API。当您想要启动或停止网络时，通常使用中级 API（尤其是Mininet类）。</p>
<p>当您开始考虑创建完整的网络时，事情就会变得有趣起来。可以使用任何 API 级别创建完整网络（如示例中所示），但通常您会希望选择中级 API（例如Mininet.add*()）或高级 API ( Topo.add*()) 来创建您的网络。</p>
<p>以下是使用每个 API 级别创建网络的示例：</p>
<h4 id="低级-api节点和链接">低级 API：节点和链接</h4>
<pre tabindex="0"><code>h1 = Host( &#39;h1&#39; )                                                                                                     
h2 = Host( &#39;h2&#39; )                                                                                                     
s1 = OVSSwitch( &#39;s1&#39;, inNamespace=False )                                                                             
c0 = Controller( &#39;c0&#39;, inNamespace=False )                                                                            
Link( h1, s1 )                                                                                                        
Link( h2, s1 )                                                                                                        
h1.setIP( &#39;10.1/8&#39; )                                                                                                  
h2.setIP( &#39;10.2/8&#39; )                                                                                                  
c0.start()                                                                                                            
s1.start( [ c0 ] )                                                                                                    
print( h1.cmd( &#39;ping -c1&#39;, h2.IP() ) )
s1.stop()                                                                                                             
c0.stop() 
</code></pre><h4 id="中级-api网络对象">中级 API：网络对象</h4>
<pre tabindex="0"><code>net = Mininet()
h1 = net.addHost( &#39;h1&#39; )
h2 = net.addHost( &#39;h2&#39; )
s1 = net.addSwitch( &#39;s1&#39; )
c0 = net.addController( &#39;c0&#39; )
net.addLink( h1, s1 )
net.addLink( h2, s1 )
net.start()
print( h1.cmd( &#39;ping -c1&#39;, h2.IP() ) )
CLI( net )
net.stop()
</code></pre><h4 id="高级-api拓扑模板">高级 API：拓扑模板</h4>
<pre tabindex="0"><code>class SingleSwitchTopo( Topo ):                                                                                               
    &#34;Single Switch Topology&#34;                                                                                                  
    def build( self, count=1 ):                                                                                      
        hosts = [ self.addHost( &#39;h%d&#39; % i )                                                                                   
                  for i in range( 1, count + 1 ) ]                                                                                
        s1 = self.addSwitch( &#39;s1&#39; )                                                                                           
        for h in hosts:                                                                                                       
            self.addLink( h, s1 )                                                                                             

net = Mininet( topo=SingleSwitchTopo( 3 ) )                                                                               
net.start()                                                                                                               
CLI( net )                                                                                                                
net.stop()   
</code></pre><p>如您所见，中级 API 对于本示例实际上是最简单和最简洁的，因为它不需要创建拓扑类。低级和中级 API 灵活而强大，但与高级TopoAPI 及其拓扑模板相比，重用起来可能不太方便。</p>
<p>另请注意，在 2.2.0 之前的 Mininet 版本中，高层Topo不支持节点之间的多链接，但低层 API 支持。目前Topo也不关心哪些开关由哪些控制器控制（您可以使用自定义Switch子类来执行此操作，如上所述。）使用中级和低级 API，您可以根据需要手动启动开关，将适当的控制器列表传递给每个交换机。</p>
<h4 id="mininet-api-文档">Mininet API 文档</h4>
<p>Mininet 包含每个模块和 API 调用的 Python 文档字符串。这些可以从 Python 的常规help()机制访问。例如，</p>
<pre tabindex="0"><code>	python
	&gt;&gt;&gt; from mininet.node import Host
	&gt;&gt;&gt; help(Host.IP)
	Help on method IP in module mininet.node:
	
	IP(self, intf=None) unbound mininet.node.Host method
		Return IP address of a node or specific interface.
</code></pre><p>同样的文档也可以在 Mininet 网站 <a href="http://api.mininet.org" target="_blank" rel="noopener noreffer ">http://api.mininet.org</a>上找到。</p>
<p>您可能希望自己使用以下方法生成 HTML（和 PDF）文档doxypy：</p>
<pre tabindex="0"><code>sudo apt-get install doxypy
cd ~/mininet
make doc
cd doc
python -m SimpleHTTPServer
</code></pre><p>此时，您可以将 Web 浏览器指向运行 Mininet 的主机的端口 8000，并浏览每个 Mininet 类的文档。</p>
<h4 id="测试性能">测试性能</h4>
<p>这些是推荐的，尽管您可以自由使用您熟悉的任何工具。</p>
<ol>
<li>带宽 ( bwm-ng, ethstats)</li>
<li>延迟（使用ping）</li>
<li>队列（使用tc包含在monitor.py）</li>
<li>TCPCWND统计信息（tcp_probe，也许我们应该将其添加到monitor.py）</li>
<li>CPU 使用率（全局：top或每个容器cpuacct）</li>
</ol>
<h3 id="openflow-和自定义路由">OpenFlow 和自定义路由</h3>
<p>Mininet 最强大和最有用的功能之一是它使用 软件定义网络。使用OpenFlow协议和相关工具，您可以对交换机进行编程，以对进入它们的数据包执行几乎任何您想要的操作。OpenFlow 使像 Mininet 这样的仿真器变得更加有用，因为网络系统设计（包括使用 OpenFlow 的自定义数据包转发）可以轻松地转移到硬件 OpenFlow 交换机以进行线速操作。可以在以下位置找到使用 Mininet 和 OpenFlow 创建简单学习交换机的教程：</p>
<p><a href="https://github.com/mininet/openflow-tutorial/wiki" target="_blank" rel="noopener noreffer ">https://github.com/mininet/openflow-tutorial/wiki</a></p>
<h4 id="openflow控制器">OpenFlow控制器</h4>
<p>如果您在mn未指定控制器的情况下运行该命令，它将选择一个默认控制器，例如Controller或OVSController，具体取决于可用的控制器。</p>
<p>这相当于：</p>
<pre tabindex="0"><code>$ sudo mn --controller default
</code></pre><p>该控制器实现了一个简单的以太网学习交换机，并支持多达 16 个单独的交换机。</p>
<p>如果您在脚本中调用Mininet()构造函数而不指定控制器类，默认情况下它将使用Controller()类来创建 Stanford/OpenFlow 参考控制器的实例，controller. ovs-controller把你的交换机变成简单的学习交换机，但是如果你使用Mininet的 install.sh -f脚本安装controller，补丁版本controller应该支持大量的交换机（理论上最多4096个，但你可能会更早地用完你的计算资源.) 您还可以通过mn指定&ndash;controller ref来选择参考控制器。</p>
<p>如果你想使用你自己的控制器，你可以很容易地创建一个自定义的子类Controller()并将它传递到 Mininet 中。可以在mininet.controller.NOX()中看到一个示例，它使用一组作为选项传入的模块调用 NOX classic。</p>
<p>下面是创建和使用自定义 POXController子类的简单示例：</p>
<pre tabindex="0"><code>#!/usr/bin/python                                                                                      
                                                                                                       
from mininet.net import Mininet                                                                        
from mininet.node import Controller                                                                    
from mininet.topo import SingleSwitchTopo                                                              
from mininet.log import setLogLevel                                                                    
                                                                                                       
import os                                                                                              
                                                                                                       
class POXBridge( Controller ):                                                                         
    &#34;Custom Controller class to invoke POX forwarding.l2_learning&#34;                                     
    def start( self ):                                                                                 
        &#34;Start POX learning switch&#34;                                                                    
        self.pox = &#39;%s/pox/pox.py&#39; % os.environ[ &#39;HOME&#39; ]                                              
        self.cmd( self.pox, &#39;forwarding.l2_learning &amp;&#39; )                                               
    def stop( self ):                                                                                  
        &#34;Stop POX&#34;                                                                                     
        self.cmd( &#39;kill %&#39; + self.pox )                                                                
                                                                                                       
controllers = { &#39;poxbridge&#39;: POXBridge }                                                               
                                                                                                       
if __name__ == &#39;__main__&#39;:                                                                             
    setLogLevel( &#39;info&#39; )                                                                              
    net = Mininet( topo=SingleSwitchTopo( 2 ), controller=POXBridge )                                  
    net.start()                                                                                        
    net.pingAll()                                                                                      
    net.stop()      
</code></pre><p>请注意，上面的脚本是这样编写的，因此它也可以用作mn自定义参数以用于不同的拓扑和测试以及 Mininet CLI：</p>
<pre tabindex="0"><code>$ sudo mn --custom poxbridge.py --controller poxbridge --topo tree,2,2 --test pingall -v output
*** Ping: testing ping reachability
h1 -&gt; h2 h3 h4 
h2 -&gt; h1 h3 h4 
h3 -&gt; h1 h2 h4 
h4 -&gt; h1 h2 h3 
*** Results: 0% dropped (0/12 lost)
</code></pre><p>如果查看mininet/node.py中NOX类的实现，您会注意到它实际上可以接受选项以允许根据从构造函数或mn命令行传递给它的参数启动不同的模块。</p>
<h4 id="外部-openflow-控制器">外部 OpenFlow 控制器</h4>
<p>自定义Controller()子类是自动启动和关闭控制器的最方便的方法。创建start()和stop()方法很容易，这样 Mininet 将根据需要自动启动和停止您的控制器。</p>
<p>但是，您可能会发现将 Mininet 连接到已经在其他地方运行的现有控制器很有用，例如 LAN 上的某个地方、另一个 VM 中或笔记本电脑上。</p>
<p>您可以使用Mininet的RemoteController：</p>
<pre tabindex="0"><code>from functools import partial
net = Mininet( topo=topo, controller=partial( RemoteController, ip=&#39;127.0.0.1&#39;, port=6633 ) )
</code></pre><p>或者如果你喜欢：</p>
<pre tabindex="0"><code>net = Mininet( topo=topo, controller=lambda name: RemoteController( name, ip=&#39;127.0.0.1&#39; ) )
</code></pre><p>甚至</p>
<pre tabindex="0"><code>net = Mininet( topo=topo, controller=None)
net.addController( &#39;c0&#39;, controller=RemoteController, ip=&#39;127.0.0.1&#39;, port=6633 )
</code></pre><p>请注意，在这种情况下， controller（如host和switch）是一个构造函数，而不是一个对象（但请参阅下面的附加信息！）您可以使用partial或lambda在线创建自定义构造函数，或者您可以传入自己的函数（必须采用name参数并返回控制器对象）或类（例如RemoteController的子类）</p>
<p>您还可以创建多个控制器并创建一个自定义Switch()子类，根据需要连接到不同的控制器：</p>
<pre tabindex="0"><code>
c0 = Controller( &#39;c0&#39; )  # local controller
c1 = RemoteController( &#39;c1&#39;, ip=&#39;127.0.0.2&#39; )  # external controller
cmap = { &#39;s1&#39;: c0, &#39;s2&#39;: c1, &#39;s3&#39;: c1 }

class MultiSwitch( OVSSwitch ):
    &#34;Custom Switch() subclass that connects to different controllers&#34;
    def start( self, controllers ):
        return OVSSwitch.start( self, [ cmap[ self.name ] ] )
</code></pre><p>您还可以从mn命令行指定外部控制器：</p>
<pre tabindex="0"><code>$ sudo mn --controller remote,ip=192.168.51.101
</code></pre><h4 id="通过传入控制器对象滥用-api">通过传入控制器对象滥用 API</h4>
<p>在 Mininet 2.2.0 及更高版本中，您可以选择传入Controller 对象而不是构造函数（甚至是对象列表）。添加此选项是因为尽管 API 明确指定需要构造函数，但人们仍在这样做.</p>
<p>这使您可以执行以下操作：</p>
<pre tabindex="0"><code>net = Mininet( topo, controller=RemoteController( &#39;c0&#39;, ip=&#39;127.0.0.1&#39; ) )
</code></pre><p>并获得您想要的行为。仍然允许构造函数。</p>
<h4 id="多路径路由">多路径路由</h4>
<p>重要的是要记住，以太网桥（也称为学习交换机）会淹没在其 MAC 表中丢失的数据包。它们还会像 ARP 和 DHCP 请求一样泛滥广播。这意味着，如果您的网络中有环路或多条路径，它无法将默认ovs-controller与充当学习交换机/以太网桥的controller控制器|NOX的pyswitch|POX的l2_learning一起使用。</p>
<p>尽管这个问题很明显，但它已成为一个 常见问题。</p>
<p>更新（和更复杂）的 OpenFlow 控制器确实支持多路径路由 - 请查阅控制器的文档以确定是否需要任何特殊配置。</p>
<p>如果您正在构建类似胖树的拓扑结构，您可能希望查看 RipLPOX，这是一个使用 POX 实现的基本数据中心控制器。您可以将其用作您自己的自定义多路径路由的起点。</p>
<p>为了方便起见，您可能还希望实现一个自定义Controller()子类来调用 RipLPOX。</p>
<p>（或者如果你真的很大胆/疯狂，你甚至可以尝试将 Mininet 和 POX 或 RipLPOX 导入到一个 Python 脚本中！但你可能不想这样做。）</p>
<h3 id="更新-mininet">更新 Mininet</h3>
<p>如果我们需要对 Mininet 进行更改或添加以修复错误或其他问题，并且您已经从源代码安装了 Mininet，您可能希望更新您的 Mininet 副本。这可以使用以下两种方法之一轻松完成：</p>
<p>使用指向 Mininet 源代码树的符号链接更新（使更新 Mininet 的 python 代码变得容易）：</p>
<pre tabindex="0"><code>cd ~/mininet
    git checkout master # assuming you want to update to the current master branch
sudo make develop # this only needs to be done initially and when mnexec.c changes
git fetch
git pull --rebase
</code></pre><p>更新将 Mininet 源代码复制到 /usr/lib/python&hellip;（允许您删除或移动 Mininet 源代码树）：</p>
<pre tabindex="0"><code>cd ~/mininet
    git checkout master # assuming you want to update to the current master branch
git fetch
git pull --rebase
    sudo make install
</code></pre><h3 id="学习python">学习Python</h3>
<p>Mininet 是用 Python 编写的，允许基于 Python 的用户脚本与其交互。幸运的是，Python 是最容易理解、学习和使用的计算机语言之一，因为它的（大部分）可读语法、与其他面向对象语言的相似性以及许多有用的库。一旦您适应了它的怪癖（显着缩进、强制使用self、运行时错误检查等），您可能会欣赏它作为一种非常快速（如果有时很脏）的方式来编写有用的脚本和代码。</p>
<p>互联网上有大量免费的 Python 教程，从书籍到完整的课程。http://docs.python.org上的 Python 文档 也将很快成为您的朋友（如果您还没有的话）。</p>
<p>除了帮助查找 Python 教程外，Google 在寻找 Python 问题的答案方面似乎也做得非常好，其中许多问题都在http://stackoverflow.com上得到了解答。</p>
<p>也许更令人吃惊的是，Microsoft 的 Bing 实际上可以在其搜索结果中找到并运行 Python 代码！例如，您可以搜索python 冒泡排序，它实际上会显示可执行代码。</p>
<h3 id="使用-mininet-的有用背景">使用 Mininet 的有用背景</h3>
<ol>
<li>面向对象编程（创建类、从类创建对象等）</li>
<li>导入 Python 模块:http://docs.python.org/tutorial/modules.html</li>
<li>从 Python 调用系统实用程序:http://docs.python.org/library/subprocess.html <a href="http://docs.python.org/library/os.html]" target="_blank" rel="noopener noreffer ">http://docs.python.org/library/os.html]</a> <a href="https://github.com/amoffat/pbs" target="_blank" rel="noopener noreffer ">https://github.com/amoffat/pbs</a></li>
<li>以您自己的格式解析输出文件:http://docs.python.org/library/re.html</li>
<li>将命令行参数传递给脚本:http://docs.python.org/dev/library/argparse.html</li>
<li>matplotlib用于绘制图表:http://matplotlib.sourceforge.net</li>
</ol>
<h3 id="有用的-python-资源">有用的 Python 资源</h3>
<ol>
<li>Python 文档是一个很好的起点：http://docs.python.org/tutorial/index.html</li>
<li>初学者指南：http://www.python.org/about/gettingstarted</li>
</ol>
<h3 id="它是如何工作的可选出于好奇">它是如何工作的？（可选：出于好奇）</h3>
<p>Mininet 幻觉背后的魔力是 Linux 中内置的一组功能，允许将单个系统拆分为一堆较小的“容器”，每个容器具有固定份额的处理能力，并结合允许链接准确的虚拟链接代码延迟和速度。</p>
<p>在内部，Mininet 采用 Linux 内核中的轻量级虚拟化功能，包括进程组、CPU 带宽隔离和网络命名空间，并将它们与链接调度程序和虚拟以太网链接相结合。与使用完整虚拟机的仿真器相比，这些功能产生的系统启动速度更快，可扩展到更多主机。</p>
<p>Mininet 网络由以下组件组成：</p>
<ol>
<li>孤立的主机。Mininet 中的模拟主机是一组移动到网络命名空间中的用户级进程 - 网络状态的容器。网络名称空间为进程组提供接口、端口和路由表（例如 ARP 和 IP）的独占所有权。例如，两个网络命名空间中的两个 Web 服务器可以在一个系统中共存，它们都监听端口 80 上的私有 eth0 接口。Mininet 使用 CPU 带宽限制来限制每个进程组可用的 CPU 比例。</li>
<li>模拟链接。每个链路的数据速率由 Linux 流量控制 ( tc) 强制执行，它有许多数据包调度程序来将流量调整为配置的速率。每个模拟主机都有自己的虚拟以太网接口（使用 ip link add/set 创建和安装）。虚拟以太网（或veth）对，就像连接两个虚拟接口或虚拟交换机端口的电线一样；通过一个接口发送的数据包被传送到另一个接口，每个接口对所有系统和应用程序软件来说都是一个功能齐全的以太网端口。</li>
<li>仿真交换机。Mininet 通常使用在内核模式下运行的默认 Linux 网桥或 Open vSwitch 来跨接口交换数据包。交换机和路由器可以在内核中运行（为了速度）或在用户空间中运行（因此我们可以轻松修改它们）。</li>
</ol>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 2022-11-29</span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="Share on Twitter" data-sharer="twitter" data-url="https://oublie6.github.io/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/" data-title="Python-第三方库-mininet-Mininet简介" data-hashtags="mininet"><i class="fab fa-twitter fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Facebook" data-sharer="facebook" data-url="https://oublie6.github.io/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/" data-hashtag="mininet"><i class="fab fa-facebook-square fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Hacker News" data-sharer="hackernews" data-url="https://oublie6.github.io/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/" data-title="Python-第三方库-mininet-Mininet简介"><i class="fab fa-hacker-news fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Line" data-sharer="line" data-url="https://oublie6.github.io/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/" data-title="Python-第三方库-mininet-Mininet简介"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on 微博" data-sharer="weibo" data-url="https://oublie6.github.io/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/" data-title="Python-第三方库-mininet-Mininet简介"><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/mininet/">mininet</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/" class="prev" rel="prev" title="Python-第三方库-mininet-Mininet演练"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>Python-第三方库-mininet-Mininet演练</a>
            <a href="/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/git%E4%B8%A2%E5%BC%83%E5%8E%86%E5%8F%B2commit/" class="next" rel="next" title="版本控制-git-Git丢弃历史commit">版本控制-git-Git丢弃历史commit<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
<div id="comments"><div id="gitalk" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://github.com/gitalk/gitalk"></a>Gitalk</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.102.3">Hugo</a> | Theme - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden="true"></i> LoveIt</a>
                </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2019 - 2023</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://oublie6.github.io/" target="_blank">oublie</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/css/lightgallery-bundle.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/lightgallery.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/plugins/thumbnail/lg-thumbnail.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/plugins/zoom/lg-zoom.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":50},"comment":{"gitalk":{"admin":["oublie6"],"clientID":"288ce7d75b58873d5587","clientSecret":"4a2de9270c3e7bcfead921c7e3be225d462e6cee","id":"2022-11-29T11:18:06+08:00","owner":"oublie6","repo":"https://github.com/oublie6/oublie6.github.io.git","title":"Python-第三方库-mininet-Mininet简介"}},"lightgallery":true,"search":{"highlightTag":"em","lunrIndexURL":"/index.json","maxResultLength":10,"noResultsFound":"No results found","snippetLength":50,"type":"lunr"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
