<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>Python-第三方库-Mininet - Oublie的Hugo博客</title><meta name="Description" content="Oublie的Hugo博客"><meta property="og:title" content="Python-第三方库-Mininet" />
<meta property="og:description" content="mininet示例工作流程 mininet官网 创建网络 使用单个命令创建网络 在 OpenFlow/Stanford 参考控制器的控制下使用 Open vSwitch 交换机启动深度为 2 和扇出为 8 的树状拓扑" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://oublie6.github.io/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/" /><meta property="og:image" content="https://oublie6.github.io/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-28T14:57:48+08:00" />
<meta property="article:modified_time" content="2022-11-28T14:57:48+08:00" /><meta property="og:site_name" content="我的网站" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://oublie6.github.io/logo.png"/>

<meta name="twitter:title" content="Python-第三方库-Mininet"/>
<meta name="twitter:description" content="mininet示例工作流程 mininet官网 创建网络 使用单个命令创建网络 在 OpenFlow/Stanford 参考控制器的控制下使用 Open vSwitch 交换机启动深度为 2 和扇出为 8 的树状拓扑"/>
<meta name="application-name" content="LoveIt">
<meta name="apple-mobile-web-app-title" content="LoveIt"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://oublie6.github.io/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/" /><link rel="prev" href="https://oublie6.github.io/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/" /><link rel="next" href="https://oublie6.github.io/posts/python/%E6%9D%82%E8%AE%B0/functools.partial/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"></noscript><link rel="preload" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Python-第三方库-Mininet",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/oublie6.github.io\/posts\/python\/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93\/mininet\/"
        },"genre": "posts","wordcount":  13808 ,
        "url": "https:\/\/oublie6.github.io\/posts\/python\/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93\/mininet\/","datePublished": "2022-11-28T14:57:48+08:00","dateModified": "2022-11-28T14:57:48+08:00","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "oublie"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Oublie的Hugo博客">Oublie的Hugo博客</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/about/"> 关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="Search">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="Clear">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Oublie的Hugo博客">Oublie的Hugo博客</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="Search">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="Clear">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        Cancel
                    </a>
                </div><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/about/" title="">关于</a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><div class="search-dropdown desktop">
        <div id="search-dropdown-desktop"></div>
    </div>
    <div class="search-dropdown mobile">
        <div id="search-dropdown-mobile"></div>
    </div><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Python-第三方库-Mininet</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://oublie6.github.io/" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>oublie</a></span>&nbsp;<span class="post-category">included in <a href="/categories/python/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>Python</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2022-11-28">2022-11-28</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;13808 words&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;28 minutes&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="true">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#mininet示例工作流程">mininet示例工作流程</a>
      <ul>
        <li><a href="#创建网络">创建网络</a></li>
        <li><a href="#与网络互动">与网络互动</a></li>
        <li><a href="#自定义网络">自定义网络</a></li>
        <li><a href="#共享网络">共享网络</a></li>
        <li><a href="#在硬件上运行">在硬件上运行</a></li>
      </ul>
    </li>
    <li><a href="#mininet演练">Mininet演练</a>
      <ul>
        <li><a href="#第-1-部分mininet-的日常使用">第 1 部分：Mininet 的日常使用</a></li>
        <li><a href="#第-2-部分高级启动选项">第 2 部分：高级启动选项</a></li>
        <li><a href="#第-3-部分mininet-命令行界面-cli-命令">第 3 部分：Mininet 命令行界面 (CLI) 命令</a></li>
        <li><a href="#第-4-部分python-api-示例">第 4 部分：Python API 示例</a></li>
        <li><a href="#第-5-部分演练完成">第 5 部分：演练完成！</a></li>
        <li><a href="#附录补充信息">附录：补充信息</a></li>
      </ul>
    </li>
    <li><a href="#mininet简介">mininet简介</a>
      <ul>
        <li><a href="#什么是迷你网">什么是迷你网？</a></li>
        <li><a href="#为什么-mininet-很酷">为什么 Mininet 很酷？</a></li>
        <li><a href="#mininet-的局限性是什么">Mininet 的局限性是什么？</a></li>
        <li><a href="#使用-mininet">使用 Mininet</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="mininet示例工作流程">mininet示例工作流程</h2>
<p><a href="http://mininet.org/sample-workflow/" target="_blank" rel="noopener noreffer ">mininet官网</a></p>
<h3 id="创建网络">创建网络</h3>
<p>使用单个命令创建网络</p>
<p>在 OpenFlow/Stanford 参考控制器的控制下使用 Open vSwitch 交换机启动深度为 2 和扇出为 8 的树状拓扑结构的网络（即 64 台主机连接到 9 台交换机），并运行pingall测试以检查每对节点之间的连接性.</p>
<pre tabindex="0"><code>sudo mn --switch ovs --controller ref --topo tree,depth=2,fanout=8 --test pingall
</code></pre><h3 id="与网络互动">与网络互动</h3>
<p>Mininet 的 CLI 允许您从单个控制台控制和管理整个虚拟网络</p>
<p>告诉主机h2 ping 主机h3的 IP 地址。</p>
<pre tabindex="0"><code>mininet&gt; h2 ping h3
</code></pre><p>任何可用的 Linux 命令或程序都可以在任何虚拟主机上运行。您可以轻松地在一台主机上启动 Web 服务器并从另一台主机发出 HTTP 请求：</p>
<pre tabindex="0"><code>mininet&gt; h2 python -m SimpleHTTPServer 80 &gt;&amp; /tmp/http.log &amp;
mininet&gt; h3 wget -O - h2
</code></pre><h3 id="自定义网络">自定义网络</h3>
<p>Mininet 的 API 允许您使用几行 Python 创建自定义网络。例如，下面的脚本</p>
<pre tabindex="0"><code>from mininet.net import Mininet
from mininet.topolib import TreeTopo
tree4 = TreeTopo(depth=2,fanout=2)
net = Mininet(topo=tree4)
net.start()
h1, h4  = net.hosts[0], net.hosts[3]
print h1.cmd(&#39;ping -c1 %s&#39; % h4.IP())
net.stop()
</code></pre><p>创建一个小型网络（4 台主机，3 台交换机），并从一台主机 ping 另一台主机</p>
<h3 id="共享网络">共享网络</h3>
<p>Mininet 作为虚拟机 (VM) 映像分发，所有依赖项均已预安装，可在 VMware、Xen 和 VirtualBox 等常见虚拟机监视器上运行。这为分发提供了一个方便的容器；一旦原型被开发出来，VM 映像就可以分发给其他人运行、检查和修改。</p>
<h3 id="在硬件上运行">在硬件上运行</h3>
<p>一旦设计在 Mininet 上运行，就可以将其部署在硬件上以供实际使用、测试和测量。</p>
<p>为了在第一次尝试时成功移植到硬件，每个 Mininet 仿真组件必须以与其对应的物理组件相同的方式运行。虚拟拓扑应该与物理拓扑相匹配；虚拟以太网对必须替换为链路级以太网连接。模拟为进程的主机应替换为具有自己的操作系统映像的主机。此外，每个模拟的 OpenFlow 交换机都应替换为配置为指向控制器的物理交换机。但是，控制器不需要更改。当 Mininet 运行时，控制器“看到”一个物理交换机网络，这是通过具有明确定义的状态语义的接口实现的。</p>
<h2 id="mininet演练">Mininet演练</h2>
<h3 id="第-1-部分mininet-的日常使用">第 1 部分：Mininet 的日常使用</h3>
<p>首先，关于本演练的命令语法的（可能是显而易见的）注释：</p>
<ul>
<li>$在应该在 shell 提示符下键入的 Linux 命令之前</li>
<li>mininet&gt;之前应该在 Mininet 的 CLI 中键入的 Mininet 命令，</li>
<li>#在 root shell 提示符下键入的 Linux 命令之前</li>
</ul>
<h4 id="显示启动选项">显示启动选项</h4>
<p>键入以下命令以显示描述 Mininet 启动选项的帮助消息：</p>
<pre tabindex="0"><code>$ sudo mn -h
</code></pre><h4 id="启动-wireshark">启动 Wireshark</h4>
<p>要使用 OpenFlow Wireshark dissector 查看控制流量，首先在后台打开 wireshark：</p>
<pre tabindex="0"><code>$ sudo wireshark &amp;
</code></pre><p>这里报错看官网</p>
<h4 id="与主机和交换机交互">与主机和交换机交互</h4>
<p>启动最小拓扑并输入 CLI：</p>
<pre tabindex="0"><code>$ sudo mn
</code></pre><p>默认拓扑是minimal拓扑结构，包括一个OpenFlow内核交换机连接到两个主机，加上OpenFlow参考控制器。此拓扑也可以在命令行上使用&ndash;topo=minimal. 开箱即用的其他拓扑也可用；请参阅&ndash;topo的输出中的部分mn -h。</p>
<p>所有四个实体（2 个主机进程、1 个交换进程、1 个基本控制器）现在都在 VM 中运行。控制器可以在 VM 外部，其说明位于底部。</p>
<p>如果没有特定的测试作为参数传递，Mininet CLI 就会出现。</p>
<p>在 Wireshark 窗口中，您应该看到内核交换机连接到参考控制器。</p>
<p>显示 Mininet CLI 命令：</p>
<pre tabindex="0"><code>mininet&gt; help
</code></pre><p>显示节点：</p>
<pre tabindex="0"><code>mininet&gt; nodes
</code></pre><p>显示链接：</p>
<pre tabindex="0"><code>mininet&gt; net
</code></pre><p>转储有关所有节点的信息：</p>
<pre tabindex="0"><code>mininet&gt; dump
</code></pre><p>您应该会看到列出的交换机和两台主机。</p>
<p>如果在 Mininet CLI 中输入的第一个字符串是主机、交换机或控制器名称，则该命令将在该节点上执行。在主机进程上运行命令：</p>
<pre tabindex="0"><code>mininet&gt; h1 ifconfig -a
</code></pre><p>会看到主机h1-eth0和环回 ( lo) 接口。请注意，此接口 ( h1-eth0) 在运行时不会被主 Linux 系统看到ifconfig，因为它特定于主机进程的网络命名空间。</p>
<p>相比之下，交换机默认运行在根网络命名空间中，因此在“交换机”上运行命令与从常规终端运行命令相同：</p>
<pre tabindex="0"><code>mininet&gt; s1 ifconfig -a
</code></pre><p>这将显示交换机接口，以及 VM 的连接输出( eth0)。</p>
<p>对于其他突出显示主机具有隔离网络状态的示例，请在s1\h1两者上运行arp和route。</p>
<p>可以将每个主机、交换机和控制器都放在自己独立的网络名称空间中，但这样做并没有真正的优势，除非您想复制一个复杂的多控制器网络。Mininet 确实支持这个；查看&ndash;innamespace选项。</p>
<p>请注意，只有网络是虚拟化的；每个主机进程看到同一组进程和目录。例如，从主机进程打印进程列表：</p>
<pre tabindex="0"><code>mininet&gt; h1 ps -a
</code></pre><p>这应该与根网络命名空间所看到的完全相同：</p>
<pre tabindex="0"><code>mininet&gt; s1 ps -a
</code></pre><p>Linux 容器可以使用单独的进程空间，但目前 Mininet 不这样做。让一切都在“根”进程命名空间中运行便于调试，因为它允许您使用ps、kill等从控制台查看所有进程。</p>
<h4 id="测试主机之间的连通性">测试主机之间的连通性</h4>
<p>现在，验证您是否可以从主机 0 ping 主机 1：</p>
<pre tabindex="0"><code>mininet&gt; h1 ping -c 1 h2
</code></pre><p>如果命令后面出现一个字符串和节点名称，则该节点名称将替换为它的 IP 地址；这发生在 h2 上。</p>
<p>您应该看到 OpenFlow 控制流量。第二个 MAC 地址的第一个主机 ARP，这会导致packet_in消息转到控制器。然后，控制器发送一条packet_out消息，将广播数据包泛洪到交换机上的其他端口（在本例中，是唯一的其他数据端口）。第二台主机看到 ARP 请求并发送回复。该回复到达控制器，控制器将其发送到第一台主机并下推流条目。</p>
<p>现在第一台主机知道第二台主机的 MAC 地址，并且可以通过 ICMP Echo Request 发送它的 ping。该请求及其来自第二台主机的相应回复都进入控制器并导致流条目被下推（连同实际数据包被发送出去）。</p>
<p>重复上一个ping：</p>
<pre tabindex="0"><code>mininet&gt; h1 ping -c 1 h2
</code></pre><p>第二次尝试的时间应该短得多ping(&lt; 100us)。之前在交换机中安装了涵盖ICMPping流量的流表项，因此没有产生控制流量，数据包立即通过交换机。</p>
<p>运行此测试的更简单方法是使用 Mininet CLI 内置pingall命令，该命令执行所有主机对ping：</p>
<pre tabindex="0"><code>mininet&gt; pingall
</code></pre><h4 id="运行一个简单的-web-服务器和客户端">运行一个简单的 Web 服务器和客户端</h4>
<p>请记住，这ping不是您可以在主机上运行的唯一命令！Mininet 主机可以运行底层 Linux 系统（或 VM）及其文件系统可用的任何命令或应用程序。您还可以输入任何bash命令，包括作业控制（&amp;、jobs、kill等。）</p>
<p>接下来，尝试在 上启动一个简单的 HTTP 服务器h1，从 发出请求h2，然后关闭 Web 服务器：</p>
<pre tabindex="0"><code>mininet&gt; h1 python -m http.server 80 &amp;
mininet&gt; h2 wget -O - h1
...
mininet&gt; h1 kill %python
</code></pre><p>注意：对于 Python 3，HTTP 服务器称为http.server; 对于 Python 2，它被称为SimpleHTTPServer. 确保您使用的是与您正在运行的 Mininet 版本相符的版本。要找出 Mininet 使用的是哪个 Python 版本，您可以键入</p>
<pre tabindex="0"><code>mininet&gt; py sys.version
3.8.5 (default, Jan 27 2021, 15:41:15)
</code></pre><p>退出 CLI：</p>
<pre tabindex="0"><code>mininet&gt; exit
</code></pre><h4 id="清理">清理</h4>
<p>如果 Mininet 由于某种原因崩溃，请清理它：</p>
<pre tabindex="0"><code>$ sudo mn -c
</code></pre><h3 id="第-2-部分高级启动选项">第 2 部分：高级启动选项</h3>
<h4 id="运行回归测试">运行回归测试</h4>
<p>您不需要进入 CLI；Mininet 也可用于运行独立的回归测试。</p>
<p>运行回归测试：</p>
<pre tabindex="0"><code>$ sudo mn --test pingpair
</code></pre><p>该命令创建了一个最小拓扑，启动了 OpenFlow 参考控制器，运行了所有对ping测试，并拆除了拓扑和控制器。</p>
<p>另一个有用的测试是iperf（给它大约 10 秒来完成）：</p>
<pre tabindex="0"><code>$ sudo mn --test iperf
</code></pre><p>此命令创建相同的 Mininet，在一台主机上运行 iperf 服务器，在第二台主机上运行 iperf 客户端，并解析所达到的带宽。</p>
<h4 id="更改拓扑大小和类型">更改拓扑大小和类型</h4>
<p>默认拓扑是连接到两个主机的单个交换机。您可以使用&ndash;topo将其更改为不同的拓扑，并为该拓扑的创建传递参数。例如，验证一台交换机和三台主机的所有对 ping 连接：</p>
<p>运行回归测试：</p>
<pre tabindex="0"><code>$ sudo mn --test pingall --topo single,3
</code></pre><p>另一个示例，使用线性拓扑（其中每个交换机都有一个主机，并且所有交换机连接成一条线）：</p>
<pre tabindex="0"><code>$ sudo mn --test pingall --topo linear,4
</code></pre><p>参数化拓扑是 Mininet 最有用和最强大的特性之一。</p>
<h4 id="链接变体">链接变体</h4>
<p>Mininet 2.0 允许您设置链接参数，这些甚至可以从命令行自动设置：</p>
<pre tabindex="0"><code> $ sudo mn --link tc,bw=10,delay=10ms
 mininet&gt; iperf
 ...
 mininet&gt; h1 ping -c10 h2
</code></pre><p>如果每条链路的延迟为 10 毫秒，则往返时间 (RTT) 应约为 40 毫秒，因为 ICMP 请求遍历两条链路（一条到交换机，一条到目的地）并且 ICMP 回复遍历两条返回的链路.</p>
<p>您可以使用Mininet 的 Python API自定义每个链接 ，但现在您可能想要继续演练。</p>
<h4 id="可调输出粒度">可调输出粒度</h4>
<p>默认的详细级别是info，它打印 Mininet 在启动和拆卸期间正在做什么。将此与带有参数-v的完整debug输出进行比较：</p>
<pre tabindex="0"><code>$ sudo mn -v debug
...
mininet&gt; exit
</code></pre><p>将打印出许多额外的细节。现在试试output，一个打印 CLI 输出的设置，除此之外别无其他：</p>
<pre tabindex="0"><code>$ sudo mn -v output
mininet&gt; exit
</code></pre><p>在 CLI 之外，可以使用其他详细级别，例如warning，它与回归测试一起使用以隐藏不需要的函数输出。</p>
<h4 id="自定义拓扑">自定义拓扑</h4>
<p>也可以使用简单的 Python API 轻松定义自定义拓扑，并且在custom/topo-2sw-2host.py. 此示例直接连接两个交换机，每个交换机有一个主机</p>
<pre tabindex="0"><code>&#34;&#34;&#34;Custom topology example

Two directly connected switches plus a host for each switch:

   host --- switch --- switch --- host

Adding the &#39;topos&#39; dict with a key/value pair to generate our newly defined
topology enables one to pass in &#39;--topo=mytopo&#39; from the command line.
&#34;&#34;&#34;

from mininet.topo import Topo

class MyTopo( Topo ):
    &#34;Simple topology example.&#34;

    def build( self ):
        &#34;Create custom topo.&#34;

        # Add hosts and switches
        leftHost = self.addHost( &#39;h1&#39; )
        rightHost = self.addHost( &#39;h2&#39; )
        leftSwitch = self.addSwitch( &#39;s3&#39; )
        rightSwitch = self.addSwitch( &#39;s4&#39; )

        # Add links
        self.addLink( leftHost, leftSwitch )
        self.addLink( leftSwitch, rightSwitch )
        self.addLink( rightSwitch, rightHost )


topos = { &#39;mytopo&#39;: ( lambda: MyTopo() ) }
</code></pre><p>当提供自定义 mininet 文件时，它可以向命令行添加新拓扑、交换机类型和测试。例如：</p>
<pre tabindex="0"><code>$ sudo mn --custom ~/mininet/custom/topo-2sw-2host.py --topo mytopo --test pingall
</code></pre><h4 id="id--mac">ID = MAC</h4>
<p>默认情况下，主机以随机分配的 MAC 地址开头。这会使调试变得困难，因为每次创建 Mininet 时，MAC 都会发生变化，因此很难将控制流量与特定主机相关联。</p>
<p>该&ndash;mac选项非常有用，它将主机 MAC 和 IP 地址设置为小的、唯一的、易于阅读的 ID。</p>
<pre tabindex="0"><code>$ sudo mn
...
mininet&gt; h1 ifconfig
h1-eth0  Link encap:Ethernet  HWaddr f6:9d:5a:7f:41:42
          inet addr:10.0.0.1  Bcast:10.255.255.255  Mask:255.0.0.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:6 errors:0 dropped:0 overruns:0 frame:0
          TX packets:6 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:392 (392.0 B)  TX bytes:392 (392.0 B)
mininet&gt; exit
</code></pre><pre tabindex="0"><code>$ sudo mn --mac
...
mininet&gt; h1 ifconfig
h1-eth0  Link encap:Ethernet  HWaddr 00:00:00:00:00:01
          inet addr:10.0.0.1  Bcast:10.255.255.255  Mask:255.0.0.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
mininet&gt; exit
</code></pre><p>相反，Linux 报告的交换机数据端口的 MAC 将保持随机。这是因为您可以使用 OpenFlow 将 MAC“分配”到数据端口，如常见问题解答中所述。这是一个有点微妙的问题，您现在可以忽略它。</p>
<h4 id="xterm-显示">XTerm 显示</h4>
<p>对于更复杂的调试，您可以启动 Mininet 以便它生成一个或多个 xterms。</p>
<p>要为每个主机和交换机启动一个xterm，请传递以下-x选项：</p>
<pre tabindex="0"><code>$ sudo mn -x
</code></pre><p>一秒钟后，xterms 将弹出，并自动设置窗口名称。</p>
<p>或者，您可以调出额外的 xterms，如下所示。</p>
<p>默认情况下，只有主机被放在一个单独的命名空间中；每个交换机的窗口都是不必要的（即，相当于一个常规终端），但可以方便地运行和离开交换机调试命令，例如流计数器转储。</p>
<p>Xterms 对于运行您可能需要取消的交互式命令也很有用，您希望看到这些命令的输出。</p>
<p>例如：在标有“switch: s1 (root)”的 xterm 中，运行：</p>
<pre tabindex="0"><code># ovs-ofctl dump-flows tcp:127.0.0.1:6654
</code></pre><p>什么都不会打印出来；交换机没有添加流。要ovs-ofctl与其他交换机使用，请以详细模式启动 mininet，并在创建交换机时查看交换机的被动侦听端口。</p>
<p>现在，在标有“host: h1”的 xterm 中，运行：</p>
<pre tabindex="0"><code># ping 10.0.0.2
</code></pre><p>返回s1并转储流：# ovs-ofctl dump-flows tcp:127.0.0.1:6654</p>
<p>您现在应该看到多个流条目。或者（通常更方便），您可以使用Mininet CLI 中内置的命令dpctl，而无需任何 xterms 或手动指定交换机的 IP 和端口。</p>
<p>您可以通过检查 ifconfig 来判断 xterm 是否在根名称空间中；如果显示所有接口（包括eth0），则它位于根名称空间中。此外，其标题应包含“(root)”。</p>
<p>从 Mininet CLI 关闭设置：</p>
<pre tabindex="0"><code>mininet&gt; exit
</code></pre><p>xterms 应该会自动关闭。</p>
<h4 id="其他交换机类型">其他交换机类型</h4>
<p>可以使用其他交换机类型。例如，要运行用户空间交换机：</p>
<pre tabindex="0"><code>$ sudo mn --switch user --test iperf
</code></pre><p>请注意，与之前使用内核开关看到的相比，TCP iperf 报告的带宽要低得多。</p>
<p>如果您进行前面所示的 ping 测试，您应该注意到更高的延迟，因为现在数据包必须经受额外的内核到用户空间的转换。ping 时间将更加可变，因为代表主机的用户空间进程可能由操作系统安排进出。</p>
<p>另一方面，用户空间切换可以是实现新功能的一个很好的起点，尤其是在软件性能不重要的情况下。</p>
<p>另一个示例交换机类型是 Open vSwitch (OVS)，它预装在 Mininet VM 上。iperf 报告的 TCP 带宽应该类似于 OpenFlow 内核模块，并且可能更快：</p>
<pre tabindex="0"><code>$ sudo mn --switch ovsk --test iperf
</code></pre><h4 id="mininet基准">mininet基准</h4>
<p>要记录设置和拆除拓扑的时间，请使用测试“none”：</p>
<pre tabindex="0"><code>$ sudo mn --test none
</code></pre><h4 id="一切都在自己的命名空间中仅限用户切换">一切都在自己的命名空间中（仅限用户切换）</h4>
<p>默认情况下，主机位于它们自己的命名空间中，而交换机和控制器位于根命名空间中。要将交换机放在它们自己的命名空间中，请传递以下&ndash;innamespace选项：</p>
<pre tabindex="0"><code>$ sudo mn --innamespace --switch user
</code></pre><p>交换机将通过单独的桥接控制连接与控制器通信，而不是使用环回。这个选项本身并不是很有用，但它确实提供了一个如何隔离不同交换机的示例。</p>
<p>请注意，此选项（自 2012 年 11 月 19 日起）不适用于 Open vSwitch。</p>
<pre tabindex="0"><code>mininet&gt; exit
</code></pre><h3 id="第-3-部分mininet-命令行界面-cli-命令">第 3 部分：Mininet 命令行界面 (CLI) 命令</h3>
<h4 id="显示选项">显示选项</h4>
<p>要查看命令行界面 (CLI) 选项列表，请启动最小拓扑并使其保持运行状态。构建迷你网：</p>
<pre tabindex="0"><code>$ sudo mn
</code></pre><p>显示选项：</p>
<pre tabindex="0"><code>mininet&gt; help
</code></pre><h4 id="python解释器">Python解释器</h4>
<p>如果 Mininiet 命令行上的第一个短语是py，那么该命令将使用 Python 执行。这可能对扩展 Mininet 以及探索其内部工作机制很有用。每个主机、交换机和控制器都有一个关联的节点对象。</p>
<p>在 Mininet CLI 中，运行：</p>
<pre tabindex="0"><code>mininet&gt; py &#39;hello &#39; + &#39;world&#39;
</code></pre><p>打印可访问的局部变量：</p>
<pre tabindex="0"><code>mininet&gt; py locals()
</code></pre><p>接下来，使用 dir() 函数查看节点可用的方法和属性：</p>
<pre tabindex="0"><code>mininet&gt; py dir(s1)
</code></pre><p>您可以使用 help() 函数阅读节点上可用方法的联机文档：</p>
<pre tabindex="0"><code>mininet&gt; py help(h1) (Press &#34;q&#34; to quit reading the documentation.)
</code></pre><p>您还可以评估变量的方法：</p>
<pre tabindex="0"><code>mininet&gt; py h1.IP()
</code></pre><h4 id="链接上下">链接上/下</h4>
<p>对于容错测试，打开和关闭链接会很有帮助。</p>
<p>要禁用虚拟以太网对：</p>
<pre tabindex="0"><code>mininet&gt; link s1 h1 down
</code></pre><p>这里h1和h2能ping通s1，原因是s1转换的ip地址是127.0.0.1所以他们相当于给自己发包（回环），所以能通。</p>
<p>您应该会看到生成了 OpenFlow 端口状态更改通知。要恢复链接：</p>
<pre tabindex="0"><code>mininet&gt; link s1 h1 up
</code></pre><h4 id="xterm-显示-1">XTerm 显示</h4>
<p>显示 h1 和 h2 的 xterm：</p>
<pre tabindex="0"><code>mininet&gt; xterm h1 h2
</code></pre><h3 id="第-4-部分python-api-示例">第 4 部分：Python API 示例</h3>
<p>Mininet 源代码树中的示例目录包括如何使用 Mininet 的 Python API 的示例，以及尚未集成到主代码库中的潜在有用代码。</p>
<p>注意：如开头所述，本演练假定您正在使用 Mininet VM，其中包括您需要的一切，或者使用所有相关工具的本机安装，包括参考控制器controller，它是 OpenFlow 参考实现的一部分install.sh -f如果尚未安装，则可以使用安装。</p>
<h4 id="每个主机的-ssh-守护进程">每个主机的 SSH 守护进程</h4>
<p>一个可能特别有用的示例在每台主机上运行 SSH 守护进程：</p>
<pre tabindex="0"><code>$ sudo ~/mininet/examples/sshd.py
</code></pre><p>从另一个终端，您可以通过 ssh 连接到任何主机并运行交互式命令：</p>
<pre tabindex="0"><code>$ ssh 10.0.0.1
$ ping 10.0.0.2
...
$ exit
</code></pre><p>退出 SSH 示例 mininet：</p>
<pre tabindex="0"><code>$ exit
</code></pre><p>在阅读介绍 Python API 的Mininet 简介后，您将希望重新访问这些示例 。</p>
<h3 id="第-5-部分演练完成">第 5 部分：演练完成！</h3>
<p>恭喜！您已经完成了 Mininet 演练。随意尝试新的拓扑结构和控制器或查看源代码。</p>
<h4 id="掌握-mininet-的后续步骤">掌握 Mininet 的后续步骤</h4>
<p>虽然您可以使用 Mininet 的 CLI 走得相当远，但是当您掌握了它的 Python API 后，Mininet 会变得更加有用和强大。Mininet 简介 介绍了 Mininet 及其 Python API。</p>
<p>如果您想知道如何使用远程控制器（例如在 Mininet 的控制之外运行的远程控制器），下面将对此进行解释。</p>
<h3 id="附录补充信息">附录：补充信息</h3>
<h4 id="使用控制器">使用控制器</h4>
<p>注意：此步骤不是默认演练的一部分；如果您有一个在 VM 外部运行的控制器，例如在 VM 主机或不同的物理 PC 上，它主要有用。OpenFlow 教程controller &ndash;remote用于启动您使用 POX、NOX、Beacon 或 Floodlight 等控制器框架创建的简单学习交换机。</p>
<p>当你启动一个 Mininet 网络时，每个交换机都可以连接到一个远程控制器——它可以在 VM 中、VM 外部和你的本地机器上，或者在世界的任何地方。</p>
<p>如果你想尝试这个，填写主机 IP 和/或监听端口：</p>
<pre tabindex="0"><code>$ sudo mn --controller=remote,ip=[controller IP],port=[controller listening port]
</code></pre><p>例如，要运行 POX 的示例学习开关，您可以执行类似</p>
<pre tabindex="0"><code>$ cd ~/pox
$ ./pox.py forwarding.l2_learning
</code></pre><p>在一个窗口中，在另一个窗口中，启动 Mininet 以连接到“远程”控制器（它实际上在本地运行，但不受 Mininet 的控制）：</p>
<pre tabindex="0"><code>$ sudo mn --controller=remote,ip=127.0.0.1,port=6633
</code></pre><p>请注意，POX 使用旧的 OpenFlow 端口 6633，该端口未注册，后来被 Cisco 占用。OpenFlow 的当前注册/规范端口是端口 6653。请为您的控制器使用适当的端口号。</p>
<p>默认情况下，&ndash;controller=remote将使用127.0.0.1并将尝试端口6653和6633。</p>
<p>如果您生成一些流量（例如h1 ping h2），您应该能够在 POX 窗口中观察到一些输出，表明交换机已连接并且一些流表条目已安装。</p>
<p>许多 OpenFlow 控制器框架很容易获得，只要您启动它们并使用 remote控制器运行所在机器的正确 IP 地址和它正在侦听的正确端口指定控制器选项，就应该很容易与 Mininet 一起工作。</p>
<p>有许多可用的 OpenFlow 控制器，您可以使用 Google 或您最喜欢的搜索引擎轻松找到更多控制器。一些流行的包括（按代码大小、功能和复杂性的近似顺序）：</p>
<ul>
<li>Ryu，一个用 Python 编写的基本（有点像 POX）OpenFlow 控制器框架</li>
<li>FAUCET，一个控制器（也是用 Python 编写的，基于 Ryu 框架），通过一个简单的 YML 配置文件支持以太网交换和 IP 路由以及其他功能</li>
<li>ONOS，一个功能齐全的网络操作系统，用 Java 编写</li>
<li>OpenDaylight，“最大的开源 SDN 控制器”</li>
</ul>
<p>所有这些控制器都可以与 Mininet 或硬件网络一起使用。</p>
<h4 id="ryu">Ryu</h4>
<p>Ryu是一个用 Python 编写的基本 OpenFlow 控制器框架。它在 Mininet 中是开箱即用的：</p>
<pre tabindex="0"><code>$ sudo pip3 install ryu  # install ryu if it&#39;s not already installed
$ sudo mn --controller ryu
</code></pre><p>这将运行ryu.app.simple_switch。</p>
<p>您还可以在mn命令行中指定 Ryu 应用程序：</p>
<pre tabindex="0"><code>$ sudo mn --controller,ryu.app.simple_switch_13
</code></pre><p>您还可以将 Ryu 作为远程控制器运行。</p>
<p>在一个窗口中：</p>
<pre tabindex="0"><code>$ ryu run ryu.app.simple_switch
</code></pre><p>然后在另一个窗口中：</p>
<pre tabindex="0"><code>$ sudo mn --controller remote
</code></pre><h2 id="mininet简介">mininet简介</h2>
<p><a href="https://github.com/mininet/mininet/wiki/Introduction-to-Mininet" target="_blank" rel="noopener noreffer ">github</a></p>
<h3 id="什么是迷你网">什么是迷你网？</h3>
<p>Mininet 是一个网络仿真器，或者更准确地说是一个 网络仿真编排系统。它在单个 Linux 内核上运行终端主机、交换机、路由器和链路的集合。它使用轻量级虚拟化使单个系统看起来像一个完整的网络，运行相同的内核、系统和用户代码。Mininet 主机的行为就像一台真实的机器；你可以ssh进入它（如果你启动 sshd并将网络桥接到您的主机）并运行任意程序（包括安装在底层 Linux 系统上的任何程序。）您运行的程序可以通过看似真实的以太网接口发送数据包，具有给定的链接速度和延迟。数据包由看起来像真正的以太网交换机、路由器或中间盒的东西处理，并进行一定数量的排队。当两个程序（如 iperf客户端和服务器）通过 Mininet 进行通信时，测得的性能应该与两台（较慢的）本地机器的性能相匹配。</p>
<p>简而言之，Mininet 的虚拟主机、交换机、链路和控制器是真实存在的——它们只是使用软件而不是硬件创建的——并且在大多数情况下，它们的行为类似于离散的硬件元素。通常可以创建类似于硬件网络的 Mininet 网络，或类似于 Mininet 网络的硬件网络，并在任一平台上运行相同的二进制代码和应用程​​序。</p>
<h3 id="为什么-mininet-很酷">为什么 Mininet 很酷？</h3>
<ol>
<li>它很快——启动一个简单的网络只需几秒钟。这意味着您的运行-编辑-调试循环可以非常快。</li>
<li>您可以创建自定义拓扑：单个交换机、更大的类似 Internet 的拓扑、斯坦福骨干网、数据中心或其他任何东西。</li>
<li>您可以运行真正的程序：任何在 Linux 上运行的程序都可以运行，从 Web 服务器到 TCP 窗口监控工具再到 Wireshark。</li>
<li>您可以自定义数据包转发：Mininet 的交换机可以使用 OpenFlow 协议进行编程。在 Mininet 中运行的自定义软件定义网络设计可以轻松转移到硬件 OpenFlow 交换机以进行线速数据包转发。</li>
<li>您可以在笔记本电脑、服务器、虚拟机、本地 Linux 机器（Ubuntu 12.10+ 中包含 Mininet！）或云（例如 Amazon EC2）上运行 Mininet。</li>
<li>您可以共享和复制结果：一旦您将代码打包，任何拥有计算机的人都可以运行您的代码。</li>
<li>您可以轻松使用它：您可以通过编写简单（或必要时复杂）Python 脚本来创建和运行 Mininet 实验。</li>
<li>Mininet 是一个开源项目，因此我们鼓励您在https://github.com/mininet上检查其源代码、修改它、修复错误、文件问题/功能请求以及提交补丁/拉取请求。您还可以编辑此文档以修复任何错误或添加说明或其他信息。</li>
<li>Mininet正在积极开发中。所以，如果它很糟糕，没有意义，或者由于某种原因不起作用，请告诉我们mininet-discuss ，Mininet 用户和开发人员社区可以尝试解释、修复或帮助您修复它。:-) 如果您发现错误，我们鼓励您提交补丁来修复它们，或者至少在 github 上提交一个问题，包括一个可重现的测试用例。</li>
</ol>
<h3 id="mininet-的局限性是什么">Mininet 的局限性是什么？</h3>
<p>尽管我们认为 Mininet 很棒，但它确实有一些局限性。例如，</p>
<ul>
<li>在单个系统上运行很方便，但它施加了资源限制：如果您的服务器有 3 GHz 的 CPU 并且可以交换大约 10 Gbps 的模拟流量，那么这些资源将需要在您的虚拟主机和交换机之间进行平衡和共享。</li>
<li>Mininet 为所有虚拟主机使用单个 Linux 内核；这意味着您不能运行依赖于 BSD、Windows 或其他操作系统内核的软件。（尽管您可以将 VM 附加到 Mininet。）</li>
<li>Mininet 不会为您编写 OpenFlow 控制器；如果您需要自定义路由器或交换机行为，则需要查找或开发具有所需功能的控制器。</li>
<li>默认情况下，您的 Mininet 网络与您的 LAN 和 Internet 隔离 - 这通常是一件好事！但是，您可以使用该 NAT对象和/或&ndash;nat选项通过网络地址转换将您的 Mininet 网络连接到您的 LAN。您还可以将真实（或虚拟）硬件接口附加到您的 Mininet 网络（有关详细信息，请参阅 examples/hwintf.py。）</li>
<li>默认情况下，所有 Mininet 主机共享主机文件系统和 PID 空间；这意味着如果您正在运行需要在 /etc 中配置的守护进程，您可能必须小心，并且您需要小心不要错误地杀死错误的进程。（请注意该bind.py 示例演示了如何拥有每个主机的私有目录。）</li>
<li>与模拟器不同，Mininet 没有强烈的虚拟时间概念；这意味着时序测量将基于实时，并且无法轻易模拟比实时更快的结果（例如 100 Gbps 网络）。</li>
</ul>
<p>关于性能的旁白：对于网络受限的实验，您必须牢记的主要事情是您可能需要使用较慢的链接，例如 10 或 100 Mb/秒而不是 10 Gb/秒，因为数据包由一组共享 CPU 和内存资源的软件交换机（例如 Open vSwitch）转发，通常性能低于专用交换硬件。对于 CPU 限制的实验，您还需要确保仔细限制 Mininet 主机的 CPU 带宽。如果您主要关心功能的正确性，则可以在没有特定带宽限制的情况下运行 Mininet - 这是运行 Mininet 的快速简便的方法，并且它还以牺牲负载下的计时精度为代价提供最高的性能。</p>
<p>除了少数例外，您可能遇到的许多限制都不是 Mininet 固有的；消除它们可能只是代码问题，我们鼓励您贡献您可能开发的任何增强功能！</p>
<h3 id="使用-mininet">使用 Mininet</h3>
<p>以下部分描述了 Mininet（及其 Python API）的几个功能，您可能会发现这些功能很有用。</p>
<h4 id="创建拓扑">创建拓扑</h4>
<p>Mininet 支持参数化拓扑。使用几行 Python 代码，您可以创建一个灵活的拓扑结构，该拓扑结构可以根据您传递给它的参数进行配置，并可重复用于多个实验。</p>
<p>例如，这是一个简单的网络拓扑（基于mininet/topo.py:SingleSwitchTopo），它由连接到单个交换机（s1）的指定数量的主机（h1通过hN）组成。</p>
<p>请注意，这是 Mininet 2.2 中引入的推荐（简化）拓扑语法：</p>
<pre tabindex="0"><code>#!/usr/bin/python                                                                            
                                                                                             
from mininet.topo import Topo
from mininet.net import Mininet
from mininet.util import dumpNodeConnections
from mininet.log import setLogLevel

class SingleSwitchTopo(Topo):
    &#34;Single switch connected to n hosts.&#34;
    def build(self, n=2):
        switch = self.addSwitch(&#39;s1&#39;)
        # Python&#39;s range(N) generates 0..N-1
        for h in range(n):
            host = self.addHost(&#39;h%s&#39; % (h + 1))
            self.addLink(host, switch)

def simpleTest():
    &#34;Create and test a simple network&#34;
    topo = SingleSwitchTopo(n=4)
    net = Mininet(topo)
    net.start()
    print( &#34;Dumping host connections&#34; )
    dumpNodeConnections(net.hosts)
    print( &#34;Testing network connectivity&#34; )
    net.pingAll()
    net.stop()

if __name__ == &#39;__main__&#39;:
    # Tell mininet to print useful information
    setLogLevel(&#39;info&#39;)
    simpleTest()
</code></pre><p>上述代码中重要的类、方法、函数和变量包括：</p>
<ul>
<li>Topo: Mininet 拓扑的基类</li>
<li>build(): 在拓扑类中重写的方法。构造函数参数 (n) 将由Topo.<strong>init</strong>()自动传递给它。此方法创建一个模板（基本上是一个节点名称图和一个配置信息数据库），然后使用它来创建Mininet实际拓扑。</li>
<li>addSwitch(): 添加一个交换机到拓扑并返回交换机名称</li>
<li>addHost(): 将主机添加到拓扑并返回主机名</li>
<li>addLink()：添加双向链接到拓扑（并返回链接键，但这并不重要）。除非另有说明，否则 Mininet 中的链接是双向的。</li>
<li>Mininet: 创建和管理网络的主类</li>
<li>start(): 启动你的网络</li>
<li>pingAll()：通过尝试让所有节点相互 ping 来测试连通性</li>
<li>stop(): 停止你的网络</li>
<li>net.hosts：网络中的所有主机</li>
<li>dumpNodeConnections()：将连接转储到/来自一组节点。</li>
<li>setLogLevel( &lsquo;info&rsquo; | &lsquo;debug&rsquo; | &lsquo;output&rsquo; ): 设置 Mininet 的默认输出电平；建议使用“info”，因为它提供了有用的信息。</li>
</ul>
<p>可以在mininet/examples中找到其他示例代码。</p>
<h4 id="注意mininet和构造函数">注意：Mininet()和构造函数</h4>
<p>如果您是 Python 新手，这可能会造成混淆，但区分 构造函数（返回对象的函数）和对象（实际对象实例）很重要。</p>
<p>Mininet()是创建并返回网络对象的构造函数。Mininet它需要一些配置参数，特别是：</p>
<ul>
<li>topo：拓扑对象（不是构造函数或模板 - 实际对象！）</li>
<li>host：用于在拓扑中创建Host元素的构造函数</li>
<li>switch：用于在拓扑中创建Switch元素的构造函数</li>
<li>controller：用于在拓扑中创建Controller元素的构造函数</li>
<li>link: 用于在拓扑中创建 Link s 的构造函数、</li>
</ul>
<p>请注意，由于host、switch、controller和link是构造函数，因此不应直接调用它们。</p>
<p>例如，这是错误的：</p>
<pre tabindex="0"><code>net = Mininet( topo=SingleSwitchTopo(), switch=OVSSwitch(protocols=&#39;OpenFlow10&#39;) ... )
                                               ^ ERROR! Not a constructor function
</code></pre><p>但是，构造函数可能专门使用functools.partial：</p>
<pre tabindex="0"><code>from functools import partial

net = Mininet( topo=SingleSwitchTopo(), link=partial(TCLink,delay=&#39;30ms&#39;, bw=100) ... )
</code></pre><p>您还可以创建自己的构造函数或子类。请记住，将为拓扑中的每个网络元素调用构造函数。</p>
<p>请注意，Mininet 开发人员最终让步并允许您传入一个controller 对象或对象列表。这对于使用多个控制器的网络来说还算可以。控制器列表将传递给switch 构造函数。</p>
<h4 id="仅限早期-mininet-版本10-和-20的拓扑说明">仅限早期 Mininet 版本（1.0 和 2.0）的拓扑说明</h4>
<p>见官网</p>
<h4 id="脚本输出">脚本输出</h4>
<p>运行此脚本应该会产生类似于以下内容的结果：</p>
<pre tabindex="0"><code>$ sudo python simpletest.py
*** Creating network
*** Adding controller
*** Adding hosts:
h1 h2 h3 h4 
*** Adding switches:
s1 
*** Adding links:
(h1, s1) (h2, s1) (h3, s1) (h4, s1) 
*** Configuring hosts
h1 h2 h3 h4 
*** Starting controller
c0 
*** Starting 1 switches
s1 ...
Dumping host connections
h1 h1-eth0:s1-eth1
h2 h2-eth0:s1-eth2
h3 h3-eth0:s1-eth3
h4 h4-eth0:s1-eth4
Testing network connectivity
*** Ping: testing ping reachability
h1 -&gt; h2 h3 h4 
h2 -&gt; h1 h3 h4 
h3 -&gt; h1 h2 h4 
h4 -&gt; h1 h2 h3 
*** Results: 0% dropped (12/12 received)
*** Stopping 1 controllers
c0 
*** Stopping 4 links
....
*** Stopping 1 switches
s1 
*** Stopping 4 hosts
h1 h2 h3 h4 
*** Done
</code></pre><h4 id="设置性能参数">设置性能参数</h4>
<p>除了基本的行为网络之外，Mininet 还通过CPULimitedHost和TCLink 类提供性能限制和隔离功能。</p>
<p>这些类有多种使用方式，但一种简单的方法是将它们指定为默认宿主并将类/构造函数链接到Mininet()，然后在拓扑中指定适当的参数。（您还可以在拓扑本身中指定自定义类，或创建自定义节点和链接构造函数和/或子类。）</p>
<pre tabindex="0"><code>#!/usr/bin/python

from mininet.topo import Topo
from mininet.net import Mininet
from mininet.node import CPULimitedHost
from mininet.link import TCLink
from mininet.util import dumpNodeConnections
from mininet.log import setLogLevel

class SingleSwitchTopo( Topo ):
    &#34;Single switch connected to n hosts.&#34;
    def build( self, n=2 ):
	switch = self.addSwitch( &#39;s1&#39; )
	for h in range(n):
	    # Each host gets 50%/n of system CPU
	    host = self.addHost( &#39;h%s&#39; % (h + 1),
		                 cpu=.5/n )
	    # 10 Mbps, 5ms delay, 2% loss, 1000 packet queue
	    self.addLink( host, switch, bw=10, delay=&#39;5ms&#39;, loss=2,
                          max_queue_size=1000, use_htb=True )

def perfTest():
    &#34;Create network and run simple performance test&#34;
    topo = SingleSwitchTopo( n=4 )
    net = Mininet( topo=topo,
	           host=CPULimitedHost, link=TCLink )
    net.start()
    print( &#34;Dumping host connections&#34; )
    dumpNodeConnections( net.hosts )
    print( &#34;Testing network connectivity&#34; )
    net.pingAll()
    print( &#34;Testing bandwidth between h1 and h4&#34; )
    h1, h4 = net.get( &#39;h1&#39;, &#39;h4&#39; )
    net.iperf( (h1, h4) )
    net.stop()

if __name__ == &#39;__main__&#39;:
    setLogLevel( &#39;info&#39; )
    perfTest()
</code></pre><p>重要方法和参数：</p>
<p>self.addHost(name, cpu=f):这允许您指定将分配给虚拟主机的整个系统 CPU 资源的一部分。</p>
<p>self.addLink( node1, node2, bw=10, delay=&lsquo;5ms&rsquo;, max_queue_size=1000, loss=10, use_htb=True)：添加具有带宽、延迟和丢失特性的双向链接，使用分层令牌桶速率限制器和 netem 延迟/丢失模拟器，最大队列大小为 1000 个数据包。该参数bw以Mbit为单位的数字表示；delay表示为带有单位的字符串（例如“5ms”、“100us”、“1s”）；loss以百分比表示（介于 0 和 100 之间）；max_queue_size以数据包表示。</p>
<p>您可能会发现创建Python 字典非常有用，这样可以轻松地将相同的参数传递给多个方法调用，例如：</p>
<pre tabindex="0"><code>     linkopts = dict(bw=10, delay=&#39;5ms&#39;, loss=10, max_queue_size=1000, use_htb=True)
     # (or you can use brace syntax: linkopts = {&#39;bw&#39;:10, &#39;delay&#39;:&#39;5ms&#39;, ... } )
     self.addLink(node1, node2, **linkopts)
</code></pre><p>同样的技术(**dict)对于将选项传递给 Matplotlib 和其他库很有用。</p>
<p>net.get()：按名称检索节点（主机或交换机）对象。如果您想向主机发送命令（例如使用 host.cmd()）并获取其输出，这一点很重要。</p>
<p>注意：在 Mininet 的当前 master 分支中，您可以简单地使用大括号（例如net[&lsquo;h1&rsquo;]）按名称检索给定的节点。</p>
<h4 id="在主机中运行程序">在主机中运行程序</h4>
<p>在你的实验中你需要做的最重要的事情之一是在主机上运行程序，这样你就可以运行比 Mininet 本身提供的简单测试pingAll()和iperf()测试更多的测试。</p>
<p>每个 Mininet 主机本质上是一个附加到一个或多个网络接口的 bash shell 进程，因此与其交互的最简单方法是使用 cmd() 方法将输入发送到 shell。</p>
<p>要在主机中运行命令并获取输出，请使用cmd()方法。</p>
<pre tabindex="0"><code>    h1 = net.get(&#39;h1&#39;)	
    result = h1.cmd(&#39;ifconfig&#39;)
    print( result )
</code></pre><p>在许多情况下，您会希望在后台运行命令一段时间，然后停止该命令，并将其输出保存到一个文件中：</p>
<pre tabindex="0"><code>from time import sleep
...
print( &#34;Starting test...&#34; )
h1.cmd(&#39;while true; do date; sleep 1; done &gt; /tmp/date.out &amp;&#39;)
sleep(10)
print( &#34;Stopping test&#34; )
h1.cmd(&#39;kill %while&#39;)
print( &#34;Reading output&#34; )
f = open(&#39;/tmp/date.out&#39;)
lineno = 1
for line in f.readlines():
    print( &#34;%d: %s&#34; % ( lineno, line.strip() ) )
    lineno += 1
f.close()
</code></pre><p>请注意，我们使用 shell 的输出重定向功能将输出发送到/tmp/date.out，使用 shell 的后台执行功能在后台&amp;运行命令，并使用作业控制kill %while关闭在后台运行的程序。不幸的是，如果你让作业在后台运行，它们不能保证在 Mininet 退出时停止（无论是有意还是由于错误），所以你需要确保你完全停止所有作业。您可能希望定期使用 ps 命令来确保没有僵尸作业在无意识地向前推进并减慢您的 EC2 实例。</p>
<p>（注意：Python 字符串可以使用单引号或双引号分隔。上面的示例在 print 语句中使用双引号，在函数参数中使用单引号，但您可以随心所欲。Python 2 的print语句 [和 Python 3 的print()函数] 存在于方便，并可能帮助 BASIC 程序员感觉更自在。）</p>
<p>拥有一个 shell 进程可以让您轻松执行其他任务。例如，您可以使用以下命令找出后台命令的 PID</p>
<pre tabindex="0"><code>pid = int( h1.cmd(&#39;echo $!&#39;) )
</code></pre><p>然后你可以使用 wait 等待特定进程完成执行，例如：</p>
<pre tabindex="0"><code>h1.cmd(&#39;wait&#39;, pid)
</code></pre><p>请注意，这仅适用于 UNIX 命令，不适用于内置于 bash shell 本身（并且没有单独的 pid！）的命令（例如while，cd）。还要注意，这些命令中的每一个都在前台执行（没有&amp;）而不是后台 (&amp;)，因为我们想要获得输出。</p>
<p>除了使用 shell 的等待机制之外，Mininet 本身还允许您使用以下命令启动前台命令sendCmd()，然后等待它在稍后的某个时间完成waitOutput()：</p>
<pre tabindex="0"><code>for h in hosts:
    h.sendCmd(&#39;sleep 20&#39;)
…
results = {}
for h in hosts:
    results[h.name] = h.waitOutput()
</code></pre><p>如果将输出发送到文件，您可能希望在测试运行时以交互方式监视该文件的内容。该 examples/multipoll.py 示例提供了一个函数，该函数monitorFiles()实现了一种可能的机制来监视多个输出文件。这简化了交互式监视来自多个主机的输出的测试的实现：</p>
<pre tabindex="0"><code>def monitorTest( N=3, seconds=3 ):
    &#34;Run pings and monitor multiple hosts&#34;
    topo = SingleSwitchTopo( N )
    net = Mininet( topo )
    net.start()
    hosts = net.hosts
    print( &#34;Starting test...&#34; )
    server = hosts[ 0 ]
    outfiles, errfiles = {}, {}
    for h in hosts:
        # Create and/or erase output files
        outfiles[ h ] = &#39;/tmp/%s.out&#39; % h.name
        errfiles[ h ] = &#39;/tmp/%s.err&#39; % h.name
        h.cmd( &#39;echo &gt;&#39;, outfiles[ h ] )
        h.cmd( &#39;echo &gt;&#39;, errfiles[ h ] )
        # Start pings
        h.cmdPrint(&#39;ping&#39;, server.IP(),
                   &#39;&gt;&#39;, outfiles[ h ],
                   &#39;2&gt;&#39;, errfiles[ h ],
                   &#39;&amp;&#39; )
    print( &#34;Monitoring output for&#34;, seconds, &#34;seconds&#34; )
    for h, line in monitorFiles( outfiles, seconds, timeoutms=500 ):
        if h:
            print( &#39;%s: %s&#39; % ( h.name, line ) )
    for h in hosts:
        h.cmd(&#39;kill %ping&#39;)
    net.stop()
</code></pre><p>您可能希望运行multipoll.py并查看其输出。</p>
<p>另一个示例examples/multiping.py 演示了一种不同的（可能更简单但不太灵活）方法来监视来自主机的标准输出，使用Node.monitor()方法，因此您可能也希望查看它。</p>
<h4 id="新popenpexec界面">新：popen()/pexec()界面</h4>
<p>除了cmd()/sendCmd()的基于 shell 的机制之外，Mininet 现在还支持返回标准 Python Popen()对象的基于管道的接口（有关详细信息，请参阅 Python 的 subprocess 模块。）该机制较新且没有经过充分测试cmd()，但您可能会发现在后台运行多个进程并监视它们的输出很方便。提供了一个pmonitor()功能，Popen()可以更轻松地监视多个对象。</p>
<p>examples/popenpoll.py中的代码使用popen()接口和pmonitor()辅助函数实现与上述类似的功能：</p>
<pre tabindex="0"><code>def pmonitorTest( N=3, seconds=10 ):
    &#34;Run pings and monitor multiple hosts using pmonitor&#34;
    topo = SingleSwitchTopo( N )
    net = Mininet( topo )
    net.start()
    hosts = net.hosts
    print( &#34;Starting test...&#34; )
    server = hosts[ 0 ]
    popens = {}
    for h in hosts:
        popens[ h ] = h.popen(&#39;ping&#39;, server.IP() )
        print( &#34;Monitoring output for&#34;, seconds, &#34;seconds&#34; )
        endTime = time() + seconds
        for h, line in pmonitor( popens, timeoutms=500 ):
            if h:
                print( &#39;%s: %s&#39; % ( h.name, line ), )
                if time() &gt;= endTime:
                    for p in popens.values():
                        p.send_signal( SIGINT )
        net.stop()
</code></pre><p>请注意，此实现略有不同，因为它将时间管理从pmonitor()辅助函数中提取出来，但这使得ping能够在它被中断后捕获它的输出。</p>
<p>当然，您不必使用pmonitor()- 您可以使用 Popen.communicate()（只要您没有太多文件描述符）或select.poll()以及任何其他有效的机制。</p>
<h4 id="重要共享文件系统">重要：共享文件系统！</h4>
<p>要记住的一件事是，默认情况下 Mininet 主机共享底层服务器的根文件系统。通常这是一件非常好的事情，因为为每个 Mininet 主机创建一个单独的文件系统是一件非常痛苦的事情（而且很慢）（如果你愿意，你可以这样做，然后 chroot 进去！）</p>
<p>共享根文件系统还意味着您几乎不需要在 Mininet 主机之间复制数据，因为它已经存在。</p>
<p>然而，这样做的一个副作用是主机共享 Mininet 服务器的 /etc目录。这意味着如果您需要对程序进行特定配置（例如httpd），那么您可能需要为每个 Mininet 主机创建不同的配置文件，并将它们指定为您正在运行的程序的启动选项。</p>
<p>另一个副作用是，如果您尝试在多个主机上的同一目录中创建同一文件，则可能会发生文件冲突。</p>
<p>如果您需要每个主机的私有目录，您可以将它们指定为Host的选项，例如：</p>
<pre tabindex="0"><code>h = Host( &#39;h1&#39;, privateDirs=[ &#39;/some/directory&#39; ] )
</code></pre><p>有关详细信息，请参阅examples/bind.py。</p>
<h4 id="主机配置方法">主机配置方法</h4>
<p>Mininet hosts 提供了一些方便的网络配置方法：</p>
<ol>
<li>IP(): 返回主机或特定接口的 IP 地址。</li>
<li>MAC()：返回主机或特定接口的 MAC 地址。</li>
<li>setARP(): 将静态 ARP 条目添加到主机的 ARP 缓存中。</li>
<li>setIP()：设置主机或特定接口的 IP 地址。</li>
<li>setMAC()：设置主机或特定接口的MAC地址</li>
</ol>
<p>例如：</p>
<pre tabindex="0"><code>    print( &#34;Host&#34;, h1.name, &#34;has IP address&#34;, h1.IP(), &#34;and MAC address&#34;, h1.MAC() )
</code></pre><p>在任何情况下，如果您不提供特定接口（例如h1-eth0 或接口对象），该方法将使用主机的默认接口。以上函数定义在 mininet/node.py 中。</p>
<h4 id="在-mininet-中命名">在 Mininet 中命名</h4>
<p>为了有效地使用 Mininet，了解其主机、交换机和接口的命名方案非常重要。通常，主机被称为h1..hN，交换机被称为s1..sN。我们建议您遵循此约定或类似约定。为清楚起见，属于节点的接口以节点名称开头命名，例如h1-eth0是主机h1的默认接口，s1-eth1是交换机s1的第一个数据端口。主机接口仅在主机内部可见，但交换机数据端口在“根”命名空间中可见（您可以ip link show在 Mininet 运行时通过在另一个窗口中键入来查看它们。）因此，很容易检查交换机接口，但检查主机接口有点棘手（主要使用host.cmd())。</p>
<h4 id="命令行界面">命令行界面</h4>
<p>Mininet 包括一个可以在网络上调用的命令行界面 (CLI)，并提供各种有用的命令，以及显示 xterm 窗口和在网络中的各个节点上运行命令的能力。您可以通过将网络对象传递给CLI()构造函数来在网络上调用 CLI：</p>
<pre tabindex="0"><code>from mininet.topo import SingleSwitchTopo
from mininet.net import Mininet
from mininet.cli import CLI

net = Mininet(SingleSwitchTopo(2))
net.start()
CLI(net)
net.stop()
</code></pre><p>启动 CLI 可用于调试网络，因为它允许您查看网络拓扑（使用net命令）、测试连接性（使用pingall命令）以及向各个主机发送命令。</p>
<pre tabindex="0"><code>*** Starting CLI:
mininet&gt; net
c0
s1 lo:  s1-eth1:h1-eth0 s1-eth2:h2-eth0
h1 h1-eth0:s1-eth1
h2 h2-eth0:s1-eth2
mininet&gt; pingall
*** Ping: testing ping reachability
h1 -&gt; h2
h2 -&gt; h1
*** Results: 0% dropped (0/2 lost)
mininet&gt; h1 ip link show
746: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 16436 qdisc noqueue state UNKNOWN
	link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
749: h1-eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
	link/ether d6:13:2d:6f:98:95 brd ff:ff:ff:ff:ff:ff
</code></pre><h4 id="mn使用--custom文件自定义">mn使用&ndash;custom文件自定义</h4>
<p>除了用 Python 编写完整的 Mininet 脚本外，您还可以使用&ndash;custom选项扩展mn命令行工具。该选项允许您使用mn来调用您自己的自定义拓扑、交换机、主机、控制器或链接类。您还可以定义和调用自己的系统测试，并添加新的 Mininet CLI 命令。</p>
<p>要添加可以使用mn命令调用的新功能，您需要根据选项类型在&ndash;custom文件中定义一个字典。DICT的键是将其短名称传递给了适当的选项，并且值是相应的子类，构造函数或函数：</p>
<p><a href="https://github.com/mininet/mininet/wiki/Introduction-to-Mininet#customizing-mn-using---custom-files" target="_blank" rel="noopener noreffer ">图表</a></p>
<p>例如：</p>
<pre tabindex="0"><code>class MyTopo( Topo ):
   def build( self, ...):
def myTest( net ):
...
topos = { &#39;mytopo&#39;: MyTopo }
tests = { &#39;mytest&#39;: myTest }
</code></pre><p>这会将 MyTopo 类（或构造函数）添加到 topos 字典中，允许它与&ndash;topo选项以及新测试一起使用mytest。请注意，测试函数是使用顶级Mininet对象调用的，您可以将字符串或数字参数传递给MyTopo：</p>
<pre tabindex="0"><code>sudo mn --custom mytopo.py --topo mytopo,3
</code></pre><p>您还可以指定多个自定义文件：</p>
<pre tabindex="0"><code>sudo mn --custom mytopo.py,mytest.py --topo mytopo,3 --test mytest
</code></pre><p>这将mytopo用作默认拓扑并调用mytest测试。</p>
<p>这是启动 Mininet、运行端到端系统测试（或多个测试）以及关闭 Mininet 的非常方便的单行命令。如果发生异常，标准的 Mininet 清理代码将被调用，就像mn通常在这种情况下所做的那样。</p>
<h5 id="--custom在文件中添加新的-cli-命令">&ndash;custom在文件中添加新的 CLI 命令</h5>
<p>在文件中添加新的 CLI 命令很容易&ndash;custom：</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 2022-11-28</span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="Share on Twitter" data-sharer="twitter" data-url="https://oublie6.github.io/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/" data-title="Python-第三方库-Mininet"><i class="fab fa-twitter fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Facebook" data-sharer="facebook" data-url="https://oublie6.github.io/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/"><i class="fab fa-facebook-square fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Hacker News" data-sharer="hackernews" data-url="https://oublie6.github.io/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/" data-title="Python-第三方库-Mininet"><i class="fab fa-hacker-news fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Line" data-sharer="line" data-url="https://oublie6.github.io/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/" data-title="Python-第三方库-Mininet"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on 微博" data-sharer="weibo" data-url="https://oublie6.github.io/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/" data-title="Python-第三方库-Mininet"><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/" class="prev" rel="prev" title="数据结构-线段树"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>数据结构-线段树</a>
            <a href="/posts/python/%E6%9D%82%E8%AE%B0/functools.partial/" class="next" rel="next" title="Python-杂记-Functools.partial">Python-杂记-Functools.partial<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
<div id="comments"></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.102.3">Hugo</a> | Theme - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden="true"></i> LoveIt</a>
                </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2019 - 2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://oublie6.github.io/" target="_blank">oublie</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/css/lightgallery-bundle.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/lightgallery.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/plugins/thumbnail/lg-thumbnail.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/plugins/zoom/lg-zoom.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":50},"comment":{},"lightgallery":true,"search":{"highlightTag":"em","lunrIndexURL":"/index.json","maxResultLength":10,"noResultsFound":"No results found","snippetLength":50,"type":"lunr"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
