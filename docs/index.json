[{"categories":["数据结构与算法"],"content":"华为机试 ","date":"2023-04-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/%E7%89%9B%E5%AE%A2/:1:0","tags":["刷题"],"title":"数据结构与算法-刷题-牛客","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/%E7%89%9B%E5%AE%A2/"},{"categories":["数据结构与算法"],"content":"HJ16 购物单 HJ16 购物单 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 package main import ( \"bufio\" \"fmt\" \"os\" \"strconv\" \"strings\" ) func main() { //修改标准输入设备为in文件，提交代码时删除该部分代码以及上面的引入的os库 fin, errin := os.Open(\"in\") if errin != nil { panic(errin) } defer fin.Close() os.Stdin = fin //修改标准输出设备为out文件，提交代码时删除该部分代码 fout, errout := os.OpenFile(\"out\", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0755) if errout != nil { panic(errout) } defer fout.Close() os.Stdout = fout //这里往下开始写解题过程 //----------------- //输入预处理 sc := bufio.NewScanner(os.Stdin) sc.Scan() str := strings.Split(sc.Text(), \" \") money, _ := strconv.Atoi(str[0]) n, _ := strconv.Atoi(str[1]) items := make([]item, n) for i := 0; i \u003c n; i++ { //构造物品 sc.Scan() it := strings.Split(sc.Text(), \" \") v, _ := strconv.Atoi(it[0]) p, _ := strconv.Atoi(it[1]) q, _ := strconv.Atoi(it[2]) items[i] = item{ v, p, q, nil, nil, } } for j, k := range items { //构造主物品 if k.q != 0 { if items[k.q-1].acc1 == nil { // fmt.Println(k,\"acc1\") items[k.q-1].acc1 = \u0026items[j] } else { items[k.q-1].acc2 = \u0026items[j] } } } // fmtx.Println(\"ist\",items) //由于每个东西只能买一件，并且买了主件才能买附件，同时主键的附件数量是确定的不大于2 //因此我们可以看成购买就是针对于主件，只不过主件的附件数量不同而已，因为只能买一次 //因此主件和附件的搭配只能选一种，之后就可以看成01背包问题，只不过背包的物品是多选一的 matrix := make([][]int, n+1) for j, _ := range matrix { matrix[j] = make([]int, money+1) } cnt := 1 for i := 0; i \u003c n; i++ { if items[i].q != 0 { //附件直接跳过 continue } //构造各个选择的价格和满意度 var ( v0 = items[i].v //只有主件 myd0 = v0 * items[i].p v1 = v0 //主件加附件1 myd1 = myd0 v2 = v0 //主件加附件2 myd2 = myd0 v3 = v0 //主件加两个附件 myd3 = myd0 ) if items[i].acc1 != nil { v1 += items[i].acc1.v myd1 += items[i].acc1.v * items[i].acc1.p } if items[i].acc2 != nil { v2 += items[i].acc2.v myd2 += items[i].acc2.v * items[i].acc2.p } if items[i].acc1 != nil \u0026\u0026 items[i].acc2 != nil { v3 = v3 + items[i].acc1.v + items[i].acc2.v myd3 = myd3 + items[i].acc1.v*items[i].acc1.p + items[i].acc2.v*items[i].acc2.p } // fmt.Println(\"gz\",v0,myd0,v1,myd1,v2,myd2,v3,myd3) for j := 1; j \u003c= money; j++ { matrix[cnt][j] = matrix[cnt-1][j] if j \u003e= v0 { matrix[cnt][j] = max(matrix[cnt][j], matrix[cnt-1][j-v0]+myd0) } if j \u003e= v1 \u0026\u0026 v1 \u003e v0 { matrix[cnt][j] = max(matrix[cnt][j], matrix[cnt-1][j-v1]+myd1) } if j \u003e= v2 \u0026\u0026 v2 \u003e v0 { matrix[cnt][j] = max(matrix[cnt][j], matrix[cnt-1][j-v2]+myd2) } if j \u003e= v3 \u0026\u0026 v3 \u003e v0 { matrix[cnt][j] = max(matrix[cnt][j], matrix[cnt-1][j-v3]+myd3) } } cnt++ } fmt.Println(matrix[cnt-1][money]) } type item struct { v int p int q int acc1 *item acc2 *item } func max(a int, b int) int { if a \u003e= b { return a } return b } ","date":"2023-04-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/%E7%89%9B%E5%AE%A2/:1:1","tags":["刷题"],"title":"数据结构与算法-刷题-牛客","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/%E7%89%9B%E5%AE%A2/"},{"categories":["数据结构与算法"],"content":"HJ17 坐标移动 HJ17 坐标移动 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 package main import ( \"bufio\" \"fmt\" \"os\" \"strconv\" \"strings\" ) func main() { //修改标准输入设备为in文件，提交代码时删除该部分代码以及上面的引入的os库 fin, errin := os.Open(\"in\") if errin != nil { panic(errin) } defer fin.Close() os.Stdin = fin //修改标准输出设备为out文件，提交代码时删除该部分代码 fout, errout := os.OpenFile(\"out\", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0755) if errout != nil { panic(errout) } defer fout.Close() os.Stdout = fout //这里往下开始写解题过程 //----------------- //输入预处理 sc := bufio.NewScanner(os.Stdin) sc.Scan() str := strings.Split(sc.Text(), \" \") money, _ := strconv.Atoi(str[0]) n, _ := strconv.Atoi(str[1]) items := make([]item, n) for i := 0; i \u003c n; i++ { //构造物品 sc.Scan() it := strings.Split(sc.Text(), \" \") v, _ := strconv.Atoi(it[0]) p, _ := strconv.Atoi(it[1]) q, _ := strconv.Atoi(it[2]) items[i] = item{ v, p, q, nil, nil, } } for j, k := range items { //构造主物品 if k.q != 0 { if items[k.q-1].acc1 == nil { // fmt.Println(k,\"acc1\") items[k.q-1].acc1 = \u0026items[j] } else { items[k.q-1].acc2 = \u0026items[j] } } } // fmtx.Println(\"ist\",items) //由于每个东西只能买一件，并且买了主件才能买附件，同时主键的附件数量是确定的不大于2 //因此我们可以看成购买就是针对于主件，只不过主件的附件数量不同而已，因为只能买一次 //因此主件和附件的搭配只能选一种，之后就可以看成01背包问题，只不过背包的物品是多选一的 matrix := make([][]int, n+1) for j, _ := range matrix { matrix[j] = make([]int, money+1) } cnt := 1 for i := 0; i \u003c n; i++ { if items[i].q != 0 { //附件直接跳过 continue } //构造各个选择的价格和满意度 var ( v0 = items[i].v //只有主件 myd0 = v0 * items[i].p v1 = v0 //主件加附件1 myd1 = myd0 v2 = v0 //主件加附件2 myd2 = myd0 v3 = v0 //主件加两个附件 myd3 = myd0 ) if items[i].acc1 != nil { v1 += items[i].acc1.v myd1 += items[i].acc1.v * items[i].acc1.p } if items[i].acc2 != nil { v2 += items[i].acc2.v myd2 += items[i].acc2.v * items[i].acc2.p } if items[i].acc1 != nil \u0026\u0026 items[i].acc2 != nil { v3 = v3 + items[i].acc1.v + items[i].acc2.v myd3 = myd3 + items[i].acc1.v*items[i].acc1.p + items[i].acc2.v*items[i].acc2.p } // fmt.Println(\"gz\",v0,myd0,v1,myd1,v2,myd2,v3,myd3) for j := 1; j \u003c= money; j++ { matrix[cnt][j] = matrix[cnt-1][j] if j \u003e= v0 { matrix[cnt][j] = max(matrix[cnt][j], matrix[cnt-1][j-v0]+myd0) } if j \u003e= v1 \u0026\u0026 v1 \u003e v0 { matrix[cnt][j] = max(matrix[cnt][j], matrix[cnt-1][j-v1]+myd1) } if j \u003e= v2 \u0026\u0026 v2 \u003e v0 { matrix[cnt][j] = max(matrix[cnt][j], matrix[cnt-1][j-v2]+myd2) } if j \u003e= v3 \u0026\u0026 v3 \u003e v0 { matrix[cnt][j] = max(matrix[cnt][j], matrix[cnt-1][j-v3]+myd3) } } cnt++ } fmt.Println(matrix[cnt-1][money]) } type item struct { v int p int q int acc1 *item acc2 *item } func max(a int, b int) int { if a \u003e= b { return a } return b } ","date":"2023-04-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/%E7%89%9B%E5%AE%A2/:1:2","tags":["刷题"],"title":"数据结构与算法-刷题-牛客","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/%E7%89%9B%E5%AE%A2/"},{"categories":["数据结构与算法"],"content":"HJ18 识别有效的IP地址和掩码并进行分类统计 HJ18 识别有效的IP地址和掩码并进行分类统计 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 package main import ( \"bufio\" \"fmt\" \"io\" \"os\" ) func main() { ////修改标准输入设备为in文件，提交代码时删除该部分代码以及上面的引入的os库 //fin, errin := os.Open(\"in\") //if errin != nil { // panic(errin) //} //defer fin.Close() //os.Stdin = fin // ////修改标准输出设备为out文件，提交代码时删除该部分代码 //fout, errout := os.OpenFile(\"out\", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0755) //if errout != nil { // panic(errout) //} //defer fout.Close() //os.Stdout = fout //这里往下开始写解题过程 //----------------- //输入预处理 A, B, C, D, E, erripormask, private := 0, 0, 0, 0, 0, 0, 0 b := bufio.NewReader(os.Stdin) //mmm := map[byte]int{ // 'A': (1\u003c\u003c8 - 1) \u003c\u003c 24, // 'B': (1\u003c\u003c16 - 1) \u003c\u003c 16, // 'C': (1\u003c\u003c24 - 1) \u003c\u003c 8, // 'D': 1\u003c\u003c32 - 1, // 'E': 1\u003c\u003c32 - 1, //} //for k, v := range mmm { // fmt.Printf(\"%d:%b\\n\", k, v) //} tag: for true { //fmt.Println() ip := make([]int, 4) mask := make([]int, 4) s, err := b.ReadString('\\n') if err != nil { //fmt.Println(err) if err == io.EOF { break } erripormask++ //fmt.Println(\"erripormask++\") continue } if _, err := fmt.Sscanf(s, \"%d.%d.%d.%d~%d.%d.%d.%d\\n\", \u0026ip[0], \u0026ip[1], \u0026ip[2], \u0026ip[3], \u0026mask[0], \u0026mask[1], \u0026mask[2], \u0026mask[3]); err != nil { //fmt.Println(\"erripormask++\") erripormask++ continue } //fmt.Println(\"ip:\", ip, \"mask\", mask) m := 0 for _, v := range mask { m \u003c\u003c= 8 m += v } ipn := 0 for _, v := range ip { ipn *= 1000 ipn += v } //fmt.Println(\"ipn:\", ipn, \"\\tm:\", m) if !((ipn \u003e= 1000000000 \u0026\u0026 ipn \u003c= 126255255255) || (ipn \u003e= 128000000000 \u0026\u0026 ipn \u003c= 191255255255) || (ipn \u003e= 192000000000 \u0026\u0026 ipn \u003c= 223255255255) || (ipn \u003e= 224000000000 \u0026\u0026 ipn \u003c= 239255255255) || (ipn \u003e= 240000000000 \u0026\u0026 ipn \u003c= 255255255255)) { continue } if m == 0 || m == (1\u003c\u003c32-1) { erripormask++ continue } for tmp, flag := 1\u003c\u003c31, true; tmp != 0; tmp \u003e\u003e= 1 { if tmp\u0026m != 0 \u0026\u0026 flag { continue } else if tmp\u0026m == 0 \u0026\u0026 flag { flag = false } else if tmp\u0026m != 0 \u0026\u0026 !flag { //fmt.Printf(\"errmusk,m:%b,tmp:%b,m\u0026tmp:%b\", m, tmp, m\u0026tmp) //fmt.Println(\"erripormask++\") erripormask++ continue tag } } //fmt.Printf(\"ipn:%d\\tm:%b\\n\", ipn, m) switch { case ipn \u003e= 1000000000 \u0026\u0026 ipn \u003c= 126255255255: //if m != mmm['A'] { // erripormask++ // continue tag //} //fmt.Println(\"A++\") A++ case ipn \u003e= 128000000000 \u0026\u0026 ipn \u003c= 191255255255: //if m != mmm['B'] { // erripormask++ // continue tag //} //fmt.Println(\"B++\") B++ case ipn \u003e= 192000000000 \u0026\u0026 ipn \u003c= 223255255255: //if m != mmm['C'] { // erripormask++ // continue tag //} //fmt.Println(\"C++\") C++ case ipn \u003e= 224000000000 \u0026\u0026 ipn \u003c= 239255255255: //if m != mmm['D'] { // erripormask++ // continue tag //} //fmt.Println(\"D++\") D++ case ipn \u003e= 240000000000 \u0026\u0026 ipn \u003c= 255255255255: //if m != mmm['E'] { // erripormask++ // continue tag //} //fmt.Println(\"E++\") E++ default: continue tag } if (ipn \u003e= 10000000000 \u0026\u0026 ipn \u003c= 10255255255) || (ipn \u003e= 172016000000 \u0026\u0026 ipn \u003c= 172031255255) || (ipn \u003e= 192168000000 \u0026\u0026 ipn \u003c= 192168255255) { //fmt.Println(\"private++\") private++ } } fmt.Println(A, B, C, D, E, erripormask, private) } ","date":"2023-04-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/%E7%89%9B%E5%AE%A2/:1:3","tags":["刷题"],"title":"数据结构与算法-刷题-牛客","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/%E7%89%9B%E5%AE%A2/"},{"categories":["数据库"],"content":"倒排索引 CSDN @Sup 对文档进行分词，然后建立分词到id的倒排索引，当需要进行搜索时，求分词的交集即可找到匹配文档的id值，最后通过id查正排索引即可获取完整文档 ","date":"2023-04-20","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:1:0","tags":["elasticsearch"],"title":"数据库-elasticsearch-个人笔记","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["前端"],"content":"本系列是作者在跟着微信官网文档学习时做的笔记，可能并不详尽，读者可以到官网中查看完整内容。 第三方平台官方文档 ","date":"2023-04-18","objectID":"/posts/%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B9%B3%E5%8F%B0/:0:0","tags":["微信开发"],"title":"前端-微信-第三方平台","uri":"/posts/%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B9%B3%E5%8F%B0/"},{"categories":["前端"],"content":"新手指引 ","date":"2023-04-18","objectID":"/posts/%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B9%B3%E5%8F%B0/:1:0","tags":["微信开发"],"title":"前端-微信-第三方平台","uri":"/posts/%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B9%B3%E5%8F%B0/"},{"categories":["前端"],"content":"基本概念 不同类型的ID： AppID：不同类型的产品的帐号ID openid：openid是微信用户在不同类型的产品的身份ID unionid：微信用户在同一个开放平台下的产品的身份ID ","date":"2023-04-18","objectID":"/posts/%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B9%B3%E5%8F%B0/:1:1","tags":["微信开发"],"title":"前端-微信-第三方平台","uri":"/posts/%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B9%B3%E5%8F%B0/"},{"categories":["Golang"],"content":"go语言中文网 godoc go语言中文网有很多文档缺少内容比如string.Builder就没有，godoc绝对详尽，推荐阅读godoc ","date":"2023-04-18","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/encoding/:0:0","tags":["go标准库"],"title":"go标准库-Encoding","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/encoding/"},{"categories":["Golang"],"content":"hex子包 常用函数 func DecodedLen(x int) int：长度x的编码数据解码后的明文数据的长度 func Decode(dst, src []byte) (int, error)：解码 func EncodedLen(n int) int：长度x的明文数据编码后的编码数据的长度 func Encode(dst, src []byte) int：编码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \"encoding/hex\" \"fmt\" ) func main() { a := []byte(\"sadafzxczsd\") b := make([]byte, hex.EncodedLen(len(a))) hex.Encode(b, a) fmt.Println(string(b)) c := make([]byte, hex.DecodedLen(len(b))) hex.Decode(c, b) fmt.Println(string(c)) } func EncodeToString(src []byte) string：将src编码为字符串s func DecodeString(s string) ([]byte, error)：将hex编码的字符串s解码 ","date":"2023-04-18","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/encoding/:1:0","tags":["go标准库"],"title":"go标准库-Encoding","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/encoding/"},{"categories":["P4"],"content":"github nsg-ethz/p4-learning ","date":"2023-04-17","objectID":"/posts/p4/p4-learning/:0:0","tags":["P4"],"title":"P4-P4 Learning","uri":"/posts/p4/p4-learning/"},{"categories":["P4"],"content":"examples simple switch examples ","date":"2023-04-17","objectID":"/posts/p4/p4-learning/:1:0","tags":["P4"],"title":"P4-P4 Learning","uri":"/posts/p4/p4-learning/"},{"categories":["P4"],"content":"基本示例 数据包反射 交换机将所有接收的数据包发回给发送者 network.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \"\"\" +----+ +----+ | h1 +-------+ s1 + +----+ +----+ \"\"\" from p4utils.mininetlib.network_API import NetworkAPI net = NetworkAPI() # 网络配置选项 net.setLogLevel('info') # 设置日志等级 net.enableCli() # 启动mininet CLI # 添加网络节点和链路 net.addP4Switch('s1') # 添加s1 p4交换机 net.setP4Source('s1','reflector.p4') # 给s1 添加p4文件 net.addHost('h1') # 添加主机h1 net.addLink('s1', 'h1') # 添加s1到h1的链路 # 设置分配策略 net.l2() # 2层分配策略 # 网络节点配置选项 net.enablePcapDumpAll() # 允许所有节点记录PcapDump net.enableLogAll() # 允许所有节点记录日志 # 启动网络 net.startNetwork() reflector.p4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 /* -*- P4_16 -*- */ #include \u003ccore.p4\u003e #include \u003cv1model.p4\u003e /************************************************************************* *********************** H E A D E R S *********************************** *************************************************************************/ //mac地址类型 typedef bit\u003c48\u003e macAddr_t; //以太头 header ethernet_t { macAddr_t dstAddr; macAddr_t srcAddr; bit\u003c16\u003e etherType; } //元数据 struct metadata { /* empty */ } //数据包头 struct headers { ethernet_t ethernet; } /************************************************************************* *********************** P A R S E R *********************************** *************************************************************************/ //状态机 parser MyParser(packet_in packet, out headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) { //起始状态 state start{ //读取以太头 packet.extract(hdr.ethernet); //转换状态为接受 transition accept; } } /************************************************************************* ************ C H E C K S U M V E R I F I C A T I O N ************* *************************************************************************/ //校验和控制管道，这里管道流程为空，因为交换机仅作为反射器，不需要校验和 control MyVerifyChecksum(inout headers hdr, inout metadata meta) { //管道流程 apply { } } /************************************************************************* ************** I N G R E S S P R O C E S S I N G ******************* *************************************************************************/ //入口管道 control MyIngress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) { //定义swap_mac动作，用于交换以太头的源mac和目的mac action swap_mac(){ macAddr_t tmp; tmp = hdr.ethernet.srcAddr; hdr.ethernet.srcAddr = hdr.ethernet.dstAddr; hdr.ethernet.dstAddr = tmp; } //管道流程 apply { //交换源mac和目的mac swap_mac(); //将出口设置为和入口所在端口 standard_metadata.egress_spec = standard_metadata.ingress_port; } } /************************************************************************* **************** E G R E S S P R O C E S S I N G ******************* *************************************************************************/ //出口管道 control MyEgress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) { //管道流程为空 apply { } } /************************************************************************* ************* C H E C K S U M C O M P U T A T I O N ************** *************************************************************************/ //计算校验和 control MyComputeChecksum(inout headers hdr, inout metadata meta) { apply { } } /************************************************************************* *********************** D E P A R S E R ******************************* *************************************************************************/ //出口解析器 control MyDeparser(packet_out packet, in headers hdr) { apply { // 将修改后的以太头添加给数据包载荷 packet.emit(hdr.ethernet); } } /*************************************************","date":"2023-04-17","objectID":"/posts/p4/p4-learning/:1:1","tags":["P4"],"title":"P4-P4 Learning","uri":"/posts/p4/p4-learning/"},{"categories":["数据库"],"content":"分库分表 知乎 零声Github整理库 垂直分表：将一个表按字段分成多表，每个表存储其中一部分字段 避免IO争抢并减少锁表的几率，充分发挥热门数据的操作效率 水平分表：在同一个数据库内，把同一个表的数据按一定规则拆到多个表中（对数据的拆分，不影响表结构） 避免IO争抢并减少锁表的几率，优化单一表数据量过大而产生的性能问题 垂直分库：按照业务将表进行分类，分布到不同的数据库上面，每个库可以放在不同的服务器上 解决业务层面的耦合，业务清晰 对不同业务的数据进行分级管理、维护、监控和扩展 提升IO、数据库连接和降低单机硬件资源的瓶颈 水平分库：把同一个表的数据按一定规则拆到不同的数据库中，每个库可以放在不同的服务器上 解决了单库大数据，高并发的性能瓶颈 提高了系统的稳定性和可用性 CSDN 勤天 数据分片规则 Hash取模分表 数值Range分表 一致性Hash算法 ","date":"2023-04-16","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:1:0","tags":[],"title":"数据库-个人笔记","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"python官网标准库参考 python官网标准库详细文档索引 python官网语言参考文档 python官网标准库参考collections 这个模块实现了特定目标的容器，以提供Python标准内建容器 dict , list , set , 和 tuple 的替代选择 ","date":"2023-04-09","objectID":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/collections/:0:0","tags":["Python标准库"],"title":"Python-标准库-Collections","uri":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/collections/"},{"categories":["Python"],"content":"Counter Counter 是 dict 的子类，用于计数可哈希对象。计数可以是任何整数值，包括0和负数。 Counter也有默认值为0，所以不用判断是否存在某数据项x，而直接让x对应的值加1 1 2 3 4 5 6 7 8 from collections import Counter # Instantiate an empty Counter object counter = Counter() # Add elements to the Counter object for item in items: counter[item] += 1 运算符 合并两个Counter +:相同项的值相加 -:相同项的值进行减法运算 \u0026:交集，相同项取最小值 |:并集，相同项取最大值 方法 字典的所有方法 update:可以高效的合并两个Counter，将第二个Counter的值加到第一个Counter的值 1 2 3 4 5 6 7 8 9 10 11 12 from collections import Counter my_list1 = ['apple', 'banana', 'apple', 'pear', 'banana', 'orange'] my_list2 = ['apple', 'banana', 'pear', 'pear', 'orange', 'orange'] my_list3 = ['apple', 'pear', 'pear', 'pear', 'orange'] my_dict1 = Counter(my_list1) my_dict2 = Counter(my_list2) my_dict3 = Counter(my_list3) merged_dict = my_dict1.copy() merged_dict.update(my_dict2) merged_dict.update(my_dict3) print(merged_dict) ","date":"2023-04-09","objectID":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/collections/:1:0","tags":["Python标准库"],"title":"Python-标准库-Collections","uri":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/collections/"},{"categories":["Python"],"content":"python官网标准库参考 python官网标准库详细文档索引 python官网语言参考文档 该库用于对象持久化到文件 ","date":"2023-04-09","objectID":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/pickle/:0:0","tags":["Python标准库"],"title":"Python-标准库-Pickle","uri":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/pickle/"},{"categories":["Python"],"content":"函数 pickle.dump(obj, file, protocol=None, *, fix_imports=True, buffer_callback=None):将对象 obj 封存以后的对象写入已打开的 file object file pickle.load(file, *, fix_imports=True, encoding=“ASCII”, errors=“strict”, buffers=None):从已打开的 file object 文件 中读取封存后的对象，重建其中特定对象的层次结构并返回 1 2 with open(self.name + '_target', 'wb') as f: pickle.dump(self, f) ","date":"2023-04-09","objectID":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/pickle/:1:0","tags":["Python标准库"],"title":"Python-标准库-Pickle","uri":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/pickle/"},{"categories":["操作系统"],"content":"本系列笔记为作者在跟随小林coding学习的时候做的笔记。感谢小林大大。 ","date":"2023-04-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/:0:0","tags":["小林coding系列"],"title":"操作系统-小林coding-网络系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"什么是零拷贝 减少「用户态与内核态的上下文切换」和「内存拷贝」的次数 两种实现方式 mmap+write 零拷贝1\rsendfile 零拷贝2\r真正的零拷贝技术:网卡支持 SG-DMA（The Scatter-Gather Direct Memory Access）技术（和普通的 DMA 有所不同） 零拷贝3\r","date":"2023-04-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/:1:0","tags":["小林coding系列"],"title":"操作系统-小林coding-网络系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"I/O 多路复用：select/poll/epoll I/O 多路复用：select/poll/epoll ","date":"2023-04-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/:2:0","tags":["小林coding系列"],"title":"操作系统-小林coding-网络系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"什么是一致性哈希 一致性哈希\r提高均衡度：将虚拟节点映射到哈希环上，并将虚拟节点映射到实际节点，所以这里有「两层」映射关系 一致性哈希2\r","date":"2023-04-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/:3:0","tags":["小林coding系列"],"title":"操作系统-小林coding-网络系统","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["Python"],"content":"python官网标准库参考 python官网标准库详细文档索引 python官网语言参考文档 ipaddress python官方文档 IP主机地址 1 ip=ipaddress.ip_address('192.0.2.1') 也可以直接从整数创建 1 ipaddress.ip_address(3221225985) 定义网络 1 ipaddress.ip_network('192.0.2.0/24') 网络对象不能设置任何主机位。 网络也可以用整数定义 1 ipaddress.ip_network(3221225984) 主机接口 1 ipaddress.ip_interface('192.0.2.1/24') 属性 version：提取ip版本： network：接口获取网段号 num_addresses：网段中的独立地址数 netmask：网络掩码 hostmask：主机掩码 exploded：展开ipv6地址 compressed：压缩ipv6地址 语法 网络可以作为地址列表：可以进行索引，也可以进行in逻辑运算 地址可以进行比较运算 ","date":"2023-04-03","objectID":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/ipaddress/:0:0","tags":["Python标准库"],"title":"Python-标准库-Ipaddress","uri":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/ipaddress/"},{"categories":["Golang"],"content":"go语言中文网 godoc go语言中文网有很多文档缺少内容比如string.Builder就没有，godoc绝对详尽，推荐阅读godoc ","date":"2023-03-31","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/regexp/:0:0","tags":["go标准库"],"title":"go标准库-Regexp","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/regexp/"},{"categories":["Golang"],"content":"语法 单字符 .:匹配任意字符 [xyz] :匹配xyz [^xyz] :不匹配xyz \\d:数字，[0-9] \\D:非数字 \\s:空字符，[\\t\\n\\f\\r ] \\S:非空字符 \\w:单词字符，[0-9A-Za-z_] \\W:非单词字符 结合 xy:匹配x后匹配y x|y:匹配x或者y 重复，匹配最多次 x*:重复任意次 x+:重复至少1次 x{n,m}:重复[n,m]次，n或m可省略 x{n}:重复n次 x?:匹配1次或0次，x可以为上面的重复类型 捕获分组，匹配后可以访问 (re):以索引访问的捕获分组 (?P\u003cname\u003ere):以索引或命名访问的捕获分组 (?:re):不捕获的分组 (?flags):设置当前所在分组的标志，不捕获也不匹配，常用flag有 i：大小写不敏感（默认关闭），标志语法为xy-z（设置xy，清楚z） 边界匹配 ^:匹配开始 $:匹配结尾 重要提醒： 对于正则表达式尽量使用原生字符串即用反引号`括起来的字符串，否则对于\"括起来的字符串会自动进行转义，所以`\\.`就得使用\"\\\\.\"来表示 ","date":"2023-03-31","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/regexp/:1:0","tags":["go标准库"],"title":"go标准库-Regexp","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/regexp/"},{"categories":["Golang"],"content":"函数 func Match(pattern string, b []byte) (matched bool, err error) func MatchString(pattern string, s string) (matched bool, err error) ","date":"2023-03-31","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/regexp/:2:0","tags":["go标准库"],"title":"go标准库-Regexp","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/regexp/"},{"categories":["Golang"],"content":"Regexp 函数 func Compile(expr string) (*Regexp, error):Compile解析并返回一个正则表达式。 方法 Find(All)?(String)?(Submatch)?(Index)? 如果’String’出现了，匹配对象为字符串，否则应该是[]byte类型，返回值和匹配对象的类型是对应的。 如果’Submatch’出现了，返回值是表示正则表达式中成功的组匹配（子匹配/次级匹配）的切片。 如果’Index’出现了，匹配/分组匹配会用输入流的字节索引对表示result[2n:2n+1]表示第n个分组匹配的的匹配结果。 func (re *Regexp) FindSubmatch(b []byte) [][]byte func (re *Regexp) FindStringSubmatch(s string) []string ","date":"2023-03-31","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/regexp/:3:0","tags":["go标准库"],"title":"go标准库-Regexp","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/regexp/"},{"categories":["数据库"],"content":"本文为作者跟随SqlZoo学习sql的笔记，仅看mysql支持的内容 ","date":"2023-03-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/:0:0","tags":[],"title":"数据库-SqlZoo","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/"},{"categories":["数据库"],"content":"select selcet用于提取数据，空格加标识符命名列名 1 select xxx x,yyy y; 数值字段允许计算：+-*/% 嵌套查询一定要给表取别名，否则会报错 1 2 3 select ... from (select ... from ...) a ","date":"2023-03-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/:1:0","tags":[],"title":"数据库-SqlZoo","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/"},{"categories":["数据库"],"content":"函数 较为常见的函数列表见官网 列举常用的函数，聚合函数配合group by使用，否则为整个表聚合: 语法 case:类似其他语言的switch 1 2 3 4 CASE WHEN condition1 THEN value1 WHEN condition2 THEN value2 ELSE def_value END if:IF(condition, value_if_true, value_if_false)，case的二元形式的简写 CSDN 半笙彷徨 cast:显式类型转换，CAST(value AS datatype) CSDN 山茶花开时 1 SELECT CAST(150 AS CHAR); 数值 ceil(n):n向上取整 floor(n):n向下取整 round(n,k):四舍五入保留k位小数 abs(n):n取绝对值 cos(n):求n余弦 sin(n):求n正弦 tan(n):求n正切 a div b:a地板除以b coalesce(n…):取n切片中第一个非null值 字符串，索引以1开头 concat(s…):连接字符串 left(s,n):取s字符串的左边n个字符 right(s,n):取s字符串的右边n个字符 instr(s1,s2):s2在s1中出现第一次的索引 length(s):s的长度 replace(s,p,r):将s中的p替换成r substr(s,n,k):将s从索引n向后取k个字符 trim(s):将s两端的空白符去掉 时间 current_date:当前时间，datetime类型，精确到日 current_timestamp:当前时间，datetime类型，精确到秒 extract(xxx from d):根据xxx粒度提取datetime类型d的信息，xxx可以是year,quarter,month,day,hour,minute和second，同时这些值也可以作为函数来提取值，比如datepart(year,d)和year(d)是一样的 +interval n xxx:增加n个xxx，xxx可以是year,quarter,month,day,hour,minute和second 聚合函数 avg(field):求field的平均值 count(field):求field为非空的记录数，count(*)查询表的记录数 max(field):求field的最大值 min(field):求field的最小值 sum(field):求field的和 rank,dense_rank,row_number:8.0之后能用，可以通过变量加case语法实现，RANK并列跳跃排名，DENSE_RANK并列连续排序，ROW_NUMBER连续排名 CSDN 哲这这 1 2 # order by提到over后面的括号，xxx为order by后每组内再细分一次 rank() over (partition by xxx,yyy order by score desc) ranking ","date":"2023-03-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/:2:0","tags":[],"title":"数据库-SqlZoo","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/"},{"categories":["数据库"],"content":"SELECT .. WHERE 添加对记录的条件判断 1 2 3 SELECT yr, city FROM games WHERE yr = 2004 ","date":"2023-03-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/:3:0","tags":[],"title":"数据库-SqlZoo","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/"},{"categories":["数据库"],"content":"SELECT .. GROUP BY 分组进行统计 1 2 SELECT continent, COUNT(yr) FROM games GROUP BY continent ","date":"2023-03-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/:4:0","tags":[],"title":"数据库-SqlZoo","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/"},{"categories":["数据库"],"content":"A JOIN B on condition 内连接两个表 1 2 3 SELECT games.yr, city.country FROM games JOIN city ON (games.city = city.name) ","date":"2023-03-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/:5:0","tags":[],"title":"数据库-SqlZoo","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/"},{"categories":["数据库"],"content":"SELECT .. SELECT 嵌套查询，子查询得添加别名，格式为空格加别名 1 2 3 4 5 6 SELECT name, ROUND(gdp_per_capita) FROM (SELECT name, gdp/population AS gdp_per_capita FROM bbc) X WHERE gdp_per_capita\u003e20000 ","date":"2023-03-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/:6:0","tags":[],"title":"数据库-SqlZoo","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/"},{"categories":["数据库"],"content":"INSERT .. VALUES 添加记录 1 INSERT INTO games(yr, city) VALUES (2012,'London') ","date":"2023-03-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/:7:0","tags":[],"title":"数据库-SqlZoo","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/"},{"categories":["数据库"],"content":"INSERT .. SELECT 批量添加记录 1 2 INSERT INTO games(yr,city) SELECT yr+12, city FROM games; ","date":"2023-03-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/:8:0","tags":[],"title":"数据库-SqlZoo","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/"},{"categories":["数据库"],"content":"UPDATE 更新记录 1 UPDATE games SET city='Paris' WHERE yr = 2012; ","date":"2023-03-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/:9:0","tags":[],"title":"数据库-SqlZoo","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/"},{"categories":["数据库"],"content":"DELETE 删除记录 1 DELETE FROM games WHERE yr=2000; ","date":"2023-03-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/:10:0","tags":[],"title":"数据库-SqlZoo","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/"},{"categories":["数据库"],"content":"CREATE TABLE 创建表 1 2 3 4 5 6 7 8 9 10 CREATE TABLE games ( /* 这里举例了添加主键和非空 */ yr INT NOT NULL PRIMARY KEY, city VARCHAR(20) UNIQUE KEY indexname(index_column_1,index_column_2,...) USING BTREE INDEX indexname(index_column_1,index_column_2,...) /*前缀索引*/ INDEX indexname(column_name(length)) ); ","date":"2023-03-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/:11:0","tags":[],"title":"数据库-SqlZoo","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/"},{"categories":["数据库"],"content":"CREATE VIEW 创建视图，其实就是一个存一个select语句，创建的视图的使用方法和table的使用方法一致 1 2 3 CREATE VIEW og AS SELECT yr,city FROM games WHERE yr\u003c2006; ","date":"2023-03-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/:12:0","tags":[],"title":"数据库-SqlZoo","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/"},{"categories":["数据库"],"content":"CREATE INDEX 创建索引 1 CREATE [unique] INDEX gamesIdx ON games(city,yr [desc]) USING BTREE; 在表中创建索引见CREATE TABLE CSDN qq_41044636 MySQL InnoDB数据表不设置主键时的情况 第一种情况：用户定义了主键，那么InnoDB会使用主键作为聚簇索引； 第二种情况：用户没有定义主键，那么InnoDB会使用第一个非空的唯一索引作为聚簇索引； 第三种情况：用户既没有定义主键，也没有定义唯一索引，那么InnoDB会自动生成一个不可见的ROW_ID的列名为GEN_CLUST_INDEX的聚簇索引，该列是一个6字节的自增数值，随着插入而自增。 CSDN 思想永无止境 MySQL添加/删除主键、外键、唯一键、索引、自增 绝大部分情况下，mysql中的索引index和键key是同义词 ","date":"2023-03-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/:13:0","tags":[],"title":"数据库-SqlZoo","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/"},{"categories":["数据库"],"content":"DROP 删除表，视图，索引 1 2 DROP VIEW old_games; DROP INDEX gamesIdx ON games; ","date":"2023-03-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/:14:0","tags":[],"title":"数据库-SqlZoo","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/"},{"categories":["数据库"],"content":"ALTER 修改表，索引 1 ALTER TABLE games ADD season VARCHAR(6); ","date":"2023-03-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/:15:0","tags":[],"title":"数据库-SqlZoo","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/"},{"categories":["数据库"],"content":"UNION 合并两个结构相同的表，会进行去重，union all不进行去重 1 2 3 SELECT name FROM bbc WHERE name LIKE 'Z%' UNION SELECT name FROM actor WHERE name LIKE 'Z%' ","date":"2023-03-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/:16:0","tags":[],"title":"数据库-SqlZoo","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/"},{"categories":["数据库"],"content":"LEFT JOIN 左外连接 1 2 3 SELECT games.yr, city.country FROM games LEFT JOIN city ON (games.city = city.name) ","date":"2023-03-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/:17:0","tags":[],"title":"数据库-SqlZoo","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/"},{"categories":["数据库"],"content":"NULL 空值判断使用is null 1 2 3 SELECT name,gdp FROM world WHERE gdp IS NULL ","date":"2023-03-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/:18:0","tags":[],"title":"数据库-SqlZoo","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/"},{"categories":["数据库"],"content":"个人笔记 ","date":"2023-03-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/:19:0","tags":[],"title":"数据库-SqlZoo","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/"},{"categories":["数据库"],"content":"select后的字段是否可以运算 可以直接引用from表里面的字段并进行运算，当使用group by时引用字段遵循group by规则（group by字段和聚合函数）。 注意可以直接进行运算 ","date":"2023-03-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/:19:1","tags":[],"title":"数据库-SqlZoo","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/"},{"categories":["数据库"],"content":"utf8和utf8mb4 CSDN 骑台风走 utf8和utf8mb4的区别 uft8最大字符长度为 3 字节 utf8mb4（mb4 = most bytes 4） utf8mb4是utf8的超集。用来兼容四字节的unicode ","date":"2023-03-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/:19:2","tags":[],"title":"数据库-SqlZoo","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/"},{"categories":["数据库"],"content":"变量 CSDN xiaoniuxqq 1 2 # 定义变量或修改 select @a := xxx; 因为这种变量的可以直接在需要查询的表table的后面添加select ... from table,(select @var1=xxx,@var2=yyy)，这其实是一个联表查询，但是不影响要查询的表，因为变量所在的表只有一行记录 ","date":"2023-03-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/:19:3","tags":[],"title":"数据库-SqlZoo","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/"},{"categories":["数据库"],"content":"需要关键字字段名或值 可以使用反引号括起来就能用了，比如rank不让使用可以用`rank`来使用。 ","date":"2023-03-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/:19:4","tags":[],"title":"数据库-SqlZoo","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/"},{"categories":["数据库"],"content":"避免sql注入 使用预编译语句(参数化查询) ？占位符来预编译语句，然后使用setval类似的api来执行语句 客户端或服务端检查用户输入是否合法 ","date":"2023-03-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/:19:5","tags":[],"title":"数据库-SqlZoo","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlzoo/"},{"categories":["Python"],"content":"python官网标准库参考 python官网标准库详细文档索引 python官网语言参考文档 multiprocessing文档 multiprocessing包主要复制threading模块的 API ","date":"2023-03-28","objectID":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/multiprocessing/:0:0","tags":["Python标准库"],"title":"Python-标准库-Multiprocessing","uri":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/multiprocessing/"},{"categories":["Python"],"content":"Pool 进程池，使用map方法来实现调用 常用函数 Pool(n):创建n个进程的进程池 常用方法 map(f,[args]):args里面的arg，运行f(arg)，并将最后的结果以列表形式返回 1 2 3 4 5 6 7 8 from multiprocessing import Pool def f(x): return x*x if __name__ == '__main__': with Pool(5) as p: print(p.map(f, [1, 2, 3])) ","date":"2023-03-28","objectID":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/multiprocessing/:1:0","tags":["Python标准库"],"title":"Python-标准库-Multiprocessing","uri":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/multiprocessing/"},{"categories":["Python"],"content":"Process 变量 name:进程的名称 pid:进程id 常用函数 Process(target,args):构造函数，target为选择执行的函数，args为选择的参数 常用方法 start():启动进程 join():join子进程到调用的进程 run():子进程流程，可以对此进行覆盖 kill():使用SIGKILL信号杀死进程 close():关闭Process对象，释放与其关联的所有资源 1 2 3 4 5 6 7 8 9 from multiprocessing import Process def f(name): print('hello', name) if __name__ == '__main__': p = Process(target=f, args=('bob',)) p.start() p.join() ","date":"2023-03-28","objectID":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/multiprocessing/:2:0","tags":["Python标准库"],"title":"Python-标准库-Multiprocessing","uri":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/multiprocessing/"},{"categories":["Python"],"content":"Queue 进程间通信，读写线程和进程安全，类似go的channel，但是这里面什么都能塞 常用函数 Queue():构造函数 常用方法 put(a):把a塞入队列 get():获取队列的一个元素 1 2 3 4 5 6 7 8 9 10 11 from multiprocessing import Process, Queue def f(q): q.put([42, None, 'hello']) if __name__ == '__main__': q = Queue() p = Process(target=f, args=(q,)) p.start() print(q.get()) # prints \"[42, None, 'hello']\" p.join() ","date":"2023-03-28","objectID":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/multiprocessing/:3:0","tags":["Python标准库"],"title":"Python-标准库-Multiprocessing","uri":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/multiprocessing/"},{"categories":["Python"],"content":"Lock 用于进程间同步 常用函数 Lock:构造函数 常用方法 acquire():上锁 release():取消上锁 ","date":"2023-03-28","objectID":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/multiprocessing/:4:0","tags":["Python标准库"],"title":"Python-标准库-Multiprocessing","uri":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/multiprocessing/"},{"categories":["计算机网络"],"content":"TCP校验和和UDP校验和的计算 都需要添加伪首部（共有12字节（前96Bits），包含如下信息：源IP地址4字节、目的IP地址4字节、保留字节(置0)1字节、传输层协议号(TCP是6)1字节、TCP报文长度(报头+数据)2字节） 首先，把伪首部、TCP报头、TCP数据分为16位的字，如果总长度为奇数个字节，则在最后增添一个位都为0的字节 把TCP报头中的校验和字段置为0 反码相加法累加所有的16位字（进位也要累加） 对计算结果取反，作为TCP的校验和 ","date":"2023-03-27","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:1:0","tags":[],"title":"计算机网络-个人笔记","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["计算机网络"],"content":"网段地址判断 通过abc类地址判断网段范围 详见笔记 ","date":"2023-03-27","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:2:0","tags":[],"title":"计算机网络-个人笔记","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["IDE"],"content":"保存时自动格式化代码 设置=\u003e工具=\u003e保存时的操作，将重新格式化代码勾上 ","date":"2023-03-27","objectID":"/posts/ide/pycharm/:1:0","tags":[],"title":"IDE-Pycharm","uri":"/posts/ide/pycharm/"},{"categories":["Python"],"content":"PYPI官网 networkx官网 networkx官网文档 这个包专门用于描述图，topology zoo里面的拓扑都需要这个包来读取下载的gml文件 ","date":"2023-03-23","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/networkx/:0:0","tags":["Python第三方库"],"title":"Python-第三方库-Networkx","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/networkx/"},{"categories":["Python"],"content":"常用函数 read_gml(path[, label, destringizer]):读取gml文件 write_gml(G, path[, stringizer]):将图G存为gml文件 read_graphml(path[, node_type, …]):读取graphml文件 write_graphml(G, path[, encoding, …]):将图G存为graphml文件 ","date":"2023-03-23","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/networkx/:1:0","tags":["Python第三方库"],"title":"Python-第三方库-Networkx","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/networkx/"},{"categories":["Python"],"content":"class Graph(incoming_graph_data=None, **attr) 无向图 常用方法 add_node(node_for_adding, **attr)：添加节点 add_nodes_from(nodes_for_adding, **attr)：添加多个节点 remove_node(n)：删除节点n remove_nodes_from(nodes)：删除多个节点 add_edge(u_of_edge, v_of_edge, **attr)：添加连接u和v的边 add_edges_from(ebunch_to_add, **attr)：添加多个边 remove_edge(u, v)：删除u到v的边 remove_edges_from(ebunch)：删除多个边 删除某个属性不属于列表的节点 1 2 3 for node in list(G.nodes()): if not 'GeoLocation' in G.nodes[node] or not (G.nodes[node]['GeoLocation'] in ('Germany', 'Poland', 'France', 'Switzerland')): G.remove_node(node) ","date":"2023-03-23","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/networkx/:2:0","tags":["Python第三方库"],"title":"Python-第三方库-Networkx","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/networkx/"},{"categories":["数据结构与算法"],"content":"随机刷 ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:1:0","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"8. 字符串转换整数 (atoi) 8. 字符串转换整数 (atoi) 简单模拟，打败双百 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func myAtoi(s string) int { s=strings.TrimSpace(s) if s==\"\"{return 0} nagative:=false if s[0]=='-'||s[0]=='+'{ if s[0]=='-'{nagative=true} s=s[1:] } ans:=0 for _,v:=range s{ if !unicode.IsDigit(v){break} ans=ans*10+int(v-'0') if ans\u003emath.MaxInt32{break} } if nagative{ans=-ans} if ans\u003emath.MaxInt32{ans=math.MaxInt32} if ans\u003cmath.MinInt32{ans=math.MinInt32} return ans } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:1:1","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"51. N 皇后 51. N 皇后 回溯算法，通过左上对角线元素对应索引lu和右上对角线元素对应索引ru优化冲突检查 N皇后\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 func solveNQueens(n int) [][]string { colbool:=make([]bool,n) leftup:=make([]bool,2*n-1) rightup:=make([]bool,2*n-1) ans:=make([][]string,0) sb:=strings.Builder{} queue:=make([]int,n) var backtrack func(row int) backtrack=func(row int){ //fmt.Println(colbool,leftup,rightup,queue) if row==n{ anstmp:=make([]string,0) for _,v:=range queue{ sb.Reset() for i:=0;i\u003cn;i++{ if i!=v{ sb.WriteByte('.') }else{sb.WriteByte('Q')} } anstmp=append(anstmp,sb.String()) } ans=append(ans,anstmp) return } for col:=0;col\u003cn;col++{ lu,ru:=row-col+n-1,row+col if !(colbool[col]||leftup[lu]||rightup[ru]){ colbool[col],leftup[lu],rightup[ru]=true,true,true queue[row]=col backtrack(row+1) colbool[col],leftup[lu],rightup[ru]=false,false,false } } } backtrack(0) return ans } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:1:2","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"52. N 皇后 II 52. N 皇后 II 逻辑与N皇后一样，但是统计basecase的逻辑改为计数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func totalNQueens(n int) int { colbool:=make([]bool,n) leftup:=make([]bool,2*n-1) rightup:=make([]bool,2*n-1) ans:=0 var backtrack func(row int) backtrack=func(row int){ //fmt.Println(colbool,leftup,rightup) if row==n{ ans++ return } for col:=0;col\u003cn;col++{ lu,ru:=row-col+n-1,row+col if !(colbool[col]||leftup[lu]||rightup[ru]){ colbool[col],leftup[lu],rightup[ru]=true,true,true backtrack(row+1) colbool[col],leftup[lu],rightup[ru]=false,false,false } } } backtrack(0) return ans } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:1:3","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"58. 最后一个单词的长度 58. 最后一个单词的长度 简单模拟，从后往前数字母 1 2 3 4 5 6 7 8 9 10 func lengthOfLastWord(s string) int { s=strings.TrimSpace(s) ans:=0 for i:=len(s)-1;i\u003e=0;i--{ if unicode.IsLetter(rune(s[i])){ ans++ }else{break} } return ans } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:1:4","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"60. 排列序列 60. 排列序列 数学，从最高位开始往后计算值，对于从右往左第t位每一个值包含的子状态数步长为t!，首先计算每一位的步长sep，然后根据sep从左往右计算t位上的第ans[t]个未使用数字，最后使用onpath数组迭代从左往右求每位的具体值，最后输出值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 func getPermutation(n int, k int) string { onpath:=make([]bool,n+1) ans:=make([]int,n) sep:=make([]int,n) tmp:=1 for i,j:=n-1,1;i\u003e=0;{ tmp*=j sep[i]=tmp i-- j++ } //统一结果，-1过后k/v正好就是从左往右第i位取的第ans[i]个未使用数字 k-- for i,v:=range sep[1:]{ ans[i]=k/v k-=ans[i]*v } //fmt.Println(\"sep\",sep) sb:=strings.Builder{} for _,v:=range ans{ tmp:=1 for onpath[tmp]{tmp++} for v\u003e0{ tmp++ for onpath[tmp]{tmp++} v-- } onpath[tmp]=true sb.WriteString(strconv.Itoa(tmp)) } //fmt.Println(\"ans\",ans) return sb.String() } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:1:5","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"树的直径 树的直径（两次DFS + 树形DP） 两种方法，两遍dfs和树形DP，这里的graph均为邻接表([][]int)，深度的定义为从当前根节点到叶子节点的路径的最大值 dfs，O(2N) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 visited:=make([]bool,n) var dfs func(int)int dfs=func(i int)(int,int){ visited[i]=true //maxLen记录i作为根节点的最大深度,node记录最深的叶子节点 maxLen,node:=0,i for _,j:=range graph[i]{ if !visited[j]{ tmp,tmpnode:=dfs(j)+1 if maxLen\u003ctmp{ maxLen=tmp node=tmpnode } } } return maxLen,node } _,n1:=dfs(0) diameter,n2:=dfs(n1) 树形DP（在遍历子树的过程中记录子树的结果并返回给父节点），O(N) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 visited:=make([]bool,n) diameter:=0 var dfs func(int) int dfs = func(i int) (int) { visited[i]=true maxLen=0 for _, j := range graph[i] { if !visited[j] { tmp := dfs(j)+1 //max即上面的工具函数，maxLen记录最深子树分支的深度，当前分支的深度，看加起来是否大于当前记录diameter diameter = max(diameter, maxLen+tmp) //更新maxLen记录 maxLen = max(maxLen, tmp) } } return } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:1:6","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"27. 移除元素 27. 移除元素 双指针 1 2 3 4 5 6 7 8 9 10 11 func removeElement(nums []int, val int) int { right:=len(nums)-1 for i,v:=range nums{ if v==val{ for right\u003e=0\u0026\u0026nums[right]==val{right--} if i\u003eright{break} nums[i],nums[right]=nums[right],v } } return right+1 } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:1:7","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"41. 缺失的第一个正数 41. 缺失的第一个正数 哈希数组，因为求的是数组中未出现的最小正数，那么对于数组长度为l最小正数的范围只能是[1,l]，由于需要空间复杂度为O(1)，时间复杂度O(N)，我们不能使用map来记录。数组索引到数组元素可以实现一个hash函数，设置hash(i)=i+1，i\u003e=0\u0026\u0026i\u003cl，通过这个函数来遍历数组并交换元素使满足条件的元素v=i+1，v\u003e0\u0026\u0026v\u003c=l在自己应该处于的位置。然后对不上的元素不在这个范围内，所以第一个对不上的元素的索引值加1就是缺失的第一个正数return i+1。 如果全部遍历完都对的上，那么就return l+1。 这道题的核心思想就是将数组作为hash函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func firstMissingPositive(nums []int) int { l:=len(nums) swap:=func(i,j int){nums[i],nums[j]=nums[j],nums[i]} for i,_:=range nums{ for nums[i]\u003e0\u0026\u0026nums[i]\u003c=l\u0026\u0026 nums[i]!=i+1\u0026\u0026nums[nums[i]-1]!=nums[i]{ swap(i,nums[i]-1) } } for i,v:=range nums{ if v!=i+1{return i+1} } return l+1 } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:1:8","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"152. 乘积最大子数组 152. 乘积最大子数组 动态规划，dp[i][0]为以num[i]结尾的最小子串的乘积之和，dp[i][1]为以num[i]结尾的最大子串的乘积之和 状态转移为： dp[i][0]=min(dp[i-1][0]* num[i], dp[i-1][1] *num[i], num[i]) dp[i][1]=max(dp[i-1][0]* num[i], dp[i-1][1] *num[i], num[i]) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 func maxProduct(nums []int) int { l:=len(nums) memo:=make([][]int,l) for i,_ := range memo{ memo[i]=make([]int,2) for j,_:=range memo[i]{ memo[i][j]=math.MaxInt } } memo[0][0]=nums[0] memo[0][1]=nums[0] ans:=nums[0] var dp func(i,j int)int dp=func(i,j int)int{ if memo[i][j]!=math.MaxInt{return memo[i][j]} a,b:=dp(i-1,0)*nums[i],dp(i-1,1)*nums[i] //fmt.Println(a,b,nums[i],ans) ans=max(a,b,nums[i],ans) memo[i][0]=min(a,b,nums[i]) memo[i][1]=max(a,b,nums[i]) return memo[i][j] } dp(l-1,1) //fmt.Println(memo) return ans } func max(s ...int)int{ tmp:=math.MinInt for _,v:=range s{ if tmp\u003cv{tmp=v} } return tmp } func min(s ...int)int{ tmp:=math.MaxInt for _,v:=range s{ if tmp\u003ev{tmp=v} } return tmp } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:1:9","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"146. LRU 缓存 146. LRU 缓存 用一个双向链表和一个哈希表来实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 type LRUCache struct { h int l *list.List m map[int]*list.Element } type Kv struct{ k,v int } func Constructor(capacity int) LRUCache { return LRUCache{ h:capacity, l:list.New(), m:map[int]*list.Element{}, } } func (this *LRUCache) Get(key int) int { ans:=-1 if e,has:=this.m[key];has{ ans=e.Value.(*Kv).v this.l.MoveToFront(e) } return ans } func (this *LRUCache) Put(key int, value int) { e,has:=this.m[key] if has{ kv:=e.Value.(*Kv) this.l.MoveToFront(e) kv.v=value }else{ t:=this.l.PushFront(\u0026Kv{key,value}) this.m[key]=t for this.l.Len()\u003ethis.h{ r:=this.l.Back() rkv:=r.Value.(*Kv) delete(this.m,rkv.k) this.l.Remove(r) } } //this.show() } func (this *LRUCache) show(){ fmt.Println(this.l.Len()) for tmp:=this.l.Front();tmp!=nil;tmp=tmp.Next(){ fmt.Print(tmp.Value.(*Kv),\" \") } fmt.Println() } /** * Your LRUCache object will be instantiated and called as such: * obj := Constructor(capacity); * param_1 := obj.Get(key); * obj.Put(key,value); */ ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:1:10","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"503. 下一个更大元素 II 503. 下一个更大元素 II 复制一倍断环成链，单调栈放下标 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func nextGreaterElements(nums []int) []int { l:=len(nums) tmp:=make([]int,l+l) copy(tmp,nums) copy(tmp[l:],nums) //fmt.Println(tmp) stack:=make([]int,0,l+l) ans:=make([]int,l+l) for i,v:=range tmp{ for { ls:=len(stack) if ls==0{break} top:=stack[ls-1] if tmp[top]\u003e=v{break} ans[top]=v stack=stack[:ls-1] } stack=append(stack,i) } for _,v:=range stack{ ans[v]=-1 } return ans[:l] } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:1:11","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"115. 不同的子序列 115. 不同的子序列 动态规划 dp[i][j]表示s[:i]中s[:j]出现次数 basecase： dp[…][0]=1 dp[i][j]=0,i\u003cj 选择： 当s[i]==t[j]时，可以选择将s[i]和s[j]作为子序列的一部分，次数为dp[i-1][j-1]，还可以选择不作为子序列的一部分，次数为dp[i-1][j] 当s[i]!=t[j]时，只能选择不作为子序列一部分，次数为dp[i-1][j] 转移方程： 1 2 dp[i][j]=dp[i-1][j-1]+dp[i-1][j],s[i]==t[j] dp[i-1][j],s[i]!=s[j] 等式右边只有i和i-1，i从小到大遍历 等式右边只有j和j-1，j从小到大遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func numDistinct(s string, t string) int { ls,lt:=len(s),len(t) dp:=make([][]int,ls+1) for i,_:=range dp{ dp[i]=make([]int,lt+1) dp[i][0]=1 } for i,si:=range s{ i=i+1 for j,sj:=range t{ j=j+1 if si==sj{ dp[i][j]=dp[i-1][j]+dp[i-1][j-1] }else{ dp[i][j]=dp[i-1][j] } } } return dp[ls][lt] } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:1:12","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"每日一题 ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:2:0","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"面试题 17.05. 字母与数字 面试题 17.05. 字母与数字 前缀和+哈希表优化查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 func findLongestSubarray(array []string) []string { l:=len(array) presum:=make([]int,l+1) sum:=0 for i,v:=range array{ if unicode.IsDigit(rune(v[0])){ sum++ }else{sum--} presum[i+1]=sum } //fmt.Println(presum) ans:=math.MinInt var ansi,ansj int m:=make(map[int]int) for j,v:=range presum{ if i,has:=m[v];has{ if ans\u003cj-i{ ans=j-i ansi=i ansj=j } }else{m[v]=j} } //fmt.Println(ans,ansi,ansj) if ans==math.MinInt{return nil} return array[ansi:ansj] } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:2:1","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"1617. 统计子树中城市之间最大距离 1617. 统计子树中城市之间最大距离 枚举子集（二进制枚举）+ 树形DP求树的直径 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 func countSubgraphsForEachDiameter(n int, edges [][]int) []int { graph:=make([][]int,n) for i,_:=range graph{graph[i]=[]int{}} for _,e :=range edges{ graph[e[0]-1]=append(graph[e[0]-1],e[1]-1) graph[e[1]-1]=append(graph[e[1]-1],e[0]-1) } ans:=make([]int,n) //fmt.Println(graph) for mask:=3;mask\u003c(1\u003c\u003cn);mask++{ //fmt.Println(\"mask:\",mask) //至少得有2个节点 if mask\u0026(mask-1)==0{continue} diameter,onpath:=0,0 var dfs func(int)int dfs=func(i int)int{ //fmt.Println(\"dfs:\",i) onpath|=1\u003c\u003ci ml:=0 for _,j:=range graph[i]{ if (onpath\u003e\u003ej)\u00261!=1\u0026\u0026(mask\u003e\u003ej)\u00261==1{ tmp:=dfs(j)+1 if diameter\u003ctmp+ml{diameter=tmp+ml} if ml\u003ctmp{ml=tmp} } } return ml } start:=0 //fmt.Println(onpath,mask) for mask\u0026(1\u003c\u003cstart)==0{start++} dfs(start) //fmt.Println(mask,onpath) if onpath==mask{ //fmt.Println(mask) ans[diameter]++ } } return ans[1:] } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:2:2","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"2383. 赢得比赛需要的最少训练时长 2383. 赢得比赛需要的最少训练时长 简单模拟 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func minNumberOfHours(initialEnergy int, initialExperience int, energy []int, experience []int) int { ans,tmp:=0,0 for i,exp:=range experience{ ene:=energy[i] //fmt.Println(initialExperience,initialEnergy,exp,ene) tmp=exp+1-initialExperience if tmp\u003e0{ ans+=tmp initialExperience+=tmp } tmp=ene+1-initialEnergy if tmp\u003e0{ ans+=tmp initialEnergy+=tmp } initialExperience+=exp initialEnergy-=ene } return ans } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:2:3","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"1605. 给定行和列的和求可行矩阵 1605. 给定行和列的和求可行矩阵 考虑最简单的情况，rowSum和colSum都是0时为最简单情况，所有值取0即可 所以可以尝试将问题状态往最简单状态转换，每取一个元素的值，可直接将该元素所在行和列的Sum值减去取的值 使用贪心策略，按从左往右和从上往下的方向遍历，每次取rowSum和colSum两者的较小值就可以将问题转换为最简单状态 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func restoreMatrix(rowSum []int, colSum []int) [][]int { r,c:=len(rowSum),len(colSum) ans:=make([][]int,r) for i,_:=range ans{ ans[i]=make([]int,c) } for row,rowslice :=range ans{ for col,_:=range rowslice{ ans[row][col]=Min(rowSum[row],colSum[col]) rowSum[row]-=ans[row][col] colSum[col]-=ans[row][col] } } return ans } func Min(a,b int)int{ if a\u003cb{return a} return b } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:2:4","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"1615. 最大网络秩 1615. 最大网络秩 贪心，选择度最大的节点为第一个节点，然后将该节点的邻居节点的度-1并将该节点的度置零，然后再找度最大的节点为第二个节点 由于第一个节点可能有多个，需要对每一个节点都进行计算 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 func maximalNetworkRank(n int, roads [][]int) int { degree:=make([]int,n) graph:=make([][]int,n) for i,_:=range graph{graph[i]=[]int{}} for _,e:=range roads{ a,b:=e[0],e[1] graph[a]=append(graph[a],b) graph[b]=append(graph[b],a) degree[a]++ degree[b]++ } //fmt.Println(degree) maxdegree:=0 for _,v:=range degree{ if v\u003emaxdegree{ maxdegree=v } } maxdegree2:=0 for i,v:=range degree{ if v==maxdegree{ tmp:=make([]int,n) copy(tmp,degree) for _,to:=range graph[i]{ tmp[to]-- } tmp[i]=0 for _,vv:=range tmp{ if maxdegree2\u003cvv{ maxdegree2=vv } } } } return maxdegree+maxdegree2 } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:2:5","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"2488. 统计中位数为 K 的子数组 2488. 统计中位数为 K 的子数组 官方题解是前缀和+哈希表优化查询。自己做第一时间分析问题后选择记忆化搜索（类似区间动规），但是核心思想和官方题解一致。 数组中一定是有索引为t值为k的数，并且子数组的左端点索引left和右端点索引right一定满足：0\u003c=left\u003c=k\u003c=right\u003cl，并且子数组中大于k的数的数目减去小于k的数的数目为0或1 我的解题思路是首先通过memo[i]记录[i,k]区间大于k的数的数目减去小于k的数的数目的值，并以memo[i]为键i为值存入哈希表m，优化后续查询，然后固定右端点为[k,l)区间的j，使用tmp来记录后面 [k,j]区间大于k的数的数目减去小于k的数的数目的值。然后通过查询m中键为1-tmp或0-tmp的值i，那么[i,j]即为一个满足条件的子数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 func countSubarrays(nums []int, k int) int { l:=len(nums) var t int for i,v:=range nums{ if v==k{ t=i break } } ans:=1 memo:=make([]int,t+1) memo[t]=0 m:=make(map[int][]int,l) m[0]=[]int{t} for i:=t-1;i\u003e=0;i--{ if nums[i]\u003ek{ memo[i]=memo[i+1]+1 }else{memo[i]=memo[i+1]-1} m[memo[i]]=append(m[memo[i]],i) if memo[i]==0||memo[i]==1{ ans++ //fmt.Println(i,t) } } //fmt.Println(memo) //fmt.Println(m) tmp:=0 for j:=t+1;j\u003cl;j++{ if nums[j]\u003ek{ tmp++ }else{tmp--} ans+=len(m[0-tmp])+len(m[1-tmp]) //fmt.Println(tmp) } return ans } 后续按官方题解优化代码，除了使用preSum，还有哈希表的值不使用数组，直接计数即可 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func countSubarrays(nums []int, k int) int { l:=len(nums) preSum:=make([]int,l) m:=make(map[int]int,l) flag:=false ans:=0 tmp:=0 for i,v:=range nums{ if v\u003ek{tmp++}else if v\u003ck{tmp--} preSum[i]=tmp if v==k{flag=true} if flag{ if tmp==0||tmp==1{ans++} //tmp-target=1||tmp-target=0 ans+=m[tmp-1]+m[tmp] }else{m[tmp]++} } //fmt.Println(preSum) //fmt.Println(m) return ans } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:2:6","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"2389. 和有限的最长子序列 2389. 和有限的最长子序列 贪心，排序+前缀和+二分搜索 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 func answerQueries(nums []int, queries []int) []int { sort.Ints(nums) lq,ln:=len(queries),len(nums) preSum:=make([]int,ln) ans:=make([]int,lq) tmp:=0 for i,v:=range nums{ tmp+=v preSum[i]=tmp } bs:=func(t int)int{ l,r,m:=0,ln-1,0 for l\u003c=r{ m=l+(r-l)/2 if preSum[m]\u003et{ r=m-1 }else if preSum[m]\u003ct{ l=m+1 }else {r=m-1} } if l\u003cln\u0026\u0026preSum[l]==t{l++} return l } for i,v:=range queries{ ans[i]=bs(v) } //fmt.Println(preSum) //fmt.Println(queries) return ans } 官方题解用了sort.SearchInts方法，此方法用于找到最左值或插入点，另外巧妙的使用了目标值+1的特殊值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func answerQueries(nums []int, queries []int) []int { sort.Ints(nums) n := len(nums) f := make([]int, n) f[0] = nums[0] for i := 1; i \u003c n; i++ { f[i] = f[i-1] + nums[i] } ans := []int{} for _, q := range queries { idx := sort.SearchInts(f, q+1) ans = append(ans, idx) } return ans } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:2:7","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"1616. 分割两个字符串得到回文串 1616. 分割两个字符串得到回文串 双指针 从两边往中间判断，当字符不相同时找到分裂点，此时分两种情况，一种是公共部分是a的子数组，另一种是公共部分是b的子数组，两种情况都得计算 时间复杂度O(N) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func checkPalindromeFormation(a string, b string) bool { check:=func(s string,l,r int)bool{ for l\u003cr{ if s[l]!=s[r]{ return false }else{ l++ r-- } } return true } findSplit:=func(a,b string)bool{ l,r:=0,len(a)-1 for l\u003cr\u0026\u0026a[l]==b[r]{ l++ r-- } //fmt.Println(a,l,r) return check(a,l,r)||check(b,l,r) } return findSplit(a,b)||findSplit(b,a) } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:2:8","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"1625. 执行操作后字典序最小的字符串 1625. 执行操作后字典序最小的字符串 暴力搜索dfs，map[string]bool去重 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 func findLexSmallestString(s string, a int, b int) string { m:=make(map[string]bool,0) ans:=[]byte(s) cmp:=func(a,b []byte)int{ for i,_:=range a{ if a[i]\u003cb[i]{ return 1 }else if a[i]\u003eb[i]{ return -1 } } return 0 } adda:=func(bs []byte)([]byte){ ret:=make([]byte,len(bs)) for i,v:=range bs{ ret[i]=v if i\u00261==1{ ret[i]+=byte(a) if ret[i]\u003e'9'{ ret[i]-='0' ret[i]%=10 ret[i]+='0' } } } return ret } shift:=func(bs []byte)([]byte){ ret:=make([]byte,0,len(bs)) for _,v:=range bs[b:]{ ret=append(ret,v) } for _,v:=range bs[:b]{ ret=append(ret,v) } return ret } var dfs func([]byte) dfs=func(bs []byte){ if m[string(bs)]{return} if cmp(ans,bs)==-1{ ans=bs } m[string(bs)]=true dfs(adda(bs)) dfs(shift(bs)) } dfs([]byte(s)) return string(ans) } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:2:9","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"1012. 至少有 1 位重复的数字 1012. 至少有 1 位重复的数字 问题转换+数位DP，自己没写出来，看的三叶姐的题解和灵神的题解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 func numDupDigitsAtMostN(n int) (ans int) { s := strconv.Itoa(n) m := len(s) dp := make([][1 \u003c\u003c 10]int, m) for i := range dp { for j := range dp[i] { dp[i][j] = -1 // -1 表示没有计算过 } } var f func(int, int, bool, bool) int f = func(i, mask int, isLimit, isNum bool) (res int) { if i == m { if isNum { return 1 // 得到了一个合法数字 } return } if !isLimit \u0026\u0026 isNum { dv := \u0026dp[i][mask] if *dv \u003e= 0 { return *dv } defer func() { *dv = res }() } if !isNum { // 可以跳过当前数位 res += f(i+1, mask, false, false) } d := 0 if !isNum { d = 1 // 如果前面没有填数字，必须从 1 开始（因为不能有前导零） } up := 9 if isLimit { up = int(s[i] - '0') // 如果前面填的数字都和 n 的一样，那么这一位至多填数字 s[i]（否则就超过 n 啦） } for ; d \u003c= up; d++ { // 枚举要填入的数字 d if mask\u003e\u003ed\u00261 == 0 { // d 不在 mask 中 res += f(i+1, mask|1\u003c\u003cd, isLimit \u0026\u0026 d == up, true) } } return } return n - f(0, 0, true, false) } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:2:10","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"2469. 温度转换 2469. 温度转换 模拟 1 2 3 func convertTemperature(celsius float64) []float64 { return []float64{celsius+273.15,celsius*1.8+32} } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:2:11","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"1626. 无矛盾的最佳球队 1626. 无矛盾的最佳球队 排序+DP 状态转移方程为 dp[i]=max(dp[j])+scores[i],j\u003ci\u0026\u0026scores[i]\u003c=scores[j]，方程比较简单就直接自底向上求解即可 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 func bestTeamScore(scores []int, ages []int) int { type pair struct{age,score int} l:=len(scores) s:=make([]pair,0,l) for i,v:=range scores{ s=append(s,pair{ages[i],v}) } sort.Slice(s,func (i,j int)bool{ if s[i].age\u003cs[j].age{ return true }else if s[i].age==s[j].age{ if s[i].score\u003cs[j].score{ return true } } return false }) //fmt.Println(s) ans:=0 memo:=make([]int,l) for i,vi:=range s{ tmp:=0 for j,vj:=range s[:i]{ if vi.score\u003e=vj.score\u0026\u0026tmp\u003c=memo[j]{tmp=memo[j]} } memo[i]=tmp+vi.score if ans\u003cmemo[i]{ans=memo[i]} } return ans } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:2:12","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"1630. 等差子数组 1630. 等差子数组 模拟，对每个子数组判断是否是等差子数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func checkArithmeticSubarrays(nums []int, l []int, r []int) []bool { ans:=make([]bool,len(l)) check:=func(nums []int)bool{ l:=len(nums) max:=math.MinInt min:=math.MaxInt m:=map[int]bool{} for _,v:=range nums{ if min\u003ev{min=v} if max\u003cv{max=v} m[v]=true } sep:=(max-min)/(l-1) if min+sep*(l-1)!=max{return false} for tmp:=min+sep;tmp\u003cmax;tmp+=sep{ if _,has:=m[tmp];!has{return false} } return true } for i,_:=range l{ ans[i]=check(nums[l[i]:r[i]+1]) } return ans } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:2:13","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"1032. 字符流 1032. 字符流 后缀树优化暴力搜索，每加入一个字符则从后往前遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 type m map[byte]*m type StreamChecker struct { s []byte trie *m } func Constructor(words []string) StreamChecker { ret:=StreamChecker{} ret.trie=\u0026m{} for _,s:=range words{ tmp:=ret.trie for i:=len(s)-1;i\u003e=0;i--{ v:=s[i] if _,has:=(*tmp)[v];!has{ (*tmp)[v]=\u0026m{} } tmp=(*tmp)[v] } (*tmp)['0']=\u0026m{} } return ret } func (this *StreamChecker) Query(letter byte) bool { this.s=append(this.s,letter) tmp:=this.trie for i:=len(this.s)-1;i\u003e=0;i--{ v:=this.s[i] if next,has:=(*tmp)[v];has{ tmp=next if (*tmp)['0']!=nil{ return true } }else{return false} } return false } /** * Your StreamChecker object will be instantiated and called as such: * obj := Constructor(words); * param_1 := obj.Query(letter); */ ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:2:14","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"1574. 删除最短的子数组使剩余数组有序 1574. 删除最短的子数组使剩余数组有序 分析问题，数组长度为l，对于从最左边往右找的最长递增子数组索引为[0,i)和最右边往左找的最长递增子数组为 [j+1,l)，那么删除的子数组的左索引 left 取值为 [0,i]，右索引 right 取值为[j,l)。 然后就可以通过滑动窗口来找到答案了，由于要求剩余的子数组为最长，所以满足条件的最小滑动窗口是最终答案 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func findLengthOfShortestSubarray(arr []int) int { l:=len(arr) i,j:=1,l-2 for i\u003cl{ if arr[i]\u003carr[i-1]{break} i++ } if i==l{return 0} for j\u003e0{ if arr[j]\u003earr[j+1]{break} j-- } left,right:=-1,j+1 //fmt.Println(left,right) ans:=math.MaxInt for left\u003ci{ for right\u003cl\u0026\u0026left\u003e=0\u0026\u0026arr[left]\u003earr[right]{ right++ } if ans\u003eright-left-1{ans=right-left-1} left++ } return ans } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:2:15","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"2395. 和相等的子数组 2395. 和相等的子数组 简单模拟 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func findSubarrays(nums []int) bool { l:=len(nums) presum:=make([]int,l+1) tmp:=0 for i,_:=range presum[1:]{ tmp+=nums[i] presum[i+1]=tmp } //fmt.Println(presum) m:=map[int]bool{} for i,vl:=range presum[:l-1]{ vr:=presum[i+2] if m[vr-vl]{return true} m[vr-vl]=true } return false } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:2:16","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"1638. 统计只差一个字符的子串数目 1638. 统计只差一个字符的子串数目 暴力枚举，确定左端点枚举右端点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func countSubstrings(s string, t string) int { ls,lt:=len(s),len(t) ans:=0 for i:=0;i\u003cls;i++{ for j:=0;j\u003clt;j++{ flag:=false for k:=0;i+k\u003cls\u0026\u0026j+k\u003clt;k++{ if s[i+k]!=t[j+k]{ if flag{break} flag=true } if flag{ans++} } } } return ans } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:2:17","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"1092. 最短公共超序列 1092. 最短公共超序列 求最长公共子序列（动态规划，我这里用的是自顶向下的方法），倒序遍历构造字符串，最后将字符串翻转即为答案 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 func shortestCommonSupersequence(str1 string, str2 string) string { //预处理，设置memo数组和memopre数组 l1,l2:=len(str1),len(str2) memo:=make([][]int,l1) for i,_:=range memo{ memo[i]=make([]int,l2) for j,_:=range memo[i]{ memo[i][j]=-1 } } memopre:=make([][][]int,l1) for i,_:=range memopre{ memopre[i]=make([][]int,l2) } //basecase if str1[0]==str2[0]{ memo[0][0]=1 memopre[0][0]=[]int{-1,-1} }else{ memo[0][0]=0 memopre[0][0]=[]int{-1,0} } //dp函数遍历 var dp func(i,j int)int dp=func(i,j int)int{ if i\u003c0||j\u003c0{return 0} if memo[i][j]!=-1{ return memo[i][j] } if str1[i]==str2[j]{ memo[i][j]=dp(i-1,j-1)+1 memopre[i][j]=[]int{i-1,j-1} }else{ i1j:=dp(i-1,j) ij1:=dp(i,j-1) max,maxi,maxj:=i1j,i-1,j if i1j\u003cij1{ max,maxi,maxj=ij1,i,j-1 } memo[i][j]=max memopre[i][j]=[]int{maxi,maxj} } return memo[i][j] } //求解 dp(l1-1,l2-1) //fmt.Println(memo) //fmt.Println(memopre) //构造答案 b:=strings.Builder{} i,j:=l1-1,l2-1 for i\u003e=0\u0026\u0026j\u003e=0{ if memopre[i][j][0]==i{ b.WriteByte(str2[j]) }else{ b.WriteByte(str1[i]) } i,j=memopre[i][j][0],memopre[i][j][1] } for i\u003e=0{ b.WriteByte(str1[i]) i-- } for j\u003e=0{ b.WriteByte(str2[j]) j-- } ansr:=b.String() b.Reset() for i=len(ansr)-1;i\u003e=0;i--{ b.WriteByte(ansr[i]) } return b.String() } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:2:18","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"1641. 统计字典序元音字符串的数目 1641. 统计字典序元音字符串的数目 动态规划 dp[i][j]=sum(dp[i-1][k-1]),i\u003e1 dp[i][j]=1,i=1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func countVowelStrings(n int) int { dp:=make([][]int,n+1) for i,_:=range dp{ dp[i]=make([]int,5) } for j,_:=range dp[1]{dp[1][j]=1} for i:=2;i\u003c=n;i++{ tmp:=0 for j,_:=range dp[i]{ tmp+=dp[i-1][j] dp[i][j]=tmp } } ans:=0 for _,v:=range dp[n]{ans+=v} return ans } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:2:19","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"1637. 两点之间不包含任何点的最宽垂直区域 1637. 两点之间不包含任何点的最宽垂直区域 仔细分析题意，排序贪心，遍历选择最大的x间距 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func maxWidthOfVerticalArea(points [][]int) int { s:=make([]int,0) for _,v :=range points{ s=append(s,v[0]) } sort.Ints(s) ans:=0 for i:=1;i\u003clen(s);i++{ ans=max(ans,s[i]-s[i-1]) } return ans } func max(a,b int)int{ if a\u003cb{return b} return a } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:2:20","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"2367. 算术三元组的数目 2367. 算术三元组的数目 哈希表优化搜索 1 2 3 4 5 6 7 8 9 10 11 12 13 func arithmeticTriplets(nums []int, diff int) int { l:=len(nums) ans:=0 m:=make(map[int]int,l) for _,v:=range nums{ m[v]++ } for j:=1;j\u003cl-1;j++{ v:=nums[j] ans+=m[v-diff]*m[v+diff] } return ans } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:2:21","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"831. 隐藏个人信息 831. 隐藏个人信息 模拟，使用regexp包捕获分组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 func maskPII(s string) string { ans:=strings.Builder{} email,_:=regexp.Compile(`^(\\w+)((?i)@\\w+\\.\\w+)$`) ss:=email.FindStringSubmatch(s) //fmt.Println(ss) if len(ss)\u003e0{ ans.WriteRune(unicode.ToLower(rune(ss[1][0]))) ans.WriteString(\"*****\") ans.WriteRune(unicode.ToLower(rune(ss[1][len(ss[1])-1]))) ans.WriteString(strings.ToLower(ss[2])) }else{ tmp:=strings.Builder{} for _,v:=range s{ if unicode.IsDigit(v){ tmp.WriteRune(v) } } t:=tmp.String() n:=len(t) if n\u003e10{ ans.WriteRune('+') for n\u003e10{ ans.WriteRune('*') n-- } ans.WriteRune('-') } ans.WriteString(\"***-***-\") ans.WriteString(t[len(t)-4:]) } return ans.String() } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:2:22","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"1039. 多边形三角剖分的最低得分 1039. 多边形三角剖分的最低得分 自顶向下动态规划，dp[i][j]表示索引范围[i,j]的最低得分 dp[i][j]=min(dp[i][k]+dp[k][j])+values[i] * values[k] * values[j],k属于(i,j) 0,j-i\u003c=1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 func minScoreTriangulation(values []int) int { l:=len(values) if l\u003c3{return 0} memo :=make([][]int,l) for i,_:=range memo{ memo[i]=make([]int,l) } var dp func(i,j int)int dp=func(i,j int)int{ if memo[i][j]!=0{ return memo[i][j] } min:=math.MaxInt for k:=i+1;k\u003cj;k++{ part1,part3:=0,0 part2:=values[i]*values[j]* values[k] if k-i\u003e1{part1=dp(i,k)} if j-k\u003e1{part3=dp(k,j)} tmp:=part1+part2+part3 if min\u003etmp{min=tmp} } memo[i][j]=min return memo[i][j] } return dp(0,l-1) } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:2:23","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"1053. 交换一次的先前排列 1053. 交换一次的先前排列 贪心策略 从后往前遍历，取第一个增大的元素x，然后再往后找比x小的最大的元素y，交换这两个的操作就是答案， 如果找不到x则表示已经是最小序列，这里用一个flag来判断，如果找到了flag赋值为true 这里有一个小细节，因为有重复元素，所以y元素必须保证是所有重复元素的最左边的元素，所以添加了一列找最左元素的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func prevPermOpt1(arr []int) []int { l:=len(arr) var i,j int flag:=false for i=l-2;i\u003e=0;i--{ if arr[i]\u003earr[i+1]{ flag=true for j=i+1;j\u003cl;j++{ if arr[j]\u003e=arr[i]{ break } } j-- // 找最左元素 for arr[j]==arr[j-1]{j--} break } } if flag{ arr[i],arr[j]=arr[j],arr[i] } return arr } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:2:24","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"1000. 合并石头的最低成本 1000. 合并石头的最低成本 动态规划，官方题解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 func mergeStones(stones []int, k int) int { n := len(stones) if (n-1)%(k-1) != 0 { return -1 } d := make([][][]int, n) for i := range d { d[i] = make([][]int, n) for j := range d[i] { d[i][j] = make([]int, k+1) for k := range d[i][j] { d[i][j][k] = 1e9 } } } sum := make([]int, n+1) for i, s := 0, 0; i \u003c n; i++ { d[i][i][1] = 0 s += stones[i] sum[i+1] = s } for len := 2; len \u003c= n; len++ { for l := 0; l \u003c n \u0026\u0026 l+len-1 \u003c n; l++ { r := l + len - 1 for t := 2; t \u003c= k; t++ { for p := l; p \u003c r; p += k - 1 { d[l][r][t] = min(d[l][r][t], d[l][p][1]+d[p+1][r][t-1]) } } d[l][r][1] = min(d[l][r][1], d[l][r][k]+sum[r+1]-sum[l]) } } return d[0][n-1][1] } func min(a, b int) int { if a \u003e b { return b } return a } 状态转移方程太复杂了，自己的代码没有完善 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 func mergeStones(stones []int, k int) int { l:=len(stones) memo:=make([][][]int,l) for i,_ :=range memo{ memo[i]=make([][]int,l) for j,_:=range memo[i]{ memo[i][j]=make([]int,k+1) memo[i][i][1]=stones[i] } } presum:=make([]int,l+1) tmp:=0 for i,v:=range stones{ tmp+=v presum[i+1]=tmp } var dp func(i,j,k int)int dp=func(i,j,k int)int{ if memo[i][j][k]!=0{return memo[i][j][k]} if j-i+1\u003ck{return math.MaxInt} cost:=presum[j+1]-presum[i] min:=math.MaxInt for t:=i;t\u003c=j-k;t++{ tmp:=dp(i,t,1) } } } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:2:25","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"2427. 公因子的数目 2427. 公因子的数目 模拟，这里使用了最小公因数优化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func commonFactors(a int, b int) int { g:=gcd(a,b) ans:=0 for i:=1;i\u003c=g;i++{ if a%i==0\u0026\u0026b%i==0{ans++} } return ans } func gcd(a,b int)int{ for a!=0{ a,b=b%a,a } return b } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:2:26","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"1040. 移动石子直到连续 II 1040. 移动石子直到连续 II 贪心计算最大值，滑动窗口判断最小值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 func numMovesStonesII(stones []int) []int { sort.Ints(stones) l:=len(stones) max:=Max(stones[l-1]-stones[1],stones[l-2]-stones[0])-(l-2) if stones[l-1]-stones[0]==l-1{return []int{0,0}} min,curcount:=math.MaxInt,0 left,right:=0,0 fmt.Println(stones) for right\u003cl{ curcount++ right++ for left\u003cright\u0026\u0026stones[left]\u003c=stones[right-1]-l{ curcount-- left++ } tmp:=l-curcount if curcount==l-1\u0026\u0026 stones[right-1]-stones[left]==curcount-1{tmp++} //fmt.Println(left,right,tmp,min) min=Min(tmp,min) } return []int{min,max} } func Max(s ...int)int{ tmp:=math.MinInt for _,v:=range s{ if tmp\u003cv{tmp=v} } return tmp } func Min(s ...int)int{ tmp:=math.MaxInt for _,v:=range s{ if tmp\u003ev{tmp=v} } return tmp } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:2:27","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"1026. 节点与其祖先之间的最大差值 1026. 节点与其祖先之间的最大差值 树形dp，返回左右子树的最大节点和最小节点，合并最大节点max和最小节点min，ans=Max(ans,Abs(root.Val-min),Abs(root.Val-max)) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func maxAncestorDiff(root *TreeNode) int { ans:=math.MinInt var dfs func(root *TreeNode)(min,max int) dfs=func(root *TreeNode)(min,max int){ if root==nil{return math.MaxInt,math.MinInt} lmin,lmax:=dfs(root.Left) if lmin==math.MaxInt{ lmin=root.Val lmax=root.Val } rmin,rmax:=dfs(root.Right) if rmin==math.MaxInt{ rmin=root.Val rmax=root.Val } min=Min(lmin,rmin,root.Val) max=Max(lmax,rmax,root.Val) ans=Max(abs(root.Val-min),abs(root.Val-max),ans) return } dfs(root) return ans } func abs(i int)int{ if i\u003c0{i=-i} return i } func Max(s ...int)int{ tmp:=math.MinInt for _,v:=range s{ if tmp\u003cv{tmp=v} } return tmp } func Min(s ...int)int{ tmp:=math.MaxInt for _,v:=range s{ if tmp\u003ev{tmp=v} } return tmp } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:2:28","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"剑指offer ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:3:0","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"剑指 Offer II 111. 计算除法 剑指 Offer II 111. 计算除法 官方题解为bfs，floyd算法和带权并查集 我这里使用dfs+回溯优化，耗时0ms，时间复杂度打败100%提交 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 func calcEquation(equations [][]string, values []float64, queries [][]string) []float64 { l:=len(equations) lq:=len(queries) eq:=make(map[string]map[string]float64,0) //onpath:=make(map[string]bool,0) visited:=make(map[string]bool,0) for i:=0;i\u003cl;i++{ if _,has:=eq[equations[i][0]];!has{eq[equations[i][0]]=make(map[string]float64,2)} if _,has:=eq[equations[i][1]];!has{eq[equations[i][1]]=make(map[string]float64,2)} eq[equations[i][0]][equations[i][1]]=values[i] eq[equations[i][1]][equations[i][0]]=1/values[i] //onpath[equations[i][0]]=false //onpath[equations[i][1]]=false visited[equations[i][0]]=false visited[equations[i][1]]=false } init:=func(){ for k,_:=range visited{ //onpath[k]=false visited[k]=false } } var dfs func (from,to string)float64 dfs=func (from,to string)float64{ if visited[from]{return -1} if v,has:=eq[from][to];has{return v} //onpath[from]=true visited[from]=true ret:=-1.0 for mid,_:=range eq[from]{ if ret=dfs(mid,to);ret!=-1{ ret*=eq[from][mid] eq[from][to]=ret eq[to][from]=1/ret break } } //onpath[from]=false return ret } ans:=make([]float64,lq) for i:=0;i\u003clq;i++{ _,has1:=visited[queries[i][0]] _,has2:=visited[queries[i][1]] if !(has1\u0026\u0026has2){ //fmt.Println(\"aaa\") ans[i]=-1 continue } if queries[i][0]==queries[i][1]{ ans[i]=1 }else{ init() ans[i]=dfs(queries[i][0],queries[i][1]) } } return ans } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:3:1","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"剑指 Offer II 109. 开密码锁 剑指 Offer II 109. 开密码锁 BFS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 func openLock(deadends []string, target string) int { type pair struct{ s string step int } visited:=make(map[string]bool,0) dead:=make(map[string]bool,0) for i:=0;i\u003clen(deadends);i++{dead[deadends[i]]=true} isdead:=func(s string)bool{ _,ok:=dead[s] return ok } isvisited:=func(s string)bool{ _,ok:=visited[s] return ok } add:=func (s []byte,i int){ if s[i]=='9'{ s[i]='0' }else { s[i]++ } } dec:=func (s []byte,i int){ if s[i]=='0'{ s[i]='9' }else { s[i]-- } } if isdead(\"0000\"){return -1} q:=list.New() q.PushBack(pair{\"0000\",0}) visited[\"0000\"]=true for q.Len()!=0{ p:=q.Remove(q.Front()).(pair) if p.s==target{return p.step} for i:=0;i\u003c4;i++{ tmp1,tmp2:=[]byte(p.s),[]byte(p.s) add(tmp1,i) dec(tmp2,i) if !isvisited(string(tmp1))\u0026\u0026!isdead(string(tmp1)){ q.PushBack(pair{string(tmp1),p.step+1}) visited[string(tmp1)]=true } if !isvisited(string(tmp2))\u0026\u0026!isdead(string(tmp2)){ q.PushBack(pair{string(tmp2),p.step+1}) visited[string(tmp2)]=true } } } return -1 } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:3:2","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"剑指 Offer II 112. 最长递增路径 剑指 Offer II 112. 最长递增路径 动态规划，树形dp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 func longestIncreasingPath(matrix [][]int) int { row,col,ans:=len(matrix),len(matrix[0]),1 dp:=make([][]int,row) for i,_:=range dp{ dp[i]=make([]int,col) } dirs:=[][]int{{0,1},{1,0},{0,-1},{-1,0}} var dfs func(i,j int) int dfs=func(i,j int) int{ if dp[i][j]!=0{return dp[i][j]} tmp:=1 for _,v:=range dirs{ in,jn:=i+v[0],j+v[1] if in\u003e=0\u0026\u0026jn\u003e=0\u0026\u0026in\u003crow\u0026\u0026jn\u003ccol\u0026\u0026matrix[i][j]\u003cmatrix[in][jn]{ ret:=dfs(in,jn)+1 if tmp\u003cret{tmp=ret} } } dp[i][j]=tmp if tmp\u003eans{ans=tmp} return dp[i][j] } for i,_ :=range matrix{ for j,_ := range matrix[i]{ dfs(i,j) } } return ans } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:3:3","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"25 K 个一组翻转链表 25 K 个一组翻转链表 给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。 学会东哥反转链表技巧后结合go语言特有的可以返回多个值的特性写出的解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseKGroup(head *ListNode, k int) *ListNode { reverseK:=func (current *ListNode) (Start,Last *ListNode){ Last=current var prev,next *ListNode=nil,nil for i:=0;i\u003ck;i++{ next=current.Next current.Next=prev prev=current current=next } Start=prev return } dummy:=\u0026ListNode{Next:head} cur,prev:=head,dummy for cur!=nil{ i:=0 for ;i\u003ck\u0026\u0026cur!=nil;i++{ cur=cur.Next } if i==k{ Start,Last:=reverseK(prev.Next) prev.Next=Start Last.Next=cur prev=Last }else{break} } return dummy.Next } 利用匿名函数特有的闭包特性定义反转函数reverseK，这样就不用在外面定义全局变量了，reverseK函数中可以直接使用reverseKGroup函数的变量。另外该函数返回反转完后新链表的start和last供外界操作。 首先给链表添加一个dummy虚拟头节点，统一链表头和链表头后面的节点的操作逻辑，而且方便最后返回答案。 然后使用prev记录反转初始节点的前一个节点，然后遍历看是否还有k个节点可供翻转，如果不够就直接break并返回dummy.Next；如果够就给prev.Next调用reverseK。 ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:3:4","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"剑指 Offer 04. 二维数组中的查找 剑指 Offer 04. 二维数组中的查找 贪心，从左下或者右上开始遍历，相当于一个二叉排序树 1 2 3 4 5 6 7 8 9 10 11 12 13 func findNumberIn2DArray(matrix [][]int, target int) bool { if len(matrix)==0{return false} m,n:=len(matrix),len(matrix[0]) i,j:=m-1,0 for i\u003e=0\u0026\u0026j\u003cn\u0026\u0026matrix[i][j]!=target{ if matrix[i][j]\u003ctarget{ j++ }else{i--} } fmt.Println(i,j) if i\u003e=0\u0026\u0026j\u003cn{return true} return false } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:3:5","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"剑指 Offer 59 - I. 滑动窗口的最大值 剑指 Offer 59 - I. 滑动窗口的最大值 滑动窗口（单调队列），保持队列单调性，时间复杂度O(N) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func maxSlidingWindow(nums []int, k int) []int { queue:=[]int{} ans:= []int{} for i:=0;i\u003clen(nums);i++{ for len(queue)\u003e0 \u0026\u0026 nums[queue[len(queue)-1]]\u003c=nums[i]{ queue=queue[:len(queue)-1] } queue=append(queue,i) for queue[0]\u003ci-k+1{ queue=queue[1:] } if i\u003e=k-1{ ans=append(ans,nums[queue[0]]) } } return ans } 优先队列（二叉堆）做法需要在堆中存储对应值的下标，及时将下标小于当前值-k的节点pop掉 ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:3:6","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"hot100 ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:4:0","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"19. 删除链表的倒数第 N 个结点 19. 删除链表的倒数第 N 个结点 删除倒数第n个，所以选择倒数第n+1个节点，删除它的下一个节点即可 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func removeNthFromEnd(head *ListNode, n int) *ListNode { dummy:=\u0026ListNode{Next:head} fast,slow:=dummy,dummy for i:=0;i\u003cn+1;i++{ if fast==nil{return head} fast=fast.Next } for fast!=nil{ fast=fast.Next slow=slow.Next } target:=slow.Next slow.Next=target.Next target.Next=nil return dummy.Next } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:4:1","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"17. 电话号码的字母组合 17. 电话号码的字母组合 回溯，这里使用了string不可变类型的特性，将[]byte转换为string会自动复制一份，这样就不需要你make后再copy了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 func letterCombinations(digits string) []string { l:=len(digits) if l==0{return []string{}} ans:=[]string{} onpath:=make([]byte,l) var backtrack func(i int) backtrack=func(i int){ if i==l{ ans=append(ans,string(onpath)) return } for _,v :=range m[digits[i]]{ onpath[i]=v backtrack(i+1) } } backtrack(0) return ans } var m map[byte][]byte=map[byte][]byte{ '2':[]byte{'a','b','c'}, '3':[]byte{'d','e','f'}, '4':[]byte{'g','h','i'}, '5':[]byte{'j','k','l'}, '6':[]byte{'m','n','o'}, '7':[]byte{'p','q','r','s'}, '8':[]byte{'t','u','v'}, '9':[]byte{'w','x','y','z'}, } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:4:2","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"20. 有效的括号 20. 有效的括号 栈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func isValid(s string) bool { stack:=make([]rune,0,len(s)) m:=map[rune]rune{ ']':'[', ')':'(', '}':'{', } for _,v:=range s{ if v=='['||v=='('||v=='{'{ stack=append(stack,v) }else if v==']'||v==')'||v=='}'{ l:=len(stack) if l==0{return false} if stack[l-1]!=m[v]{ return false } stack=stack[:l-1] } } if len(stack)!=0{return false} return true } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:4:3","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"21. 合并两个有序链表 21. 合并两个有序链表 迭代，使用虚拟节点技巧 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode { dummy:=\u0026ListNode{Next:nil} now:=dummy for list1!=nil\u0026\u0026list2!=nil{ if list1.Val\u003clist2.Val{ now.Next=list1 list1=list1.Next }else{ now.Next=list2 list2=list2.Next } now=now.Next } if list1!=nil{ now.Next=list1 }else{now.Next=list2} return dummy.Next } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:4:4","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"33. 搜索旋转排序数组 33. 搜索旋转排序数组 二分搜索，先比较nums[mid]和nums[0]，再考虑num[mid]和target 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func search(nums []int, target int) int { if target==nums[0]{return 0} l,r:=0,len(nums)-1 var mid int for l\u003c=r{ mid=l+(r-l)/2 //fmt.Println(l,r,mid) if nums[mid]==target{return mid} if nums[mid]\u003enums[0]{ if target\u003enums[0]\u0026\u0026target\u003cnums[mid]{ r=mid-1 }else { l=mid+1 } }else if nums[mid]\u003cnums[0]{ if target\u003enums[mid]\u0026\u0026target\u003cnums[0]{ l=mid+1 }else{ r=mid-1 } }else{l=mid+1} } //fmt.Println(l,r) return -1 } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:4:5","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"39. 组合总和 39. 组合总和 回溯，东哥说的回溯解决所有排列组合子集问题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func combinationSum(candidates []int, target int) [][]int { cur:=0 l:=len(candidates) onpath:=[]int{} ans:=[][]int{} var backtrack func(start int) backtrack=func(start int){ if cur==target{ tmp:=make([]int,len(onpath)) copy(tmp,onpath) ans=append(ans,tmp) return } if cur\u003etarget{return} for i:=start;i\u003cl;i++{ cur+=candidates[i] onpath=append(onpath,candidates[i]) backtrack(i) onpath=onpath[:len(onpath)-1] cur-=candidates[i] } } backtrack(0) return ans } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:4:6","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"46. 全排列 46. 全排列 回溯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 func permute(nums []int) [][]int { l:=len(nums) onpath:=make([]int,0,l) visited:=make([]bool,l) ans:=[][]int{} var backtrack func(i int) backtrack=func(i int){ if visited[i]{return} visited[i]=true onpath=append(onpath,nums[i]) if len(onpath)==l{ tmp:=make([]int,l) copy(tmp,onpath) ans=append(ans,tmp) }else{ for i,_:=range nums{ backtrack(i) } } onpath=onpath[:len(onpath)-1] visited[i]=false } for i,_:=range nums{ backtrack(i) } return ans } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:4:7","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"48. 旋转图像 48. 旋转图像 模拟，将左上1/4的元素循环修改即可 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func rotate(matrix [][]int) { l:=len(matrix) m:=(l+1)/2 -1 n:=m swap:=func (i,j int){ tmp:=matrix[i][j] matrix[i][j]=matrix[l-1-j][i] matrix[l-1-j][i]=matrix[l-1-i][l-1-j] matrix[l-1-i][l-1-j]=matrix[j][l-1-i] matrix[j][l-1-i]=tmp } if l\u00261==1{ m-- } //fmt.Println(m,n) for i:=0;i\u003c=m;i++{ for j:=0;j\u003c=n;j++{ swap(i,j) } } return } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:4:8","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"49. 字母异位词分组 49. 字母异位词分组 数组每个单词计数字母数，哈希表记录分组结果，这里运用了使用数组作为键的技巧，数组可以快速判断计数是否一致 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func groupAnagrams(strs []string) [][]string { m:=map[[26]int][]string{} for _,s:=range strs{ tmp:=[26]int{} for _,v:=range s{ tmp[v-'a']++ } m[tmp]=append(m[tmp],s) } ans:=make([][]string,0,len(m)) for _,v:=range m{ ans=append(ans,v) } return ans } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:4:9","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"53. 最大子数组和 53. 最大子数组和 动态规划 定义状态:dp[i]为以i结尾的最大子数组和 basecase:dp[0]=nums[0] 选择:当前位置要nums[i-1]（接着dp[i-1]的子数组加上nums[i]）和不要nums[i-1]（nums[i]自己成为一个新的子数组） 状态转移方程:dp[i]=Max(dp[i-1]+nums[i],nums[i]) 在转移过程中用ans更新最大值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func maxSubArray(nums []int) int { l:=len(nums) dp:=make([]int,l) dp[0]=nums[0] ans:=dp[0] for i,v:=range nums[1:]{ i+=1 dp[i]=Max(dp[i-1]+v,v) if dp[i]\u003eans{ans=dp[i]} } return ans } func Max(a,b int)int{ if a\u003eb{return a} return b } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:4:10","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"55. 跳跃游戏 55. 跳跃游戏 贪心，记录最远能到的位置，遍历数组更新最远位置 1 2 3 4 5 6 7 8 9 func canJump(nums []int) bool { l:=len(nums) tmp:=0 for i:=0;i\u003c=tmp\u0026\u0026tmp\u003cl;i++{ r:=i+nums[i] if tmp\u003cr{tmp=r} } return tmp\u003e=l-1 } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:4:11","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"56. 合并区间 56. 合并区间 按start排序，模拟合并，分两种情况，v[0]\u003estart和其他情况 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func merge(intervals [][]int) [][]int { sort.Slice(intervals,func (i,j int)bool{ return intervals[i][0]\u003cintervals[j][0] }) start,end:=intervals[0][0],intervals[0][1] ans:=[][]int{} for _,v:=range intervals{ if v[0]\u003eend{ ans=append(ans,[]int{start,end}) start=v[0] end=v[1] }else{ end=Max(end,v[1]) } } ans=append(ans,[]int{start,end}) return ans } func Max(a,b int)int{ if a\u003cb{return b} return a } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:4:12","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"62. 不同路径 62. 不同路径 动态规划，添加虚拟行列技巧 dp[i][j]代表到(i,j)位置的路径数 basecase:dp[1][1]=1，但是为了统一遍历逻辑，将dp[0][1]设置为1 选择：只能往右或往下，可以选择从(i-1,j)到(i,j)或者(i,j-1)到(i,j) 状态转移:dp[i][j]=dp[i-1][j]+dp[i][j-1] 1 2 3 4 5 6 7 8 9 10 11 12 13 func uniquePaths(m int, n int) int { dp:=make([][]int,m+1) for i:=range dp{ dp[i]=make([]int,n+1) } dp[0][1]=1 for i:=1;i\u003cm+1;i++{ for j:=1;j\u003cn+1;j++{ dp[i][j]=dp[i-1][j]+dp[i][j-1] } } return dp[m][n] } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:4:13","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"64. 最小路径和 64. 最小路径和 动态规划，添加虚拟行列技巧 dp[i][j]代表到(i,j)位置的最小值 basecase：dp[1][1]=nums[0][0]，为了统一遍历逻辑将虚拟行列都设置为math.MaxInt，然后将dp[0][1]设置为0 选择：只能往右或往下，可以选择从(i-1,j)到(i,j)或者(i,j-1)到(i,j) 状态转移:dp[i][j]=Min(dp[i-1][j],dp[i][j-1])+nums[i-1][j-1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func minPathSum(grid [][]int) int { m,n:=len(grid),len(grid[0]) dp:=make([][]int,m+1) for i:=range dp{ dp[i]=make([]int,n+1) dp[i][0]=math.MaxInt } for j:=0;j\u003cn+1;j++{ dp[0][j]=math.MaxInt } dp[0][1]=0 for i:=1;i\u003cm+1;i++{ for j:=1;j\u003cn+1;j++{ dp[i][j]=Min(dp[i-1][j],dp[i][j-1])+grid[i-1][j-1] } } return dp[m][n] } func Min(a,b int)int{ if a\u003cb{return a} return b } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:4:14","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"70. 爬楼梯 70. 爬楼梯 动态规划 dp[i]为到第i阶的路径数 basecase：dp[0],dp[1]都为1 选择：只能跳上1，2阶，可以从i-1阶或i-2阶跳上来 dp[i]=dp[i-1]+dp[i-2] 1 2 3 4 5 6 7 8 9 func climbStairs(n int) int { dp:=make([]int,n+1) dp[0]=1 dp[1]=1 for i:=2;i\u003cn+1;i++{ dp[i]=dp[i-1]+dp[i-2] } return dp[n] } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:4:15","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"75. 颜色分类 75. 颜色分类 快排 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func sortColors(nums []int) { var fs func(i,j int) fs=func(i,j int){ //fmt.Println(i,j) if i\u003e=j{return} tmp:=nums[i] l,r:=i,j for l\u003cr{ for l\u003cr\u0026\u0026nums[r]\u003e=tmp{ r-- } nums[l]=nums[r] for l\u003cr\u0026\u0026nums[l]\u003c=tmp{ l++ } nums[r]=nums[l] } //fmt.Println(l,nums) nums[l]=tmp fs(i,l-1) fs(l+1,j) } fs(0,len(nums)-1) } 一次遍历，计数排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func sortColors(nums []int) { n0,n1:=0,0 for _,v:=range nums{ switch v{ case 0:n0++ case 1:n1++ } } tmp:=0 for i:=0;i\u003cn0;i++{ nums[tmp]=0 tmp++ } for i:=0;i\u003cn1;i++{ nums[tmp]=1 tmp++ } for tmp\u003clen(nums){ nums[tmp]=2 tmp++ } } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:4:16","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"76. 最小覆盖子串 76. 最小覆盖子串 滑动窗口，官方题解使用check函数遍历比对是否覆盖，时间复杂度O(NK)，K为子串不同字符数，我这里用还未覆盖字符数n优化，在滑动过程中维护该值，时间复杂度为O(N) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func minWindow(s string, t string) string { mt:=map[byte]int{} for i:=range t{ mt[t[i]]++ } n:=len(mt) var ansl,ansr int ans:=math.MaxInt ms:=map[byte]int{} r,l:=0,0 for r\u003clen(s){ ms[s[r]]++ if mt[s[r]]!=0\u0026\u0026ms[s[r]]==mt[s[r]]{n--} r++ for l\u003cr\u0026\u0026n==0{ if r-l\u003cans{ ans=r-l ansl=l ansr=r } ms[s[l]]-- if mt[s[l]]!=0\u0026\u0026ms[s[l]]==mt[s[l]]-1{n++} l++ } } return s[ansl:ansr] } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:4:17","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"78. 子集 78. 子集 回溯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func subsets(nums []int) [][]int { l:=len(nums) onpath:=make([]int,0,l) ans:=[][]int{} var backtrack func(i int) backtrack=func(i int){ if i==l{ tmp:=make([]int,len(onpath)) copy(tmp,onpath) ans=append(ans,tmp) return } backtrack(i+1) onpath=append(onpath,nums[i]) backtrack(i+1) onpath=onpath[:len(onpath)-1] } backtrack(0) return ans } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:4:18","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"79. 单词搜索 79. 单词搜索 回溯剪枝 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 func exist(board [][]byte, word string) bool { m,n,l:=len(board),len(board[0]),len(word) visited:=make([][]bool,m) for i:=range visited{ visited[i]=make([]bool,n) } ans:=false var backtrack func(i,j,k int) backtrack=func(i,j,k int){ if ans{return} if k==l{ ans=true return } if i\u003c0||i\u003e=m||j\u003c0||j\u003e=n{return} if visited[i][j]{return} if board[i][j]!=word[k]{ return }else{ visited[i][j]=true for _,v:=range dir{ backtrack(i+v[0],j+v[1],k+1) } visited[i][j]=false } } for i:=0;i\u003cm;i++{ for j:=0;j\u003cn;j++{ backtrack(i,j,0) } } return ans } var dir=[][]int{ {1,0}, {0,1}, {-1,0}, {0,-1}, } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:4:19","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"84. 柱状图中最大的矩形 84. 柱状图中最大的矩形 单调栈，维护单调递增，存索引，遇到索引i对应值v小于顶部元素索引对应值s[len(s)-1]时，弹出顶部元素，可以确定顶部元素索引值为高h的最大矩形，左端点l为该元素索引前一个元素索引+1，如果没有前一个元素索引则l为0，右端点为x-1。 所以面积为h*(r-l+1) 遍历完后将计算面积的逻辑再调用一遍，不过此时r为数组长度lh 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 func largestRectangleArea(heights []int) int { lh:=len(heights) s:=make([]int,0,lh) ans:=math.MinInt for i,v:=range heights{ r:=i-1 for len(s)\u003e0\u0026\u0026heights[s[len(s)-1]]\u003e=v{ l:=0 if len(s)\u003e1{ l=s[len(s)-2]+1 } h:=heights[s[len(s)-1]] tmp:=h*(r-l+1) if ans\u003ctmp{ans=tmp} s=s[:len(s)-1] } s=append(s,i) } r:=lh-1 for len(s)\u003e0{ l:=0 if len(s)\u003e1{ l=s[len(s)-2]+1 } h:=heights[s[len(s)-1]] tmp:=h*(r-l+1) if ans\u003ctmp{ans=tmp} s=s[:len(s)-1] } return ans } 代码复用优化后 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 func largestRectangleArea(heights []int) int { lh:=len(heights) s:=make([]int,0,lh) ans:=math.MinInt countmianji:=func(r int){ l:=0 if len(s)\u003e1{ l=s[len(s)-2]+1 } h:=heights[s[len(s)-1]] tmp:=h*(r-l+1) if ans\u003ctmp{ans=tmp} } for i,v:=range heights{ r:=i-1 for len(s)\u003e0\u0026\u0026heights[s[len(s)-1]]\u003e=v{ countmianji(r) s=s[:len(s)-1] } s=append(s,i) } r:=lh-1 for len(s)\u003e0{ countmianji(r) s=s[:len(s)-1] } return ans } ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:4:20","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"sql ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:5:0","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["数据结构与算法"],"content":"178. 分数排名 178. 分数排名 使用变量，这里注意rank作为关键字不允许使用，需要用rank来标记字段名 1 2 3 4 5 6 7 SELECT score, `rank` FROM (SELECT score, cast((case when @prevScore = score then @curRank := @curRank else @curRank := @curRank + 1 end) as SIGNED) `rank`, @prevScore := score FROM Scores sc, (SELECT @curRank := 0, @prevScore := null) ra ORDER BY score DESC ) newscore ","date":"2023-03-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/:5:1","tags":["刷题"],"title":"数据结构与算法-刷题-Leetcode","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/leetcode/"},{"categories":["Golang"],"content":"go语言中文网 godoc go语言中文网有很多文档缺少内容比如string.Builder就没有，godoc绝对详尽，推荐阅读godoc time包提供了时间的显示和测量用的函数。日历的计算采用的是公历 ","date":"2023-03-11","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/:0:0","tags":["go标准库"],"title":"go标准库-Time","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/"},{"categories":["Golang"],"content":"type Weekday 1 2 3 4 5 6 7 8 9 10 11 type Weekday int const ( Sunday Weekday = iota Monday Tuesday Wednesday Thursday Friday Saturday ) 常用函数 func (d Weekday) String() string: String返回该日（周几）的英文名 ","date":"2023-03-11","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/:1:0","tags":["go标准库"],"title":"go标准库-Time","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/"},{"categories":["Golang"],"content":"type Month 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 type Month int const ( January Month = 1 + iota February March April May June July August September October November December ) 常用函数 func (m Month) String() string: String返回月份的英文名 ","date":"2023-03-11","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/:2:0","tags":["go标准库"],"title":"go标准库-Time","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/"},{"categories":["Golang"],"content":"type Location Location代表一个（关联到某个时间点的）地点，以及该地点所在的时区 常用函数 func LoadLocation(name string) (*Location, error): 返回使用给定的地名创建的Location，可用的名字有UTC，Local或者IANA时区数据库里有记录的地点名如\"America/New_York\" func FixedZone(name string, offset int) *Location: 使用给定的地点名name和时间偏移量offset（单位秒）创建并返回一个Location func (l *Location) String() string: 返回值绑定为LoadLocation或FixedZone函数创建l时的name参数 ","date":"2023-03-11","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/:3:0","tags":["go标准库"],"title":"go标准库-Time","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/"},{"categories":["Golang"],"content":"type Time 1 2 3 4 type Time struct { // 内含隐藏或非导出字段 loc *Location } 纳秒精度的时间点 ","date":"2023-03-11","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/:4:0","tags":["go标准库"],"title":"go标准库-Time","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/"},{"categories":["Golang"],"content":"常用函数 func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time:返回一个根据参数设置值的Time对象 func Now() Time:当前本地时间的Time对象 func Unix(sec int64, nsec int64) Time：使用Unix时间戳创建一个Time对象 ","date":"2023-03-11","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/:4:1","tags":["go标准库"],"title":"go标准库-Time","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/"},{"categories":["Golang"],"content":"常用方法 func (t Time) Location() *Location: 返回t的Location对象 func (t Time) Zone() (name string, offset int): 计算t所在的时区，返回该时区的规范名（如\"CET\"）和该时区相对于UTC的时间偏移量（单位秒） func (t Time) Local() Time: 返回采用本地和本地时区，但指向同一时间点的Time func (t Time) UTC() Time: 返回UTC零时区，但指向同一时间点的Time func (t Time) Unix() int64: 返回t表示时间的Unix时间戳，单位为秒 func (t Time) UnixNano() int64: 返回t表示时间的Unix时间戳，单位为纳秒 func (t Time) Equal(u Time) bool: 判断两个时间是否相同，会考虑时区的影响，因此不同时区标准的时间也可以正确比较。==不比较地区和对应时区信息 func (t Time) Before(u Time) bool: t是否在u之后 func (t Time) After(u Time) bool: t是否在u之前 func (t Time) Date() (year int, month Month, day int): 返回年、月、日 func (t Time) Clock() (hour, min, sec int): 返回时、分、秒 func (t Time) Year() int:返回年 func (t Time) Month() Month:返回月 func (t Time) YearDay() int: t对应的那一年的第几天 func (t Time) Day() int: 返回日 func (t Time) Weekday() Weekday: 返回是周几 func (t Time) Hour() int:返回时 func (t Time) Minute() int:返回分 func (t Time) Second() int:返回秒 func (t Time) Nanosecond() int: 返回纳秒 func (t Time) Add(d Duration) Time: 返回时间点t+d func (t Time) Sub(u Time) Duration: 返回时间段t-u func (t Time) Format(layout string) string: 根据layout指定的格式返回t代表的时间点的格式化文本表示，格式为Mon Jan 2 15:04:05 -0700 MST 2006 ","date":"2023-03-11","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/:4:2","tags":["go标准库"],"title":"go标准库-Time","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/"},{"categories":["Golang"],"content":"type Duration 1 type Duration int64 常量 1 2 3 4 5 6 7 8 const ( Nanosecond Duration = 1 Microsecond = 1000 * Nanosecond Millisecond = 1000 * Microsecond Second = 1000 * Millisecond Minute = 60 * Second Hour = 60 * Minute ) 常用函数 func Since(t Time) Duration: Since返回从t到现在经过的时间，等价于time.Now().Sub(t) 常用方法 func (d Duration) Hours() float64: 表示为float64类型的小时数 func (d Duration) Minutes() float64: 表示为float64类型的分钟数 func (d Duration) Seconds() float64: 表示为int64类型的纳秒数，等价于int64(d) ","date":"2023-03-11","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/:5:0","tags":["go标准库"],"title":"go标准库-Time","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/"},{"categories":["Golang"],"content":"type Timer 1 2 3 4 type Timer struct { C \u003c-chan Time // 内含隐藏或非导出字段 } 常用函数 func NewTimer(d Duration) *Timer: 创建一个倒计时为d的Timer，时间到后像C发送当前时间 func AfterFunc(d Duration, f func()) *Timer: 另起一个go程等待时间段d过去，然后调用f，返回Timer对象 常用方法 func (t *Timer) Reset(d Duration) bool: Reset使t重新开始计时，返回真表示调用时t还在倒计时，为假表示t已经停止了 func (t *Timer) Stop() bool: Stop停止Timer的执行，返回真表示调用时t还在倒计时，为假表示t已经停止了。Stop不会关闭通道t.C ","date":"2023-03-11","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/:6:0","tags":["go标准库"],"title":"go标准库-Time","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/"},{"categories":["Golang"],"content":"type Ticker 1 2 3 4 type Ticker struct { C \u003c-chan Time // 周期性传递时间信息的通道 // 内含隐藏或非导出字段 } 常用函数 func NewTicker(d Duration) *Ticker: 创建频率为d的Ticker，时间到了会向C发送当前时间 常用方法 func (t *Ticker) Stop(): 关闭一个Ticker，Stop不会关闭通道t.C ","date":"2023-03-11","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/:7:0","tags":["go标准库"],"title":"go标准库-Time","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/"},{"categories":["Golang"],"content":"常用函数 func Sleep(d Duration): 阻塞当前go程至少d代表的时间段 func After(d Duration) \u003c-chan Time: 在另一线程经过时间段d后向返回值发送当时的时间 ","date":"2023-03-11","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/:8:0","tags":["go标准库"],"title":"go标准库-Time","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/"},{"categories":["Golang"],"content":"go语言中文网 godoc go语言中文网有很多文档缺少内容比如string.Builder就没有，godoc绝对详尽，推荐阅读godoc bytes包实现了操作[]byte的常用函数 ","date":"2023-03-11","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/bytes/:0:0","tags":["go标准库"],"title":"go标准库-Bytes","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/bytes/"},{"categories":["Golang"],"content":"常用函数 strings中具有的函数bytes里面基本都有 func Equal(a, b []byte) bool:判断两个切片的内容是否完全相同 func EqualFold(s, t []byte) bool:判断两个utf-8编码切片（将unicode大写、小写、标题三种格式字符视为相同）是否相同 func Runes(s []byte) []rune: 返回和s等价的[]rune切片 func TrimSpace(s []byte) []byte:后端所有空白（unicode.IsSpace指定）都去掉的子切片 func Fields(s []byte) [][]byte:返回将字符串按照空白（unicode.IsSpace确定，可以是一到多个连续的空白字符）分割的多个子切片 func Split(s, sep []byte) [][]byte:用去掉s中出现的sep的方式进行分割，会分割到结尾，并返回生成的所有[]byte切片组成的切片（每一个sep都会进行一次切割，即使两个sep相邻，也会进行两次切割） func Join(s [][]byte, sep []byte) []byte: 将一系列[]byte切片连接为一个[]byte切片，之间用sep来分隔，返回生成的新切片 ","date":"2023-03-11","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/bytes/:1:0","tags":["go标准库"],"title":"go标准库-Bytes","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/bytes/"},{"categories":["Golang"],"content":"type Buffer 常用函数 func NewBuffer(buf []byte) *Buffer:NewBuffer使用buf作为初始内容创建并初始化一个Buffer。 func NewBufferString(s string) *Buffer:NewBuffer使用s作为初始内容创建并初始化一个Buffer。 常用方法 func (b *Buffer) Reset():Reset重设缓冲 func (b *Buffer) Len() int:返回缓冲中未读取部分的字节长度 func (b *Buffer) Bytes() []byte:返回未读取部分字节数据的切片 func (b *Buffer) String() string:将未读取部分的字节数据作为字符串返回 func (b *Buffer) Read(p []byte) (n int, err error):从缓冲中读取数据直到缓冲中没有数据或者读取了len(p)字节数据，将读取的数据写入p func (b *Buffer) ReadByte() (c byte, err error):读取并返回缓冲中的下一个字节 func (b *Buffer) ReadRune() (r rune, size int, err error):ReadRune读取并返回缓冲中的下一个utf-8码值 func (b *Buffer) ReadBytes(delim byte) (line []byte, err error):ReadBytes读取直到第一次遇到delim字节，返回一个包含已读取的数据和delim字节的切片 func (b *Buffer) ReadString(delim byte) (line string, err error):ReadString读取直到第一次遇到delim字节，返回一个包含已读取的数据和delim字节的字符串 func (b *Buffer) Write(p []byte) (n int, err error):Write将p的内容写入缓冲中，如必要会增加缓冲容量 func (b *Buffer) WriteString(s string) (n int, err error):Write将s的内容写入缓冲中，如必要会增加缓冲容量 ","date":"2023-03-11","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/bytes/:2:0","tags":["go标准库"],"title":"go标准库-Bytes","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/bytes/"},{"categories":["Golang"],"content":"面向对象理解interface golang修养之路 ","date":"2023-03-11","objectID":"/posts/golang/%E6%9D%82%E8%AE%B0/:1:0","tags":["golang杂记"],"title":"golang-杂记","uri":"/posts/golang/%E6%9D%82%E8%AE%B0/"},{"categories":["Golang"],"content":"理解interface interface 是方法声明的集合 任何类型的对象实现了在interface 接口中声明的全部方法，则表明该类型实现了该接口 interface 可以作为一种数据类型，实现了该接口的任何对象都可以给对应的接口类型变量赋值 ","date":"2023-03-11","objectID":"/posts/golang/%E6%9D%82%E8%AE%B0/:1:1","tags":["golang杂记"],"title":"golang-杂记","uri":"/posts/golang/%E6%9D%82%E8%AE%B0/"},{"categories":["Golang"],"content":"开闭原则 对扩展开放，对修改封闭 ","date":"2023-03-11","objectID":"/posts/golang/%E6%9D%82%E8%AE%B0/:1:2","tags":["golang杂记"],"title":"golang-杂记","uri":"/posts/golang/%E6%9D%82%E8%AE%B0/"},{"categories":["Golang"],"content":"依赖倒转原则 程序要依赖于抽象接口，不要依赖于具体实现 ","date":"2023-03-11","objectID":"/posts/golang/%E6%9D%82%E8%AE%B0/:1:3","tags":["golang杂记"],"title":"golang-杂记","uri":"/posts/golang/%E6%9D%82%E8%AE%B0/"},{"categories":["Golang"],"content":"内存逃逸和内存泄露 go程序员面试笔试宝典 腾讯云 素履coder ","date":"2023-03-11","objectID":"/posts/golang/%E6%9D%82%E8%AE%B0/:2:0","tags":["golang杂记"],"title":"golang-杂记","uri":"/posts/golang/%E6%9D%82%E8%AE%B0/"},{"categories":["Golang"],"content":"内存逃逸 Go语言编译器通过分析代码来决定将变量分配到何处 如果函数外部没有引用，则优先放到栈中，栈空间不足时放到堆上； 如果函数外部存在引用，则必定放到堆中；（内存逃逸） 不可预知大小的内存分配堆到堆 以下命令在构建程序的时候输出内存逃逸信息 1 go build -gcflags '-m -l' main.go ","date":"2023-03-11","objectID":"/posts/golang/%E6%9D%82%E8%AE%B0/:2:1","tags":["golang杂记"],"title":"golang-杂记","uri":"/posts/golang/%E6%9D%82%E8%AE%B0/"},{"categories":["Golang"],"content":"内存泄露 slice内存泄漏 slice只使用底层数组的一部分 time.Ticker 没有stop会导致定时任务一直在发送 goruntine 主要是CSP模型下，goruntine死锁的情况 ","date":"2023-03-11","objectID":"/posts/golang/%E6%9D%82%E8%AE%B0/:2:2","tags":["golang杂记"],"title":"golang-杂记","uri":"/posts/golang/%E6%9D%82%E8%AE%B0/"},{"categories":["Golang"],"content":"设计模式 博客园 aganippe go语言设计模式 ","date":"2023-03-11","objectID":"/posts/golang/%E6%9D%82%E8%AE%B0/:3:0","tags":["golang杂记"],"title":"golang-杂记","uri":"/posts/golang/%E6%9D%82%E8%AE%B0/"},{"categories":["Golang"],"content":"创建型模式 简单工厂模式 NewXXX 函数返回接口时就是简单工厂模式 函数返回实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //API is interface type API interface { Say(name string) string } //NewAPI return Api instance by type func NewAPI(t int) API { if t == 1 { return \u0026hiAPI{} } else if t == 2 { return \u0026helloAPI{} } return nil } 工厂方法模式 工厂方法模式使用子类的方式延迟生成对象到子类中实现。Go中不存在继承 所以使用匿名组合来实现 工厂结构体的create方法返回实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 //Operator 是被封装的实际类接口 type Operator interface { SetA(int) SetB(int) Result() int } //OperatorBase 是Operator 接口实现的基类，封装公用方法 type OperatorBase struct { a, b int } //SetA 设置 A func (o *OperatorBase) SetA(a int) { o.a = a } //SetB 设置 B func (o *OperatorBase) SetB(b int) { o.b = b } //OperatorFactory 是工厂接口 type OperatorFactory interface { Create() Operator } //PlusOperatorFactory 是 PlusOperator 的工厂类 type PlusOperatorFactory struct{} func (PlusOperatorFactory) Create() Operator { return \u0026PlusOperator{ OperatorBase: \u0026OperatorBase{}, } } //PlusOperator Operator 的实际加法实现 type PlusOperator struct { *OperatorBase } //Result 获取结果 func (o PlusOperator) Result() int { return o.a + o.b } 抽象工厂模式 抽象工厂模式用于生成产品族的工厂，所生成的对象是有关联的 单例模式 使用懒惰模式的单例模式，使用双重检查加锁保证线程安全 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //Singleton 是单例模式类 type Singleton struct{} var singleton *Singleton var once sync.Once //GetInstance 用于获取单例模式对象 func GetInstance() *Singleton { once.Do(func() { singleton = \u0026Singleton{} }) return singleton } ","date":"2023-03-11","objectID":"/posts/golang/%E6%9D%82%E8%AE%B0/:3:1","tags":["golang杂记"],"title":"golang-杂记","uri":"/posts/golang/%E6%9D%82%E8%AE%B0/"},{"categories":["Golang"],"content":"Geth区块链 博客园 王陸 搭建自己的以太坊私链 ","date":"2023-03-11","objectID":"/posts/golang/%E6%9D%82%E8%AE%B0/:4:0","tags":["golang杂记"],"title":"golang-杂记","uri":"/posts/golang/%E6%9D%82%E8%AE%B0/"},{"categories":["Golang"],"content":"Go性能调优pprof 李文周博客 CSDN raoxiaoya CPU profile：报告程序的 CPU 使用情况，按照一定频率去采集应用程序在 CPU 和寄存器上面的数据 Memory Profile（Heap Profile）：报告程序的内存使用情况 Block Profiling：报告 goroutines 不在运行状态的情况，可以用来分析和查找死锁等性能瓶颈 Goroutine Profiling：报告 goroutines 的使用情况，有哪些 goroutine，它们的调用关系是怎样的 内置标准库： runtime/pprof：采集 工具型应用运行数据 进行分析 net/http/pprof：采集 服务型应用运行时数据 进行分析 ","date":"2023-03-11","objectID":"/posts/golang/%E6%9D%82%E8%AE%B0/:5:0","tags":["golang杂记"],"title":"golang-杂记","uri":"/posts/golang/%E6%9D%82%E8%AE%B0/"},{"categories":["Golang"],"content":"工具型应用 在应用退出的时候把 profiling 的报告保存到文件中，进行分析 1 import \"runtime/pprof\" CPU性能分析 开始记录 1 pprof.StartCPUProfile(w io.Writer) 停止记录 1 pprof.StopCPUProfile() 内存性能优化 记录堆栈信息 1 pprof.WriteHeapProfile(w io.Writer) go tool pprof进行内存分析，默认-inuse_space选项，-inuse-objects选项查看分配对象数量 ","date":"2023-03-11","objectID":"/posts/golang/%E6%9D%82%E8%AE%B0/:5:1","tags":["golang杂记"],"title":"golang-杂记","uri":"/posts/golang/%E6%9D%82%E8%AE%B0/"},{"categories":["Golang"],"content":"服务型应用 使用默认的http.DefaultServeMux：直接导入net/http/pprof自动帮你注册pprof路由 1 import _ \"net/http/pprof\" 自己的处理器Mux需要自己注册pprof路由 1 2 3 4 5 r.HandleFunc(\"/debug/pprof/\", pprof.Index) r.HandleFunc(\"/debug/pprof/cmdline\", pprof.Cmdline) r.HandleFunc(\"/debug/pprof/profile\", pprof.Profile) r.HandleFunc(\"/debug/pprof/symbol\", pprof.Symbol) r.HandleFunc(\"/debug/pprof/trace\", pprof.Trace) gin框架注册pprof路由： 1 pprof.Register(router) 运行应用后可以打开这些路由查看机器情况 /debug/pprof/profile：访问这个链接会自动进行 CPU profiling，持续 30s，并生成一个文件供下载 /debug/pprof/heap： Memory Profiling 的路径，访问这个链接会得到一个内存 Profiling 结果的文件 /debug/pprof/block：block Profiling 的路径 /debug/pprof/goroutines：运行的 goroutines 列表，以及调用关系 ","date":"2023-03-11","objectID":"/posts/golang/%E6%9D%82%E8%AE%B0/:5:2","tags":["golang杂记"],"title":"golang-杂记","uri":"/posts/golang/%E6%9D%82%E8%AE%B0/"},{"categories":["Golang"],"content":"go tool pprof命令 读取pprof文件，出现命令行交互界面 1 go tool pprof [binary] [source] topN 命令查看程序中占用CPU前3的函数 list 函数名 命令查看具体的函数分析 web 命令调用 graphviz 生成svg图片，需要安装graphviz， pdf 命令可以生成可视化的pdf文件 help 命令可以提供所有pprof支持的命令说明 ","date":"2023-03-11","objectID":"/posts/golang/%E6%9D%82%E8%AE%B0/:5:3","tags":["golang杂记"],"title":"golang-杂记","uri":"/posts/golang/%E6%9D%82%E8%AE%B0/"},{"categories":["Golang"],"content":"go-torch和火焰图 下载go-torch： 1 go get -v github.com/uber/go-torch 自行下载perl 下载FlameGraph，并将目录添加到PATH： 1 git clone https://github.com/brendangregg/FlameGraph.git windows需要修改go-torch/render/flamegraph.go的enerateFlameGraph 1 2 3 4 5 6 7 8 9 // GenerateFlameGraph runs the flamegraph script to generate a flame graph SVG. func GenerateFlameGraph(graphInput []byte, args ...string) ([]byte, error) { flameGraph := findInPath(flameGraphScripts) if flameGraph == \"\" { return nil, errNoPerlScript } if runtime.GOOS == \"windows\" { return runScript(\"perl\", append([]string{flameGraph}, args...), graphInput) } return runScript(flameGraph, args, graphInput) 然后安装 1 go install github.com/uber/go-torch ","date":"2023-03-11","objectID":"/posts/golang/%E6%9D%82%E8%AE%B0/:5:4","tags":["golang杂记"],"title":"golang-杂记","uri":"/posts/golang/%E6%9D%82%E8%AE%B0/"},{"categories":["Golang"],"content":"压测工具wrk 1 go install github.com/adjust/go-wrk ","date":"2023-03-11","objectID":"/posts/golang/%E6%9D%82%E8%AE%B0/:5:5","tags":["golang杂记"],"title":"golang-杂记","uri":"/posts/golang/%E6%9D%82%E8%AE%B0/"},{"categories":["Golang"],"content":"使用go-torch 压测 1 go-wrk -n 50000 http://127.0.0.1:8080/book/list 生成火焰图 1 go-torch -u http://127.0.0.1:8080 -t 30 火焰图的y轴表示cpu调用方法的先后，x轴表示方法调用时间 火焰图分析内存性能数据 1 2 3 4 go-torch -inuse_space http://127.0.0.1:8080/debug/pprof/heap go-torch -inuse_objects http://127.0.0.1:8080/debug/pprof/heap go-torch -alloc_space http://127.0.0.1:8080/debug/pprof/heap go-torch -alloc_objects http://127.0.0.1:8080/debug/pprof/heap ","date":"2023-03-11","objectID":"/posts/golang/%E6%9D%82%E8%AE%B0/:5:6","tags":["golang杂记"],"title":"golang-杂记","uri":"/posts/golang/%E6%9D%82%E8%AE%B0/"},{"categories":["Golang"],"content":"pprof与性能测试结合 go test 的-cpuprofile和-memprofile选项也会生成pprof文件 ","date":"2023-03-11","objectID":"/posts/golang/%E6%9D%82%E8%AE%B0/:5:7","tags":["golang杂记"],"title":"golang-杂记","uri":"/posts/golang/%E6%9D%82%E8%AE%B0/"},{"categories":["Golang"],"content":"GoGC CSDN smartaconf golang修养之路 ","date":"2023-03-11","objectID":"/posts/golang/%E6%9D%82%E8%AE%B0/:6:0","tags":["golang杂记"],"title":"golang-杂记","uri":"/posts/golang/%E6%9D%82%E8%AE%B0/"},{"categories":["Golang"],"content":"Go V1.3之前的标记-清除(mark and sweep)算法 暂停程序业务逻辑, 找出不可达的对象，然后做上标记，最后回收标记好的对象 需要程序暂停！即 STW(stop the world) ","date":"2023-03-11","objectID":"/posts/golang/%E6%9D%82%E8%AE%B0/:6:1","tags":["golang杂记"],"title":"golang-杂记","uri":"/posts/golang/%E6%9D%82%E8%AE%B0/"},{"categories":["Golang"],"content":"Go V1.5的三色并发标记法 ","date":"2023-03-11","objectID":"/posts/golang/%E6%9D%82%E8%AE%B0/:6:2","tags":["golang杂记"],"title":"golang-杂记","uri":"/posts/golang/%E6%9D%82%E8%AE%B0/"},{"categories":["Golang"],"content":"屏障机制 插入屏障：强三色不变式。对于堆空间，A对象引用B对象的时候，B对象被标记为灰色。对于栈空间，回收白色对象之前STW，然后三色标记扫描。 删除屏障：弱三色不变式。被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。这种方式的回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。 ","date":"2023-03-11","objectID":"/posts/golang/%E6%9D%82%E8%AE%B0/:6:3","tags":["golang杂记"],"title":"golang-杂记","uri":"/posts/golang/%E6%9D%82%E8%AE%B0/"},{"categories":["Golang"],"content":"Go V1.8的混合写屏障(hybrid write barrier)机制 弱三色不变式。屏障技术是不在栈上应用的，因为要保证栈的运行效率 GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW) GC期间，任何在栈上创建的新对象，均为黑色 被堆对象删除的堆对象标记为灰色 被堆对象添加的堆对象标记为灰色（包括已存在的对象） ","date":"2023-03-11","objectID":"/posts/golang/%E6%9D%82%E8%AE%B0/:6:4","tags":["golang杂记"],"title":"golang-杂记","uri":"/posts/golang/%E6%9D%82%E8%AE%B0/"},{"categories":["杂项"],"content":"保持窗口最前神器DeskPins DeskPins官网 windows下保持窗口最前是一个很常用的需求，但是windows并没有实现这个需求，只给了编程的api。 DeskPins是windows环境下一款轻量级的工具软件，让你能够随时选择某个窗口保持最前。 快捷键：ctrl+f12 ","date":"2023-03-10","objectID":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:1:0","tags":[],"title":"杂项-个人笔记","uri":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["杂项"],"content":"显卡驱动更新 记一次显卡驱动更新不规范导致的问题 事情起因是这样的，我一大早起来更新显卡驱动，更新过程中黑屏了，半天也没好，我就断电重启了，然后就再也开不了机。尝试诊断系统问题检查bios都没有发现问题。无奈只能求助客服。 客服一下子就判断出来应该是我开了直连显卡模式，然后在这个模式下更新显卡驱动，在更新过程中卸载掉旧的显卡驱动后直接导致机器失去显示输出设备，黑屏，相当于直接把显示器的数据线给拔掉了。 最终解决办法是客服让我在bios里面把显卡直连改成混合连接，重启电脑后再重新安装显卡驱动，之后就OK了。 以后更新显卡驱动首先开启混连模式再更新，规范操作。 ","date":"2023-03-10","objectID":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:2:0","tags":[],"title":"杂项-个人笔记","uri":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["杂项"],"content":"邮箱授权码 邮箱授权码用于使用smtp协议在不泄露邮箱密码的情况下发送邮件，一般编程语言都封装好了发送邮箱的包。 qq邮箱的授权码在设置=》账户=》POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务下，需要发送手机短信来获取授权码。 ","date":"2023-03-10","objectID":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:3:0","tags":[],"title":"杂项-个人笔记","uri":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["杂项"],"content":"抓包分析工具charles charles官网 charles 配置 zoukankan charles详解 charles是一个抓包和应用层信息分析工具。它跟wireshark作用类似。但是wireshark监听的是网卡，分析http层以下的包，charles监听的是端口，分析http及以上层的包 注意，当charles和v2rayN一起使用时，打开charles会将系统代理设置为charles的代理（默认使用8888端口），同时设置外部代理为v2ray的代理。相当于给v2ray和主机之间加了一层转发，在这层转发中可以进行抓包分析。 SSL代理让 Charles 可以用作中间人 HTTPS 代理，以纯文本形式查看 Web 浏览器和 SSL Web 服务器之间的通信。 charles的代理也分为socks代理和http代理 虚拟机访问需要设置proxy=》访问控制，将虚拟机地址或所在网段添加到允许列表中 虚拟机需要注意防火墙的问题 连接chales的虚拟机需要同时安装charles的证书 no cache阻止代理应用缓存内容，总是发送请求到服务区获取最新内容 charles开启系统代理时会记录之前的系统代理是啥，在关闭系统代理时还原之前的系统代理设置 ","date":"2023-03-10","objectID":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:4:0","tags":[],"title":"杂项-个人笔记","uri":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["杂项"],"content":"使用手机热点代理 查看手机ip地址，设置»关于手机»状态信息»ip地址 手机打开代理软件，然后电脑设置代理为该ip以及该软件的端口 ","date":"2023-03-10","objectID":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:5:0","tags":[],"title":"杂项-个人笔记","uri":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["杂项"],"content":"github搜索技巧 [github文档]（https://docs.github.com/cn） github文档搜索语法 github文档搜索仓库 github文档搜索排序 ","date":"2023-03-10","objectID":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:6:0","tags":[],"title":"杂项-个人笔记","uri":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["杂项"],"content":"github搜索技巧 常用关键字： in: size: stars: language: ","date":"2023-03-10","objectID":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:6:1","tags":[],"title":"杂项-个人笔记","uri":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["杂项"],"content":"github下载单个文件 CSDN battledao eternity 点击raw，然后ctrl+s保存 ","date":"2023-03-10","objectID":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:6:2","tags":[],"title":"杂项-个人笔记","uri":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["杂项"],"content":"clash clash github 官网 clash for windows github 官网 clash for windows github 文档 clash for windows 中文文档 clash for windows 汉化补丁 ","date":"2023-03-10","objectID":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:7:0","tags":[],"title":"杂项-个人笔记","uri":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["杂项"],"content":"ipv6服务安装 常规页面里面安装一下服务模式，另外还需要设置网卡开启ipv6协议 ","date":"2023-03-10","objectID":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:7:1","tags":[],"title":"杂项-个人笔记","uri":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["杂项"],"content":"分开设置http代理端口和socks5代理端口 点击常规里面的clash核心Premium页面，在设置里面进行设置，通常对于从使用v2ray转到clash的用户很有用 另外为了能够每次启动都自动配置可以修改配置文件 ","date":"2023-03-10","objectID":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:7:2","tags":[],"title":"杂项-个人笔记","uri":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["杂项"],"content":"配置文件位置 ~\\.config\\clash目录下的config.yml 用于添加配置，配置示例见官网文档 ","date":"2023-03-10","objectID":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:7:3","tags":[],"title":"杂项-个人笔记","uri":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["杂项"],"content":"代理的配置文件 有的时候代理的配置可能没有成功加载，这时候可以尝试点一下混合配置或者先选一下其他代理的配置再重新激活原来的代理。混合配置是在原来代理配置的基础上添加（js）或覆盖（yaml）新的配置。 添加新的规则使用js配置，可以使用的规则写法详见官方文档。根据官网文档可以这么写： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 module.exports.parse = async ( { content, name, url }, { axios, yaml, notify } ) =\u003e { const myRules = [ 'DOMAIN-SUFFIX,bilivideo.com,'+name, 'DOMAIN-SUFFIX,bilibili.com,'+name, 'PROCESS-NAME,BaiduNetdiskHost.exe'+name, 'PROCESS-NAME,Baidunetdisk.exe'+name, 'PROCESS-NAME,Baidunetdiskhost.exe'+name, 'PROCESS-NAME,DownloadSDKServer.exe'+name, 'PROCESS-NAME,Thunder.exe'+name, 'DOMAIN-KEYWORD,leigod,DIRECT', 'DOMAIN-KEYWORD,networktunnel_proxy.exe,DIRECT', ] const middleRules = content.rules.filter((item)=\u003e{ return item.indexOf('MATCH')==-1}) const endRules = [ 'MATCH,'+name, 'MATCH,DIRECT', ] const extra = { // dns: { // enable: true, // listen: \":53\", // nameserver: [\"8.8.8.8\"], // }, rules: [...myRules, ...middleRules, endRules[0]] }; return { ...content, ...extra }; }; ","date":"2023-03-10","objectID":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:7:4","tags":[],"title":"杂项-个人笔记","uri":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["杂项"],"content":"坑 当很多节点超时的时候可能是时间对不上，时间对不上服务器不会处理请求，重新自动设置一下时间就好了 ","date":"2023-03-10","objectID":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:7:5","tags":[],"title":"杂项-个人笔记","uri":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["杂项"],"content":"steam ","date":"2023-03-10","objectID":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:8:0","tags":[],"title":"杂项-个人笔记","uri":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["杂项"],"content":"steam下载技巧 最近发现wallpaper取消订阅后没有自定删除本地文件，自己删除后还会重新下载之前已经取消订阅的壁纸。因为我是拷贝我之前电脑上的steamLib库到新电脑上，所以破坏了下载缓存。 解决方法是直接在设置页面的下载选项页里面点击清除下载缓存即可恢复。 另外在下载的过程中如果发现下载速度很慢，可能是你选择了较远的下载服务器这个也可以在该页面进行修改为离自己更近的服务器。 ","date":"2023-03-10","objectID":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:8:1","tags":[],"title":"杂项-个人笔记","uri":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["杂项"],"content":"steam组变换csgoid bilibili Arguan阿关 很简单，在steam里面自己添加组 然后在csgo控制台将按键绑定原命令加上\"cl_clanid 组id;“就可以在按下按键的时候显示设置的组id ","date":"2023-03-10","objectID":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:8:2","tags":[],"title":"杂项-个人笔记","uri":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["杂项"],"content":"voicemeeter 推荐一个开源免费的混音软件voicemeeter，功能非常强大。 官网地址 b站Up主Ultronxr分享的笔记 明确声音仅仅包括频率（HZ）和响度（dB），这里补充几个配置的知识点： 物理输入设备的配置：Comp可以理解为将声音响度按比例放大，Gate可以理解为过滤调响度小于值的部分声音。INTELLIPAN面板POSITION中的点表示音源位置；VOICE中的点表示按频率增加响度，横坐标是声音频率，纵坐标是响度调解；MODULATION中的点是合声效应Chorus effect不太懂。mono设置单声道，solo静音其他输入设备，Mute静音该设备 虚拟输入设备上面的三个圆圈从上到下分别可以增加或减少高音中音和低音的响度，下面的小框和1中的POSOTION一样，表示音源位置 物理虚拟输出设备上面分别有输出模式，mono单声道设置，EQ过滤器设置和Mute静音设置。具体说一下EQ过滤器设置，右键单击它弹出的图里面横坐标表示频率纵坐标表示响度增量，可以添加过滤器进行修改三个圈分别是过滤器部署的HZ，增量分贝数还有过滤器梯度。 ","date":"2023-03-10","objectID":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:9:0","tags":[],"title":"杂项-个人笔记","uri":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["杂项"],"content":"坑 设备设置静音 由于voicemeter是在系统和输入输出设备之间添加了一层，但是如果你的输出设备本身的设置是静音那么也没办法，即你将windows的输出设备（桌面任务栏里面的小喇叭）设置为耳机，然后将其静音，最后再把输出设备设置为voicemeter VAIO，虽然voicemeter将系统输出传给了耳机但是耳机设置静音，所以你也听不到声音。 声音不保真 断开蓝牙再重新连接 ","date":"2023-03-10","objectID":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:9:1","tags":[],"title":"杂项-个人笔记","uri":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["杂项"],"content":"ipv6地址 ipv6的地址和网关配置与ipv4是一致的 可以通过python的scapy库的conf.route和conf.route6来查看本地的ipv6路由设置 当你的ipv6被网关禁了时，可以自己修改ipv6地址 dns也是和ipv4一致的，热门ipv6 dns 阿里:2400:3200::1 阿里:2400:3200:baba::1 百度:2400:da00::6666 ","date":"2023-03-10","objectID":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:10:0","tags":[],"title":"杂项-个人笔记","uri":"/posts/%E6%9D%82%E9%A1%B9/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["机器学习"],"content":"pytorch官网 pytorch教程 ","date":"2023-03-09","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch/:0:0","tags":["深度学习"],"title":"机器学习-深度学习-Pytorch","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch/"},{"categories":["机器学习"],"content":"教程 ","date":"2023-03-09","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch/:1:0","tags":["深度学习"],"title":"机器学习-深度学习-Pytorch","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch/"},{"categories":["机器学习"],"content":"tensors张量 张量是一种特殊的数据结构，与数组和矩阵非常相似 使用张量对模型的输入和输出以及模型的参数进行编码 导入张量 1 import torch 初始化张量 直接来自已有数据:x_data = torch.tensor([[1, 2],[3, 4]]) 来自 NumPy 数组（也可以转换成NumPy数组）: 1 2 np_array = np.array(data) x_np = torch.from_numpy(np_array) 从另一个张量（除非明确覆盖，否则新张量保留参数张量的属性（形状、数据类型））: 1 2 x_ones = torch.ones_like(x_data) # retains the properties of x_data x_rand = torch.rand_like(x_data, dtype=torch.float) # overrides the datatype of x_data 使用随机值或常数值 shape是张量维度的元组:shape = (2,3,) 1 2 3 4 shape = (2,3,) rand_tensor = torch.rand(shape) ones_tensor = torch.ones(shape) zeros_tensor = torch.zeros(shape) 张量的属性 张量属性描述了它们的形状、数据类型和存储它们的设备 1 2 3 4 tensor = torch.rand(3,4) print(f\"Shape of tensor: {tensor.shape}\") print(f\"Datatype of tensor: {tensor.dtype}\") print(f\"Device tensor is stored on: {tensor.device}\") 张量运算 所有的运算方式见官网文档 默认情况下，张量是在 CPU 上创建的，使用.to方法将张量显式移动到 GPU 1 2 if torch.cuda.is_available(): tensor = tensor.to(\"cuda\") 标准的类似 numpy 的索引和切片： 1 2 3 4 5 6 tensor = torch.ones(4, 4) print(f\"First row: {tensor[0]}\") print(f\"First column: {tensor[:, 0]}\") print(f\"Last column: {tensor[..., -1]}\") tensor[:,1] = 0 print(tensor) torch.cat沿给定维度连接一系列张量 1 t1 = torch.cat([tensor, tensor, tensor], dim=1) 算术运算 单元素张量:使用聚合函数获取聚合值对象，然后使用聚合值对象的item()方法转换为python数值 1 2 3 agg = tensor.sum() agg_item = agg.item() print(agg_item, type(agg_item)) 就地操作:将结果存储到操作数中的操作称为就地操作，这个方法会改变原张量，方法名以_符结尾 1 tensor.add_(5) 会立即丢失历史记录，求导数可能会出问题，不鼓励使用 桥接 NumPy 张量的numpy方法转换为 NumPy 数组，这种转换类似于传指针，对张量的改变会等价改变numpy数组 1 2 t = torch.ones(5) n = t.numpy() NumPy 数组到 Tensor，对numpy数组的改变会等价改变张量 1 2 n = np.ones(5) t = torch.from_numpy(n) ","date":"2023-03-09","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch/:1:1","tags":["深度学习"],"title":"机器学习-深度学习-Pytorch","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch/"},{"categories":["机器学习"],"content":"数据集和数据加载器 实现一个数据集类： __init__, __len__, 和 __getitem__ 方法 ","date":"2023-03-09","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch/:1:2","tags":["深度学习"],"title":"机器学习-深度学习-Pytorch","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch/"},{"categories":["机器学习"],"content":"Transforms变换 使用Transform对数据进行一些操作，使其适合训练。 ToTensor():将 PIL 图像或 NumPy 转换ndarray为FloatTensor. 并在 [0., 1.] 范围内缩放图像的像素强度值 Lambda 转换:Lambda 转换应用任何用户定义的 lambda 函数 ","date":"2023-03-09","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch/:1:3","tags":["深度学习"],"title":"机器学习-深度学习-Pytorch","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch/"},{"categories":["机器学习"],"content":"构建神经网络 神经网络由对数据执行操作的层/模块组成。torch.nn命名空间提供了构建自己的神经网络所需的所有构建块。 PyTorch 中的每个模块都是nn.Module 的子类。 神经网络本身就是一个由其他模块（层）组成的模块。 设置训练设备 检查 torch.cuda 是否可用，不可用使用 CPU 1 device = \"cuda\" if torch.cuda.is_available() else \"cpu\" 定义类 通过子类化nn.Module来定义神经网络，在 __init__ 方法中初始化神经网络层，在 forward 方法中实现对输入数据的操作，比如下面的NeuralNetwork类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class NeuralNetwork(nn.Module): def __init__(self): super().__init__() self.flatten = nn.Flatten() self.linear_relu_stack = nn.Sequential( nn.Linear(28*28, 512), nn.ReLU(), nn.Linear(512, 512), nn.ReLU(), nn.Linear(512, 10), ) def forward(self, x): x = self.flatten(x) logits = self.linear_relu_stack(x) return logits 创建 NeuralNetwork 实例，并将其移动到device 1 model = NeuralNetwork().to(device) 使用该模型只需将输入数据传递给它（使用__Call__方法），不要直接调用forward方法 1 2 3 4 5 6 X = torch.rand(1, 28, 28, device=device) ## 直接调用__Call__方法 logits = model(X) pred_probab = nn.Softmax(dim=1)(logits) y_pred = pred_probab.argmax(1) print(f\"Predicted class: {y_pred}\") 模型层 分解 FashionMNIST 模型中的层，这里取3张28*28的图像 1 input_image = torch.rand(3,28,28)# [3, 28, 28] nn.Flatten 将每个 2D 28x28 图像转换为 784 个像素值的连续数组 1 2 flatten = nn.Flatten() flat_image = flatten(input_image)# [3, 784] nn.Linear 使用其存储的权重和偏差对输入应用线性变换 1 2 layer1 = nn.Linear(in_features=28*28, out_features=20) hidden1 = layer1(flat_image)# [3, 20] nn.ReLU 在线性变换之后应用以引入非线性，帮助神经网络学习各种各样的现象 1 hidden1 = nn.ReLU()(hidden1) nn.Sequential nn.Sequential是一个有序的模块容器，按照定义的相同顺序通过所有模块 1 2 3 4 5 6 7 8 seq_modules = nn.Sequential( flatten, layer1, nn.ReLU(), nn.Linear(20, 10) ) input_image = torch.rand(3,28,28) logits = seq_modules(input_image) nn.Softmax logits中值范围为[-infty, infty]，nn.Softmax将其缩放为值 [0, 1]，表示模型对每个类的预测概率，dim参数表示值总和必须为 1 的维度 1 2 softmax = nn.Softmax(dim=1) pred_probab = softmax(logits) 模型参数 神经网络中的许多层都是参数化的，即具有在训练期间优化的相关权重和阈值。通过parameters()或named_parameters()方法访问 1 2 for name, param in model.named_parameters(): print(f\"Layer: {name} | Size: {param.size()} | Values : {param[:2]} \\n\") ","date":"2023-03-09","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch/:1:4","tags":["深度学习"],"title":"机器学习-深度学习-Pytorch","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch/"},{"categories":["机器学习"],"content":"自动微分TORCH.AUTOGRAD 反向传播:根据损失函数相对于给定参数的梯度进行调整 torch.autograd支持自动计算任何计算图的梯度 例子\r1 2 3 4 5 6 7 8 import torch x = torch.ones(5) # input tensor y = torch.zeros(3) # expected output w = torch.randn(5, 3, requires_grad=True) b = torch.randn(3, requires_grad=True) z = torch.matmul(x, w)+b loss = torch.nn.functional.binary_cross_entropy_with_logits(z, y) w和b是我们需要优化的参数，计算损失函数关于这些参数的的梯度，为此设置这些参数张量的requires_grad属性（定义张量时设置该属性为true或后面使用requires_grad_(True)方法设置） 张量的grad_fn属性为反向传播函数的引用 计算梯度 调用backward方法，当进行第二次以上重复调用时添加retain_graph=True参数给backward方法，而且多次重复调用会将结果累加，所以第二次以上调用时需要先将参数张量的grad属性归零 然后就可以检查设置了requires_grad为true的参数张量的grad属性，里面存储了计算的梯度 1 2 3 loss.backward() print(w.grad) print(b.grad) 禁用梯度跟踪 对requires_grad=True的参数张量只进行正向计算不进行反向传播 使用with torch.no_grad():块包围计算代码 1 2 3 with torch.no_grad(): z = torch.matmul(x, w)+b print(z.requires_grad) 使用张量的detach方法的返回值 1 z_det = z.detach() 它的requires_grad为false 有关计算图的更多信息 正向传递： 运行请求的操作来计算结果张量 在 DAG 中维护操作的梯度函数 DAG根上执行backward方法执行反向传播： 根据grad_fn属性计算梯度 将结果存储在参数张量的grad属性中 使用链式法则，一直传播到叶张量 ","date":"2023-03-09","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch/:1:5","tags":["深度学习"],"title":"机器学习-深度学习-Pytorch","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch/"},{"categories":["机器学习"],"content":"优化模型参数 训练模型是一个迭代过程；在每次迭代中，模型对输出进行猜测，计算其猜测中的误差（损失），收集关于其参数的误差的导数（如我们在上一节中看到的），并使用梯度下降优化这些参数. 超参数 超参数是可调整的参数，可让您控制模型优化过程。不同的超参数值会影响模型训练和收敛速度 Number of Epochs：迭代数据集的次数 Batch Size：参数更新前通过网络传播的数据样本数量 Learning Rate：每个Batch/Epoch更新模型参数的步长。较小学习速度较慢的，较大可能会导致训练期间出现不可预测的行为 1 2 3 learning_rate = 1e-3 batch_size = 64 epochs = 5 优化循环 优化循环的每次迭代称为一个epoch 每个epoch由两个主要部分组成： The Train Loop：迭代训练数据集并尝试收敛到最佳参数 The Validation/Test Loop：遍历测试数据集以检查模型性能是否正在提高 损失函数 损失函数衡量的是得到的结果与目标值的相异程度，训练目标是最小化的损失函数 使用给定数据样本的输入进行预测，损失函数将结果与真实数据标签值进行比较 常见的损失函数包括用于回归任务的nn.MSELoss（均方误差）和 用于分类的nn.NLLLoss（负对数似然）。nn.CrossEntropyLoss结合了nn.LogSoftmax和nn.NLLLoss 将模型的输出 logits 传递给nn.CrossEntropyLoss，这将标准化 logits 并计算预测误差 1 2 # Initialize the loss function loss_fn = nn.CrossEntropyLoss() 优化器 优化算法（如SGD随机梯度下降，ADAM 和 RMSProp）定义了这个过程是如何执行的。所有优化逻辑都封装在optimizer对象中。 1 optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate) 训练循环中，优化分三步进行 调用optimizer.zero_grad()方法重置模型参数的梯度 调用loss.backward()方法反向传播预测损失 调用optimizer.step()方法通过反向传播的梯度调整参数张量 ","date":"2023-03-09","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch/:1:6","tags":["深度学习"],"title":"机器学习-深度学习-Pytorch","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch/"},{"categories":["机器学习"],"content":"保存和加载模型 保存和加载模型权重 torch.save函数保存张量的信息，可以只保存参数（model的state_dict方法），也可以保存包括形状的所有信息（依赖于pickle模块） 1 2 3 4 5 model = models.vgg16(pretrained=True) # 保存参数信息 torch.save(model.state_dict(), 'model_weights.pth') # 保存整个模型 torch.save(model, 'model.pth') 使用model.load_state_dict()方法加载模型参数，使用torch.load函数加载整个模型 1 2 3 4 5 6 # 加载参数，运行推理之前，您必须调用model.eval()以将 dropout 和 batch normalization 层设置为评估模式 model = models.vgg16() # we do not specify pretrained=True, i.e. do not load default weights model.load_state_dict(torch.load('model_weights.pth')) model.eval() # 加载整个模型 model = torch.load('model.pth') ","date":"2023-03-09","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch/:1:7","tags":["深度学习"],"title":"机器学习-深度学习-Pytorch","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch/"},{"categories":["Python"],"content":"PYPI官网 pandas官网 pandas API文档 pandas 提供快速、灵活和富有表现力的数据结构，旨在使处理“关系”或“标记”数据简单又直观 ","date":"2023-03-05","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/:0:0","tags":["Python第三方库"],"title":"Python-第三方库-Pandas","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/"},{"categories":["Python"],"content":"安装 anaconda 1 conda install pandas pip 1 pip install pandas ","date":"2023-03-05","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/:1:0","tags":["Python第三方库"],"title":"Python-第三方库-Pandas","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/"},{"categories":["Python"],"content":"常用函数 pd.DataFrame():创建df pd.concat():合并两个结构相似的表 pd.merge():连接两个表，on参数指定参照的key，how参数选择连接方式 pd.to_datetime():将字符串Series转换为datetime对象Series，该类型为DatetimeIndex pd.read_xxx():读取xxx类型文件并返回df，parse_dates参数进行datetime对象列的转换 ","date":"2023-03-05","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/:2:0","tags":["Python第三方库"],"title":"Python-第三方库-Pandas","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/"},{"categories":["Python"],"content":"数据类型 ","date":"2023-03-05","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/:3:0","tags":["Python第三方库"],"title":"Python-第三方库-Pandas","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/"},{"categories":["Python"],"content":"dataframe和series（单列的df）方法： describe():对数值列进行统计并返回dataframe，百分号为百分位数 max():获取最大值 count():行数 mean():平均值 std():方差 min():最小值 pivot():重塑df，以选择一列的值作为新df的列名，colume参数选择选择的列，values参数设置默认值，index选择索引（没有index则使用原表的index） reset_index():添加新的索引列，id_vars参数指定新df的索引列 pivot_table():和pivot类似，但是该方法统计聚合值 head():返回前N行的df tail():返回最后N行的df to_xxx():将df转换为xxx类型文件 isin():转换Series为布尔Series，值包含在其中的行为True，否则为False notna():转换Series为布尔Series，值不为None则为True，否则为False plot():生成plot绘图对象，之后可以使用matplotlib.pyplot.show()显式结果 rename():修改列名 agg():给出列名和对于列要统计的聚合量，返回df groupby():按给定列的不同值进行分组，返回DataframeGroupby对象，该对象拥有和pd类似的方法和运算符 value_counts():给定列统计不同值的行数，返回df info():查看技术信息 set_index():设置索引列 resample():具有DatetimeIndex对象列的df的方法，按给定频率将时间索引进行分组，后面可以使用聚合函数来获取聚合值 idxmax():返回Series中最大值所在行的索引值 replace():使用to_replace参数的字典对行进行替换，返回df 属性 dtypes:返回每列的类型的df plot:plot画图属性，返回PlotAccessor对象 str:对列的文本值进行操作的对象，返回StringMethod对象 运算符： 加减乘除和逻辑运算 []:读取特定列返回df，作为左值时修改原df loc[]:根据传入布尔Series过滤行并选择列返回df，作为左值时修改原df iloc[]:直接传入行数和列数返回df，作为左值时修改原df ","date":"2023-03-05","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/:3:1","tags":["Python第三方库"],"title":"Python-第三方库-Pandas","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/"},{"categories":["Python"],"content":"PlotAccessor 方法 xxx():画出xxx图，后面可以用matplotlib.pyplot.show()显式结果，比如scatter，box等，详见文档 ","date":"2023-03-05","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/:3:2","tags":["Python第三方库"],"title":"Python-第三方库-Pandas","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/"},{"categories":["Python"],"content":"datetime 属性 dt:通过该属性访问year，month等具体信息，这些信息可以用于给原df分组groupby ","date":"2023-03-05","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/:3:3","tags":["Python第三方库"],"title":"Python-第三方库-Pandas","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/"},{"categories":["Python"],"content":"DatetimeIndex 方法：具有和df类似的方法 ","date":"2023-03-05","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/:3:4","tags":["Python第三方库"],"title":"Python-第三方库-Pandas","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/"},{"categories":["Python"],"content":"DatetimeIndexResampler 方法：具有和df类似的方法 属性： freq：分组频率 ","date":"2023-03-05","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/:3:5","tags":["Python第三方库"],"title":"Python-第三方库-Pandas","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/"},{"categories":["Python"],"content":"StringMethod 方法 lower():转换为小写 split():按pat参数指定的字符串分割每行的值，返回Series get():获取每行第n个元素，返回Series contains():判断每行是否包含pat参数的字符串，返回布尔Series len():返回每行的长度，返回Series ","date":"2023-03-05","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/:3:6","tags":["Python第三方库"],"title":"Python-第三方库-Pandas","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/"},{"categories":["Python"],"content":"入门教程 ","date":"2023-03-05","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/:4:0","tags":["Python第三方库"],"title":"Python-第三方库-Pandas","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/"},{"categories":["Python"],"content":"处理的数据类型 1 import pandas as pd DataFrame DataFrame\r1 2 3 4 5 6 7 8 9 10 11 df = pd.DataFrame( { \"Name\": [ \"Braund, Mr. Owen Harris\", \"Allen, Mr. William Henry\", \"Bonnell, Miss. Elizabeth\", ], \"Age\": [22, 35, 58], \"Sex\": [\"male\", \"male\", \"female\"], } ) DataFrame是一种二维数据结构，可以在列中存储不同类型的数据（包括字符、整数、浮点值、分类数据等），类似于excel 使用下标访问Series列 1 df[\"Age\"] Series\rSeries也可以创建 1 ages = pd.Series([22, 35, 58], name=\"Age\") 许多 pandas 操作返回 DataFrame 或 Series 常用方法，更多详见文档 ","date":"2023-03-05","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/:4:1","tags":["Python第三方库"],"title":"Python-第三方库-Pandas","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/"},{"categories":["Python"],"content":"如何读取和写入表格数据 Series\rread_xxx()函数读取xxx类型文件并返回DataFrame，如read_csv()函数读取csv文件并返回DataFrame，其他的还有csv、excel、sql、json、parquet 等 1 titanic = pd.read_csv(\"data/titanic.csv\") to_xxx()函数存储DataFrame为xxx类型文件 1 titanic.to_excel(\"titanic.xlsx\", sheet_name=\"passengers\", index=False) df.head(N)方法查看df的前N行，df.tail(N)方法查看df的最后N行 1 2 titanic.head(8) titanic.tail(10) df.types属性查看每列的数据类型 1 titanic.dtypes df.info()方法查看df的技术信息 1 titanic.info() ","date":"2023-03-05","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/:4:2","tags":["Python第三方库"],"title":"Python-第三方库-Pandas","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/"},{"categories":["Python"],"content":"如何选择 df 的子集 选择列\r使用[]选择单个列，返回Series对象，或选择多个列的列表，返回df对象 df.shape属性返回一个元组，包含行数和列数，series.shape属性返回只包含行数的元组 1 age_sex = titanic[[\"Age\", \"Sex\"]] 传入[]布尔值Series过滤特定行 1 above_35 = titanic[titanic[\"Age\"] \u003e 35] 过滤行\r除了比较运算符还可以用来生成布尔Series的函数 isin([…]):值含于列表中 notna():值不为None 1 class_23 = titanic[titanic[\"Pclass\"].isin([2, 3])] 布尔值Series之间可以进行逻辑运算 1 class_23 = titanic[(titanic[\"Pclass\"] == 2) | (titanic[\"Pclass\"] == 3)] 选择特定行和列\r在[]前面添加loc运算符，第一个参数是行过滤条件，第二个参数是选择的列 1 adult_names = titanic.loc[titanic[\"Age\"] \u003e 35, \"Name\"] 还可以使用iloc函数直接指定行数和列数 1 titanic.iloc[9:25, 2:5] 使用loc和iloc选择单列时可以直接赋值 1 titanic.iloc[0:3, 3] = \"anonymous\" ","date":"2023-03-05","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/:4:3","tags":["Python第三方库"],"title":"Python-第三方库-Pandas","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/"},{"categories":["Python"],"content":"如何创建plot绘图 plot绘图\r1 2 import pandas as pd import matplotlib.pyplot as plt 读取csv文件并设置索引列参数index_col，这里索引列是date类型，所以需要参数parse_dates为true转换一下 1 air_quality = pd.read_csv(\"air_quality_no2.csv\", index_col=0, parse_dates=True) 创建plot对象，然后展示plot对象 1 2 air_quality.plot() plt.show() df.plot.scatter方法比较两个列的散点图，参数x和参数y选择列名， 1 2 air_quality.plot.scatter(x=\"station_london\", y=\"station_paris\", alpha=0.5) plt.show() df.plot.box方法画箱线图 1 2 air_quality.plot.box() plt.show() 除了scatter和box还有很多其他的图，比如箱线图，详见文档 df.plot.area画堆积面积图，figsize为一个二元组表示图表的长和宽，参数subplots将每一列单独放到一个图中，其他图也可以使用这两个参数，类似参数详见文档 1 2 air_quality.plot.area(figsize=(12, 4), subplots=True) plt.show() pandas 创建的每个绘图对象都是一个 Matplotlib 对象 ","date":"2023-03-05","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/:4:4","tags":["Python第三方库"],"title":"Python-第三方库-Pandas","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/"},{"categories":["Python"],"content":"从现有列派生的新列 派生新列\r给[]传入新列名称并赋值，可以直接用一个Series进行运算的结果赋值 1 air_quality[\"london_mg_per_cubic\"] = air_quality[\"station_london\"] * 1.882 可以直接将Series加减乘除一个值或逻辑运算，会给每一个元素进行这样的运算，Series之间也可以进行加减乘除运算或逻辑运算，会逐个对应元素进行运算。如果需要更高级的逻辑可以使用apply方法 1 air_quality[\"ratio_paris_antwerp\"] = air_quality[\"station_paris\"] / air_quality[\"station_antwerp\"] rename方法重命名列标签，未重命名的列保持原名 1 2 3 4 5 6 7 8 9 air_quality_renamed = air_quality.rename( columns={ \"station_antwerp\": \"BETR801\", \"station_paris\": \"FR04014\", \"station_london\": \"London Westminster\", } ) air_quality_renamed.plot() plt.show() 还可以使用函数来重命名映射，如str.lower将名称转换为小写 1 2 air_quality_renamed = air_quality_renamed.rename(columns=str.lower) air_quality_renamed.head() ","date":"2023-03-05","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/:4:5","tags":["Python第三方库"],"title":"Python-第三方库-Pandas","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/"},{"categories":["Python"],"content":"计算汇总统计量 聚合统计 DataFrame.agg方法定义给定列的聚合统计信息的特定组合，更多聚合统计信息见文档 1 2 3 4 5 6 titanic.agg( { \"Age\": [\"min\", \"max\", \"median\", \"skew\"], \"Fare\": [\"min\", \"max\", \"median\", \"mean\"], } ) 返回以键为列名，所有值列表的并集为index索引的dataframe groupby\rgroupby方法将dataframe按指定列的值分组，然后可以给每一组求聚合统计信息，分组也拥有df的几乎所有方法 1 titanic[[\"Sex\", \"Age\"]].groupby(\"Sex\").mean() 返回以选择的列名为返回值的列明，groupby列不同值为索引的dataframe 整个过程为： 将数据分组 将函数独立应用于每个组 将结果组合成数据结构 也可以先分组再选择列 1 titanic.groupby([\"Sex\", \"Pclass\"])[\"Fare\"].mean() 可以选择多个列进行分组 1 titanic.groupby([\"Sex\", \"Pclass\"])[\"Fare\"].mean() groupby文档详解 value_counts方法统计每种值的行数，其实是分组操作的组合，常用于离散化 1 2 3 titanic[\"Pclass\"].value_counts() # 等价于 titanic.groupby(\"Pclass\")[\"Pclass\"].count() ","date":"2023-03-05","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/:4:6","tags":["Python第三方库"],"title":"Python-第三方库-Pandas","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/"},{"categories":["Python"],"content":"重塑dataframe的布局 df.sort_values方法排序行，by参数选择排序依据的列，ascending参数确定是否升序排列，默认升序。排序详细内容文档 1 titanic.sort_values(by=['Pclass', 'Age'], ascending=False).head() 前面如何选择df子集，可以传入布尔值df来取子集 1 no2 = air_quality[air_quality[\"parameter\"] == \"no2\"] pivot\rpivot()方法重塑df，以选择的列的不同值为新df的列，colume参数为选择的列，values参数设置默认值，index选择索引（没有index则使用原表的index，修改index后会表格会取平均值），更多详见官网文档 reset_index()方法将添加新的索引列 1 no2_pivoted = no2.pivot(columns=\"location\", values=\"value\").reset_index() melt\rmelt()方法与pivot()方法相反的转换，id_vars参数指定新df的索引列 1 no_2 = no2_pivoted.melt(id_vars=\"date.utc\") pivot方法只是将数据重新排列多个值将出现多个索引值，列聚合值可以使用pivot_table()方法，它多了一个aggfunc参数标记聚合值，将margins参数设为True时会统计边际总和值 1 2 3 air_quality.pivot_table( values=\"value\", index=\"location\", columns=\"parameter\", aggfunc=\"mean\" ) ","date":"2023-03-05","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/:4:7","tags":["Python第三方库"],"title":"Python-第三方库-Pandas","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/"},{"categories":["Python"],"content":"如何合并多个表的数据 concat函数合并两个结构相似的df 1 pd.concat([air_quality_pm25, air_quality_no2], axis=0) merge函数根据on参数连接两个df，how参数选择连接方式，可以选择内连接，外连接和左右连接 1 air_quality = pd.merge(air_quality, stations_coord, how=\"left\", on=\"location\") ","date":"2023-03-05","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/:4:8","tags":["Python第三方库"],"title":"Python-第三方库-Pandas","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/"},{"categories":["Python"],"content":"如何轻松处理时间序列数据 to_datetime函数将字符串Series转换为datetime对象列，该对象为DatetimeIndex 1 air_quality[\"datetime\"] = pd.to_datetime(air_quality[\"datetime\"]) 另外在read_csv函数中添加parse_dates参数可以在读取文件时顺便转换 1 pd.read_csv(\"../data/air_quality_no2_long.csv\", parse_dates=[\"datetime\"]) datetime对象的dt属性访问详细日期信息，且该信息可以像df中的普通列一样进行分组groupby 1 2 3 air_quality[\"month\"] = air_quality[\"datetime\"].dt.month # 用于分组 air_quality.groupby([air_quality[\"datetime\"].dt.weekday, \"location\"])[\"value\"].mean() 索引为datetime对象时可以不通过dt属性，而使用index属性来访问内部时间信息 1 no_2.index.year, no_2.index.weekday resample方法按给定频率将时间索引进行分组，结果时DatetimeIndexResampler对象，它后面可以使用聚合函数来获取聚合值 1 monthly_max = no_2.resample(\"M\").max() ","date":"2023-03-05","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/:4:9","tags":["Python第三方库"],"title":"Python-第三方库-Pandas","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/"},{"categories":["Python"],"content":"如何操作文本数据 通过列的str属性来访问StringMethod对象的文本方法 lower()方法转换为小写 1 titanic[\"Name\"].str.lower() split()方法按pat参数指定的字符串分割每行的值，返回Series 1 titanic[\"Name\"].str.split(\",\") get()方法获取每行第n个元素，返回Series 1 titanic[\"Surname\"] = titanic[\"Name\"].str.split(\",\").str.get(0) contains()方法判断每行是否包含pat参数的字符串，返回布尔Series 1 titanic[\"Name\"].str.contains(\"Countess\") len()方法返回每行的长度，返回Series 1 titanic[\"Name\"].str.len() Series.idxmax()方法返回最大值所在行的索引值 1 titanic[\"Name\"].str.len().idxmax() Series.replace()方法使用to_replace参数的字典对行进行替换 1 titanic[\"Sex_short\"] = titanic[\"Sex\"].replace({\"male\": \"M\", \"female\": \"F\"}) ","date":"2023-03-05","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/:4:10","tags":["Python第三方库"],"title":"Python-第三方库-Pandas","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/pandas/"},{"categories":["Python"],"content":"PYPI官网 numpy官网 numpy官方教程 numpy官网API文档 本文中的np表示numpy包的别名 NumPy 是 Python 中科学计算的基础包。提供多维数组对象、各种派生对象（例如掩码数组和矩阵）以及用于对数组进行快速操作的各种例程，包括数学、逻辑、形状操作、排序、选择、I/O 、离散傅里叶变换、基本线性代数、基本统计运算、随机模拟等等。 NumPy 包的核心是ndarray对象。这封装了同构数据类型的n维数组，许多操作在编译代码中执行以提高性能。 NumPy 数组和标准 Python 序列之间有几个重要的区别： 更改ndarray的大小将创建一个新数组并删除原始数组 NumPy 数组中的元素都需要具有相同的数据类型 NumPy 数组有助于对大量数据进行高级数学运算和其他类型的运算 ","date":"2023-03-04","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/numpy/:0:0","tags":["Python第三方库"],"title":"Python-第三方库-Numpy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/numpy/"},{"categories":["Python"],"content":"安装 conda 1 conda install numpy pip 1 pip install numpy ","date":"2023-03-04","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/numpy/:1:0","tags":["Python第三方库"],"title":"Python-第三方库-Numpy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/numpy/"},{"categories":["Python"],"content":"基础用法 ","date":"2023-03-04","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/numpy/:2:0","tags":["Python第三方库"],"title":"Python-第三方库-Numpy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/numpy/"},{"categories":["Python"],"content":"绝对基础 类型 ndarray ndim:轴数或维数 size:元素的总数 shape:每个维度存储的元素数元组 T:转置 flat:返回一个元素迭代器 base:值为None表示副本，否则为视图，且该值为原数组 常用函数 np.expand_dims():指定索引位置来插入维度 1 2 b = np.expand_dims(a, axis=0) # (1,6) c = np.expand_dims(a, axis=1) # (6,1) np.array():创建数组 np.unique():找到数组中的唯一元素 flip():选择维度反转元素 flatten():创建一个新的一维数组，里面是原数组的元素 ravel():将原数组转换为一维数组 save():数组保存为npy文件 load():导入npy文件的数组 savetxt():数组保存为csv文件 loadtxt():导入csv文件的数组 常用方法 ndarray reshape():重塑数组的形状，重塑的形状元素个数需要保证不变 sum():返回指定维度(axis命名参数)或全部数组元素的总和 min():最小值 max():最大值 mean():平均值 prod():乘积 transpose():根据指定的值来反转或更改数组的轴 copy():新建一个副本 运算符 数组支持加减乘除 其他常用类型 np.newaxis函数用于当前位置添加一个维度 1 2 3 a = np.array([1, 2, 3, 4, 5, 6]) row_vector = a[np.newaxis, :] # (1,6) col_vector = a[:, np.newaxis] # (6,1) ","date":"2023-03-04","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/numpy/:2:1","tags":["Python第三方库"],"title":"Python-第三方库-Numpy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/numpy/"},{"categories":["Python"],"content":"数组创建 创建数组有 6 种方法（这里列举的函数和方法都只是一部分，全部函数和方法见官网API文档）： 从其他 Python 结构（即列表和元组）转换：numpy.array函数，dtype定义数组元素类型比如numpy.int8类型 内在的 NumPy 数组创建函数： 一维数组： numpy.arange()：指定步长 numpy.linspace()：指定元素个数 二维数组： numpy.eye()：二维单位矩阵 numpy.diag()：指定对角线和对角线元素的方形数组 数组： numpy.ones()：全1数组 numpy.zeros()：全0数组 random.Generator.random()：[0.0, 1.0) 随机浮点数填充数组 复制、加入或改变现有数组： numpy.copy()：拷贝一份数组，直接复制给另一个变量使用的仍然是同一个数组 numpy.vstack()：纵向堆叠数组，N为数组元素个数则生成一个[1,N]的数组 numpy.hstack()：组合多个数组，按块的方式堆叠 从磁盘读取数组，无论是标准格式还是自定义格式 numpy.loadtxt()：导入逗号分隔值 (csv) 和制表符分隔值 (tsv) 的文本文件 numpy.genfromtxt()：从文本文件加载数据，可以指定默认值 通过使用字符串或缓冲区从原始字节创建数组 使用其他库的函数（例如，SciPy、Pandas 和 OpenCV） ","date":"2023-03-04","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/numpy/:2:2","tags":["Python第三方库"],"title":"Python-第三方库-Numpy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/numpy/"},{"categories":["Python"],"content":"索引 基本索引 与其他标准 Python 序列完全相同：x[0][2] 语法糖：x[0, 2] == x[0][2] 切片和步长 1 2 # start:stop:step x[1:7:2] NumPy 切片创建一个视图而不是副本，所以尽量同时调用copy()以生成副本，视图范围为[start,stop) 负数索引从后往前找，比如数组该维度元素个数为N，那么-k表示索引为N-k 索引超过长度则表示到数组最后一个元素 默认start为0，stop为N-1，step为1 使用与切片相同大小的其他数组对切片赋值可以设置原数组中的值 维度索引工具 np.newaxis对象来添加维度 Ellipsis对象等价于... 高级索引 高级索引总是返回数据的副本，不像切片返回视图 高级索引总是进行广播和迭代 整数数组索引 将整数数组作为索引会取整数数组中的元素作为下标来索引原数组中的元素，将索引到的元素作为一个新的数组，相当于增加一个维度 索引超出范围会抛出错误 多个整数数组作为索引并且个数小于等于原数组的维数时，每个整数数组标记一个维数，整数数组的元素个数一样表示生成的数组的元素个数 布尔数组索引 将布尔数组作为索引时，下标为true的布尔数组元素在布尔数组中的下标对应值 索引的原数组元素添加到返回数组中 作为数组与整形类似，多个布尔数组作为索引时，仍然是每一个布尔数组标记一个维度 平面迭代器索引 x.flat返回元素迭代器 为索引数组赋值 切片视图可以直接修改 1 2 3 x[2:7] = np.arange(5) # 广播 x[2:7] = 1 如果想根据高级索引修改元素，不要使用返回值（副本），在高级索引的后面直接进行修改如： 1 2 x = np.array([1., -1., -2., 3]) x[x \u003c 0] += 20 处理程序中可变数量的索引 Ellipsis对象或...自动填充:，如 1 2 3 4 a=np.arrange(4).reshape(2,2) b=a[...,1] # 等价于 b=a[:,1] ","date":"2023-03-04","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/numpy/:2:3","tags":["Python第三方库"],"title":"Python-第三方库-Numpy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/numpy/"},{"categories":["Python"],"content":"NumPy 的 I/O genfromtxt函数从表格数据创建数组 ","date":"2023-03-04","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/numpy/:2:4","tags":["Python第三方库"],"title":"Python-第三方库-Numpy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/numpy/"},{"categories":["Python"],"content":"数据类型 ","date":"2023-03-04","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/numpy/:2:5","tags":["Python第三方库"],"title":"Python-第三方库-Numpy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/numpy/"},{"categories":["Python"],"content":"广播 1\r2\r3\r4\r","date":"2023-03-04","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/numpy/:2:6","tags":["Python第三方库"],"title":"Python-第三方库-Numpy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/numpy/"},{"categories":["Python"],"content":"副本和视图 更改某些元数据（如stride和dtype）而不更改数据缓冲区从而以不同方式访问数组的实现为视图 ndarray.view()方法新建一个视图 ndarray.copy()方法新建副本 切片是视图，高级索引总是创建副本 base属性判断是视图还是副本，副本返回None，视图返回原始数组 ","date":"2023-03-04","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/numpy/:2:7","tags":["Python第三方库"],"title":"Python-第三方库-Numpy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/numpy/"},{"categories":["Python"],"content":"结构化数组 ","date":"2023-03-04","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/numpy/:2:8","tags":["Python第三方库"],"title":"Python-第三方库-Numpy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/numpy/"},{"categories":["IDE"],"content":"andriod_studio_AVD安装位置修改 51TCO mob604756fb13b1 修改~/.android/avd目录下的.ini配置文件的path属性 ","date":"2023-03-03","objectID":"/posts/ide/androidstudio/:1:0","tags":[],"title":"IDE-AndroidStudio","uri":"/posts/ide/androidstudio/"},{"categories":["中间件"],"content":"Nginx,apatch和tomcat的区别 CSDN 芒果果。 apatch和nginx可以做静态资源服务器，tomcat是用于部署java动态页面应用（servlet和jsp）的容器。 nginx还可以用于做正向和反向代理，负载均衡 nginx的一个进程可以处理多个请求，apatch一个进程对应一个请求。nginx效率比apatch高的多 ","date":"2023-03-03","objectID":"/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:1:0","tags":[],"title":"中间件-个人笔记","uri":"/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["中间件"],"content":"本文为作者跟着nginx官网学习时做的笔记，可能并不详尽，要了解完整内容请上官网查看 ","date":"2023-03-03","objectID":"/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/:0:0","tags":[],"title":"中间件-Nginx","uri":"/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/"},{"categories":["中间件"],"content":"初学者指南 本指南对 nginx 进行了基本介绍，并描述了一些可以用它完成的简单任务。本指南介绍如何启动和停止 nginx，以及重新加载其配置，解释配置文件的结构，并描述如何设置 nginx 以提供静态内容，如何将 nginx 配置为代理服务器，以及如何将其连接到FastCGI 应用程序。 nginx 有一个主进程和几个工作进程。主进程的主要目的是读取和评估配置，并维护工作进程。工作进程对请求进行实际处理。nginx 采用基于事件的模型和依赖于操作系统的机制来有效地在工作进程之间分配请求。工作进程的数量在配置文件中定义，并且可以针对给定的配置进行固定或自动调整为可用 CPU 内核的数量（请参阅 worker_processes）。 nginx 及其模块的工作方式在配置文件中确定。默认情况下，配置文件被命名nginx.conf 并放置在目录 /usr/local/nginx/conf、 /etc/nginx或 /usr/local/etc/nginx. ","date":"2023-03-03","objectID":"/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/:1:0","tags":[],"title":"中间件-Nginx","uri":"/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/"},{"categories":["中间件"],"content":"启动、停止和重新加载配置 要启动 nginx，请运行可执行文件。nginx一旦启动，就可以通过-s参数调用可执行文件来控制它。使用以下语法： 1 nginx -s signal 其中signal可能是以下之一： stop — 快速关机 quit — 优雅关机 reload — 重新加载配置文件 reopen — 重新打开日志文件 例如，要停止 nginx 进程并等待工作进程完成当前请求，可以执行以下命令： 1 nginx -s 退出 此命令应在启动 nginx 的同一用户下执行。 在将重新加载配置的命令发送到 nginx 或重新启动之前，不会应用在配置文件中所做的更改。要重新加载配置，请执行： 1 nginx -s reload 一旦主进程接收到重新加载配置的信号，它就会检查新配置文件的语法有效性并尝试应用其中提供的配置。如果这是成功的，主进程启动新的工作进程并向旧的工作进程发送消息，请求它们关闭。否则，主进程将回滚更改并继续使用旧配置。旧的工作进程收到关闭命令，停止接受新连接并继续为当前请求提供服务，直到所有此类请求都得到服务。之后，旧的工作进程退出。 也可以借助 Unix 工具（例如kill实用程序）向 nginx 进程发送信号。在这种情况下，信号被直接发送到具有给定进程 ID 的进程。nginx主进程的进程ID默认写入 nginx.pid目录 /usr/local/nginx/logs或 /var/run. 例如，如果主进程 ID 是 1628，要发送导致 nginx 正常关闭的 QUIT 信号，请执行： 1 kill -s QUIT 1628 要获取所有正在运行的 nginx 进程的列表，ps 可以使用该实用程序，例如，以下列方式： 1 ps -ax | grep nginx ","date":"2023-03-03","objectID":"/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/:1:1","tags":[],"title":"中间件-Nginx","uri":"/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/"},{"categories":["中间件"],"content":"配置文件的结构 nginx 由模块组成，这些模块由配置文件中指定的指令控制。指令分为简单指令和块指令。一个简单的指令由名称和参数组成，由空格分隔并以分号 ( ;) 结尾。块指令与简单指令具有相同的结构，但它不是以分号结尾，而是以一组由大括号 ({和}) 包围的附加指令。如果块指令可以在大括号内包含其他指令，则称为上下文（例如： events、 http、 server和 location）。 放在配置文件以外的任何指令被认为是在main上下文。event和http指令放在main上下文中，server在http中，location在server中。 符号#后一行的其余部分被视为注释。 ","date":"2023-03-03","objectID":"/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/:1:2","tags":[],"title":"中间件-Nginx","uri":"/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/"},{"categories":["中间件"],"content":"提供静态内容 一个重要的 Web 服务器任务是提供文件（例如图像或静态 HTML 页面）。您将实现一个示例，根据请求，文件将从不同的本地目录提供服务：（/data/www 可能包含 HTML 文件）和/data/images （包含图像）。 这将需要编辑配置文件并在带有两个location块的http块 内设置 server 块。 首先，创建/data/www目录并将 包含任何文本内容的index.html文件放入其中，然后创建/data/images目录并在其中放置一些图像。 接下来，打开配置文件。默认配置文件已经包含了该server块的几个示例，大部分都被注释掉了。现在注释掉所有这些块并开始一个新 server块： 1 2 3 4 http { server { } } 通常情况下配置文件包括几个server块，他们通过监听的端口号和server 名称区分，一旦nginx决定哪一个server块处理一个请求，他会将 请求头中特定的URI 和 server块中定义的location指令的参数进行测试。 将以下location块添加到 server块中： 1 2 3 location / { root /data/www; } location块指定将 “/” 前缀与请求的URI进行对比。如果匹配，这个URI将会被添加root指令指定的路径，即data/www，从而组成请求文件在本地文件系统的路径。如果这里有多个匹配的location块，nginx选择具有最长匹配前缀的那个块。当所有其他的location块都不匹配的时候上面的\"/\" location块将被使用。 接下来，添加第二个location块： location /images/ { root /data; } 它将匹配以/images/ (location /也匹配此类请求，但前缀较短) 开头的请求。 生成的server块配置应如下所示： 1 2 3 4 5 6 7 8 9 server { location / { root /data/www; } location /images/ { root /data; } } 这已经是一个服务器工作的配置，其监听80端口，并在本地机器的http://localhost/是可访问的，服务器将从/data/images目录发送文件。例如，为了响应 http://localhost/images/example.png请求，nginx 会发送/data/images/example.png文件。如果这样的文件不存在，nginx 将发送一个响应，指示 404 错误。不以 URI 开头的请求/images/将被映射到/data/www目录。例如，为了响应 http://localhost/some/example.html请求，nginx 会发送/data/www/some/example.html文件。 要应用新配置，请启动 nginx（如果尚未启动）或将reload信号发送到 nginx 的主进程，方法是执行： 1 nginx -s reload 如果某些东西没有按预期工作，您可以 尝试在/usr/local/nginx/logs/var/log/nginx目录下的 access.log或error.log寻找原因 ","date":"2023-03-03","objectID":"/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/:1:3","tags":[],"title":"中间件-Nginx","uri":"/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/"},{"categories":["中间件"],"content":"设置一个简单的代理服务器 nginx 的常见用途之一是将其设置为代理服务器，这意味着服务器接收请求，将它们传递给被代理的服务器，从它们获取响应，并将响应发送给客户端。 我们将配置一个基本的代理服务器，它为来自本地目录的文件的图像请求提供服务，并将所有其他请求发送到代理服务器。在此示例中，两个服务器都将在单个 nginx 实例上定义。 首先，通过在 nginx 的配置文件中 添加一个server块来定义代理服务器，其内容如下： 1 2 3 4 5 6 7 server { listen 8080; root /data/up1; location / { } } 这将是一个简单的服务器，它在端口 8080 上进行侦听（listen由于使用了标准端口 80，因此没有指定该指令）并将所有请求映射到本地文件系统上的/data/up1目录。创建此目录并将index.html文件放入其中。请注意，该root指令放置在 server上下文中。这样的root指令被用于当被选择处理请求的location块没有定义他自己的root指令时生效。接下来，使用上一节中的服务器配置并对其进行修改以使其成为代理服务器配置。在第一个location块中，将 proxy_pass 指令与参数中指定的代理服务器的协议、名称和端口一起放入（在我们的例子中，它是http://localhost:8080）： 1 2 3 4 5 6 7 8 9 server { location / { proxy_pass http://localhost:8080; } location /images/ { root /data; } } 我们将修改第二个location 块，该块当前将带有/images/前缀的请求映射 到/data/images目录下的文件，以使其匹配具有典型文件扩展名的图像的请求。修改后的location块如下所示： 1 2 3 location ~ \\.(gif|jpg|png)$ { root /data/images; } 该参数是一个正则表达式，匹配所有以.gif、.jpg或.png 结尾的 URI 。正则表达式应该以~开始. 相应的请求将映射到/data/images 目录。 当 nginx 选择一个location块来服务请求时，它首先检查指定前缀的location 指令，记住location 最长的前缀，然后检查正则表达式。如果与正则表达式匹配，则 Nginx 会选择这个 location，否则，它会选择之前记住的那个。 代理服务器的最终配置将如下所示： 1 2 3 4 5 6 7 8 9 server { location / { proxy_pass http://localhost:8080/; } location ~ \\.(gif|jpg|png)$ { root /data/images; } } 此服务器将筛选以.gif、.jpg或.png结尾的请求 并将它们映射到/data/images目录（通过将 URI 添加到 root指令的参数）并将所有其他请求传递给上面配置的代理服务器。 要应用新配置，请按照前面部分中的说明将reload信号发送到 nginx。 ","date":"2023-03-03","objectID":"/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/:1:4","tags":[],"title":"中间件-Nginx","uri":"/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/"},{"categories":["中间件"],"content":"设置 FastCGI 代理 nginx 可用于将请求路由到 FastCGI 服务器，这些服务器运行使用各种框架和编程语言（如 PHP）构建的应用程序。 使用 FastCGI 服务器的最基本的 nginx 配置包括使用 fastcgi_pass 指令而不是proxy_pass指令，以及使用fastcgi_param 指令来设置传递给 FastCGI 服务器的参数。假设 FastCGI 服务在localhost:9000.以上一节中的代理配置为基础，将proxy_pass指令 替换为指令，fastcgi_pass并将参数更改为 localhost:9000. 在PHP中，SCRIPT_FILENAME参数用于确定脚本名称，QUERY_STRING 参数用于传递请求参数。生成的配置将是： 1 2 3 4 5 6 7 8 9 10 11 server { location / { fastcgi_pass localhost:9000; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param QUERY_STRING $query_string; } location ~ \\.(gif|jpg|png)$ { root /data/images; } } 这将设置一个服务器，它将除了静态图像请求之外的所有请求路由到 localhost:9000通过 FastCGI 协议运行的代理服务器。 ","date":"2023-03-03","objectID":"/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/:1:5","tags":[],"title":"中间件-Nginx","uri":"/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/"},{"categories":["数据库"],"content":"redis 官网 redis 文档 redis 命令参考 ","date":"2023-03-02","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:0:0","tags":["redis"],"title":"数据库-redis-个人笔记","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"坑 CSDN isHuPei ","date":"2023-03-02","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:1:0","tags":["redis"],"title":"数据库-redis-个人笔记","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"redis配置文件 位置为/etc/redis/redis.conf redis默认不使用配置文件 你需要使用redis-server /etc/redis/redis.conf指明配置文件才能使用相应配置 ","date":"2023-03-02","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:1:1","tags":["redis"],"title":"数据库-redis-个人笔记","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"外部主机连接 注释掉配置里面的监听bind 将daemon设置为no 将peotected-mode设置为no 设置密码requirepass xxxxxx ","date":"2023-03-02","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:1:2","tags":["redis"],"title":"数据库-redis-个人笔记","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"本地连接 redis-cli -a xxxxxx 其中xxx是密码 ","date":"2023-03-02","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:1:3","tags":["redis"],"title":"数据库-redis-个人笔记","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"redis启动与关闭 均需要root权限 1 2 3 redis-server /etc/redis/redis.conf redis-cli -a mima shutdown ","date":"2023-03-02","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:1:4","tags":["redis"],"title":"数据库-redis-个人笔记","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Redis 网络IO模型 CSDN 天秤座的架构师 IO多路复用 ","date":"2023-03-02","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:2:0","tags":["redis"],"title":"数据库-redis-个人笔记","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["版本控制"],"content":"git文档 本文来源于LearnGitBranching官网 ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/:0:0","tags":["git"],"title":"版本控制-git-LearnGitBranching-远程","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/"},{"categories":["版本控制"],"content":"Push \u0026 Pull —— Git 远程仓库！ ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/:1:0","tags":["git"],"title":"版本控制-git-LearnGitBranching-远程","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/"},{"categories":["版本控制"],"content":"远程仓库 远程仓库有一系列强大的特性 首先也是最重要的的点, 远程仓库是一个强大的备份。本地仓库也有恢复文件到指定版本的能力, 但所有的信息都是保存在本地的。有了远程仓库以后，即使丢失了本地所有数据, 你仍可以通过远程仓库拿回你丢失的数据。 还有就是, 远程让代码社交化了! 既然你的项目被托管到别的地方了, 你的朋友可以更容易地为你的项目做贡献(或者拉取最新的变更) 现在用网站来对远程仓库进行可视化操作变得越发流行了(像 GitHub), 但远程仓库永远是这些工具的顶梁柱, 因此理解其概念非常的重要! ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/:1:1","tags":["git"],"title":"版本控制-git-LearnGitBranching-远程","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/"},{"categories":["版本控制"],"content":"我们创建远程仓库的命令 git clone ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/:1:2","tags":["git"],"title":"版本控制-git-LearnGitBranching-远程","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/"},{"categories":["版本控制"],"content":"远程分支 远程分支反映了远程仓库(在你上次和它通信时)的状态 远程分支有一个特别的属性，在你检出时自动进入分离 HEAD 状态。Git 这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果 远程分支命名规范:\u003cremote name\u003e/\u003cbranch name\u003e 大多数的开发人员会将它们主要的远程仓库命名为 origin，并不是 o。这是因为当你用 git clone 某个仓库时，Git 已经帮你把远程仓库的名称设置为 origin 了 ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/:1:3","tags":["git"],"title":"版本控制-git-LearnGitBranching-远程","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/"},{"categories":["版本控制"],"content":"Git Fetch 从远程仓库获取数据 git fetch。 从远程仓库获取数据时, 远程分支也会更新以反映最新的远程仓库。 ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/:1:4","tags":["git"],"title":"版本控制-git-LearnGitBranching-远程","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/"},{"categories":["版本控制"],"content":"git fetch 做了些什么 git fetch 完成了两步: 从远程仓库下载本地仓库中缺失的提交记录 更新远程分支指针(如 o/main) git fetch 将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。 git fetch 通常通过互联网（使用 http:// 或 git:// 协议) 与远程仓库通信。 git fetch 不会做的事 git fetch 并不会改变你本地仓库的状态。它不会更新你的 main 分支，也不会修改你磁盘上的文件。 ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/:1:5","tags":["git"],"title":"版本控制-git-LearnGitBranching-远程","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/"},{"categories":["版本控制"],"content":"Git Pull 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支: git cherry-pick o/main git rebase o/main git merge o/main … git pull 就是 git fetch 和 git merge 的缩写 ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/:1:6","tags":["git"],"title":"版本控制-git-LearnGitBranching-远程","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/"},{"categories":["版本控制"],"content":"模拟团队合作 ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/:1:7","tags":["git"],"title":"版本控制-git-LearnGitBranching-远程","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/"},{"categories":["版本控制"],"content":"Git Push git push 负责将你的变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录 git push 不带任何参数时的行为与 Git 的一个名为 push.default 的配置有关。它的默认值取决于你正使用的 Git 的版本，但是在教程中我们使用的是 upstream push之前如果和远程仓库的分支冲突，则会被拒绝，所以在push之前最好先执行pull或者pull –rebase ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/:1:8","tags":["git"],"title":"版本控制-git-LearnGitBranching-远程","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/"},{"categories":["版本控制"],"content":"大型团队合作 每个人维护自己的分支，另外专门由一个人来检查大家的分支并合并分支 ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/:1:9","tags":["git"],"title":"版本控制-git-LearnGitBranching-远程","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/"},{"categories":["版本控制"],"content":"关于 origin 和它的周边 —— Git 远程仓库高级操作 ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/:2:0","tags":["git"],"title":"版本控制-git-LearnGitBranching-远程","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/"},{"categories":["版本控制"],"content":"合并特性分支 团队开发工作流： 将特性分支集成到 main 上 推送并更新远程分支 让我们看看如何快速的更新 main 分支并推送到远程。 1 2 git pull --rebase git push 我们执行了两个命令: 将我们的工作 rebase 到远程分支的最新提交记录 向远程仓库推送我们的工作 ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/:2:1","tags":["git"],"title":"版本控制-git-LearnGitBranching-远程","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/"},{"categories":["版本控制"],"content":"为什么不用 merge 呢? 只要你的本地分支包含了远程分支（如 o/main）中的最新变更就可以了，至于具体是用 rebase 还是 merge，并没有限制。 在开发社区里，有许多关于 merge 与 rebase 的讨论。以下是关于 rebase 的优缺点： 优点:Rebase 使你的提交树变得很干净, 所有的提交都在一条线上 缺点:Rebase 修改了提交树的历史 比如, 提交 C1 可以被 rebase 到 C3 之后。这看起来 C1 中的工作是在 C3 之后进行的，但实际上是在 C3 之前。 一些开发人员喜欢保留提交历史，因此更偏爱 merge。而其他人可能更喜欢干净的提交树，于是偏爱 rebase。仁者见仁，智者见智。 :D ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/:2:2","tags":["git"],"title":"版本控制-git-LearnGitBranching-远程","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/"},{"categories":["版本控制"],"content":"远程跟踪分支 pull 操作时, 提交记录会被先下载到 o/main 上，之后再合并到本地的 main 分支。隐含的合并目标由这个关联确定的。 push 操作时, 我们把工作从 main 推到远程仓库中的 main 分支(同时会更新远程分支 o/main) 。这个推送的目的地也是由这种关联确定的！ 远程跟踪 直接了当地讲，main 和 o/main 的关联关系就是由分支的“remote tracking”属性决定的。main 被设定为跟踪 o/main —— 这意味着为 main 分支指定了推送的目的地以及拉取后合并的目标。 当你克隆仓库的时候, Git 就自动帮你把这个属性设置好了。 当你克隆时, Git 会为远程仓库中的每个分支在本地仓库中创建一个远程分支（比如 o/main）。然后再创建一个跟踪远程仓库中活动分支的本地分支，默认情况下这个本地分支会被命名为 main。 克隆完成后，你会得到一个本地分支（如果没有这个本地分支的话，你的目录就是“空白”的），但是可以查看远程仓库中所有的分支（如果你好奇心很强的话）。这样做对于本地仓库和远程仓库来说，都是最佳选择。 这也解释了为什么会在克隆的时候会看到下面的输出： 1 local branch \"main\" set to track remote branch \"o/main\" 我能自己指定这个属性吗？ 有两种方法设置这个属性，第一种就是通过远程分支检出一个新的分支，执行: 1 git checkout -b totallyNotMain o/main 就可以创建一个名为 totallyNotMain 的分支，它跟踪远程分支 o/main。 第二种方法 另一种设置远程追踪分支的方法就是使用：git branch -u 命令，执行： 1 git branch -u o/main foo 这样 foo 就会跟踪 o/main 了。如果当前就在 foo 分支上, 还可以省略 foo： 1 git branch -u o/main ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/:2:3","tags":["git"],"title":"版本控制-git-LearnGitBranching-远程","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/"},{"categories":["版本控制"],"content":"Git Push 的参数 1 git push \u003cremote\u003e \u003cplace\u003e 1 git push origin main 我们通过“place”参数来告诉 Git 提交记录来自于 main, 要推送到远程仓库中的 main 需要注意的是，因为我们通过指定参数告诉了 Git 所有它需要的信息, 所以它就忽略了我们所检出的分支的属性 ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/:2:4","tags":["git"],"title":"版本控制-git-LearnGitBranching-远程","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/"},{"categories":["版本控制"],"content":"参数详解 如果来源和去向分支的名称不同呢？比如你想把本地的 foo 分支推送到远程仓库中的 bar 分支。 要同时为源和目的地指定 \u003cplace\u003e 的话，只需要用冒号 : 将二者连起来就可以了： 1 git push origin \u003csource\u003e:\u003cdestination\u003e source 可以是任何 Git 能识别的位置： 如果你要推送到的目的分支不存在，Git 会在远程仓库中根据你提供的名称帮你创建这个分支！ ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/:2:5","tags":["git"],"title":"版本控制-git-LearnGitBranching-远程","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/"},{"categories":["版本控制"],"content":"Git fetch 的参数 参数 1 git fetch origin foo Git 会到远程仓库的 foo 分支上，然后获取所有本地不存在的提交，放到本地的 o/foo 上，但是不会覆盖本地foo分支。 Git 做了一些特殊处理，因为你可能在 foo 分支上的工作还未完成，你也不想弄乱它。 git fetch 不会更新本地的非远程分支, 只是下载提交记录（这样, 你就可以对远程分支进行检出或者合并了）。 \u003csource\u003e:\u003cdestination\u003e ：source 现在指的是远程仓库中的位置，而 \u003cdestination\u003e 才是要放置提交的本地仓库的位置。它与 git push 刚好相反 理论上虽然行的通，但开发人员很少这么做。 来看个疯狂的例子： 1 git fetch origin foo~1:bar 跟 git push 一样，Git 会在 fetch 前自己创建立本地分支, 就像是 Git 在 push 时，如果远程仓库中不存在目标分支，会自己在建立一样 如果 git fetch 没有参数，它会下载所有的提交记录到各个远程分支 古怪的 在 git push 或 git fetch 时不指定任何 source git push origin :side git fetch origin :bugFix push 空 到远程仓库会删除远程仓库中的分支 如果 fetch 空 到本地，会在本地创建一个新分支。 ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/:2:6","tags":["git"],"title":"版本控制-git-LearnGitBranching-远程","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/"},{"categories":["版本控制"],"content":"Git pull 参数 git pull 就是 fetch 后跟 merge 的缩写，可以使用–rebase选项选择rebase而不是merge 以下命令在 Git 中是等效的: git pull origin foo ：git fetch origin foo; git merge o/foo git pull origin bar~1:bugFix ：git fetch origin bar~1:bugFix; git merge bugFix 如果我们指定要抓取的 place，所有的事情都会跟之前一样发生，只是增加了 merge 操作 pull 也可以用 source:destination 吗? 当然喽, 看看吧: ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/:2:7","tags":["git"],"title":"版本控制-git-LearnGitBranching-远程","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E8%BF%9C%E7%A8%8B/"},{"categories":["版本控制"],"content":"git文档 本文来源于LearnGitBranching官网 ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/:0:0","tags":["git"],"title":"版本控制-git-LearnGitBranching-主要","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/"},{"categories":["版本控制"],"content":"基础篇 ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/:1:0","tags":["git"],"title":"版本控制-git-LearnGitBranching-主要","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/"},{"categories":["版本控制"],"content":"git commit Git 仓库中的提交记录保存的是你的目录下所有文件的快照 Git 将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录 Git 保存了提交的历史记录 1 git commit -m \"xxx\" 在当前HEAD所在提交新建一个提交 ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/:1:1","tags":["git"],"title":"版本控制-git-LearnGitBranching-主要","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/"},{"categories":["版本控制"],"content":"git branch Git 的分支简单地指向某个提交节点 早建分支！多用分支！ 创建再多的分支也不会造成储存或内存上的开销，按逻辑分解工作到不同的分支要比维护特别臃肿的分支简单多了。 创建xxx分支 1 git branch xxx 切换分支 1 git checkout \u003cname\u003e ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/:1:2","tags":["git"],"title":"版本控制-git-LearnGitBranching-主要","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/"},{"categories":["版本控制"],"content":"分支与合并 git merge 1 git merge xxx 此命令会将当前HEAD指向的分支的提交和xxx分支的提交合并生成一个新的提交，然后将当前HEAD指向的分支指向新的提交 git rebase 1 git rebase xxx 将当前分支到当前分支和被合并分支xxx的公共祖先的一系列提交放到被合并分支的下面 ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/:1:3","tags":["git"],"title":"版本控制-git-LearnGitBranching-主要","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/"},{"categories":["版本控制"],"content":"高级篇 ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/:2:0","tags":["git"],"title":"版本控制-git-LearnGitBranching-主要","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/"},{"categories":["版本控制"],"content":"在提交树上移动 HEAD 是当前提交记录的符号引用。 commit之后，HEAD 会指向新的提交记录。 HEAD 可以指向分支名（如 bugFix），这种情况下提交，会使 bugFix 也指向新的提交记录。 分离的 HEAD 分离的 HEAD 指向了具体的提交记录而不是分支名。 1 git checkout xxx xxx为具体提交的hash值 ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/:2:1","tags":["git"],"title":"版本控制-git-LearnGitBranching-主要","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/"},{"categories":["版本控制"],"content":"相对引用 git log 来查查看当前分支提交记录的哈希值，需要找被丢弃的提交时可以通过git reflog查看所有执行过的命令 哈希值基于 SHA-1，共 40 位 只需要提供能够唯一标识提交记录的前几个字符（比如4个）即可 除了使用hash值的绝对引用提交外， Git 还引入了基于某一提交的相对引用提交 使用 ^ 向上移动 1 个提交记录:git checkout xxx^ 使用 ~ 向上移动多个提交记录，如 ~3:git checkout xxx~4 使用相对引用最多的就是移动分支。可以直接使用 -f 选项让分支指向另一个提交。例如:git branch -f main HEAD~3 ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/:2:2","tags":["git"],"title":"版本控制-git-LearnGitBranching-主要","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/"},{"categories":["版本控制"],"content":"撤销变更 CSDN 李俊的博客 Git Reset 1 git reset HEAD^ git reset 通过把分支回退几个提交来实现撤销改动 此时向远程仓库推送会出错，如果一定要推送则使用-f选项 本地的reset并不会删除，添加–hard后会删除未使用分支 Git Revert 1 git revert xxx git revert 会在HEAD提交上创建一个新的提交，该提交和xxx的状态一样 ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/:2:3","tags":["git"],"title":"版本控制-git-LearnGitBranching-主要","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/"},{"categories":["版本控制"],"content":"移动提交记录 ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/:3:0","tags":["git"],"title":"版本控制-git-LearnGitBranching-主要","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/"},{"categories":["版本控制"],"content":"整理提交记录 本系列的第一个命令是 git cherry-pick, 命令形式为: 1 git cherry-pick \u003c提交号\u003e... 将一些提交复制到当前所在的位置（HEAD）下面 该命令与rebase的区别是cherry-pick不会将rebase的祖先提交也复制到HEAD指向的提交后面，而是只拿你选中的提交 ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/:3:1","tags":["git"],"title":"版本控制-git-LearnGitBranching-主要","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/"},{"categories":["版本控制"],"content":"交互式的 rebase 交互式 rebase 指的是使用带参数 –interactive 的 rebase 命令, 简写为 -i。 Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明。 当 rebase UI界面打开时, 你能做3件事: 调整提交记录的顺序（通过鼠标拖放来完成） 删除你不想要的提交（通过切换 pick 的状态来完成，关闭就意味着你不想要这个提交记录） 合并提交。 遗憾的是由于某种逻辑的原因，我们的课程不支持此功能，因此我不会详细介绍这个操作。简而言之，它允许你把多个提交记录合并成一个。 ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/:3:2","tags":["git"],"title":"版本控制-git-LearnGitBranching-主要","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/"},{"categories":["版本控制"],"content":"杂项 ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/:4:0","tags":["git"],"title":"版本控制-git-LearnGitBranching-主要","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/"},{"categories":["版本控制"],"content":"本地栈式提交 来看一个在开发中经常会遇到的情况：我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。 这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个 Bug 的根本原因，解决掉以后觉得沾沾自喜！ 最后就差把 bugFix 分支里的工作合并回 main 分支了。你可以选择通过 fast-forward 快速合并到 main 分支上，但这样的话 main 分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式 实际我们只要让 Git 复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用 git rebase -i git cherry-pick ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/:4:1","tags":["git"],"title":"版本控制-git-LearnGitBranching-主要","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/"},{"categories":["版本控制"],"content":"提交的技巧 #1 接下来这种情况也是很常见的：你之前在 newImage 分支上进行了一次提交，然后又基于它创建了 caption 分支，然后又提交了一次。 此时你想对某个以前的提交记录进行一些小小的调整。比如设计师想修改一下 newImage 中图片的分辨率，尽管那个提交记录并不是最新的了。 我们可以通过下面的方法来克服困难： 先用 git rebase -i 将提交重新排序，然后把我们想要修改的提交记录挪到最前 然后用 git commit –amend 来进行一些小修改，这个命令会用当前暂存区的内容覆盖当前的提交 接着再用 git rebase -i 来将他们调回原来的顺序 最后我们把 main 移到修改的最前端（用你自己喜欢的方法），就大功告成啦！ ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/:4:2","tags":["git"],"title":"版本控制-git-LearnGitBranching-主要","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/"},{"categories":["版本控制"],"content":"提交的技巧 #2 正如你在上一关所见到的，我们可以使用 rebase -i 对提交记录进行重新排序。只要把我们想要的提交记录挪到最前端，我们就可以很轻松的用 –amend 修改它，然后把它们重新排成我们想要的顺序。 但这样做就唯一的问题就是要进行两次排序，而这有可能造成由 rebase 而导致的冲突。下面还是看看 git cherry-pick 是怎么做的吧。 要在心里牢记 cherry-pick 可以将提交树上任何地方的提交记录取过来追加到 HEAD 上（只要不是 HEAD 上游的提交就没问题）。 这一关的目标和上一关一样，通过 –amend 改变提交记录 C2，但你不能用 rebase -i。 ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/:4:3","tags":["git"],"title":"版本控制-git-LearnGitBranching-主要","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/"},{"categories":["版本控制"],"content":"Git Tags Git 的 tag 可以将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。它们并不会随着新的提交而移动。你也不能切换到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。 1 git tag v1 C1 我们将这个标签命名为 v1，并且明确地让它指向提交记录 C1，如果不指定提交记录，Git 会用 HEAD 所指向的位置。 ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/:4:4","tags":["git"],"title":"版本控制-git-LearnGitBranching-主要","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/"},{"categories":["版本控制"],"content":"Git Describe git describe描述离你最近的锚点（也就是标签） 1 git describe \u003cref\u003e \u003cref\u003e 可以是任何能被 Git 识别成提交记录的引用，如果没有指定，Git 会以目前所检出的位置（HEAD）。 输出的结果是这样的：\u003ctag\u003e_\u003cnumCommits\u003e_g\u003chash\u003e tag 表示的是离 ref 最近的标签， numCommits 是表示这个 ref 与 tag 相差有多少个提交记录， hash 表示的是你所给定的 ref 所表示的提交记录哈希值的前几位。 当 ref 提交记录上有某个标签时，则只输出标签名称 ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/:4:5","tags":["git"],"title":"版本控制-git-LearnGitBranching-主要","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/"},{"categories":["版本控制"],"content":"高级话题 ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/:5:0","tags":["git"],"title":"版本控制-git-LearnGitBranching-主要","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/"},{"categories":["版本控制"],"content":"多次rebase ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/:5:1","tags":["git"],"title":"版本控制-git-LearnGitBranching-主要","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/"},{"categories":["版本控制"],"content":"选择父提交记录 操作符 ^ 与 ~ 符一样，后面也可以跟一个数字。 指定merge合并提交记录的某个父提交。还记得前面提到过的一个合并提交有两个父提交吧，所以遇到这样的节点时该选择哪条路径就不是很清晰了。 Git 默认选择合并提交的“第一个”父提交，在操作符 ^ 后跟一个数字可以改变这一默认行为。 ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/:5:2","tags":["git"],"title":"版本控制-git-LearnGitBranching-主要","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/"},{"categories":["版本控制"],"content":"纠缠不清的分支 ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/:5:3","tags":["git"],"title":"版本控制-git-LearnGitBranching-主要","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/learngitbranching/%E4%B8%BB%E8%A6%81/"},{"categories":["版本控制"],"content":"git文档 ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:0:0","tags":["git"],"title":"版本控制-git-个人笔记","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["版本控制"],"content":"配置代理 CSDN慕白Lee .gitconfig文件，放etc（全部用户生效）或者~（当前用户生效） 1 2 3 4 5 6 7 [http] proxy = 192.168.171.1:8888 [https] proxy = 192.168.171.1:8888 ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:1:0","tags":["git"],"title":"版本控制-git-个人笔记","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["版本控制"],"content":"配置全局.gitignore ZhuGaochao 博客园 新建一个文件（不一定非得叫.gitignore） 在用户目录的.gitconfig文件（用户范围生效）或者git安装目录下（所有用户生效）添加：[core]excludesfile = 新建文件的绝对路径 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 .DS_Store */.DS_Store *.class *.iws *.iml *.ipr .idea .idea/* *.bak target target/* .gradle/ .DS_Store .project .settings/ *.pyc *.log *.stats *.apk *.ap_ *.dex gen/ local.properties proguard/ *.pbxuser *.mode1v3 *.mode2v3 *.perspectivev3 xcuserdata *.xccheckout *.moved-aside *.hmap *.ipa .metadata/ .metadata/* *.log pids *.pid *.seed lib-cov coverage .grunt .lock-wscript build/Release node_modules go.sum ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:2:0","tags":["git"],"title":"版本控制-git-个人笔记","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["版本控制"],"content":"git丢弃历史commit 芒草的梦呓 blog ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:3:0","tags":["git"],"title":"版本控制-git-个人笔记","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["版本控制"],"content":"第一步：创建独立的新分支 1 git checkout --orphan latest_branch –orphan 选项：创建一个独立分支并切换到该分支，该分支没有历史提交记录。但是对于打了tag的分支会保留最新tag之前的所有历史提交记录 ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:3:1","tags":["git"],"title":"版本控制-git-个人笔记","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["版本控制"],"content":"第二步：将需要的文件进行一次提交 1 2 git add -A git commit -m \"commit message\" ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:3:2","tags":["git"],"title":"版本控制-git-个人笔记","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["版本控制"],"content":"第三步：删除需要清除历史记录的分支，并将当前分支名修改为该分支 1 2 git branch -D main git branch -m main ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:3:3","tags":["git"],"title":"版本控制-git-个人笔记","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["版本控制"],"content":"第四步：关联本地分支到远程 1 git branch --set-upstream-to=origin/main ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:3:4","tags":["git"],"title":"版本控制-git-个人笔记","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["版本控制"],"content":"第五步：将本地更改推送到远程分支 1 git push -f origin main ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:3:5","tags":["git"],"title":"版本控制-git-个人笔记","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["版本控制"],"content":"推送tag到远程仓库 1 git push origin --tags ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:4:0","tags":["git"],"title":"版本控制-git-个人笔记","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["版本控制"],"content":"删除分支 1 2 3 4 5 6 # 删除本地分支 git branch -d \u003cbranch\u003e # 删除远程分支 git push origin --delete \u003cbranch\u003e # 删除追踪分支 git branch --delete --remotes \u003cremote\u003e/\u003cbranch\u003e ","date":"2023-03-02","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:5:0","tags":["git"],"title":"版本控制-git-个人笔记","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["操作系统"],"content":"windows官网 ","date":"2023-02-28","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:0:0","tags":["windows"],"title":"操作系统-windows-个人笔记","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["操作系统"],"content":"防火墙配置 windows官网防火墙文档 入站默认阻止，出站默认允许 主要配置入站规则 安全连接规则主要是配置身份验证相关的配置 入站规则可以按程序，ip，端口等进行配置，最常见的就是局域网的规则配置 ","date":"2023-02-28","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:1:0","tags":["windows"],"title":"操作系统-windows-个人笔记","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["操作系统"],"content":"windows开机启动软件 对于具有开机选项的软件选上该选项即可 对于没有该选项的软件，可以将需要开机启动的软件快捷方式放到C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp文件夹下 ","date":"2023-02-28","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:2:0","tags":["windows"],"title":"操作系统-windows-个人笔记","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["操作系统"],"content":"windows文件无法修改和删除 CSDN 阿虚同学 当windows某些文件或者文件夹（比如C:/user/xxx/program data里面的文件）无法被修改或删除时，通常会留下移动文件或文件夹的权限，可以将其移动到其他地方然后进行删除 ","date":"2023-02-28","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:3:0","tags":["windows"],"title":"操作系统-windows-个人笔记","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["操作系统"],"content":"窗口快捷键 ","date":"2023-02-28","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:4:0","tags":["windows"],"title":"操作系统-windows-个人笔记","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["操作系统"],"content":"多屏幕切换 win+shift+方向键 ","date":"2023-02-28","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:4:1","tags":["windows"],"title":"操作系统-windows-个人笔记","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["操作系统"],"content":"多桌面切换 win+ctrl+方向键 ","date":"2023-02-28","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:4:2","tags":["windows"],"title":"操作系统-windows-个人笔记","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["操作系统"],"content":"打印机相关 连接打印机的方式 直接下载官方驱动，然后通过驱动来发现设备 windows直接添加设备（按ip），自动下载打印机内部的驱动 ","date":"2023-02-28","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:5:0","tags":["windows"],"title":"操作系统-windows-个人笔记","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["操作系统"],"content":"visio 微软官网 插入表格并显示特定区域 表格文件中把要展示的单元格区域定义名称。 visio中插入对象选择excel文件，勾上链接到文件，选择表格文件 visio中搜索框中搜索链接，点击并选择自动更新，点击更改源，在项目名称里面输入定义的名称。 ","date":"2023-02-28","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:6:0","tags":["windows"],"title":"操作系统-windows-个人笔记","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["操作系统"],"content":"更新ip地址 管理员权限运行power shell 1 2 3 4 5 6 7 # ipv4 ipconfig /release ipconfig /renew # ipv6 ipconfig /release6 ipconfig /renew6 ","date":"2023-02-28","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:7:0","tags":["windows"],"title":"操作系统-windows-个人笔记","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["操作系统"],"content":"修改网卡的mac地址 mekan0.com 控制面板\\网络和 Internet\\网络连接 选择要配置的网卡，右键点击属性，点击配置，点击高级，找到网络地址，修改为其他值重启即可 ","date":"2023-02-28","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:8:0","tags":["windows"],"title":"操作系统-windows-个人笔记","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["操作系统"],"content":"edge bing ai侧边栏 设置-》侧栏-》Discover打开即可 ","date":"2023-02-28","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:9:0","tags":["windows"],"title":"操作系统-windows-个人笔记","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"PYPI官网 jupyter官网 ","date":"2023-02-28","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/jupyter/:0:0","tags":["Python第三方库"],"title":"Python-第三方库-Jupyter","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/jupyter/"},{"categories":["Python"],"content":"安装jupyter jupyter官网下载说明 1 2 3 pip install notebook # 启动jupyter服务 jupyter notebook ","date":"2023-02-28","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/jupyter/:1:0","tags":["Python第三方库"],"title":"Python-第三方库-Jupyter","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/jupyter/"},{"categories":["Python"],"content":"常用命令 1 2 3 4 5 6 # 列出本地jupyter服务器 jupyter notebook list # 停止本地jupyter服务器 jupyter notebook stop # 修改或设置密码 jupyter notebook password ","date":"2023-02-28","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/jupyter/:2:0","tags":["Python第三方库"],"title":"Python-第三方库-Jupyter","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/jupyter/"},{"categories":["Python"],"content":"找回jupyter密码 CSDN SU_ZCS 1 2 jupyter notebook --generate-config vim ~/.jupyter/jupyter_notebook_config.py 修改NotebookApp.allow_password_change=False jupyter notebook password输入新密码两次 jupyter_notebook_config.json中生成password的值 将password的值拷贝给jupyter_notebook_config.py中的c.NotebookApp.password 那么后面登录就能使用你之前输入的新密码了 ","date":"2023-02-28","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/jupyter/:3:0","tags":["Python第三方库"],"title":"Python-第三方库-Jupyter","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/jupyter/"},{"categories":["Python"],"content":"设置免密登录 secular_ 设置token：~/.jupyter/jupyter_notebook_config.py设置c.NotebookApp.token='xxx'。然后重启jupyter服务后通过http://localhost:8888/?token=xxx就可以登录jupyter服务器了 此方法通常用于与vscode集成，vscode连接jupyter只能通过token的方式 ","date":"2023-02-28","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/jupyter/:4:0","tags":["Python第三方库"],"title":"Python-第三方库-Jupyter","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/jupyter/"},{"categories":["IDE"],"content":"vscode官网 vscode官方文档 ","date":"2023-02-27","objectID":"/posts/ide/vscode/:0:0","tags":[],"title":"IDE-Vscode","uri":"/posts/ide/vscode/"},{"categories":["IDE"],"content":"概述 宇宙第一IDE ","date":"2023-02-27","objectID":"/posts/ide/vscode/:1:0","tags":[],"title":"IDE-Vscode","uri":"/posts/ide/vscode/"},{"categories":["IDE"],"content":"安装 直接去官网下载对应操作系统的安装程序直接安装 ubuntu安装使用命令 1 sudo apt install ./\u003cfile\u003e.deb ","date":"2023-02-27","objectID":"/posts/ide/vscode/:2:0","tags":[],"title":"IDE-Vscode","uri":"/posts/ide/vscode/"},{"categories":["IDE"],"content":"用户指南 ","date":"2023-02-27","objectID":"/posts/ide/vscode/:3:0","tags":[],"title":"IDE-Vscode","uri":"/posts/ide/vscode/"},{"categories":["IDE"],"content":"扩展市场 扩展安装在哪里 windows:%USERPROFILE%\\.vscode\\extensions linux:~/.vscode/extensions code --extensions-dir \u003cdir\u003e VS Code 来更改位置 ","date":"2023-02-27","objectID":"/posts/ide/vscode/:3:1","tags":[],"title":"IDE-Vscode","uri":"/posts/ide/vscode/"},{"categories":["IDE"],"content":"插件推荐 docker插件和remote插件让你管理容器更加简单快捷 vscode google translate插件用于翻译文本，快捷键ctrl+alt+t，可以选择google翻译的所有语言 VS Code Counter计算代码的行数，安装完后ctrl+shift+P，选择VS Code Counter相关的命令比如：VscodeCounter:Count lines in directory在项目下生成.VSCodeCounter文件夹 ","date":"2023-02-27","objectID":"/posts/ide/vscode/:4:0","tags":[],"title":"IDE-Vscode","uri":"/posts/ide/vscode/"},{"categories":["IDE"],"content":"常用快捷键 ctrl+shift+p:设置相关，另外有的插件需要使用该命令来运行比如VS Code Counter ","date":"2023-02-27","objectID":"/posts/ide/vscode/:5:0","tags":[],"title":"IDE-Vscode","uri":"/posts/ide/vscode/"},{"categories":["IDE"],"content":"正则搜索和替换 CSDN 璞~ ^ 开始 () 捕获组 [] 包含 [^] 不包含 {n,m} 前一个字符或组匹配次数 . 任何单个字符 $ 结尾 替换 $n 匹配时的捕获组 ","date":"2023-02-27","objectID":"/posts/ide/vscode/:6:0","tags":[],"title":"IDE-Vscode","uri":"/posts/ide/vscode/"},{"categories":["Python"],"content":"常用命令 ","date":"2023-02-26","objectID":"/posts/python/anaconda3/:1:0","tags":["Anaconda3"],"title":"Python-Anaconda3","uri":"/posts/python/anaconda3/"},{"categories":["Python"],"content":"conda环境管理 1 2 3 4 5 6 conda create -n xxx package #创建环境 conda activate xxx #激活环境 conda deactivate xxx #离开环境 conda env list #显示所有conda虚拟环境 conda env remove -n xxx #删除环境 conda create -n A --clone B # 将环境B复制到A ","date":"2023-02-26","objectID":"/posts/python/anaconda3/:1:1","tags":["Anaconda3"],"title":"Python-Anaconda3","uri":"/posts/python/anaconda3/"},{"categories":["Python"],"content":"其他 1 2 package --version 看包的版本 python -m pip install --upgrade pip 更新pip ","date":"2023-02-26","objectID":"/posts/python/anaconda3/:1:2","tags":["Anaconda3"],"title":"Python-Anaconda3","uri":"/posts/python/anaconda3/"},{"categories":["机器学习"],"content":"github FATE官方文档 fate 官网 fate 官网教程 fate 算法开发指南 算法参数 FATE组件官网 pipline官方文档 ","date":"2023-02-26","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/fate%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/%E6%95%99%E7%A8%8B/:0:0","tags":["FATE联邦学习"],"title":"机器学习-FATE联邦学习-教程","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/fate%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/%E6%95%99%E7%A8%8B/"},{"categories":["机器学习"],"content":"教程 ","date":"2023-02-26","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/fate%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/%E6%95%99%E7%A8%8B/:1:0","tags":["FATE联邦学习"],"title":"机器学习-FATE联邦学习-教程","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/fate%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/%E6%95%99%E7%A8%8B/"},{"categories":["机器学习"],"content":"部署 单机部署 官网安装页面 使用Docker镜像安装FATE 作者本地环境：ubuntu==18.04LTS，docker==20.10.17，FATE==1.7.3 拉取镜像 1 docker pull federatedai/standalone_fate:1.7.3 启动镜像 1 docker run -it --name standalone_fate -p 8080:8080 federatedai/standalone_fate:1.7.3 之后就可以通过docker exec登录FATE容器了，在.bashrc里面添加alias来简化登录，启动和关闭容器过程 1 2 3 alias fatebash=\"docker container exec -it 2fe0497f6846 /bin/bash\" alias fatestart=\"docker container start 2fe0497f6846\" alias fatestop=\"docker container stop 2fe0497f6846\" 之后就可以直接通过fatebash登录容器 百度文库 另外可以使用vscode的docker插件和remote插件来更加简化登录启动和关闭容器（强烈推荐），另外这两个插件还提供了几乎所有的容器操作以及查看和修改容器文件的操作 登录容器后测试 1 2 3 4 5 6 source bin/init_env.sh # Toy测试 flow test toy -gid 10000 -hid 10000 # success to calculate secure_sum, it is 2000.0 # 单元测试 fate_test unittest federatedml --yes # there are 0 failed test ","date":"2023-02-26","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/fate%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/%E6%95%99%E7%A8%8B/:1:1","tags":["FATE联邦学习"],"title":"机器学习-FATE联邦学习-教程","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/fate%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/%E6%95%99%E7%A8%8B/"},{"categories":["机器学习"],"content":"文档 ","date":"2023-02-26","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/fate%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/%E6%95%99%E7%A8%8B/:2:0","tags":["FATE联邦学习"],"title":"机器学习-FATE联邦学习-教程","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/fate%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/%E6%95%99%E7%A8%8B/"},{"categories":["机器学习"],"content":"FATE设计 架构 逻辑架构 overview\r物理架构 主要使用eggroll物理架构 eggroll\r组件 FATE组件官网 联邦统计: 包括隐私交集计算，并集计算，皮尔逊系数, PSI等 联邦信息检索：基于OT的PIR(SIR) 联邦特征工程：包括联邦采样，联邦特征分箱，联邦特征选择等 联邦机器学习算法：包括横向和纵向的联邦LR, GBDT， DNN，迁移学习, 无监督学习，纵向半监督学习等 模型评估：提供对二分类，多分类，回归评估，聚类评估，联邦和单边对比评估 安全协议：提供了多种安全协议，以进行更安全的多方交互计算 pipline也可以作为组件被添加到新pipline。 算法参数 ","date":"2023-02-26","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/fate%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/%E6%95%99%E7%A8%8B/:2:1","tags":["FATE联邦学习"],"title":"机器学习-FATE联邦学习-教程","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/fate%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/%E6%95%99%E7%A8%8B/"},{"categories":["机器学习"],"content":"开发资源 开发指南 为 FATE 开发可运行的算法模块（py文件） 对于xxx算法模块 1. 定义此模块将使用的参数对象 参数对象是将用户定义的运行时参数传递给开发模块的唯一途径，每个模块都有其自己的参数对象 在FATE/python/faderatedml/param目录下新建xxx_param.py，定义继承BaseParam的参数类 在init方法调用基类的init方法(super(LogisticParam, self).__init__())并添加模块使用的所有参数 重载BaseParam的check方法，检查参数是否可用，对于不可用的参数实例抛出ValueError(\"xxx\")异常。未实现check方法的参数类会在使用时抛出异常 2. 定义新模块的meta文件 向FATE-Flow模块描述如何启动算法模块程序 在FATE/python/federatedml/components/目录下新建xxx.py作为meta文件 配置文件： 传入xxx定义ComponentMeta实例：xxx_cpn_meta = ComponentMeta(\"XXX\")，xxx为小写_分隔单词，XXX为dls中调用的模块名使用大驼峰，比如：hetero_lr_cpn_meta = ComponentMeta(\"HeteroLR\") 使用装饰器xxx_cpn_meta.bind_runner.on_$role绑定模块对象到每个角色，可以将多个角色绑定到一个模块对象：xxx_cpn_meta.bind_runner.on_$role1.on_$role2.on_$role3 使用装饰器xxx_cpn_meta.bind_param将参数对象绑定到定义的组件，函数返回参数对象即可 3. 定义此模块的传递变量py文件并生成传递变量对象（可选） 不同参与方之间存在信息交互时 在FATE/python/federatedml/transfer_variable/transfer_class中新建py文件，新建一个继承BaseTransferVariables类的XXXTransferVariable类，定义相应的变量，并为其赋予需要的传输权限 1 2 3 4 5 6 7 from federatedml.transfer_variable.base_transfer_variable import BaseTransferVariables class HeteroLRTransferVariable(BaseTransferVariables): def __init__(self, flowid=0): super().__init__(flowid) self.batch_data_index = self._create_variable(name='batch_data_index', src=['guest'], dst=['host']) ... name:变量名 src:交互信息从何处发出，应为 “guest”，“host”，“arbiter” 的列表 dst:交互信息发送到何处，应为 “guest”，“host”，“arbiter” 的列表 4. 定义算法模块（继承 model_base） fate_flow_client 模块的运行规则 从数据库中检索fate的组件注册信息，获取component的每个role对应的运行对象 初始化各方的运行对象 调用运行对象的 run 方法 如果需要，调用 save_data 方法或 export_model 方法 继承python/federatedml/model_base.py中的ModelBase对象，init方法中指定一些模块信息并指定参数对象 1 2 3 4 5 6 7 8 9 10 11 12 def __init__(self): super().__init__() self.model_name = 'HeteroLogisticRegression' self.model_param_name = 'HeteroLogisticRegressionParam' self.model_meta_name = 'HeteroLogisticRegressionMeta' self.mode = consts.HETERO self.aggregator = None self.cipher = None self.batch_generator = None self.gradient_loss_operator = None self.converge_procedure = None self.model_param = HeteroLogisticParam() 需要时重载fit方法：def fit(self, train_data, validate_data=None):。fit方法是启动建模组件的训练，或者特征工程组件的fit功能的入口。接受train_data训练数据和validate验证集数据，验证集数据可不提供。该函数在用户启动训练任务时，被model_base自动调起 需要时重载 predict 方法：def predict(self, data_inst):。data_inst 是一个 Table， 用于建模组件的预测功能。在用户启动预测任务时，将被model_base自动调起，训练任务中，建模组件也会调用predict函数对训练数据和验证集数据（如果有）进行预测，并输出预测结果。后续希望接入evaluation，需要输出符合下列格式的Table： 二分类，多分类，回归任务返回一张表 表的格式为: [\"label\", \"predict_result\", \"predict_score\", \"predict_detail\", \"type\"] 聚类任务返回两张表，第一张的格式为: [\"cluster_sample_count\", \"cluster_inner_dist\", \"inter_cluster_dist\"]，第二张表的格式为: [\"predicted_cluster_index\", \"distance\"] 需要时重载 transform 方法：def transform(self, data_inst):，data_inst 是一个 Table, 用于特征工程组件对数据进行转化功能。用户启动预测任务时，将被model_base自动调起 定义 save_data 方法：fate-flow 通过它获取输出数据。 1 2 def save_data(self): return self.data_output 5. 定义模型保存所需的protobuf 为了方便模型跨平台保存和读取模型，FATE使用protobuf文件定义每个模型所需的参数和模型内容。在FATE/python/federatedml/protobuf/proto/目录新建proto文件，python protobuf 教程 一个模型需要两个proto文件，后缀为meta的文件中保存某一次任务的配置，后缀为param的文件中保存某次任务的模型结果 定义完文件后执行该目录下的proto_generate.sh文件生成对应的py文件，之后可以在项目中引用proto类型 定义 export_model 方法：fate-flow 通过它获取输出的模型，模型同时包含 “Meta” 和 “Param” 产生的proto buffer类的 dict 格式，如 1 2 3 4 5 6 7 8 def export_model(self): meta_obj = self._get_meta() param_obj = self._get_param() result = { self.model_meta_name: meta_obj, self.model_param_name: param_obj } return result 6. 开发Pipeline组件 在python/fate_client/pipeline/component中添加自己的组件，见pipline 7. 重启fate flow服务 重启fate flow从而让其发现新加的组件 1 python fate_flow_server.py --debug # debug进行代码热重载 开始建模任务 第一步: 上传数据 第二步: 开始建模任务 第三步: 检查日志文件 FATE Pipeline pipline官方文档 Pipeline 是一种高级 Python API，允许用户以顺序方式设计、启动和查询 FATE job作业。FATE Pipeline 设计为用户友好且与 FATE 命令行工具的行为一致。用户可以通过向管道添加组件来自定义工作流程，然后通过一次调用启动一个作业。 FATE 作业是有向无环图（dag） FATE 作业是一个由算法组件节点组成的 dag。FATE 管道提供易于使用的工具来配置任务的顺序和设置。 FATE 以模块化风格编写。模块是具有输入和输出数据的模型。当一个模块的输出设置为另一个模块的输入时，两个模块被连接。 FATE 作业实际上是由一系列子模块组成的。 安装Pipeline 安装fate_client会自动安装pipline命令 1 pip install fate_client 使用pipline之前外面需要指定连接的FATE Flow Service，类似聚合服务器，在单机部署的Fate里面默认是127.0.0.1:9380。执","date":"2023-02-26","objectID":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/fate%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/%E6%95%99%E7%A8%8B/:2:2","tags":["FATE联邦学习"],"title":"机器学习-FATE联邦学习-教程","uri":"/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/fate%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/%E6%95%99%E7%A8%8B/"},{"categories":["P4"],"content":"P4-utils官方文档 P4-utils详细API参考 ","date":"2023-02-24","objectID":"/posts/p4/p4-utils%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["P4"],"title":"P4-P4 Utils学习笔记","uri":"/posts/p4/p4-utils%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["P4"],"content":"介绍 P4-Utils 是一个 Python 包，允许用户创建和测试可以包含 P4 交换机的虚拟网络。 P4是一种特定领域的编程语言，它指定数据平面设备如何处理数据包。 p4app由P4社区创建，提供基于P4语言的测试和原型平台。P4-Utils是ETH Networked Systems Group为简化p4app使用和开发而进行改进的成果。 ","date":"2023-02-24","objectID":"/posts/p4/p4-utils%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["P4"],"title":"P4-P4 Utils学习笔记","uri":"/posts/p4/p4-utils%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["P4"],"content":"安装与卸载 前提条件 安装PI LIBRARY REPOSITORY为 P4Runtime 服务器提供了一个实施框架。 安装BEHAVIORAL MODEL (bmv2)提供软件交换机（simple_switch和 simple_switch_grpc）的实现 安装P4c提供P4编译器 安装mininet提供网络模拟环境 安装FRRouting提供用于 Linux 和 Unix 平台的免费开源 Internet 路由协议套件 安装 1 2 3 git clone https://github.com/nsg-ethz/p4-utils cd p4-utils sudo ./install.sh 卸载 1 sudo ./uninstall.sh ","date":"2023-02-24","objectID":"/posts/p4/p4-utils%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["P4"],"title":"P4-P4 Utils学习笔记","uri":"/posts/p4/p4-utils%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["P4"],"content":"用法 仅考虑python脚本方法，不考虑json方法 ","date":"2023-02-24","objectID":"/posts/p4/p4-utils%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["P4"],"title":"P4-P4 Utils学习笔记","uri":"/posts/p4/p4-utils%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["P4"],"content":"网络设置 创建一个网络 1 2 3 from p4utils.mininetlib.network_API import NetworkAPI net = NetworkAPI() 设置脚本执行期间显示的日志的详细程度（debug，info，output，warning，error，critical） 1 net.setLogLevel('info') 默认情况下，网络主机的 ARP 表在网络启动时以静态方式填充。disableArpTables()和disableGwArp()方法为同一子网内的主机及其网关禁用静态 ARP 条目。 添加节点，确保都具有唯一的名称 1 2 net.addP4Switch('s1') net.addHost('h1') 用P4程序来配置P4交换机，支持相对路径和绝对路径，该文件将被编译，然后配置给交换机 1 net.setP4Source('s1','l2_forwarding.p4') 添加链接，链接的节点预先添加 1 net.addLink('s1', 'h1') 可以指定节点对于链接的端口号，不指定端口号，将执行自动分配。自动分配规则是固定的，所以网络脚本的多次执行自动分配的端口号是一致的。 1 net.setIntfPort('s1', 'h1', 1) # Set the number of the port on s1 facing h1 可以限制链接带宽 1 2 3 4 # 单个链接的带宽 net.setBw('s1','h1', 5) # 一次性设置所有链接的带宽 net.setBwAll(5) 3种方式为节点分配 IP 和 MAC 默认所有节点的IP位于网段10.0.0.0/8，MAC地址是随机的 为每个接口手动指定IP和MAC setIntfIp()方法设置IP地址：net.setIntfIp('h1','s1','10.0.0.1/24') # The interface of h1 facing s1 has IP 10.0.0.1/24 setIntfMac()方法设置MAC地址：net.setIntfIp('h1','s1','00:00:00:00:00:01') # The interface of h1 facing s1 has MAC 00:00:00:00:00:01 预定义的自动分配策略，后面会详细讲解： l2策略：net.l2() mixed：net.mixed() l3：net.l3() 所有主机都在一个网段可以设置l2策略 然后可以设置节点通用选项。比如为 P4 交换机启用.pcap文件转储和日志记录 1 2 3 4 5 6 # 为所有交换机配置 net.enablePcapDumpAll(pcap_dir='./pcap') net.enableLogAll(log_dir='./log') # 为指定交换机配置 net.enablePcapDump(name, pcap_dir='./pcap') net.enableLog(name, log_dir='./log') 启用网络客户端并启动网络 1 2 net.enableCli() net.startNetwork() 执行网络，以超级用户权限运行 Python 脚本 1 sudo python3 network.py ","date":"2023-02-24","objectID":"/posts/p4/p4-utils%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:1","tags":["P4"],"title":"P4-P4 Utils学习笔记","uri":"/posts/p4/p4-utils%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["P4"],"content":"自动分配策略 主机命名为hi，交换机命名为si，i为数字 l2 将所有设备置于同一个 IPv4 网段中 ( 10.0.0.0/16) 主机ip分配为10.0.x.y/16，x和y为主机id的高字节和低字节 mixed 将连接到同一交换机的主机置于同一子网中，将不同的交换机（甚至连在一起的交换机）置于不同的子网中。 主机ip：10.x.y.z/24，x和y为网关交换机id的高字节和低字节，z为主机id 直连所在网段的交换机端口：10.x.y.254/24，x和u分别是网关交换机id的高字节和低字节 两个交换机互联的端口：20.sw1.sw2.\u003c1,2\u003e/24，按链接定义的顺序，sw1是第一个交换机的ID，sw2是第二个交换机的id。最后一个字节，第一个交换机接口为1，第二个交换机接口为2。 l3 每台主机置于不同子网。 主机ip：10.x.y.2/24，x是网关交换机的id，y是主机id 直连主机的交换机端口：10.x.y.1/24，x是网关交换机id，y是主机id 两个交换机互联的端口：20.sw1.sw2.\u003c1,2\u003e/24，按链接定义的顺序，sw1是第一个交换机的ID，sw2是第二个交换机的id。最后一个字节，第一个交换机接口为1，第二个交换机接口为2 ","date":"2023-02-24","objectID":"/posts/p4/p4-utils%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:2","tags":["P4"],"title":"P4-P4 Utils学习笔记","uri":"/posts/p4/p4-utils%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["P4"],"content":"网络客户端 由p4utils.mininetlib.cli.P4CLI实现 查看连通性 1 mininet \u003e pingall 查看命令列表 1 mininet\u003e ? ","date":"2023-02-24","objectID":"/posts/p4/p4-utils%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:3","tags":["P4"],"title":"P4-P4 Utils学习笔记","uri":"/posts/p4/p4-utils%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["P4"],"content":"控制平面配置 这里介绍Thrift客户端方式，py编程方式见高级用法 连接Thrift客户端 1 simple_switch_CLI --thrift-port 9090 --thrift-ip 127.0.0.1 查看命令列表，查看命令说明 1 2 RuntimeCmd: ? RuntimeCmd: help \u003ccommand\u003e 填充交换机的动作匹配表 1 RuntimeCmd: table_add dmac forward 00:00:0a:00:00:01 =\u003e 1 使用命令文件 1 net.setP4CliInput('s1', 's1-commands.txt') ","date":"2023-02-24","objectID":"/posts/p4/p4-utils%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:4","tags":["P4"],"title":"P4-P4 Utils学习笔记","uri":"/posts/p4/p4-utils%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["P4"],"content":"高级用法 ","date":"2023-02-24","objectID":"/posts/p4/p4-utils%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","tags":["P4"],"title":"P4-P4 Utils学习笔记","uri":"/posts/p4/p4-utils%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["P4"],"content":"控制平面配置 ThriftAPI 由 SimpleSwitchThriftAPI 实现，该控制器与交换机内置的 Thrift 客户端通信(与Thrift命令行客户端的方式是一样的) 控制器脚本可以和创建网络脚本分开，独立作为一个python脚本文件，首先导入配置 P4 交换机所需的模块 1 from p4utils.utils.sswitch_thrift_API import SimpleSwitchThriftAPI 新建控制器 1 controller = SimpleSwitchThriftAPI(9090,\"127.0.0.1\") # 可以省略默认9090，127.0.0.1 使用方法table_add()填充动作匹配表 1 controller.table_add('dmac', 'forward', ['00:00:0a:00:00:01'], ['1']) 运行python文件即可实现控制器功能 1 python3 controller.py P4Runtime API 由 SimpleSwitchP4RuntimeAPI 实现，只能与支持 P4Runtime 的交换机一起使用（比如P4RuntimeSwitch） 使用 Python 启用 P4Runtime 1 2 3 net.setCompiler(p4rt=True) # 用addP4RuntimeSwtich替换addP4Switch方法 net.addP4RuntimeSwtich('s1') 创建控制器 1 2 3 4 from p4utils.utils.sswitch_p4runtime_API import SimpleSwitchP4RuntimeAPI controller = SimpleSwitchP4RuntimeAPI(device_id=1, grpc_port=9559,p4rt_path='l2_forwarding_p4rt.txt', json_path='l2_forwarding.json') p4rt_path参数和json_path参数对应的文件由P4编译器生成，省略device_id参数按声明顺序从1开始依次加1，省略grpc_port参数按声明顺序从9559开始依次加1 填充动作匹配表 1 controller.table_add('dmac', 'forward', ['00:00:0a:00:00:01'], ['1']) 最后同样是运行脚本 1 python3 controller.py ","date":"2023-02-24","objectID":"/posts/p4/p4-utils%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:1","tags":["P4"],"title":"P4-P4 Utils学习笔记","uri":"/posts/p4/p4-utils%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["P4"],"content":"拓扑数据库 P4-Utils内置了一个网络启动后自动生成的拓扑数据库，保存在执行目录下的一个JSON文件中，通常叫做topology.json. 可以查询此文件以检索拓扑信息。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from p4utils.utils.helper import load_topo from p4utils.utils.sswitch_p4runtime_API import SimpleSwitchP4RuntimeAPI topo = load_topo('topology.json') controller = SimpleSwitchP4RuntimeAPI(topo['s1']['device_id'], topo['s1']['grpc_port'], p4rt_path=topo['s1']['p4rt_path'], json_path=topo['s1']['json_path']) for neigh topo.get_neighbors('s1'): if topo.isHost(neigh): controller.table_add('dmac', 'forward', [topo.get_host_mac(neigh)], [str(topo.node_to_node_port_num('s1', neigh))]) ","date":"2023-02-24","objectID":"/posts/p4/p4-utils%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:2","tags":["P4"],"title":"P4-P4 Utils学习笔记","uri":"/posts/p4/p4-utils%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["P4"],"content":"任务调度程序 Task Scheduler 允许用户在不同的节点上简单地安排不同的任务（例如流量的生成） 使用网络客户端安排任务 1 mininet \u003e task \u003c node \u003e \u003c start \u003e \u003c duration \u003e \u003c exe \u003e [ \u003c arg1 \u003e ] ... [ \u003c argN \u003e ] [ -- mod \u003c module \u003e ] [ --\u003c key1 \u003e \u003c kwarg1 \u003e ] ... [ --\u003c keyM \u003e \u003c kwargM \u003e ] node是节点名称 exe是要运行的可执行文件（shell 字符串命令或 Python 函数的名称） argX是传递函数的位置参数（可选） start是相对于当前时间的任务延迟秒数 duration是以秒为单位的任务持续时间（如果持续时间小于或等于 0，则任务没有时间限制） keyX和kwargX是传递函数的关键字参数（可选） 查找函数的默认模块是p4utils.utils.traffic_utils. 可以在–mod 命令中指定不同的模块。 例子 1 mininet\u003e task h1 0 10 \"ping 10.0.0.2\" 使用文件调度任务 与网络客户端任务语法一致，但省略task关键字，并且每行一个任务 如tasks.txt 1 2 h1 30 10 \"ping 10.0.0.2\" h3 10 30 \"ping 10.0.0.4\" 然后添加task到网络中 1 net.addTaskFile('tasks.txt') ","date":"2023-02-24","objectID":"/posts/p4/p4-utils%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:3","tags":["P4"],"title":"P4-P4 Utils学习笔记","uri":"/posts/p4/p4-utils%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"python官网标准库参考 python官网标准库详细文档索引 python官网语言参考文档 这个模块提供了访问 BSD 套接字 的接口 ","date":"2023-02-24","objectID":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/socket/:0:0","tags":["Python标准库"],"title":"Python-标准库-Socket","uri":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/socket/"},{"categories":["Python"],"content":"常用函数 socket.gethostbyaddr(ip_address)：返回三元组 (hostname, aliaslist, ipaddrlist)，hostname 是响应给定 ip_address 的主要主机名，aliaslist 是相同地址的其他可用主机名的列表（可能为空），而 ipaddrlist 是 IPv4/v6 地址列表，包含相同主机名、相同接口的不同地址（很可能仅包含一个地址） ","date":"2023-02-24","objectID":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/socket/:1:0","tags":["Python标准库"],"title":"Python-标准库-Socket","uri":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/socket/"},{"categories":["Python"],"content":"python官网标准库参考 python官网标准库详细文档索引 python官网语言参考文档 ","date":"2023-02-24","objectID":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/os/:0:0","tags":["Python标准库"],"title":"Python-标准库-Os","uri":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/os/"},{"categories":["Python"],"content":"常用函数 os.popen(cmd, mode=‘r’, buffering=-1):新建一个|管道进程，执行cmd命令，返回连接到管道的文件对象，根据mode是r还是w决定是否可读写。只能读写文本。如果正常子进程正常退出则该文件对象的close()方法返回None，否则返回子进程的返回码（POSIX系统返回码为正是进程返回值左移一个字节的值，如果为负则为信号终止值为- signal.XXX），子命令执行完后，文件对象存储的子命令的输出。底层使用subprocess.Popen类实现。 os.getcwd():获取当前工作目录 ","date":"2023-02-24","objectID":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/os/:1:0","tags":["Python标准库"],"title":"Python-标准库-Os","uri":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/os/"},{"categories":["Python"],"content":"PYPI官网 scapy官网 scapy官网文档 scapy官网api scapy官方api常用文档，scapy.layers package，scapy.layers.inet，scapy.sendrecv CSDN 迅鹿 libpcap使用整理 CSDN micromicrofat libpcap、struct、dpkt、scapy、pyshark五种方式获取pcap原始包的速度对比 ","date":"2023-02-20","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/:0:0","tags":["Python第三方库"],"title":"Python-第三方库-Scapy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/"},{"categories":["Python"],"content":"通用文档 ","date":"2023-02-20","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/:1:0","tags":["Python第三方库"],"title":"Python-第三方库-Scapy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/"},{"categories":["Python"],"content":"介绍 Scapy 是一个 Python 程序，它使用户能够发送、嗅探、剖析和伪造网络数据包。此功能允许构建可以探测、扫描或攻击网络的工具。 Scapy主要做两件事：发送数据包和接收应答。和go的gopackage的功能是类似的。 运行机制\r","date":"2023-02-20","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/:1:1","tags":["Python第三方库"],"title":"Python-第三方库-Scapy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/"},{"categories":["Python"],"content":"下载安装 类型 包含 命令 默认 只有 Scapy pip install scapy 基本的 Scapy 和 IPython。强烈推荐 pip install --pre scapy[basic] 完全的 Scapy 及其所有主要依赖项 pip install --pre scapy[complete] ","date":"2023-02-20","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/:1:2","tags":["Python第三方库"],"title":"Python-第三方库-Scapy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/"},{"categories":["Python"],"content":"用法 启动 Scapy 1 scapy 脚本 1 from scapy.all import * ","date":"2023-02-20","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/:1:3","tags":["Python第三方库"],"title":"Python-第三方库-Scapy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/"},{"categories":["Python"],"content":"变量 conf.use_pcap:提供原生套接字和libpcap套接字，默认使用原生套接字，设为true将socket指向conf.L2socket和conf.L3socket ","date":"2023-02-20","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/:2:0","tags":["Python第三方库"],"title":"Python-第三方库-Scapy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/"},{"categories":["Python"],"content":"常用函数 rdpcap(pwd):读取pwd pcap文件，可以是绝对路径和相对路径，返回PacketList pdfdump(pwd,layer_shift=1):图形转储为pwd文件，可以是绝对路径和相对路径，pwd为None时为临时文件，需要安装PyX和TexLive wrpcap(“temp.cap”,pkts):将pkts存储为temp.cap save_session():保存所有python会话变量 load_session():加载保存的python会话变量 arp_mitm(“192.168.122.156”, “192.168.122.17”):实施arp中间人攻击，需要设置sysctl net.ipv4.conf.virbr0.send_redirects=0 # virbr0 = interface;sysctl net.ipv4.ip_forward=1 lsc()：可用函数 ls()：可用层列表 explore()：显示现有图层的图形界面 send():发送第 3 层数据包，loop参数选择发送次数 sendp():发送第 2 层数据包，可以配置网卡接口和链路层协议，iface参数选择网卡接口，inter参数设置数据包发送间隔 sr():函数用于发送 3 层数据包和接收响应，该函数返回(ans SndRcvList,unans PacketList)，ans是被响应的(数据包,响应)，unans是未响应数据包集，retry 指定重新发送未应答的数据包最大次数，timeout参数指定发送完最后一个数据包后等待的时间。threaded开启新线程来发送（开了时间优化），filter参数使用BPF过滤器（注意BPF过滤器的语法ip指的是含有ip头，那么icmp包，udp包或者http包等应用层数据包也能被嗅探到）所有的具有接收功能的函数都具有这个参数。 sr1():返回一个数据包，该数据包响应了发送的 3 层数据包（或数据包集）， srp():对第 2 层数据包（以太网、802.3 等）执行sr函数相同的操作，返回值类型也相同 srloop():循环发送和接收包 fuzz():生成数据包对象，除了你给出的参数和需要计算的数据包字段如校验和，其他字段都是随机的。注意：IP 层 src 和 dst 参数不能使用fuzz()随机而是使用 RandIP() RawVal():注入一些不适合该类型的值，pkt = IP(len=RawVal(b\"NotAnInteger\"), src=\"127.0.0.1\") sniff():嗅探网卡接口，filter参数设置操作系统的 BPF 过滤器，count设置嗅探数据包个数，iface设置选择的网卡, prn设置处理函数，session参数可以对同一session的碎片数据包进行整理后处理，这里有一个特殊参数offline用于读取pcap文件，lfilter参数的值是一个函数用于再prn参数和filter参数之间进行一个过滤 freeCodeCamp.org 如何使用 Scapy——Python 网络工具详解 load_module(“p0f”):载入其他程序，比如p0f p0f(p):调用p0f验证发送数据包p机器的操作系统类型 hexdump(pkt,True):将层转换为十六进制串 import_hexcap(a):将十六进制串转换为Raw二进制字符串 raw(pkt):将层转换为Raw二进制字符串 export_object(pkt):将层转换为Base64编码 import_object(a):将Base64编码转换为Raw二进制字符串 in4_chksum(socket.IPPROTO_UDP, packet[IP], udp_raw):计算checksum，packet[IP]为IP头，udp_raw为udp包 ","date":"2023-02-20","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/:3:0","tags":["Python第三方库"],"title":"Python-第三方库-Scapy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/"},{"categories":["Python"],"content":"packet ","date":"2023-02-20","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/:4:0","tags":["Python第三方库"],"title":"Python-第三方库-Scapy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/"},{"categories":["Python"],"content":"Packet 数据包类 变量 payload:负载 name:名字 常用方法 add_payload():添加负载 copy():深拷贝该数据包实例 sprintf(format[, relax=1])→ str:格式化输出数据包信息，p.sprintf(\"This is a{TCP: TCP}{UDP: UDP}{ICMP:n ICMP} packet\") lastlayer(layer: Packet | None = None)→ Packet:返回最上层 layers()→ List[Type[Packet]:返回该数据包具有的层类型组成的列表 remove_payload()→ None:移除负载 remove_underlayer(other: Packet)→ None:移除层 show()：数据包的开发视图 show2()：在show的基础上加上校验和 decode_payload_as()：更改有效负载的解码方式 getlayer(cls: int | Type[Packet] | str, nb: int = 1, _track: List[int] | None = None, _subclass: bool | None = None, **flt: Any)→ Packet | None:获取某层，如果没有返回None 运算符 []:取数据包的层 /运算符组合两层或字符串 ","date":"2023-02-20","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/:4:1","tags":["Python第三方库"],"title":"Python-第三方库-Scapy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/"},{"categories":["Python"],"content":"Raw Packet的子类 二进制串 ","date":"2023-02-20","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/:4:2","tags":["Python第三方库"],"title":"Python-第三方库-Scapy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/"},{"categories":["Python"],"content":"layer layer指的是Packet的一系列子类，比如IP，TCP等 layer类官方文档 layer.inet官方文档 ","date":"2023-02-20","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/:5:0","tags":["Python第三方库"],"title":"Python-第三方库-Scapy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/"},{"categories":["Python"],"content":"属性 属性通过.运算符访问 ","date":"2023-02-20","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/:5:1","tags":["Python第三方库"],"title":"Python-第三方库-Scapy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/"},{"categories":["Python"],"content":"运算符 1 2 IP()/TCP()/\"GET / HTTP/1.0\\r\\n\\r\\n\" Ether()/IP()/IP()/UDP() del(a.ttl)内置函数删除层属性配置 =进行赋值，层之间可以任意赋值，但是只会解析该类型层的属性，其余不能解析的都作为raw对象放到最后面 ","date":"2023-02-20","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/:5:2","tags":["Python第三方库"],"title":"Python-第三方库-Scapy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/"},{"categories":["Python"],"content":"常用函数 raw(pkt):将层转换为Raw二进制字符串 hexdump(pkt):十六进制转储 ls(pkt):字段值列表 ","date":"2023-02-20","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/:5:3","tags":["Python第三方库"],"title":"Python-第三方库-Scapy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/"},{"categories":["Python"],"content":"常用方法 hide_defaults()：不显示与默认值相同的字段 summary()：一行总结 psdump()：绘制带有解释的 PostScript 图 pdfdump()：绘制带有解释的 PDF command()：返回可以生成该数据包的 Scapy 命令 ","date":"2023-02-20","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/:5:4","tags":["Python第三方库"],"title":"Python-第三方库-Scapy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/"},{"categories":["Python"],"content":"PacketList 属性设置为元组，列表或者特殊字符串的layer表示多个layer，可以用他们构造PacketList对象，这样可以对他们进行类似列表操作 元组表示属性范围，列表表示单个属性，可以进行组合，ip字符串可以添加-符号来表示一段ip比如192.168.1.1-254 可以将数据包集转换到PacketList对象中，该对象提供一些列表操作 可以进行拆解遍历 1 2 3 4 p = PacketList(a) p = PacketList([p for p in a/c]) # 原文中这里的a是IP层集，c是TCP层集 for snd,rcv in p: ... 运算符 +:将结果加起来 常用方法： summary()：显示每个数据包的摘要列表，可以使用lambda表达式，比如ans.summary( lambda s,r: r.sprintf(\"%TCP.sport% \\t %TCP.flags%\") ) nsummary()：带有数据包编号 conversations()：显示对话图 show()：显示首选表示 filter()：返回使用 lambda 函数过滤的数据包列表 hexdump()：返回所有数据包的 hexdump hexraw()：返回所有数据包Raw二进制字符串的 hexdump padding()：返回带有填充的数据包的 hexdump nzpadding()：返回具有非零填充的数据包的 hexdump plot()：绘制应用于数据包列表的 lambda 函数 make_table()：根据 lambda 函数显示表格，lambda表达式接收p为层，返回第一个参数是列名，第二个参数是行名，第三个参数是单元格中的名称 语法 1 2 for p in packetlist: ... ","date":"2023-02-20","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/:6:0","tags":["Python第三方库"],"title":"Python-第三方库-Scapy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/"},{"categories":["Python"],"content":"SndRcvList 其实就是QueryAnswer的列表 可以进行拆解遍历 1 2 for snd,rcv in ans: ... 变量 res:QueryAnswer类型的列表 运算符 +:将结果加起来 常用方法 make_table()：根据 lambda 函数显示表格，lambda表达式接收s和r作为发送数据包和响应数据包，返回第一个参数是列名，第二个参数是行名，第三个参数是单元格中的名称 1 2 3 ans.make_table( lambda s,r: (s.dst, s.dport, r.sprintf(\"{TCP:%TCP.flags%}{ICMP:%IP.src% - %ICMP.type%}\"))) PacketList.plot()：绘制应用于数据包列表的 lambda 函数 1 a.plot(lambda x:x[1].id) 语法 1 2 for s,r in sndrcvList: ... ","date":"2023-02-20","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/:7:0","tags":["Python第三方库"],"title":"Python-第三方库-Scapy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/"},{"categories":["Python"],"content":"TracerouteResult 并行发送包，返回和sr类似的结果，因为TracerouteResult继承自SndRcvList，可以将SndRcvList的res属性转换为TracerouteResult：a = TracerouteResult(a.res)，这个可以在traceroute函数里面看见，另外SndRcvList具有的属性和方法它也有 变量 res:QueryAnswer类型的列表 常用函数 TracerouteResult(SndRcvList.res):将SndRcvList类型对象转换为TracerouteResult对象 traceroute():对目标ip进行普通基于icmp不可达报文的transroute，maxttl参数设置最大ttl，minttl参数设置最小ttl，l4参数可以添加第四层负载 运算符 +:将结果加起来 常用方法 graph():制作有向图，根据AS进行聚类，需要安装graphviz，非常好用，target设置保存位置支持相对路径和绝对路径，不设置target表示作为临时文件打开 trace3D():安装了 VPython们可以对traceroute的结果对象进行3D表示 SndRcvList的方法 语法 1 2 for s,r in tracerouteresult: ... ","date":"2023-02-20","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/:7:1","tags":["Python第三方库"],"title":"Python-第三方库-Scapy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/"},{"categories":["Python"],"content":"ARPingResult 继承自SndRcvList，和TracerouteResult一样，可以通过a = ARPingResult(a.res)来新建ARPingResult对象 函数 arping(dstnet):发送arp包扫描局域网主机，返回ARPingResult和未响应数据包 PacketList的元组 ","date":"2023-02-20","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/:7:2","tags":["Python第三方库"],"title":"Python-第三方库-Scapy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/"},{"categories":["Python"],"content":"AsyncSniffer 异步嗅探允许以编程方式停止嗅探器而不是使用 ctrl^C，它使用start(),stop()和join()方法 常用函数: AsyncSniffer(iface=“enp0s3”, count=200):构造函数，iface参数选择嗅探网卡接口，count设置嗅探数据包数目，也可以使用prn，store，filter等参数 常用方法: start():开始嗅探 t.stop():停止嗅探并返回结果，结果为PacketList t.join():将异步线程join到主线程 t.results:返回嗅探结果 ","date":"2023-02-20","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/:8:0","tags":["Python第三方库"],"title":"Python-第三方库-Scapy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/"},{"categories":["Python"],"content":"route Scapy 有自己的路由表 conf.route 可以修改它以不同于系统路由表的方式路由数据包 conf.route:ipv4路由表 conf.route6:ipv6路由表 官网文档 常用函数 getmacbyip(“10.0.0.1”):获取ip的mac值 常用方法 conf.route.delt(net=“0.0.0.0/0”,gw=“192.168.8.1”):删除路由条目 conf.route.add(net=“0.0.0.0/0”,gw=“192.168.8.254”):添加路由条目 conf.route.resync():重置路由表，使其和系统一致 conf.route.route(“192.168.xxx.xxx”):查询路由结果，返回(interface, outgoing_ip, gateway)，可以通过\"0.0.0.0\"这个特殊地址查看默认网关 ","date":"2023-02-20","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/:9:0","tags":["Python第三方库"],"title":"Python-第三方库-Scapy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/"},{"categories":["Python"],"content":"QueryAnswer 运算符 [0]:query数据包 [1]:answer数据包 ","date":"2023-02-20","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/:10:0","tags":["Python第三方库"],"title":"Python-第三方库-Scapy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/"},{"categories":["Python"],"content":"网卡接口相关 变量 conf.ifaces:网卡接口列表，等价于IFACES conf.iface:默认网卡接口，默认网卡并没有什么用，因为始终是通过路由表来选择网卡的 函数 scapy不提供通过ip查主机名的函数，因为socket标准库的gethostbyaddr(ip)函数已经实现了这个功能 get_if_hwaddr(conf.iface):获取网卡的mac地址，可以传入网卡对象，也可以传入网卡的name属性对应的字符串 get_if_addr(conf.iface):获取网卡的ip地址，可以传入网卡对象，也可以传入网卡的name属性对应的字符串 ","date":"2023-02-20","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/:11:0","tags":["Python第三方库"],"title":"Python-第三方库-Scapy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/"},{"categories":["Python"],"content":"IFACES 方法 reload():重新加载网卡列表 dev_from_name():从名字获取网卡对象NetworkInterface dev_from_networkname():从网卡代码获取网卡对象 dev_from_index():从网卡索引获取网卡对象 ","date":"2023-02-20","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/:11:1","tags":["Python第三方库"],"title":"Python-第三方库-Scapy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/"},{"categories":["Python"],"content":"NetworkInterface 属性 name:网卡名称 description:网卡描述 network_name:网卡代码 index:网卡索引 ip:ip地址 mac:mac地址 方法 update():更新属性 ","date":"2023-02-20","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/:11:2","tags":["Python第三方库"],"title":"Python-第三方库-Scapy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/"},{"categories":["Python"],"content":"Scapy.Config.Conf class scapy.config.Conf 全局变量conf就是该类型的实例，该对象包含 Scapy 的配置 变量 AS_resolver: scapy.as_resolvers.AS_resolver= None ","date":"2023-02-20","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/:12:0","tags":["Python第三方库"],"title":"Python-第三方库-Scapy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/"},{"categories":["Python"],"content":"Scapy.as_resolvers.AS_resolver classscapy.as_resolvers.AS_resolver(server: str | None = None, port: int = 43, options: str | None = None)[source] ","date":"2023-02-20","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/:13:0","tags":["Python第三方库"],"title":"Python-第三方库-Scapy","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/scapy/"},{"categories":["Golang"],"content":"go语言中文网 godoc go语言中文网有很多文档缺少内容比如string.Builder就没有，godoc绝对详尽，推荐阅读godoc ","date":"2023-02-18","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/unicode/:0:0","tags":["go标准库"],"title":"go标准库-Unicode","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/unicode/"},{"categories":["Golang"],"content":"常用函数 func IsSpace(r rune) bool：报告一个字符是否是空白字符。 func IsDigit(r rune) bool：报告一个字符是否是十进制数字字符。 func IsNumber(r rune) bool：报告一个字符是否是数字字符 func IsLetter(r rune) bool：报告一个字符是否是数字字符 func IsLower(r rune) bool：返回字符是否是小写字母。 func IsUpper(r rune) bool：返回字符是否是大写字母。 func ToLower(r rune) rune：返回对应的小写字母。 func ToUpper(r rune) rune：返回对应的大写字母。 ","date":"2023-02-18","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/unicode/:1:0","tags":["go标准库"],"title":"go标准库-Unicode","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/unicode/"},{"categories":["操作系统"],"content":"ubuntu官方文档 ubuntu 18.04 server官方文档 linux265 ","date":"2023-02-18","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:0:0","tags":["linux"],"title":"操作系统-linux-个人笔记","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["操作系统"],"content":"文件权限 菜鸟教程 Linux 文件基本属性 12位四列，每列3位 第一列标记文件类型 -：普通文件 d：目录文件 b：块设备 c ： 字符设备 l ：符号链接文件 p：管道文件pipe s：套接字文件socket 后面3列分为文件所有者权限，文件所属组用户（所有者可以不在所属组中）权限和其他用户权限 每个用户可以设置r读，w写和x执行权限 ","date":"2023-02-18","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:1:0","tags":["linux"],"title":"操作系统-linux-个人笔记","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["操作系统"],"content":"Ubuntu无gui配置ip CSDN 白帽菜菜 CSDN zgrjddd 配置静态ip 1 vim /etc/network/interfaces 1 2 3 4 5 6 auto eth0 iface eth0 inet static address 192.168.126.114 netmask 255.255.255.0 gateway 192.168.126.2 broadcast 192.168.126.255 配置DNS解析器 1 vim /etc/resolv.conf 1 2 nameserver 8.8.8.8 nameserver 114.114.114.114 重启网络 1 sudo /etc/init.d/networking restart ","date":"2023-02-18","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:2:0","tags":["linux"],"title":"操作系统-linux-个人笔记","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["操作系统"],"content":"Ubuntu配置清华镜像源 见清华镜像源官网 验证ca证书出错时的解决办法 51CTO ubuntu 18.04换清华镜像源证书错误 将/etc/apt/sources.list配置源从https改为http apt update+apt install apt-transport-https ca-certificates 将配置改回来 ","date":"2023-02-18","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:3:0","tags":["linux"],"title":"操作系统-linux-个人笔记","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["操作系统"],"content":"wireshark 监听某个网卡上的数据包，lo是回环地址 添加过滤器：选择表达式，设置你要过滤的字段和过滤值，或者直接在过滤栏里面输入ip.src之类的字段，条件之间使用逻辑运算符连接\u0026\u0026、||、! ","date":"2023-02-18","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:4:0","tags":["linux"],"title":"操作系统-linux-个人笔记","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["操作系统"],"content":"图形化界面 CSDN antdz CSDN 丘上人 duoluosb ubuntu几种运行级：# 0 - 停机（千万不能把initdefault 设置为0 ）# 1 - 单用户模式 # 2 - 多用户，没有 NFS # 3 - 完全多用户模式(标准的运行级) # 4 - 没有用到 # 5 - X11 （xwindow) # 6 - 重新启动 （千万不要把initdefault 设置为6 ） 多用户字符模式下有6个默认tty，使用ctrl+alt+Fn切换，init 5会默认占用一个tty进行登录（通常时F1的tty），当登录一个用户时再占用另一个tty Linux本身没有图形界面，Linux现在的图形界面系统只是Linux下的应用程序 X是协议，不是具体的某个软件，它用于实现图形化界面，X协议主要由X应用程序和X服务器组成，X应用程序告诉服务器如何在屏幕上画图，XFree86是X服务器程序 WM（Window Manager，窗口管理器）的作用就是窗口的最大化、最小化、移动、关闭等。而这些不是X服务器来负责完成的。WM有GNOME和KDE。 X客户端程序 X客户端程序\rKDE、GNOME、QT和GTK直接关系：QT基础上实现的窗口管理器叫KDE，在GTK基础上实现的窗口管理器叫GNOME。KDE和GNOME并不只是窗口管理器，同时提供了桌面、菜单等等 命令： init n：以n启动级重启主机 startx：打开默认窗口管理器 xinit：打开图形化界面，基于X server twm，gnome-session，startkde：分别启动X服务器自带的twm窗口管理器、gnome窗口管理器或KDE窗口管理器 systemctl set-default xxx：设置默认启动级，graphical.target对应5，multi-user.target对应3 systemctl是systemd命令组的主命令，systemd是为了取代传统init的启动方式，详见linux常见命令systemd ","date":"2023-02-18","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:5:0","tags":["linux"],"title":"操作系统-linux-个人笔记","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["操作系统"],"content":"开机启动脚本 CSDN 土豆西瓜大芝麻 三种开机启动设置方法 /etc/rc.d/rc.local文件将会在开机时运行，所以可以在这个文件里面运行你要运行的脚本 crontab添加@reboot时间标记的条目 systemd方式，在/etc/systemd/system/中添加Unit配置文件比如命名为auto_run_script.service，并编辑 1 2 3 4 5 6 7 8 9 [Unit] Description=Run a Custom Script at Startup After=default.target [Service] ExecStart=/home/ok/auto_run_script.sh [Install] WantedBy=default.target 然后运行命令 1 2 3 4 # 加载添加的unit配置 systemctl daemon-reload # 激活unit配置 systemctl enable auto_run_script.service ","date":"2023-02-18","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:6:0","tags":["linux"],"title":"操作系统-linux-个人笔记","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["操作系统"],"content":"ubuntu卸载firefox，安装chrome CSDN broadview_java 卸载firefox 1 2 3 4 # 检查firefox安装的相关软件 dpkg --get-selections |grep firefox # 卸载相关的软件，remove会保留配置文件，purge不保留配置文件 sudo apt-get purge firefox firefox-locale-en firefox-locale-zh-hans 安装chrome 去官网下载或者直接wget deb包，然后dpkg -i安装 1 2 wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb dpkg -i google-chrome-stable_current_amd64.deb chrome不支持自动更新，如果要升级则把安装chrome步骤再做一遍 ","date":"2023-02-18","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:7:0","tags":["linux"],"title":"操作系统-linux-个人笔记","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["操作系统"],"content":"IO模型 CSDN #时代不杀菜鸡# ","date":"2023-02-18","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:8:0","tags":["linux"],"title":"操作系统-linux-个人笔记","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["操作系统"],"content":"阻塞与非阻塞 阻塞：调用方等待被调用方响应 非阻塞：不等待 ","date":"2023-02-18","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:8:1","tags":["linux"],"title":"操作系统-linux-个人笔记","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["操作系统"],"content":"同步与异步 同步：被调用方处理完后才响应 异步：被调用方收到请求后先返回已收到，处理完后通过回调方式通知调用方 ","date":"2023-02-18","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:8:2","tags":["linux"],"title":"操作系统-linux-个人笔记","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["操作系统"],"content":"5种IO模型 阻塞同步IO 非阻塞同步IO：轮询 （阻塞同步）IO复用 （非阻塞异步）信号驱动IO （非阻塞异步）异步IO ","date":"2023-02-18","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:8:3","tags":["linux"],"title":"操作系统-linux-个人笔记","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["操作系统"],"content":"select,poll和epoll 简书 VictorHong IO多路复用的三种方式 select poll epoll 操作方式 遍历 遍历 回调 底层实现 数组 链表 哈希表 IO效率 每次调用都进行线性遍历，时间复杂度为O(n) 每次调用都进行线性遍历，时间复杂度为O(n) 事件通知方式，每当fd就绪，系统注册的回调函数就会被调用，将就绪fd放到rdllist里面。时间复杂度O(1) 最大连接数 1024（x86）或 2048（x64） 无上限 无上限 fd拷贝 每次调用select，都需要把fd集合从用户态拷贝到内核态 每次调用poll，都需要把fd集合从用户态拷贝到内核态 调用epoll_ctl时拷贝进内核并保存，之后每次epoll_wait不拷贝 ","date":"2023-02-18","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:9:0","tags":["linux"],"title":"操作系统-linux-个人笔记","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["操作系统"],"content":"配置代理 linux265 分为用户代理和所有用户的代理配置 用户代理通常是在用户主目录里面添加配置文件，所有用户代理通常是在etc目录里面修改配置文件 ","date":"2023-02-18","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:10:0","tags":["linux"],"title":"操作系统-linux-个人笔记","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["操作系统"],"content":"ubuntu配置代理 .bashrc 1 2 3 4 5 6 7 8 9 10 11 export charles_socks_port=\"8888\" export charles_http_port=\"8889\" export charles_https_port=\"8889\" export v2ray_socks_port=\"10808\" export v2ray_http_port=\"10809\" export v2ray_https_port=\"10809\" export http_proxy=\"http://${proxy_addr}:${charles_http_port}\" export https_proxy=\"http://${proxy_addr}:${charles_https_port}\" export all_proxy=\"http://${proxy_addr}:${charles_socks_port}\" 另外安装完证书后，系统设置里面也要使用你宿主机的地址和代理端口号 注意主机防火墙的问题 对于连接到charles的虚拟机还需要安装证书 CSDN 滋滋ɷ 当配置的代理服务器需要身份验证时配置为以下形式： 1 export HTTPS_PROXY=\"http://user:password@host\" ","date":"2023-02-18","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:10:1","tags":["linux"],"title":"操作系统-linux-个人笔记","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["操作系统"],"content":"kali kali使用proxychains4或者proxychains，仅需要配置proxychains4.conf即可。 使用代理运行程序时将命令放到proxychains4后面即可。 1 proxychains msfconsole ","date":"2023-02-18","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:10:2","tags":["linux"],"title":"操作系统-linux-个人笔记","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["操作系统"],"content":"输入法切换快捷键 win+space ","date":"2023-02-18","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:11:0","tags":["linux"],"title":"操作系统-linux-个人笔记","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["操作系统"],"content":"启动主机转发功能 开启Linux系统路由转发功能 实现多网段电脑共享上网 仅对本次开机开启 1 echo \"1\" \u003e/proc/sys/net/ipv4/ip_forward 长期开启 修改/etc/sysctl.conf中net.ipv4.ip_forward为1 ","date":"2023-02-18","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:12:0","tags":["linux"],"title":"操作系统-linux-个人笔记","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["操作系统"],"content":"配置环境变量 百家号 Docker中文社区 基本都是在配置文件中添加：export PATH=$PATH:xxx 用户级别环境变量定义文件：~/.bashrc、~/.profile（部分系统为：~/.bash_profile） 系统级别环境变量定义文件：/etc/bashrc、/etc/profile (部分系统为：/etc/bash_profile)、/etc/environment ","date":"2023-02-18","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:13:0","tags":["linux"],"title":"操作系统-linux-个人笔记","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["Golang"],"content":"go语言中文网 godoc go语言中文网有很多文档缺少内容比如string.Builder就没有，godoc绝对详尽，推荐阅读godoc ","date":"2023-02-18","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/:0:0","tags":["go标准库"],"title":"go标准库-Os+io+bufio+ioutil","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/"},{"categories":["Golang"],"content":"os ","date":"2023-02-18","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/:1:0","tags":["go标准库"],"title":"go标准库-Os+io+bufio+ioutil","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/"},{"categories":["Golang"],"content":"Constants 1 2 3 4 5 6 7 8 9 10 const ( O_RDONLY int = syscall.O_RDONLY // 只读模式打开文件 O_WRONLY int = syscall.O_WRONLY // 只写模式打开文件 O_RDWR int = syscall.O_RDWR // 读写模式打开文件 O_APPEND int = syscall.O_APPEND // 写操作时将数据附加到文件尾部 O_CREATE int = syscall.O_CREAT // 如果不存在将创建一个新文件 O_EXCL int = syscall.O_EXCL // 和O_CREATE配合使用，文件必须不存在 O_SYNC int = syscall.O_SYNC // 打开文件用于同步I/O O_TRUNC int = syscall.O_TRUNC // 如果可能，打开时清空文件 ) ","date":"2023-02-18","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/:1:1","tags":["go标准库"],"title":"go标准库-Os+io+bufio+ioutil","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/"},{"categories":["Golang"],"content":"Variables 1 2 3 4 5 6 7 8 9 10 11 12 var ( Stdin = NewFile(uintptr(syscall.Stdin), \"/dev/stdin\") Stdout = NewFile(uintptr(syscall.Stdout), \"/dev/stdout\") Stderr = NewFile(uintptr(syscall.Stderr), \"/dev/stderr\") ) var ( ErrInvalid = errors.New(\"invalid argument\") ErrPermission = errors.New(\"permission denied\") ErrExist = errors.New(\"file already exists\") ErrNotExist = errors.New(\"file does not exist\") ) ","date":"2023-02-18","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/:1:2","tags":["go标准库"],"title":"go标准库-Os+io+bufio+ioutil","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/"},{"categories":["Golang"],"content":"常用function func Exit(code int)：让当前程序以给出的状态码code退出。 func Getuid() int：返回调用者的用户ID。 func Getwd() (dir string, err error)：Getwd返回一个对应当前工作目录的根路径。如果当前目录可以经过多条路径抵达（因为硬链接），Getwd会返回其中一个。 func Chdir(dir string) error：Chdir将当前工作目录修改为dir指定的目录。 ","date":"2023-02-18","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/:1:3","tags":["go标准库"],"title":"go标准库-Os+io+bufio+ioutil","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/"},{"categories":["Golang"],"content":"type FileInfo 1 2 3 4 5 6 7 8 type FileInfo interface { Name() string // 文件的名字（不含扩展名） Size() int64 // 普通文件返回值表示其大小；其他文件的返回值含义各系统不同 Mode() FileMode // 文件的模式位 ModTime() time.Time // 文件的修改时间 IsDir() bool // 等价于Mode().IsDir() Sys() interface{} // 底层数据来源（可以返回nil） } func Stat(name string) (fi FileInfo, err error)：Stat返回一个描述name指定的文件对象的FileInfo。对于符号连接会自动跳转，出错返回PathError func Lstat(name string) (fi FileInfo, err error)：和Stat一样但是不跳转 ","date":"2023-02-18","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/:1:4","tags":["go标准库"],"title":"go标准库-Os+io+bufio+ioutil","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/"},{"categories":["Golang"],"content":"type File func Create(name string) (file *File, err error)：采用模式0666（任何人都可读写，不可执行）创建一个名为name的文件，如果文件已存在会截断它（为空文件） func Open(name string) (file *File, err error)：Open打开一个文件用于读取，底层也是调用OpenFile。 func OpenFile(name string, flag int, perm FileMode) (file *File, err error)：指定的选项（如O_RDONLY等）、指定的模式（如0666等）打开指定名称的文件，模式参数用于创建不存在的文件时指定其模式，对于读取和写入可以直接传入0 func NewFile(fd uintptr, name string) *File func Mkdir(name string, perm FileMode) error：使用指定的权限和名称创建一个目录 func Rename(oldpath, newpath string) error：修改一个文件的名字，移动一个文件 方法 func (f *File) Read(b []byte) (n int, err error)：ReadAt从指定的位置（相对于文件开始位置）读取len(b)字节数据并写入b。到达文件结尾，返回值err会是io.EOF。 func (f *File) Write(b []byte) (n int, err error)：Write向文件中写入len(b)字节数据。 func (f *File) WriteString(s string) (ret int, err error)：写入字符串 func (f *File) Seek(offset int64, whence int) (ret int64, err error)：设置下一次读/写的位置。offset为相对偏移量，而whence决定相对位置：0为相对文件开头，1为相对当前位置，2为相对文件结尾。它返回新的偏移量（相对开头）和可能的错误。 func (f *File) Close() error：关闭文件，通常与defer一起使用 ","date":"2023-02-18","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/:1:5","tags":["go标准库"],"title":"go标准库-Os+io+bufio+ioutil","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/"},{"categories":["Golang"],"content":"type Process 1 2 3 4 type Process struct { Pid int // 内含隐藏或非导出字段 } Process保管一个被StarProcess创建的进程的信息。 func FindProcess(pid int) (p *Process, err error)：根据进程id查找一个运行中的进程。 func (p *Process) Signal(sig Signal) error：向进程发送一个信号。 func (p *Process) Kill() error：让进程立刻退出 func (p *Process) Wait() (*ProcessState, error)：阻塞执行主进程直到该参数进程退出 ","date":"2023-02-18","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/:1:6","tags":["go标准库"],"title":"go标准库-Os+io+bufio+ioutil","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/"},{"categories":["Golang"],"content":"io io包提供了对I/O原语的基本接口。本包的基本任务是包装这些原语已有的实现（如os包里的原语），使之成为共享的公共接口，这些公共接口抽象出了泛用的函数并附加了一些相关的原语的操作。 ","date":"2023-02-18","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/:2:0","tags":["go标准库"],"title":"go标准库-Os+io+bufio+ioutil","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/"},{"categories":["Golang"],"content":"Variables 1 var EOF = errors.New(\"EOF\") ","date":"2023-02-18","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/:2:1","tags":["go标准库"],"title":"go标准库-Os+io+bufio+ioutil","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/"},{"categories":["Golang"],"content":"function func Copy(dst Writer, src Reader) (written int64, err error)：将src的数据拷贝到dst，直到在src上到达EOF或发生错误 func CopyN(dst Writer, src Reader, n int64) (written int64, err error)：从src拷贝n个字节数据到dst，直到在src上到达EOF或发生错误 ","date":"2023-02-18","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/:2:2","tags":["go标准库"],"title":"go标准库-Os+io+bufio+ioutil","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/"},{"categories":["Golang"],"content":"io/ioutil func ReadAll(r io.Reader) ([]byte, error)：从r读取数据直到EOF或遇到error ","date":"2023-02-18","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/:3:0","tags":["go标准库"],"title":"go标准库-Os+io+bufio+ioutil","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/"},{"categories":["Golang"],"content":"bufio bufio包实现了有缓冲的I/O。它包装一个io.Reader或io.Writer接口对象，创建另一个也实现了该接口，且同时还提供了缓冲和一些文本I/O的帮助函数的对象 ","date":"2023-02-18","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/:4:0","tags":["go标准库"],"title":"go标准库-Os+io+bufio+ioutil","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/"},{"categories":["Golang"],"content":"Constants 1 2 3 4 const ( // 用于缓冲一个token，实际需要的最大token尺寸可能小一些，例如缓冲中需要保存一整行内容 MaxScanTokenSize = 64 * 1024 ) ","date":"2023-02-18","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/:4:1","tags":["go标准库"],"title":"go标准库-Os+io+bufio+ioutil","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/"},{"categories":["Golang"],"content":"type Reader 重要函数 func NewReader(rd io.Reader) Reader：创建一个具有默认大小缓冲、从r读取的Reader func NewReaderSize(rd io.Reader, size int) Reader：创建一个具有最少有size尺寸的缓冲、从r读取的Reader。如果参数r已经是一个具有足够大缓冲的* Reader类型值，会返回r 重要方法 func (b *Reader) Reset(r io.Reader)：丢弃缓冲中的数据，清除任何错误，将b重设为其下层从r读取数据 func (b *Reader) Buffered() int：返回缓冲中现有的可读取的字节数 func (b *Reader) Peek(n int) ([]byte, error)：返回输入流的下n个字节，而不会移动读取位置 func (b *Reader) Read(p []byte) (n int, err error)：读取数据写入p func (b *Reader) ReadByte() (c byte, err error)：读取并返回一个字节 func (b *Reader) ReadRune() (r rune, size int, err error)：读取一个utf-8编码的unicode码值，返回该码值、其编码长度和可能的错误 func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)：这个函数容易出错，使用ReadBytes(’\\n’)或ReadString(’\\n’)代替，或者使用Scanner func (b *Reader) ReadBytes(delim byte) (line []byte, err error)：ReadBytes读取直到第一次遇到delim字节，返回一个包含已读取的数据和delim字节的切片 func (b *Reader) ReadString(delim byte) (line string, err error)：ReadString读取直到第一次遇到delim字节，返回一个包含已读取的数据和delim字节的字符串 ","date":"2023-02-18","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/:4:2","tags":["go标准库"],"title":"go标准库-Os+io+bufio+ioutil","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/"},{"categories":["Golang"],"content":"type Writer 内容基本与Reader一一对应 重要函数 func NewWriter(w io.Writer) Writer：创建一个具有默认大小缓冲、写入w的Writer。 func NewWriterSize(w io.Writer, size int) Writer：创建一个具有最少有size尺寸的缓冲、写入w的Writer。如果参数w已经是一个具有足够大缓冲的*Writer类型值，会返回w。 重要方法 func (b *Writer) Reset(w io.Writer)：丢弃缓冲中的数据，清除任何错误，将b重设为将其输出写入w。 func (b *Writer) Buffered() int：返回缓冲中已使用的字节数 func (b *Writer) Available() int：返回缓冲中还有多少字节未使用 func (b *Writer) Write(p []byte) (nn int, err error)：将p的内容写入缓冲 func (b *Writer) WriteString(s string) (int, error)：写入一个字符串。 func (b *Writer) WriteByte(c byte) error：写入单个字节 func (b *Writer) WriteRune(r rune) (size int, err error)：写入一个unicode码值（的utf-8编码），返回写入的字节数和可能的错误 func (b *Writer) Flush() error：将缓冲中的数据写入下层的io.Writer接口 ","date":"2023-02-18","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/:4:3","tags":["go标准库"],"title":"go标准库-Os+io+bufio+ioutil","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/"},{"categories":["Golang"],"content":"type ReadWriter 1 2 3 4 type ReadWriter struct { *Reader *Writer } 所以其实没有必要使用这个，直接弄一个Reader和Writer就行了 ","date":"2023-02-18","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/:4:4","tags":["go标准库"],"title":"go标准库-Os+io+bufio+ioutil","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/"},{"categories":["Golang"],"content":"type Scanner 推荐使用Reader ","date":"2023-02-18","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/:4:5","tags":["go标准库"],"title":"go标准库-Os+io+bufio+ioutil","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/"},{"categories":["Golang"],"content":"重定向输入输出 CSDN Golang重定向fmt.Scanf从文件而不是os.Stdin读取 直接给os.Stdin赋值新的file对象，记得备份原来的Stdin 1 2 oldStdin := os.Stdin os.Stdin = f ","date":"2023-02-18","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/:5:0","tags":["go标准库"],"title":"go标准库-Os+io+bufio+ioutil","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/os+io+bufio+ioutil/"},{"categories":["Golang"],"content":"go语言中文网 godoc go语言中文网有很多文档缺少内容比如string.Builder就没有，godoc绝对详尽，推荐阅读godoc fmt godoc官方文档 ","date":"2023-02-18","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/fmt/:0:0","tags":["go标准库"],"title":"go标准库-Fmt","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/fmt/"},{"categories":["Golang"],"content":"常用输出格式 ","date":"2023-02-18","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/fmt/:1:0","tags":["go标准库"],"title":"go标准库-Fmt","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/fmt/"},{"categories":["Golang"],"content":"通用输出 %v：默认，%+v添加结构体字段名 %#v：类似python中repr的源代码go定义语句 %T：数据类型 在%后面添加数字表示输出填充最小长度，比如%3f表示输出至少包含3个字符 %p：数据地址 ","date":"2023-02-18","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/fmt/:1:1","tags":["go标准库"],"title":"go标准库-Fmt","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/fmt/"},{"categories":["Golang"],"content":"Integer %b：二进制格式 %c：Unicode格式字符 %d：十进制 %o：八进制 %O：带0o前缀的八进制 %x：小写十六进制 %X：大写十六进制 %U：带U+前缀的Unicode格式字码 %q：带上单引号的Unicode格式字符 ","date":"2023-02-18","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/fmt/:1:2","tags":["go标准库"],"title":"go标准库-Fmt","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/fmt/"},{"categories":["Golang"],"content":"String 和 slice of bytes %q：带双引号的字符串 ","date":"2023-02-18","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/fmt/:1:3","tags":["go标准库"],"title":"go标准库-Fmt","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/fmt/"},{"categories":["Golang"],"content":"Floating-point %f：类似%v，但是可以规定有效小数位数，比如%3.3f表示保留3位小数 %e：带e的科学计数法，如-1.234456e+78 %E：带E的科学计数法，如-1.234456E+78 ","date":"2023-02-18","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/fmt/:1:4","tags":["go标准库"],"title":"go标准库-Fmt","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/fmt/"},{"categories":["Golang"],"content":"获取输入 可以使用Scanf，但是Scanln会出问题 读取行尽量使用 bufio.Reader 1 2 reader := bufio.NewReader(os.Stdin) strBytes, hasMore, err := reader.ReadLine() ","date":"2023-02-18","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/fmt/:2:0","tags":["go标准库"],"title":"go标准库-Fmt","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/fmt/"},{"categories":["Golang"],"content":"函数 func Printf(format string, a …any) (n int, err error):这里的n是成果解析的变量个数 func Println(a …any) (n int, err error):这里的n是返回的字节数 ","date":"2023-02-18","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/fmt/:3:0","tags":["go标准库"],"title":"go标准库-Fmt","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/fmt/"},{"categories":["Python"],"content":"mininet官网 mininet官网文档 mininet官网api openflow教程 ","date":"2023-02-17","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/openflow%E6%95%99%E7%A8%8B/:0:0","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Openflow教程","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/openflow%E6%95%99%E7%A8%8B/"},{"categories":["Python"],"content":"学习开发工具 ","date":"2023-02-17","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/openflow%E6%95%99%E7%A8%8B/:1:0","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Openflow教程","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/openflow%E6%95%99%E7%A8%8B/"},{"categories":["Python"],"content":"启动网络 1 sudo mn --topo single,3 --mac --switch ovsk --controller remote ","date":"2023-02-17","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/openflow%E6%95%99%E7%A8%8B/:1:1","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Openflow教程","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/openflow%E6%95%99%E7%A8%8B/"},{"categories":["Python"],"content":"ovs-ofctl 示例用法 ovs-ofctl是 Open vSwitch 附带的实用程序，可以查看和控制单个交换机的流表。 连接到交换机并转储(打印)其端口状态和功能 1 ovs-ofctl show s1 只打印流表信息可以使用 1 ovs-ofctl dump-flows s1 ","date":"2023-02-17","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/openflow%E6%95%99%E7%A8%8B/:1:2","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Openflow教程","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/openflow%E6%95%99%E7%A8%8B/"},{"categories":["Python"],"content":"访问远程 OVS 实例或 Stanford 参考交换机 ovs-ofctl通过 Unix 域套接字与 Open vSwitch 通信，不管是本地交换机还是远程交换机 连接交换机的完整格式 1 2 # ovs-ofctl dump-flows tcp:{ip address}:{port} ovs-ofctl dump-flows tcp:127.0.0.1:6634 尽量不用使用dpctl和ovs-dpctl命令，使用 Open vSwitch 可以让您检查 OVS 的内核流缓存 ","date":"2023-02-17","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/openflow%E6%95%99%E7%A8%8B/:1:3","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Openflow教程","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/openflow%E6%95%99%E7%A8%8B/"},{"categories":["Python"],"content":"ping 测试 1 mininet\u003e h1 ping -c3 h2 交换机流表是空的吗，没有控制器连接到交换机，交换机不知道如何处理传入流量，从而导致 ping 失败 使用ovs-ofctl手动安装必要的流表 1 2 ovs-ofctl add-flow s1 in_port=1,actions=output:2 ovs-ofctl add-flow s1 in_port=2,actions=output:1 检查流表 1 ovs-ofctl dump-flows s1 再ping就能通过了 ","date":"2023-02-17","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/openflow%E6%95%99%E7%A8%8B/:1:4","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Openflow教程","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/openflow%E6%95%99%E7%A8%8B/"},{"categories":["Python"],"content":"启动 Wireshark 1 sudo wireshark \u0026 他这里提示使用ssh x11登录节点，我建议使用mx命令 1 2 # mx 节点名 mx c0 选择ens33添加过滤规则openflow ","date":"2023-02-17","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/openflow%E6%95%99%E7%A8%8B/:1:5","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Openflow教程","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/openflow%E6%95%99%E7%A8%8B/"},{"categories":["Python"],"content":"启动 Controller 并在 Wireshark 中查看启动消息 首先停止 mininet 并清理 1 2 mininet\u003e exit mn -c 我这里是在openflow虚拟机里面启动 OpenFlow 参考控制器 1 controller ptcp:6633 启动拓扑 1 mn --topo single,3 --mac --switch ovsk --controller remote,ip=192.168.xxx.xxx,port=6633 ","date":"2023-02-17","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/openflow%E6%95%99%E7%A8%8B/:1:6","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Openflow教程","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/openflow%E6%95%99%E7%A8%8B/"},{"categories":["Python"],"content":"带 iperf 的基准控制器 1 iperf h1 h2 ","date":"2023-02-17","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/openflow%E6%95%99%E7%A8%8B/:1:7","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Openflow教程","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/openflow%E6%95%99%E7%A8%8B/"},{"categories":["Python"],"content":"python官网标准库参考 python官网标准库详细文档索引 python官网语言参考文档 该库用于快速构建一个静态服务器，如果在静态服务器根目录有index.html则直接返回index.html -d选项配置根目录位置，不配置则为命令行的当前位置 1 python -m http.server 端口号 当你的python3提示没有这个库时，使用如下命令 1 python -m SimpleHTTPServer 端口号 因为这个库是从SimpleHTTPServer改名过来的，可能你的python版本比较低，python2中使用 SimpleHTTPServer ，python3中使用 http.server Python 3.0 有什么新变化 ","date":"2023-02-16","objectID":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/http.server/:0:0","tags":["Python标准库"],"title":"Python-标准库-http.server","uri":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/http.server/"},{"categories":["Golang"],"content":"go官方文档 go语言参考 在写过很多go代码之后，感觉自己并没有完全掌握go语言，还有很多知识盲区，所以有了这个go学习笔记系列，本系列是作者跟着电子书重新复习go语言相关内容的笔记 polarisxu 博客 ","date":"2023-02-14","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/go%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/:0:0","tags":["go学习笔记"],"title":"golang-学习笔记-Go版本管理","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/go%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"},{"categories":["Golang"],"content":"安装多个版本的go编译器 安装特定 Go 版本的包装器（go现在使用install安装main.go）：go install golang.org/dl/go\u003cversion\u003e 下载编译器：go\u003cversion\u003e download 之后就可以直接使用下载的编译器：go\u003cversion\u003e env 注意： gotip标记最新版本的编译器 go\u003cversion\u003e命令会安装到$GOBIN download会把编译器安装到~/sdk目录下 希望新安装的编译器成为系统默认的 Go 版本： 将 ~/sdk/go1.16.4/bin/go 加入 PATH 环境变量（替换原来的） 做一个软连，默认 go 执行 go1.16.4（推荐这种方式），不需要频繁修改 PATH 删除某个版本，得手动进行（删除GOBIN下的包装器和下载的 Go 安装包） ","date":"2023-02-14","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/go%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/:1:0","tags":["go学习笔记"],"title":"golang-学习笔记-Go版本管理","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/go%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"},{"categories":["Golang"],"content":"go-zero官网 go-zero详细文档 本系列为作者阅读公众号微服务实践的文章做的笔记 另外go-zero作者kevwan大佬的learnku博客也是同步更新的 原文链接 ","date":"2023-02-14","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E6%95%B4%E5%90%88websocket/:0:0","tags":["go-zero"],"title":"golang-go-zero-微服务实践-整合websocket","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E6%95%B4%E5%90%88websocket/"},{"categories":["Golang"],"content":"整体设计 ","date":"2023-02-14","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E6%95%B4%E5%90%88websocket/:1:0","tags":["go-zero"],"title":"golang-go-zero-微服务实践-整合websocket","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E6%95%B4%E5%90%88websocket/"},{"categories":["Golang"],"content":"数据流 前端发 websocket 请求； 建立连接；准备接收 / 发送通道； 注册到 engine； ","date":"2023-02-14","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E6%95%B4%E5%90%88websocket/:2:0","tags":["go-zero"],"title":"golang-go-zero-微服务实践-整合websocket","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E6%95%B4%E5%90%88websocket/"},{"categories":["Golang"],"content":"go-zero官网 go-zero详细文档 本系列为作者阅读公众号微服务实践的文章做的笔记 另外go-zero作者kevwan大佬的learnku博客也是同步更新的 原文链接 ","date":"2023-02-14","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:0:0","tags":["go-zero"],"title":"golang-go-zero-微服务实践-分布式锁源码解析","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Golang"],"content":"分布式锁需要具备特性 排他性:只能被第一个持有者持有 防死锁:设置超时时间到期自动释放锁 可重入:防止锁持有者再次重入时锁被超时释放 高性能高可用:高并发场景下，高性能高可用是基本要求 ","date":"2023-02-14","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:1:0","tags":["go-zero"],"title":"golang-go-zero-微服务实践-分布式锁源码解析","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["通用技术"],"content":"RegexOne 使用正则表达式时首先要认识到的是，一切本质上都是一个字符，我们正在编写模式来匹配特定的字符序列（也称为字符串）。 ","date":"2023-02-14","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:0","tags":[],"title":"通用技术-正则表达式","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["通用技术"],"content":"普通字母和数字 直接匹配 ","date":"2023-02-14","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:1:0","tags":[],"title":"通用技术-正则表达式","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["通用技术"],"content":"\\d 任何数字 ","date":"2023-02-14","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:2:0","tags":[],"title":"通用技术-正则表达式","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["通用技术"],"content":"\\D 任何非数字 ","date":"2023-02-14","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:3:0","tags":[],"title":"通用技术-正则表达式","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["通用技术"],"content":". 任何字符 ","date":"2023-02-14","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:4:0","tags":[],"title":"通用技术-正则表达式","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["通用技术"],"content":". 匹配. ","date":"2023-02-14","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:5:0","tags":[],"title":"通用技术-正则表达式","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["通用技术"],"content":"[abc] a或b或c ","date":"2023-02-14","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:6:0","tags":[],"title":"通用技术-正则表达式","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["通用技术"],"content":"[^abc] 不是a且不是b且不是c ","date":"2023-02-14","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:7:0","tags":[],"title":"通用技术-正则表达式","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["通用技术"],"content":"[a-z] 根据ascii排序，a到z之间的字符，多个字符范围也可以与单个字符一起用在同一组括号中，如[A-Za-z0-9_] ","date":"2023-02-14","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:8:0","tags":[],"title":"通用技术-正则表达式","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["通用技术"],"content":"\\w 字母和数字，等价于[A-Za-z0-9_] ","date":"2023-02-14","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:9:0","tags":[],"title":"通用技术-正则表达式","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["通用技术"],"content":"\\W 非 字母和数字 ","date":"2023-02-14","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:10:0","tags":[],"title":"通用技术-正则表达式","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["通用技术"],"content":"{m} 前一个字符或组匹配精确匹配m次 ","date":"2023-02-14","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:11:0","tags":[],"title":"通用技术-正则表达式","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["通用技术"],"content":"{m,n} 前一个字符或组匹配匹配m到n次闭区间 ","date":"2023-02-14","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:12:0","tags":[],"title":"通用技术-正则表达式","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["通用技术"],"content":"* 前一个字符或组匹配任意多次包括0次 ","date":"2023-02-14","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:13:0","tags":[],"title":"通用技术-正则表达式","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["通用技术"],"content":"+ 前一个字符或组匹配至少1次 ","date":"2023-02-14","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:14:0","tags":[],"title":"通用技术-正则表达式","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["通用技术"],"content":"？ 前一个字符或组匹配1次或0次 ","date":"2023-02-14","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:15:0","tags":[],"title":"通用技术-正则表达式","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["通用技术"],"content":"\\s 任意空字符 ","date":"2023-02-14","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:16:0","tags":[],"title":"通用技术-正则表达式","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["通用技术"],"content":"\\S 任意非空字符 ","date":"2023-02-14","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:17:0","tags":[],"title":"通用技术-正则表达式","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["通用技术"],"content":"^…$ 匹配开始和结束 ","date":"2023-02-14","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:18:0","tags":[],"title":"通用技术-正则表达式","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["通用技术"],"content":"(…) 捕获组 ","date":"2023-02-14","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:19:0","tags":[],"title":"通用技术-正则表达式","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["通用技术"],"content":"(a(bc)) 捕获子组 ","date":"2023-02-14","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:20:0","tags":[],"title":"通用技术-正则表达式","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["通用技术"],"content":"(.*) 捕获所有 ","date":"2023-02-14","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:21:0","tags":[],"title":"通用技术-正则表达式","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["通用技术"],"content":"(abc|def) 匹配abc或def ","date":"2023-02-14","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:22:0","tags":[],"title":"通用技术-正则表达式","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["Python"],"content":"python官网标准库参考 python官网标准库详细文档索引 python官网语言参考文档 python官网subprocess subprocess 模块允许你生成新的进程，连接它们的输入、输出、错误管道，并且获取它们的返回码。 ","date":"2023-02-11","objectID":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/subprocess/:0:0","tags":["Python标准库"],"title":"Python-标准库-Subprocess","uri":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/subprocess/"},{"categories":["Python"],"content":"使用 subprocess 模块 ","date":"2023-02-11","objectID":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/subprocess/:1:0","tags":["Python标准库"],"title":"Python-标准库-Subprocess","uri":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/subprocess/"},{"categories":["Python"],"content":"Popen 构造函数 此模块的底层的进程创建与管理由 Popen 类处理。 1 class subprocess.Popen(args, bufsize=-1, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=True, shell=False, cwd=None, env=None, universal_newlines=None, startupinfo=None, creationflags=0, restore_signals=True, start_new_session=False, pass_fds=(), *, encoding=None, errors=None, text=None) 在一个新的进程中执行子程序。 ","date":"2023-02-11","objectID":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/subprocess/:1:1","tags":["Python标准库"],"title":"Python-标准库-Subprocess","uri":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/subprocess/"},{"categories":["Python"],"content":"Popen 对象 ","date":"2023-02-11","objectID":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/subprocess/:1:2","tags":["Python标准库"],"title":"Python-标准库-Subprocess","uri":"/posts/python/%E6%A0%87%E5%87%86%E5%BA%93/subprocess/"},{"categories":["Python"],"content":"本系列为作者在官网学习python时做的笔记，详见python官网 python标准库官方文档，查阅标准库相关的内容 python语言参考，查看python语法，该文档是简洁的，但试图做到准确和完整。非必要的内建对象类型和内建函数、模块的语义描述在 Python 标准库 中。 标准库和语言参考涵盖了python的所有内容，他们是互补的，如果在语言参考中没有找到需要的内容那么就一定在便准库文档中。 ","date":"2023-02-10","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%A1%A5%E5%85%85/:0:0","tags":["Python教程"],"title":"Python教程-补充","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%A1%A5%E5%85%85/"},{"categories":["Python"],"content":"python内置标识符 ","date":"2023-02-10","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%A1%A5%E5%85%85/:1:0","tags":["Python教程"],"title":"Python教程-补充","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%A1%A5%E5%85%85/"},{"categories":["Python"],"content":"类的内置方法 object.call(self[, args…]):此方法会在实例作为一个函数被“调用”时被调用； ","date":"2023-02-10","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%A1%A5%E5%85%85/:1:1","tags":["Python教程"],"title":"Python教程-补充","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%A1%A5%E5%85%85/"},{"categories":["Python"],"content":"内置函数 ","date":"2023-02-10","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%A1%A5%E5%85%85/:1:2","tags":["Python教程"],"title":"Python教程-补充","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%A1%A5%E5%85%85/"},{"categories":["Python"],"content":"内置常量 ","date":"2023-02-10","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%A1%A5%E5%85%85/:1:3","tags":["Python教程"],"title":"Python教程-补充","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%A1%A5%E5%85%85/"},{"categories":["Python"],"content":"内置类型 ","date":"2023-02-10","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%A1%A5%E5%85%85/:1:4","tags":["Python教程"],"title":"Python教程-补充","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%A1%A5%E5%85%85/"},{"categories":["Python"],"content":"内置异常 ","date":"2023-02-10","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%A1%A5%E5%85%85/:1:5","tags":["Python教程"],"title":"Python教程-补充","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%A1%A5%E5%85%85/"},{"categories":["Python"],"content":"术语对照表 文档中出现的不常用的专业术语可以在这里面找找解释，python官方文档 ","date":"2023-02-10","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%A1%A5%E5%85%85/:2:0","tags":["Python教程"],"title":"Python教程-补充","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%A1%A5%E5%85%85/"},{"categories":["Python"],"content":"装饰器语法糖 python官方文档 返回值为另一个函数的函数，通常使用 @wrapper 语法形式来进行函数变换。装饰器语法只是一种语法糖，以下两个函数定义在语义上完全等价: 1 2 3 4 5 6 7 def f(...): ... f = staticmethod(f) @staticmethod def f(...): ... 菜鸟教程 装饰器 比较复杂的装饰器使用装饰器类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from functools import wraps class logit(object): def __init__(self, logfile='out.log'): self.logfile = logfile def __call__(self, func): @wraps(func) def wrapped_function(*args, **kwargs): log_string = func.__name__ + \" was called\" print(log_string) # 打开logfile并写入 with open(self.logfile, 'a') as opened_file: # 现在将日志打到指定的文件 opened_file.write(log_string + '\\n') # 现在，发送一个通知 self.notify() return func(*args, **kwargs) return wrapped_function def notify(self): # logit只打日志，不做别的 pass ","date":"2023-02-10","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%A1%A5%E5%85%85/:3:0","tags":["Python教程"],"title":"Python教程-补充","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%A1%A5%E5%85%85/"},{"categories":["Python"],"content":"PYPI官网 github官网 官网文档 Requests允许您非常轻松地发送 HTTP/1.1 请求。无需手动将查询字符串添加到您的 URL，或对您的 POST 数据进行表单编码。Keep-alive 和 HTTP 连接池是 100% 自动的，基于urllib3。 ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:0:0","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"安装 1 pip install requests ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:1:0","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"快速入门 ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:2:0","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"发出请求 1 2 3 4 5 6 r = requests.get('https://api.github.com/events') r = requests.post('https://httpbin.org/post', data={'key': 'value'}) r = requests.put('https://httpbin.org/put', data={'key': 'value'}) r = requests.delete('https://httpbin.org/delete') r = requests.head('https://httpbin.org/get') r = requests.options('https://httpbin.org/get') 在 URL 中传递参数 针对httpbin.org/get?key=val类型参数 1 2 payload = {'key1': 'value1', 'key2': 'value2'} r = requests.get('https://httpbin.org/get', params=payload) 打印url 1 print(r.url) 任何值为None的字典键都不会添加到 URL 的查询字符串中 ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:2:1","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"响应内容 读取服务器响应的内容 1 r.text#'[{\"repository\":{\"open_issues\":0,\"url\":\"https://github.com/... 默认提交给服务器的编码类型是unicode，可以修改服务器编码类型 1 2 r.encoding#'utf-8' r.encoding = 'ISO-8859-1' ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:2:2","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"二进制响应内容 非文本请求，以字节形式访问响应主体 1 r.content#b'[{\"repository\":{\"open_issues\":0,\"url\":\"https://github.com/... 默认解码格式是gzip 如果安装了像brotli或brotlicffi这样的 Brotli 库，br 传输编码会自动为您解码 例如，要从请求返回的二进制数据创建图像 1 2 3 4 from PIL import Image from io import BytesIO i = Image.open(BytesIO(r.content)) ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:2:3","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"JSON 响应内容 requests 内置了 JSON 解码器 1 r.json()#[{'repository': {'open_issues': 0, 'url': 'https://github.com/... 如果解码失败，r.json()引发异常，抛出requests.exceptions.JSONDecodeError。例如，如果响应获得 204（无内容），或者如果响应包含无效的 JSON。 ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:2:4","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"原始响应内容 从服务器获取原始套接字响应，进行流式传输，设置stream=True 1 2 3 r = requests.get('https://api.github.com/events', stream=True) r.raw#\u003curllib3.response.HTTPResponse object at 0x101194810\u003e r.raw.read(10) 保存流式传输到文件 1 2 3 with open(filename, 'wb') as fd: for chunk in r.iter_content(chunk_size=128): fd.write(chunk) ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:2:5","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"自定义标题 1 2 3 4 url = 'https://api.github.com/some/endpoint' headers = {'user-agent': 'my-app/0.0.1'} r = requests.get(url, headers=headers) ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:2:6","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"更复杂的 POST 请求 1 2 3 payload_dict = {'key1': ['value1', 'value2']} r2 = requests.post('https://httpbin.org/post', data=payload_dict) print(r1.text) data 可以传入 字符串 和 字典。字典将自动编码为json字符串 ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:2:7","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"添加文件 1 2 3 4 url = 'https://httpbin.org/post' files = {'file': open('report.xls', 'rb')} r = requests.post(url, files=files) 显式设置文件名、内容类型和标题 1 2 3 4 url = 'https://httpbin.org/post' files = {'file': ('report.xls', open('report.xls', 'rb'), 'application/vnd.ms-excel', {'Expires': '0'})} r = requests.post(url, files=files) 发送要作为文件接收的字符串 1 2 3 4 url = 'https://httpbin.org/post' files = {'file': ('report.csv', 'some,data,to,send\\nanother,row,to,send\\n')} r = requests.post(url, files=files) 非常大的文件作为multipart/form-data 请求发送需要流式传输该请求。默认情况下，requests不支持这个，但是有一个单独的包 requests-toolbelt支持。 ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:2:8","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"响应状态代码 1 2 r = requests.get('https://httpbin.org/get') r.status_code#200 内置的状态码查找对象 1 r.status_code == requests.codes.ok#True 判断状态码是否正常的工具函数，如果错误将抛出requests.exceptions.HTTPError异常，否则返回None 1 r.raise_for_status() ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:2:9","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"响应头 返回一个字典 1 r.headers ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:2:10","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"cookie 响应的cookie 1 r.cookies 将自己的 cookie 发送到服务器 1 2 3 4 url = 'https://httpbin.org/cookies' cookies = dict(cookies_are='working') r = requests.get(url, cookies=cookies) 使用cookieJar管理cookie 1 2 3 4 5 jar = requests.cookies.RequestsCookieJar() jar.set('tasty_cookie', 'yum', domain='httpbin.org', path='/cookies') jar.set('gross_cookie', 'blech', domain='httpbin.org', path='/elsewhere') url = 'https://httpbin.org/cookies' r = requests.get(url, cookies=jar) ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:2:11","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"重定向和历史 可以通过历史重定向的请求 1 2 3 4 r = requests.get('http://github.com/') r.url#'https://github.com/ r.status_code#200 r.history#[\u003cResponse [301]\u003e] GET、OPTIONS、POST、PUT、PATCH 或 DELETE默认启用重定向，使用allow_redirects参数禁用重定向处理 1 2 3 r = requests.get('http://github.com/', allow_redirects=False) r.status_code#301 r.history#[] HEAD默认禁用重定向，使用allow_redirects参数启用重定向处理 1 2 3 4 r = requests.head('http://github.com/', allow_redirects=True) r.url#'https://github.com/ r.status_code#200 r.history#[\u003cResponse [301]\u003e] ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:2:12","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"超时 几乎所有生产代码都应在几乎所有请求中使用此参数。不这样做可能会导致您的程序无限期挂起。这个超时不是整个交互过程超时，而是接收第一个字节超时 1 requests.get('https://github.com/', timeout=0.001) ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:2:13","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"错误和异常 Requests 显式引发的所有异常都继承自 requests.exceptions.RequestException. 出现网络问题（例如 DNS 故障、拒绝连接等），引发ConnectionError异常 HTTP 请求返回不成功的状态代码，引发HTTPError异常 请求超时，引发Timeout异常 请求超过配置的最大重定向数， 引发TooManyRedirects异常 ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:2:14","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"高级用法 ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:3:0","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"会话对象 Session 对象允许您跨请求保留某些参数。它还会在 Session 实例发出的所有请求中保留 cookie，并将使用urllib3的连接池。底层的 TCP 连接将被重用，这可能会显着提高性能。 1 2 3 4 s = requests.Session() s.get('https://httpbin.org/cookies/set/sessioncookie/123456789') r = s.get('https://httpbin.org/cookies') 会话也可用于向请求方法提供默认数据： 1 2 s.auth = ('user', 'pass') s.headers.update({'x-test': 'true'}) 传递给请求方法级字典都将与设置的会话级值合并，方法级参数覆盖会话参数 会话也可以用作上下文管理器： 1 2 with requests.Session() as s: s.get('https://httpbin.org/cookies/set/sessioncookie/123456789') 从字典参数中删除一个值:在单次请求中会话级字典的键，只需在方法级参数中将该键的值设置为None ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:3:1","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"请求和响应对象 1 2 r.headers#响应头 r.request.headers#请求头 ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:3:2","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"准备好的请求 每次API 调用或会话调用发送的请求其实就是一个PreparedRequest对象，r.request也是这个对象。所以通过在发送前修改这个对象能够实现对正文或标头（或其他任何内容）做一些额外的工作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 req = Request('POST', url, data=data, headers=headers) prepped = req.prepare() # do something with prepped.body prepped.body = 'No, I want exactly this as the body.' # do something with prepped.headers del prepped.headers['Content-Type'] resp = s.send(prepped, stream=stream, verify=verify, proxies=proxies, cert=cert, timeout=timeout ) 上面的代码无法使用session对象配置的会话级属性，使用Session.prepare_request()替换Request.prepare() 1 prepped = s.prepare_request(req) ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:3:3","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"SSL 证书验证 默认情况下，启用 SSL 验证，如果无法验证证书，Requests 将抛出 SSLError： 1 requests.get('https://requestb.in')#requests.exceptions.SSLError: hostname 'requestb.in' doesn't match either of '*.herokuapp.com', 'herokuapp.com' 可以将verify路径传递给带有受信任 CA 证书的 CA_BUNDLE 文件或目录 1 2 3 4 requests.get('https://github.com', verify='/path/to/certfile') s = requests.Session() s.verify = '/path/to/certfile' 如果verify设置为目录路径，则必须使用 OpenSSL 提供的实用程序c_rehash处理该目录。 当verify设置为时False，请求将接受服务器提供的任何 TLS 证书，并将忽略主机名不匹配和/或过期的证书 ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:3:4","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"客户端证书 指定本地证书用作客户端证书，使用单个文件（包含私钥和证书）或两个文件路径的元组 1 2 3 4 5 requests.get('https://kennethreitz.org', cert=('/path/client.cert', '/path/client.key')) \u003cResponse [200]\u003e s = requests.Session() s.cert = '/path/client.cert' 指定错误的路径或无效的证书，抛出 SSLError 本地证书的私钥必须未加密。目前，Requests 不支持使用加密密钥 ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:3:5","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"CA 证书 Requests 使用包certifi中的证书。当certifi未安装时，这会导致在使用明显较旧版本的 Requests 时出现极其过时的证书包。为了安全起见，我们建议经常升级 certifi！ ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:3:6","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"正文内容工作流程 默认情况下，当您发出请求时，会立即下载响应正文。 覆盖此行为并推迟下载响应主体，直到您使用stream参数访问Response.content 属性： 1 2 tarball_url = 'https://github.com/psf/requests/tarball/main' r = requests.get(tarball_url, stream=True) 此时只有响应标头已被下载并且连接保持打开状态，可以根据响应头信息决定下载正文： 1 2 3 if int(r.headers['content-length']) \u003c TOO_LONG: content = r.content ... 可以使用Response.iter_content() 和Response.iter_lines()方法进一步控制工作流 如果您在发出请求时设置stream为True，除非您消耗所有数据或调用Response.close，否则 Requests 无法将连接释放回池中 。这可能导致连接效率低下。在使用stream=True时部分阅读了请求正文（或根本没有阅读），您应该在with声明中发出请求以确保它始终关闭： 1 2 with requests.get('https://httpbin.org/get', stream=True) as r: # Do things with the response here. ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:3:7","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"保持活动 keep-alive 在一个会话中是 100% 自动的 ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:3:8","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"流媒体上传 Requests 支持流式上传，这允许您发送大型流或文件而无需将它们读入内存。要流式传输和上传，只需为您的身体提供一个类似文件的对象： 1 2 with open('massive-body', 'rb') as f: requests.post('http://some.url/streamed', data=f) ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:3:9","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"块编码请求 Requests 还支持传出和传入请求的分块传输编码，要发送块编码的请求，只需为您的正文提供一个生成器（或任何没有长度的迭代器） 1 2 3 4 5 def gen(): yield 'hi' yield 'there' requests.post('http://some.url/chunked', data=gen()) 对于分块编码的响应，最好使用 Response.iter_content()并设置stream=True ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:3:10","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"发送多个多部分编码文件 将文件设置为(form_field_name, file_info)元组列表： 1 2 3 4 5 url = 'https://httpbin.org/post' multiple_files = [ ('images', ('foo.png', open('foo.png', 'rb'), 'image/png')), ('images', ('bar.png', open('bar.png', 'rb'), 'image/png'))] r = requests.post(url, files=multiple_files) ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:3:11","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"事件挂钩Hook Requests 有一个挂钩系统，您可以使用它来操作部分请求过程或信号事件处理 您可以通过将字典传递给请求参数来为每个请求分配一个挂钩函数。回调函数必须处理自己的异常。如果回调函数返回一个值，将替换传入的数据。如果函数不返回任何内容，则没有影响。可以向单个请求添加多个挂钩。 1 2 3 4 5 6 7 8 def print_url(r, *args, **kwargs): print(r.url) def record_hook(r, *args, **kwargs): r.hook_called = True return r r = requests.get('https://httpbin.org/', hooks={'response': [print_url, record_hook]}) 可以向Session实例添加挂钩 1 2 3 s = requests.Session() s.hooks['response'].append(print_url) s.get('https://httpbin.org/') ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:3:12","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"自定义认证 Requests 允许指定自己的身份验证机制 身份验证实现是AuthBase的子类。Requests 在requests.auth中提供了两种常见的身份验证方案实现：HTTPBasicAuth和HTTPDigestAuth class requests.auth.HTTPBasicAuth(username, password)：Attaches HTTP Basic Authentication to the given Request object. lass requests.auth.HTTPDigestAuth(username, password)：Attaches HTTP Digest Authentication to the given Request object. 自定义身份认证： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from requests.auth import AuthBase class PizzaAuth(AuthBase): \"\"\"Attaches HTTP Pizza Authentication to the given Request object.\"\"\" def __init__(self, username): # setup any auth-related data here self.username = username def __call__(self, r): # modify and return the request r.headers['X-Pizza'] = self.username return r requests.get('http://pizzabin.org/admin', auth=PizzaAuth('kenneth')) 其实就是在__call__方法里面修改请求头 ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:3:13","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"流媒体请求 Response.iter_lines()您可以轻松地迭代流式 API。只需设置stream True并迭代响应 iter_lines： 1 2 3 4 5 6 7 8 9 10 11 import json import requests r = requests.get('https://httpbin.org/stream/20', stream=True) for line in r.iter_lines(): # filter out keep-alive new lines if line: decoded_line = line.decode('utf-8') print(json.loads(decoded_line)) 将decode_unicode=True与 Response.iter_lines()或Response.iter_content() 一起使用时，如果服务器不提供后备编码，需要指定编码： 1 2 3 4 5 6 7 8 r = requests.get('https://httpbin.org/stream/20', stream=True) if r.encoding is None: r.encoding = 'utf-8' for line in r.iter_lines(decode_unicode=True): if line: print(json.loads(line)) ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:3:14","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"代理 使用proxies参数配置单独的请求或Session： 1 2 3 4 5 6 7 8 9 10 proxies = { 'http': 'http://10.10.1.10:3128', 'https': 'http://10.10.1.10:1080', } requests.get('http://example.org', proxies=proxies) session = requests.Session() session.proxies.update(proxies) session.get('http://example.org') session.proxies的行为可能与预期不同。提供的值将被环境代理（由urllib.request.getproxies返回的那些）覆盖。为确保在存在环境代理的情况下使用代理，请明确指定proxies所有单独请求的参数。 代理有HTTP Basic Auth时，需要使用账号密码配置proxy为如下形式： 1 2 # http://user:password@host/ proxies = {'http': 'http://user:pass@10.10.1.10:3128/'} 要为特定方案和主机提供代理，请使用 scheme://hostname形式作为键。这将匹配对给定方案和确切主机名的任何请求。 1 proxies = {'http://10.20.1.128': 'http://10.10.1.10:5323'} 使用代理进行 https 连接通常需要您的本地计算机信任代理的根证书，请求信任的证书列表可以通过以下方式找到 1 print(DEFAULT_CA_BUNDLE_PATH) 将REQUESTS_CA_BUNDLE （或CURL_CA_BUNDLE）环境变量设置为另一个文件路径来覆盖此默认证书包 1 export REQUESTS_CA_BUNDLE=\"/usr/local/myproxy_info/cacert.pem\" SOCKS Requests 还支持使用 SOCKS 协议的代理 需要安装第三方库 1 python -m pip install requests[socks] 安装这些依赖项后，使用 SOCKS 代理就像使用 HTTP 代理一样简单： 1 2 3 4 proxies = { 'http': 'socks5://user:pass@host:port', 'https': 'socks5://user:pass@host:port' } ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:3:15","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"阻塞还是非阻塞 Requests 不提供任何类型的非阻塞 IO ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:3:16","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"超时 默认只配置connect超时，但是也可以通过第二个参数配置read超时 1 r = requests.get('https://github.com', timeout=(3.05, 27)) ","date":"2023-02-10","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/:3:17","tags":["Python第三方库"],"title":"Python-第三方库-Requests","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/requests/"},{"categories":["Python"],"content":"PYPI官网 本文是作者跟着selenium官方文档学习记录的笔记 selenium官网 ","date":"2023-02-06","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/selenium/:0:0","tags":["Python第三方库"],"title":"Python-第三方库-Selenium","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/selenium/"},{"categories":["Python"],"content":"概述 ","date":"2023-02-06","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/selenium/:1:0","tags":["Python第三方库"],"title":"Python-第三方库-Selenium","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/selenium/"},{"categories":["Python"],"content":"Selenium 组件 术语： API：应用程序编程接口。 库：包含 API 和实现它们所需的代码的代码模块。库特定于每种语言绑定。 Driver：负责控制实际的浏览器。特定于浏览器。 Framework：一个额外的库，用于支持 WebDriver 套件。这些框架可能是 JUnit 或 NUnit 等测试框架。 直接通信 RemoteWebDriver远程通信 Selenium Server 或 Selenium Grid远程通信 框架 本文只考虑直接通信 ","date":"2023-02-06","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/selenium/:1:1","tags":["Python第三方库"],"title":"Python-第三方库-Selenium","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/selenium/"},{"categories":["Python"],"content":"网络驱动程序 ","date":"2023-02-06","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/selenium/:2:0","tags":["Python第三方库"],"title":"Python-第三方库-Selenium","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/selenium/"},{"categories":["Python"],"content":"入门 安装Selenium库 1 pip install selenium 安装浏览器驱动程序，chrome内置了浏览器驱动程序 Hello World 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from selenium import webdriver from selenium.webdriver.common.by import By def test_eight_components(): driver = webdriver.Chrome() driver.get(\"https://www.selenium.dev/selenium/web/web-form.html\") title = driver.title assert title == \"Web form\" driver.implicitly_wait(0.5) text_box = driver.find_element(by=By.NAME, value=\"my-text\") submit_button = driver.find_element(by=By.CSS_SELECTOR, value=\"button\") text_box.send_keys(\"Selenium\") submit_button.click() message = driver.find_element(by=By.ID, value=\"message\") value = message.text assert value == \"Received!\" driver.quit() ","date":"2023-02-06","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/selenium/:2:1","tags":["Python第三方库"],"title":"Python-第三方库-Selenium","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/selenium/"},{"categories":["Python"],"content":"Driver 会话 启动和停止会话是为了打开和关闭浏览器。 启动会话可以配置： 描述您想要的会话类型的Options；默认值用于本地，但这对于远程是必需的 某种形式的CommandExecutor（实现因语言而异） Listeners Options browserName 浏览器名称 browserVersion 浏览器版本：在仅安装了 80 的系统上请求 Chrome 版本 75，则会话创建将失败 pageLoadStrategy 页面加载策略：normal（默认使用，等待所有资源下载完成），eager（DOM 访问已准备就绪，但图像等其他资源可能仍在加载），none（完全不阻止 WebDriver）。document.readyState属性描述了当前文档的加载状态 1 2 3 4 5 6 7 8 9 from selenium import webdriver from selenium.webdriver.chrome.options import Options options = Options() # xxx设置页面加载策略 options.page_load_strategy = 'xxx' driver = webdriver.Chrome(options=options) driver.get(\"http://www.google.com\") driver.quit() platformName 平台名称：远程端的操作系统 acceptInsecureCerts：false不信任不安全证书，true则信任 timeouts 超时： Script Timeout 脚本超时：指定何时中断当前浏览上下文中正在执行的脚本。默认300,000。 Page Load Timeout 页面加载超时：指定在当前浏览上下文中需要加载网页的时间间隔。默认300,000。超时抛出TimeoutException。 Implicit Wait Timeout 隐式等待超时 unhandledPromptBehavior 未处理的提示行为：指定当前会话的状态user prompt handler。默认关闭并通知状态 User Prompt Handler 用户提示处理程序：在远程端遇到用户提示时必须采取的操作：dismiss，accept，dismiss and notify，accept and notify，ignore setWindowRect 设置窗口大小 proxy 代理： 1 2 3 4 5 6 7 8 9 10 11 12 13 from selenium import webdriver PROXY = \"\u003cHOST:PORT\u003e\" webdriver.DesiredCapabilities.CHROME['proxy'] = { \"httpProxy\": PROXY, \"ftpProxy\": PROXY, \"sslProxy\": PROXY, \"proxyType\": \"MANUAL\", } with webdriver.Chrome() as driver: driver.get(\"https://selenium.dev\") ","date":"2023-02-06","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/selenium/:2:2","tags":["Python第三方库"],"title":"Python-第三方库-Selenium","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/selenium/"},{"categories":["Python"],"content":"Chrome 特定功能 Options 1 2 3 4 from selenium.webdriver.chrome.options import Options options = Options() driver = webdriver.Chrome(options=options) Arguments:args参数 用于启动浏览器时使用的命令行开关列表。常用的参数包括开启最大化–start-maximized和无界面模式–headless=new，禁用gpu –disable-gpu。详细arguments列表 1 2 chrome_options = Options() chrome_options.add_argument(\"--headless=new\") Add extensions 添加扩展:extensions参数接受 crx 文件 Keeping browser open 保持浏览器打开： 将detach参数设置为 true 将使浏览器在驱动程序进程退出后保持打开状态。 1 2 chrome_options = Options() chrome_options.add_experimental_option(\"detach\", True) ","date":"2023-02-06","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/selenium/:2:3","tags":["Python第三方库"],"title":"Python-第三方库-Selenium","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/selenium/"},{"categories":["Python"],"content":"Waits WebDriver是有阻塞API。为了克服浏览器和 WebDriver 脚本之间的竞争条件问题，大多数 Selenium 客户端都附带了一个等待包。 Explicit wait显式等待 Selenium 客户端可以使用显式等待来暂停程序执行或冻结线程，直到您传递给它的条件得到解决。以特定频率调用条件，直到等待超时结束。这意味着只要条件返回一个假值，它就会继续尝试和等待。 用等待让findElement调用等待，直到脚本中动态添加的元素被添加到 DOM 中： 1 2 3 4 5 6 7 8 9 from selenium.webdriver.support.wait import WebDriverWait def document_initialised(driver): return driver.execute_script(\"return initialised\") driver.navigate(\"file:///race_condition.html\") WebDriverWait(driver, timeout=10).until(document_initialised) el = driver.find_element(By.TAG_NAME, \"p\") assert el.text == \"Hello from JavaScript!\" 将条件作为函数引用传入，等待将重复运行，直到其返回值为真。“真实的”返回值是任何在手头语言中计算为布尔值 true 的值，例如字符串、数字、布尔值、对象（包括WebElement）或填充的（非空）序列或列表。 使用lambda表达式简化： 1 2 3 4 5 from selenium.webdriver.support.wait import WebDriverWait driver.navigate(\"file:///race_condition.html\") el = WebDriverWait(driver, timeout=3).until(lambda d: d.find_element(By.TAG_NAME,\"p\")) assert el.text == \"Hello from JavaScript!\" 预期条件:因为必须同步 DOM 和您的指令是很常见的事情，所以大多数客户端还带有一组预定义的预期条件。顾名思义，它们是为频繁等待操作预定义的条件。 存在警报 元素存在 元素可见 标题包含 标题是 元素陈旧 可见文字 python详尽列表 Implicit wait隐式等待 WebDriver 在尝试查找任何元素时轮询 DOM 一段时间。当网页上的某些元素不能立即使用并且需要一些时间加载时，这会很有用。 默认情况下，隐式等待元素出现是禁用的，需要在每个会话的基础上手动启用。 不要混合使用隐式等待和显示等待，会导致不可预测的等待时间。 1 2 3 4 driver = Chrome() driver.implicitly_wait(10) driver.get(\"http://somedomain/url_that_delays_loading\") my_dynamic_element = driver.find_element(By.ID, \"myDynamicElement\") FluentWait FluentWait 实例定义等待条件的最长时间，以及检查条件的频率。 用户可以配置等待以在等待时忽略特定类型的异常，例如在页面上搜索元素时抛出NoSuchElementException。 1 2 3 4 driver = Chrome() driver.get(\"http://somedomain/url_that_delays_loading\") wait = WebDriverWait(driver, timeout=10, poll_frequency=1, ignored_exceptions=[ElementNotVisibleException, ElementNotSelectableException]) element = wait.until(EC.element_to_be_clickable((By.XPATH, \"//div\"))) python中其实就是显式等待添加额外的参数 ","date":"2023-02-06","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/selenium/:2:4","tags":["Python第三方库"],"title":"Python-第三方库-Selenium","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/selenium/"},{"categories":["Python"],"content":"Element 上传文件 模拟操作，比如对于下面代码中的页面 1 2 3 4 5 6 7 8 9 10 11 12 from selenium import webdriver from webdriver_manager.chrome import ChromeDriverManager driver = webdriver.Chrome(ChromeDriverManager().install()) driver.implicitly_wait(10) driver.get(\"https://the-internet.herokuapp.com/upload\"); driver.find_element(By.ID,\"file-upload\").send_keys(\"selenium-snapshot.jpg\") driver.find_element(By.ID,\"file-submit\").submit() if(driver.page_source.find(\"File Uploaded!\")): print(\"file upload success\") else: print(\"file upload not successful\") driver.quit() Locator 定位器 识别页面上元素的方法。 传统定位器； class name：定位类名包含搜索值的元素（不允许使用复合类名） css selector：定位与 CSS 选择器匹配的元素 id：定位 ID 属性与搜索值匹配的元素 name：定位 NAME 属性与搜索值匹配的元素 link text：定位其可见文本与搜索值匹配的锚元素 partial link text：定位其可见文本包含搜索值的锚元素。如果匹配多个元素，则只会选择第一个。 tag name：定位标签名称与搜索值匹配的元素 xpath：定位与 XPath 表达式匹配的元素 相对定位器： Above：获取页面空间上相对目标元素“上方”符合条件的元素 Below：下方 Left of：左边 Right of：右边 Near ：相对目标元素最多50px像素的元素 1 2 3 4 5 email_locator = locate_with(By.TAG_NAME, \"input\").above({By.ID: \"password\"}) password_locator = locate_with(By.TAG_NAME, \"input\").below({By.ID: \"email\"}) cancel_locator = locate_with(By.TAG_NAME, \"button\").to_left_of({By.ID: \"submit\"}) submit_locator = locate_with(By.TAG_NAME, \"button\").to_right_of({By.ID: \"cancel\"}) email_locator = locate_with(By.TAG_NAME, \"input\").near({By.ID: \"lbl-email\"}) Finder 查找元素 根据提供的定位器值定位元素。 只查第一个匹配元素 评估整个 DOM 1 vegetable = driver.find_element(By.CLASS_NAME, \"tomatoes\") 评估 DOM 的子集 1 2 fruits = driver.find_element(By.ID, \"fruits\") fruit = fruits.find_element(By.CLASS_NAME,\"tomatoes\") 优化定位器：嵌套查找可能不是最有效的定位策略，因为它需要向浏览器发出两个单独的命令。使用 CSS 或 XPath 在单个命令中查找此元素。 1 fruit = driver.find_element(By.CSS_SELECTOR,\"#fruits .tomatoes\") 所有匹配元素 find_elements返回一个列表 1 plants = driver.find_elements(By.TAG_NAME, \"li\") 获取元素：遍历列表 从元素中查找元素 1 2 3 4 5 6 7 8 9 10 11 12 13 from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Chrome() driver.get(\"https://www.example.com\") # Get element with tag name 'div' element = driver.find_element(By.TAG_NAME, 'div') # Get all the elements available with tag name 'p' elements = element.find_elements(By.TAG_NAME, 'p') for e in elements: print(e.text) 获取活动元素 跟踪（或）查找在当前浏览上下文中具有焦点的 DOM 元素 1 2 3 4 5 6 7 8 9 10 from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Chrome() driver.get(\"https://www.google.com\") driver.find_element(By.CSS_SELECTOR, '[name=\"q\"]').send_keys(\"webElement\") # Get attribute of current active element attr = driver.switch_to.active_element.get_attribute(\"title\") print(attr) 互动 可以在一个元素上执行的基本命令有 5 个： 单击（适用于任何元素）:元素点击命令 执行在 元素中央 发送键（仅适用于文本字段和内容可编辑元素） 清除（仅适用于文本字段和内容可编辑元素） 提交（仅适用于表单元素） 选择（请参阅选择列表元素） 1 2 3 4 5 # 发送按键 driver.find_element(By.NAME, \"q\").send_keys(\"webdriver\" + Keys.ENTER) # 清除 具有 文本 类型的表单的输入元素或具有 内容可编辑 属性的元素 element.clear() 获取元素信息 是否显示 1 element.is_displayed() 是否启用 1 element.is_enabled() 是否被选定 1 element.is_selected() 获取元素标签名 1 element.tag_name 位置和大小：返回四个值，元素左上角的X轴位置，元素左上角的y轴位置，元素的高度，元素的宽度 1 res = driver.find_element(By.CSS_SELECTOR, \"h1\").rect 获取元素CSS值 1 cssValue = driver.find_element(By.LINK_TEXT, \"More information...\").value_of_css_property('color') 文本内容 1 text = driver.find_element(By.CSS_SELECTOR, \"h1\").text 获取特性或属性 1 value_info = email_txt.get_attribute(\"value\") ","date":"2023-02-06","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/selenium/:2:5","tags":["Python第三方库"],"title":"Python-第三方库-Selenium","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/selenium/"},{"categories":["Python"],"content":"交互 获取浏览器信息 获取标题 1 driver.title 获取当前 URL 1 driver.current_url 导航 打开网站 1 driver.get(\"https://selenium.dev\") 后退 1 driver.back() 前进 1 driver.forward() 刷新 1 driver.refresh() 警告框 Alerts 警告框：显示一条自定义消息, 以及一个用于关闭该警告的按钮 1 2 3 alert = wait.until(expected_conditions.alert_is_present()) text = alert.text alert.accept() Confirm 确认框 ：用户还可以选择取消消息 1 2 3 4 5 driver.find_element(By.LINK_TEXT, \"See a sample confirm\").click() wait.until(expected_conditions.alert_is_present()) alert = driver.switch_to.alert text = alert.text alert.dismiss() Prompt 提示框：包括文本输入 1 2 3 4 5 driver.find_element(By.LINK_TEXT, \"See a sample prompt\").click() wait.until(expected_conditions.alert_is_present()) alert = Alert(driver) alert.send_keys(\"Selenium\") alert.accept() Cookie 添加 Cookie 1 driver.add_cookie({\"name\": \"key\", \"value\": \"value\"}) 获取命名的 Cookie 1 driver.get_cookie(\"foo\") 获取全部 Cookies 1 driver.get_cookies() 删除 Cookie 1 driver.delete_cookie(\"test1\") 删除所有 Cookies 1 driver.delete_all_cookies() Same-Site Cookie属性 Strict:cookie不会与来自第三方网站的请求一起发送 Lax:cookie将与第三方网站发起的GET请求一起发送. 1 driver.add_cookie({\"name\": \"foo\", \"value\": \"value\", 'sameSite': 'Strict'}) Frames 使用 WebElement 使用 WebElement 进行切换是最灵活的选择 1 2 3 4 5 6 7 8 # 获取frame元素 iframe = driver.find_element(By.CSS_SELECTOR, \"#modal \u003e iframe\") # 切换到选择的 iframe driver.switch_to.frame(iframe) # 单击frame里的按钮 driver.find_element(By.TAG_NAME, 'button').click() frame 或 iframe 具有 id 或 name 属性，则可以使用该属性直接切换进去。如果名称或 id 在页面上不是唯一的， 那么将切换到找到的第一个。 1 2 3 4 5 # 通过 id 切换框架 driver.switch_to.frame('buttonframe') # 单击按钮 driver.find_element(By.TAG_NAME, 'button').click() 使用索引 1 2 3 4 5 # 基于索引切换到第 2 个 iframe iframe = driver.find_elements(By.TAG_NAME,'iframe')[1] # 切换到选择的 iframe driver.switch_to.frame(iframe) 离开框架 1 2 # 切回到默认内容 driver.switch_to.default_content() 窗口 窗口和标签页 WebDriver 没有区分窗口和标签页。每个窗口都有一个唯一的标识符，该标识符在单个会话中保持持久性。获得当前窗口的窗口句柄： 1 driver.current_window_handle 所有打开的窗口句柄 1 driver.window_handles 切换窗口或标签页 1 driver.switch_to.window(window_handle) 创建新窗口(或)新标签页并且切换 1 2 3 4 5 # 打开新标签页并切换到新标签页 driver.switch_to.new_window('tab') # 打开一个新窗口并切换到新窗口 driver.switch_to.new_window('window') 关闭窗口或标签页：如果在关闭一个窗口后忘记切换回另一个窗口句柄，WebDriver 将在当前关闭的页面上执行，并触发一个 No Such Window Exception 无此窗口异常。必须切换回有效的窗口句柄才能继续执行。 1 2 3 4 5 # 关闭标签页或窗口 driver.close() # 切回到之前的标签页或窗口 driver.switch_to.window(original_window) 在会话结束时退出浏览器 1 driver.quit() Python 的 WebDriver 现在支持 Python 上下文管理器，当使用 with 关键字时，可以在执行结束时自动退出驱动程序。 1 2 3 4 with webdriver.Firefox() as driver: # WebDriver 代码… # 在此缩进位置后 WebDriver 会自动退出 窗口管理 获取窗口大小 1 2 3 4 5 6 7 8 # 分别获取每个尺寸 width = driver.get_window_size().get(\"width\") height = driver.get_window_size().get(\"height\") # 或者存储尺寸并在以后查询它们 size = driver.get_window_size() width1 = size.get(\"width\") height1 = size.get(\"height\") 设置窗口大小 1 driver.set_window_size(1024, 768) 得到窗口的位置:获取浏览器窗口左上角的坐标 1 2 3 4 5 6 7 8 # 分别获取每个尺寸 x = driver.get_window_position().get('x') y = driver.get_window_position().get('y') # 或者存储尺寸并在以后查询它们 position = driver.get_window_position() x1 = position.get('x') y1 = position.get('y') 设置窗口位置 1 2 # 将窗口移动到主显示器的左上角 driver.set_window_position(0, 0) 最大化窗口 1 driver.maximize_window() 最小化窗口 1 driver.minimize_window() 全屏窗口 1 driver.fullscreen_window() 屏幕截图 1 driver.save_screenshot('./image.png') 元素屏幕截图 1 element.screenshot('./image.png') 执行脚本 1 2 3 header = driver.find_element(By.CSS_SELECTOR, \"h1\") driver.execute_script('return arguments[0].innerText', header) 打印页面 1 base64code = driver.print_page(print_options) ","date":"2023-02-06","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/selenium/:2:6","tags":["Python第三方库"],"title":"Python-第三方库-Selenium","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/selenium/"},{"categories":["Python"],"content":"Actions接口 除了高级元素交互之外, Actions 接口 还提供了对指定输入设备 可以执行的确切操作的精细控制. Selenium为3种输入源提供了接口： 键盘设备的键输入, 鼠标, 笔或触摸设备的输入, 以及滚轮设备的滚轮输入 暂停 1 2 3 4 clickable = driver.find_element(By.ID, \"clickable\") ActionChains(driver)\\ .pause(1)\\ .perform() 释放所有Actions 1 ActionBuilder(driver).clear_actions() 键盘操作 按键，完整按键列表 1 2 3 ActionChains(driver)\\ .key_down(Keys.SHIFT)\\ .perform() 释放按键 1 2 3 4 ActionChains(driver)\\ .key_down(Keys.SHIFT)\\ .key_up(Keys.SHIFT)\\ .perform() 键入活跃元素 1 2 3 ActionChains(driver)\\ .send_keys(\"abc\")\\ .perform() 键入指定元素 1 2 3 4 text_input = driver.find_element(By.ID, \"textInput\") ActionChains(driver)\\ .send_keys_to_element(text_input, \"abc\")\\ .perform() 复制粘贴：模仿CV Mouse actions Click and hold 1 2 3 4 clickable = driver.find_element(By.ID, \"clickable\") ActionChains(driver)\\ .click_and_hold(clickable)\\ .perform() 单击并释放 1 2 3 4 clickable = driver.find_element(By.ID, \"click\") ActionChains(driver)\\ .click(clickable)\\ .perform() 交替按钮点击：0 — 左键（默认），2 — 右键，3 — X1（后退）按钮，4 — X2（前进）按钮 上下文点击：移动到元素的中心与按下和释放鼠标右键（按钮 2） 1 2 3 4 clickable = driver.find_element(By.ID, \"clickable\") ActionChains(driver)\\ .context_click(clickable)\\ .perform() 后退点击 1 2 3 4 action = ActionBuilder(driver) action.pointer_action.pointer_down(MouseButton.BACK) action.pointer_action.pointer_up(MouseButton.BACK) action.perform() 向前点击 1 2 3 4 action = ActionBuilder(driver) action.pointer_action.pointer_down(MouseButton.FORWARD) action.pointer_action.pointer_up(MouseButton.FORWARD) action.perform() 双击 1 2 3 4 clickable = driver.find_element(By.ID, \"clickable\") ActionChains(driver)\\ .double_click(clickable)\\ .perform() 移动到元素 1 2 3 4 hoverable = driver.find_element(By.ID, \"hover\") ActionChains(driver)\\ .move_to_element(hoverable)\\ .perform() 按偏移量移动 从元素偏移（左上原点）：当元素不完全在视口内时，此方法无法正常工作 1 2 3 4 mouse_tracker = driver.find_element(By.ID, \"mouse-tracker\") ActionChains(driver)\\ .move_to_element_with_offset(mouse_tracker, 8, 0)\\ .perform() 从视口偏移 1 2 3 action = ActionBuilder(driver) action.pointer_action.move_to_location(8, 0) action.perform() 当前指针位置的偏移量 1 2 3 ActionChains(driver)\\ .move_by_offset( 13, 15)\\ .perform() 拖放元素：在源元素上执行单击并按住，移动到目标元素的位置，然后释放鼠标 1 2 3 4 5 draggable = driver.find_element(By.ID, \"draggable\") droppable = driver.find_element(By.ID, \"droppable\") ActionChains(driver)\\ .drag_and_drop(draggable, droppable)\\ .perform() 按偏移拖放 1 2 3 4 5 6 draggable = driver.find_element(By.ID, \"draggable\") start = draggable.location finish = driver.find_element(By.ID, \"droppable\").location ActionChains(driver)\\ .drag_and_drop_by_offset(draggable, finish['x'] - start['x'], finish['y'] - start['y'])\\ .perform() 滚轮动作 滚动到元素 1 2 3 4 iframe = driver.find_element(By.TAG_NAME, \"iframe\") ActionChains(driver)\\ .scroll_to_element(iframe)\\ .perform() 按给定数量滚动 1 2 3 4 5 footer = driver.find_element(By.TAG_NAME, \"footer\") delta_y = footer.rect['y'] ActionChains(driver)\\ .scroll_by_amount(0, delta_y)\\ .perform() ","date":"2023-02-06","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/selenium/:2:7","tags":["Python第三方库"],"title":"Python-第三方库-Selenium","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/selenium/"},{"categories":["Python"],"content":"双向协议 Chrome开发工具协议 模拟地理位置 1 2 3 4 5 6 7 8 9 10 11 12 from selenium import webdriver from selenium.webdriver.chrome.service import Service def geoLocationTest(): driver = webdriver.Chrome() Map_coordinates = dict({ \"latitude\": 41.8781, \"longitude\": -87.6298, \"accuracy\": 100 }) driver.execute_cdp_cmd(\"Emulation.setGeolocationOverride\", Map_coordinates) driver.get(\"\u003cyour site url\u003e\") 收集性能指标 1 2 3 4 5 6 7 8 9 from selenium import webdriver driver = webdriver.Chrome() driver.get('https://www.duckduckgo.com') driver.execute_cdp_cmd('Performance.enable', {}) t = driver.execute_cdp_cmd('Performance.getMetrics', {}) print(t) driver.quit() ","date":"2023-02-06","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/selenium/:2:8","tags":["Python第三方库"],"title":"Python-第三方库-Selenium","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/selenium/"},{"categories":["通用技术"],"content":"protobuf 官网 ","date":"2023-02-06","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/protobuf/:0:0","tags":[],"title":"通用技术-Protobuf","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/protobuf/"},{"categories":["通用技术"],"content":"概述 Protocol Buffers 是一种独立于语言、独立于平台的可扩展机制，用于序列化结构化数据。 ","date":"2023-02-06","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/protobuf/:1:0","tags":[],"title":"通用技术-Protobuf","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/protobuf/"},{"categories":["通用技术"],"content":"编程指南 ","date":"2023-02-06","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/protobuf/:2:0","tags":[],"title":"通用技术-Protobuf","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/protobuf/"},{"categories":["通用技术"],"content":"语言指南（proto 3） 定义消息类型 1 2 3 4 5 6 7 8 //默认proto2，显式声明proto3 syntax = \"proto3\"; message SearchRequest { string query = 1; int32 page_number = 2; int32 result_per_page = 3; } 指定字段类型：可以为字段指定复合类型，包括枚举 和其他消息类型 分配字段编号：每个字段都有一个唯一的编号。1 到 15 范围内的字段编号需要一个字节进行编码，包括字段编号和字段类型。16 到 2047 范围内的字段编号占用两个字节。 指定字段规则； singular:默认字段规则，除非它是默认值，否则它将被序列化。 optional:可以检查该值是否已明确设置。该字段已设置，并包含一个明确设置或从线路解析的值，将被序列化；该字段未设置，并将返回默认值，它不会被序列化。 repeated：此字段类型可以在格式正确的消息中重复零次或多次。重复值的顺序将被保留。 map：这是成对的键/值字段类型。 注释与C/C++一致 1 2 3 4 5 6 7 8 /* SearchRequest represents a search query, with pagination options to * indicate which results to include in the response. */ message SearchRequest { string query = 1; int32 page_number = 2; // Which page number do we want? int32 result_per_page = 3; // Number of results to return per page. } 保留字段:指定已删除字段的字段编号（和/或名称，这也可能导致 JSON 序列化问题）是reserved. 1 2 3 4 message Foo { reserved 2, 15, 9 to 11; reserved \"foo\", \"bar\"; } ","date":"2023-02-06","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/protobuf/:2:1","tags":[],"title":"通用技术-Protobuf","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/protobuf/"},{"categories":["通用技术"],"content":"教程 ","date":"2023-02-06","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/protobuf/:3:0","tags":[],"title":"通用技术-Protobuf","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/protobuf/"},{"categories":["通用技术"],"content":"go 定义协议格式 1 2 3 4 5 syntax = \"proto3\"; //该proto文件属于的包 package tutorial; import \"google/protobuf/timestamp.proto\"; go_package选项定义包的导入路径 1 option go_package = \"github.com/protocolbuffers/protobuf/examples/go/tutorialpb\"; 编译你的协议缓冲区 安装编译器 1 go install google.golang.org/protobuf/cmd/protoc-gen-go@latest 编译 1 protoc -I=$SRC_DIR --go_out=$DST_DIR $SRC_DIR/addressbook.proto ","date":"2023-02-06","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/protobuf/:3:1","tags":[],"title":"通用技术-Protobuf","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/protobuf/"},{"categories":["数据结构与算法"],"content":"本系列笔记为作者在跟随labuladong的算法小抄学习的时候结合golang做的笔记。感谢东哥。另外根据东哥对算法的分类法，将自己平时记的笔记也写到这里面。 第二章：手把手刷动态规划 ","date":"2023-02-04","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第二章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"动态规划解题套路框架 不要迷恋那些看起来很牛逼，代码很短小的解法思路，最好是稳一点，采取可解释性最好，最容易推广的解法思路。 动态规划问题的一般形式就是求最值。 求解动态规划的核心问题是穷举。 详见第零章 ","date":"2023-02-04","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%BA%8C%E7%AB%A0/:1:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第二章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"编辑距离 leetcode 72 编辑距离 给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数 一次操作可以插入，删除和替换1个字符 思路：动态规划 首先定义basecase，当一个字符串长度为0时，直接把另一个字符串的每个字符插入该字符或者将另一个字符的每个字符删除即可。 定义状态，要想到达basecase，只能在长度上进行缩减，两个单词的长度分别用i，j表示，dp表为一个二位数组且长度分别为len(word1)+1，len(word2)+1，basecase表示dp[i][0]=i,dp[0][j]=j。 然后定义选择，虽然说一次操作可以插入删除和替换，但是其实插入和删除可以合并位插入，因为删除word1的一个字符就等价于插入word2一个字符。所以从父问题到子问题可选择的操作有插入1个字符，替换一个字符和不操作。 另外根据word1[i]和word2[j]是否相等将问题dp[i,j]的状态转移方程分为两种情况： 当word1[i]==word2[j]时：我们可能是从子问题dp[i-1][j]选择插入一个字符得到dp[i][j]问题的答案，从子问题dp[i][j-1]选择插入一个字符得到dp[i][j]问题的答案，以及从子问题dp[i-1][j-1]不操作得到dp[i][j]问题的答案，所以dp[i][j]=min(dp[i][j−1]+1,dp[i−1][j]+1,dp[i−1][j−1]) 当word1[i]!=word2[j]时，前两种选择和上面一样，但是这里不操作就不行了，可以在子问题dp[i-1][j-1]的基础上替换一个字符得到dp[i][j]的答案，所以dp[i][j]=1+min(dp[i][j−1],dp[i−1][j],dp[i−1][j−1]) 最后根据状态转移方程写出自顶向下或者自底向上的解题代码 自顶向下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 func minDistance(word1 string, word2 string) int { l1,l2:=len(word1),len(word2) dp:=make([][]int,l1+1) for i:=0;i\u003clen(dp);i++{ dp[i]=make([]int,l2+1) for j:=0;j\u003cl2+1;j++{ dp[i][j]=-1 } dp[i][0]=i } for j:=0;j\u003clen(dp[0]);j++{ dp[0][j]=j } var dpfun func (i,j int) (int) dpfun = func (i,j int) (int){ if dp[i][j]!=-1{return dp[i][j]} if word1[i-1]==word2[j-1]{ dp[i][j]=Min(dpfun(i-1,j-1),dpfun(i-1,j)+1,dpfun(i,j-1)+1) }else { dp[i][j]=Min(dpfun(i-1,j-1)+1,dpfun(i-1,j)+1,dpfun(i,j-1)+1) } return dp[i][j] } return dpfun(l1,l2) } func Min(s ...int)int{ tmp:=s[0] for _,v:=range s{ if tmp\u003ev{tmp=v} } return tmp } ","date":"2023-02-04","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%BA%8C%E7%AB%A0/:2:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第二章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"空间压缩 如果转移方程右边的某一维(i)的值只和i或i相邻的值（i和i-k或者i和i+k）相关，那么就能把其占有的空间优化掉 通常只能优化一个维度 i和i-k则从小到大遍历，i和i+k则从大到小遍历 比如:dp[i][j]=dp[i][j-w[i-1]] 优化为:dp[j]=dp[j-w[i-1]] ","date":"2023-02-04","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%BA%8C%E7%AB%A0/:3:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第二章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"背包问题 ","date":"2023-02-04","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%BA%8C%E7%AB%A0/:4:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第二章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"01背包 每个物品只放一次，求容量w能放下的最大价值 状态定义:dp[i][j]为仅使用前i个物品（dp中的索引为i，对应物品索引为i-1），容量为j时能获取的最大价值，值为数值类型 basecase:dp[…][0]=0，dp[0][…]=0 转移方程：把第i个物品装入或不装入 dp[i][j]=max(dp[i-1][j],dp[i][j-w[i-1]]+v[i-1]),j-w[i-1]\u003e=0 dp[i-1][j],j-w[i-1]\u003c0，无法装入 空间优化:i从小到大遍历 dp[j]=max(dp[j],dp[j-w[i-1]]+v[i-1]),j-w[i-1]\u003e=0 dp[j],j-w[i-1]\u003c0 下面优化掉 dp[j]=max(dp[j],dp[j-w[i-1]]+v[i-1]),j-w[i-1]\u003e=0 ","date":"2023-02-04","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%BA%8C%E7%AB%A0/:4:1","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第二章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"子集背包：每个物品只能放一次，要求把背包装满 每个物品只放一次，求是否能完全放满背包 状态定义:dp[i][j]为使用前i个物品能否放满背包，值为bool类型 basecase:dp[…][0]=true，dp[0][…]=false 转移方程：和01背包一样 dp[i][j]=dp[i-1][j]||dp[i][j-w[i-1]],j-w[i-1]\u003e=0 dp[i-1][j],j-w[i-1]\u003c0 空间优化：i从小到大遍历 dp[j]=dp[j]||dp[j-w[i-1],j-w[i-1]\u003e=0 dp[j],j-w[i-1]\u003c0 优化掉下面这个就变成了 dp[j]=dp[j]||dp[j-w[i-1],j-w[i-1]\u003e=0 ","date":"2023-02-04","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%BA%8C%E7%AB%A0/:4:2","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第二章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"完全背包 每个物品都可以放无限次，有多少种填满背包的方法 例子：518. 零钱兑换 II 状态定义:dp[i][j]为只使用前i个物品，容量为j时填满背包的方法有多少个 basecase:dp[0][…]=0,dp[…][0]=1 转移方程:和01背包一样 dp[i][j]=dp[i-1][j]+dp[i][j-w[i-1]],j-w[i-1]\u003e=0 dp[i-1][j],j-w[i-1]\u003c0 空间优化：i从小到大遍历 dp[j]=dp[j]+dp[j-w[i-i]],j-w[i-1]\u003e=0 ","date":"2023-02-04","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%BA%8C%E7%AB%A0/:4:3","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第二章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"博弈类dp 博弈类dp 486. 预测赢家 877. 石子游戏 定义 dp 数组的含义: dp[i][j].fir = x 表示，对于 piles[i…j] 这部分石头堆，先手能获得的最高分数为 x。 dp[i][j].sec = y 表示，对于 piles[i…j] 这部分石头堆，后手能获得的最高分数为 y。 选择 先手状态：选择最左边的那堆石头，或者选择最右边的那堆石头 后手状态：先手选择后剩下石头堆的先手状态 1 2 3 4 5 6 7 dp[i][j].fir = max(piles[i] + dp[i+1][j].sec, piles[j] + dp[i][j-1].sec) dp[i][j].fir = max( 选择最左边的石头堆 , 选择最右边的石头堆 ) if 先手选择左边: dp[i][j].sec = dp[i+1][j].fir if 先手选择右边: dp[i][j].sec = dp[i][j-1].fir 由于状态转移方程右边都是i+1所以i得从大到小遍历，j-1所以j得从小到大遍历 ","date":"2023-02-04","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%BA%8C%E7%AB%A0/:5:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第二章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"数位DP CSDN unique_pursuit 给定一个闭区间[l,r]，让你求这个区间中满足某种条件的数的总数 求[0,r]满足条件的数的总数，从最高位逐位枚举，对于第n位（十进制或二进制等），r的数字位an，那么分两种情况[0,an-1]和an（有时候0也需要作为额外的特殊情况，这样就是3个特殊情况了）。[0,an-1]可以直接得到结果，an则继续细分，当第n位取an时，得到子问题第n-1位取值 求出[0,r]的结果之后，使用同样的方式求[0,l-1]的结果，然后相减就是最后的结果 通常设置memo的大小为[位数][可取值（一般为10）] 然后有一个dp(i)函数求第i位所在位置的答案(可以是递归也可以是递推) ","date":"2023-02-04","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%BA%8C%E7%AB%A0/:6:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第二章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["Golang"],"content":"go语言中文网 godoc go语言中文网有很多文档缺少内容比如string.Builder就没有，godoc绝对详尽，推荐阅读godoc ","date":"2023-02-01","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/container/:0:0","tags":["go标准库"],"title":"go标准库-Container","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/container/"},{"categories":["Golang"],"content":"heap 给一个结构体或者type一个数组类型，实现接收者为指针的Less(i,j int)bool，Swap(i,j int)，Len()int，Push(x interface{})和Pop()interface{}方法。然后就可以对这样的数据结构实例h使用heap.Push (\u0026h,x)和heap.Pop(\u0026h)。 常见使用见labuladong第一章 func Init(h Interface)：初始化，清空堆 func Push(h Interface, x interface{})：添加元素 func Pop(h Interface) interface{}：弹出堆顶元素 func Remove(h Interface, i int) interface{}：删除第i个元素 func Fix(h Interface, i int)：修改第i个元素后，调用该函数修复堆 使用sort.IntSlice实现优先队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 type PriorityQueue struct { sort.IntSlice } func (h *PriorityQueue) Push(x interface{}) { h.IntSlice = append(h.IntSlice, x.(int)) } func (h *PriorityQueue) Pop() interface{} { l := len(h.IntSlice) ret := h.IntSlice[l-1] h.IntSlice = h.IntSlice[:l-1] return ret } func (h *PriorityQueue) HPush(x int) { heap.Push(h, x) } func (h *PriorityQueue) HPop() int { return heap.Pop(h).(int) } ","date":"2023-02-01","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/container/:1:0","tags":["go标准库"],"title":"go标准库-Container","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/container/"},{"categories":["Golang"],"content":"list list是封装好的双向链表 有两个结构体，Element和List ","date":"2023-02-01","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/container/:2:0","tags":["go标准库"],"title":"go标准库-Container","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/container/"},{"categories":["Golang"],"content":"Element 1 2 3 4 5 type Element struct { // 元素保管的值 Value interface{} // 内含隐藏或非导出字段 } func (e *Element) Next() *Element:获取后一个元素 func (e *Element) Prev() *Element：获取前一个元素 直接访问Value字段可以获取存储的值，但是是空接口需要类型断言后才能使用 ","date":"2023-02-01","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/container/:2:1","tags":["go标准库"],"title":"go标准库-Container","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/container/"},{"categories":["Golang"],"content":"List 所有的mark不是l的元素的时候不起作用 func New() *List：创建一个双向链表 func (l *List) Init() *List：清空链表 func (l *List) Len() int：链表中的元素个数，O(1)时间复杂度 func (l *List) Front() *Element：返回第一个元素或nil func (l *List) Back() *Element：返回最后一个元素或nil func (l *List) PushFront(v interface{}) *Element：将v插入队头并返回生成的Element func (l *List) PushFrontList(other *List)：将other链表的拷贝插入队头 func (l *List) PushBack(v interface{}) *Element：将v插入队尾并返回生成的Element func (l *List) PushBackList(other *List)：将other链表的拷贝插入队尾 func (l *List) InsertBefore(v interface{}, mark *Element) *Element：将v插入mark的前面 func (l *List) InsertAfter(v interface{}, mark *Element) *Element：将v插入mark的后面 func (l *List) MoveToFront(e *Element)：将e放到队头 func (l *List) MoveToBack(e *Element)：将e放到队尾 func (l *List) MoveBefore(e, mark *Element)：将e放到mark前面 func (l *List) MoveAfter(e, mark *Element)：将e放到mark后面 func (l *List) Remove(e *Element) interface{}：移除e并返回e.Value ","date":"2023-02-01","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/container/:2:2","tags":["go标准库"],"title":"go标准库-Container","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/container/"},{"categories":["Golang"],"content":"ring Ring代表环形链表的一个元素 1 2 3 4 type Ring struct { Value interface{} // 供调用者使用，本包不会操作该字段 // 包含隐藏或非导出字段 } func New(n int) *Ring：创建具有n个元素的环形链表 func (r *Ring) Len() int：环形链表元素个数，O(n) func (r *Ring) Next() *Ring：后一个元素 func (r *Ring) Prev() *Ring：前一个元素 func (r *Ring) Move(n int) *Ring：移动n个位置（n\u003e=0向前移动，n\u003c0向后移动）后的元素 func (r *Ring) Link(s *Ring) *Ring：Link连接r和s，并返回r原本的后继元素r.Next() func (r *Ring) Unlink(n int) *Ring：删除链表中n % r.Len()个元素，返回删除的元素构成的链表 func (r *Ring) Do(f func(interface{}))：对链表的每一个元素都执行f（正向顺序） ","date":"2023-02-01","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/container/:3:0","tags":["go标准库"],"title":"go标准库-Container","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/container/"},{"categories":["操作系统"],"content":"ubuntu官方文档 ubuntu 18.04 server官方文档 linux265 菜鸟教程 命令大全 菜鸟教程Linux 常用命令集合 掘金 小图子 玩转Linux操作系统 博客园 单界 通常都需要配合管道符|和重定向符\u003e，\u003e\u003e，\u003c ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:0","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"常用快捷键 ctrl+alt+t:打开一个新的终端，这种方式打开的终端是不同的pts，但是属于同一个tty ctrl+z:将当前进程放到后台，后台任务可以通过fg重新放到前台执行 ctrl+c:中断当前终端 ctrl+d:发送EOF给当前终端，相当于exit命令 ctrl+s:暂停当前终端 ctrl+q:取消暂停的终端 ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:0","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"bg 查看后台任务及任务号 ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:0","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"fg 将后台任务放到前台执行 1 fg 任务号 ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:0","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"shell编程 Shell 有两种执行命令的方式交互式和批处理 第一行 #!/bin/bash 表示使用的shell程序 ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:4:0","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"Shell变量 CSDN weixin_39686634 CSDN Dust_Evc set命令显示当前shell的变量，包括当前用户的变量 env命令显示当前用户的变量 export命令显示当前导出成用户变量的shell变量 定义变量，中间不能有空格 1 2 3 variable=value variable='value' # 原样输出 variable=\"value\" # 解析动态变量 使用变量:${variable}，当variable不和其他字符串一起使用时可以去掉花括号，反例是:${variable}xxx 动态变量使用命令输出作为变量:$()或反引号。其实就是开启一个子进程执行命令，并将标准输出返回 只读变量:readonly variable 删除变量:unset variable，不能删除只读变量 ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:4:1","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"Shell数组 只支持一维数组 定义数组:array_name=(xxx xxx) 读取数组:${array_name[index]} 将数组中的元素全部输出:$arrs[*]和$arrs[@]，因为shell里面都是识别字符串（不识别数组类型），所以for in遍历时得通过这种方式来遍历数组 获取数组长度:#运算符，该运算符也可以计算字符串中单词个数或字符串中字符个数，所以： 1 2 3 len=${#arrs} len=${#arrs[*]} len=${#arrs[@]} 删除数组中的元素:unset arrs[n] 删除数组:unset arrs 拼接数组:arr3=(${arr1[@]} ${arr2[@]}) ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:4:2","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"Shell运算符 原生bash不支持算术运算，只支持逻辑运算 算术运算符+-*/%使用awk和expr命令(expr不支持浮点运算)使用动态变量进行计算:val=$(expr 1 + 2) 条件表达式要放在方括号之间，并且要有空格:[ $a == $b ] 不过一般使用关系运算符-eq(equal),-ne(not equal),-gt(greater than),-lt(less than),-ge(greater equal)和-le(less equal) 逻辑运算符:!(not),-o(or),-a(and)，使用两个方括号括起来的条件表达式[[ ]]可以直接用\u0026\u0026(and)和||(or) 字符串运算符和文件运算符见linux264教程 ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:4:3","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"Shell结构命令 if else-if else 语句 1 2 3 4 5 6 7 8 9 if condition1 then command1 elif condition2 then command2 else commandN fi for 循环 1 2 3 4 5 6 7 for var in item1 item2 ... itemN do command1 command2 ... commandN done while 语句(condition为true表示无限循环) 1 2 3 4 while condition do command done until 循环 1 2 3 4 until condition do command done case，星号 * 捕获该值，类似default 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 case 值 in 模式1) command1 command2 command3 ;; 模式2） command1 command2 command3 ;; *) command1 command2 command3 ;; esac 跳出循环，break和continue 循环k次使用seq命令返回值来进行统计 1 2 3 4 for i in $(seq 1 $1) do ... done ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:4:4","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"Shell函数 1 2 3 4 funname (){ action; [return int;] } 可以显式return，如果没有return则以最后一条命令的输出为返回值(取值为0-255) 函数参数:${n}获取第n个参数 参数个数:$# 读取返回值:$? CSDN weixin_33898876 alias别名默认不允许传入参数，可以通过alias定义一个函数来使用 1 alias tcstart='new() { /root/bin/tc-single-start \"$1\"; /root/bin/tclog \"$1\"; }; new' ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:4:5","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"Shell输入/输出重定向 \u003c:输入重定向 \u003e:输出重定向，重写 \u003e\u003e:输出重定向，追加 0为输入Stdin，1为输出Stdout，2为Stderr 当需要区分错误输出重定向和输出重定向时可以:cmd 1\u003exxx 2\u003exxx ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:4:6","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"Shell文件包含 source filename ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:4:7","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"执行子shell命令 $()或``:新建子进程执行命令 exec:使用当前shell执行命令 ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:4:8","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"gnome-terminal CSDN 宗而研之 该命令默认启动一个新的pts，图形化界面很方便，且新pts的pwd与当前终端的pwd一致 常用选项 –maximize:打开后自动最大化 –full-screen:打开后全屏 –title=“new title”:设置标题 –window 和 –tab:打开多个终端，多个tab –:要执行的命令，通常是gnome-terminal -- bash -c 'ls; exec bash'，如果要传递参数给gnome则将参数添加到后面，比如gnome-terminal -- bash -c 'ls;echo $0;exec bash' $a，这里要注意是从0开始计数的 可以通过read命令来避免直接关闭 ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:5:0","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"seq CSDN 一只小菜鸡1111 1 seq start sep end 常用选项 -s :使用指定字符串分隔数字,默认是换行符 ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:6:0","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"data CSDN 恒悦sunsite 当前系统时间 1 date [选项]... [+格式] 以下是常用的以纳秒为单位的unix时间戳 1 date +%s%N ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:7:0","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"\u0026 后台运行命令 ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:8:0","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"nohup nohup 命令运行由 Command参数和任何相关的 Arg参数指定的命令，忽略所有挂断（SIGHUP）信号。通常和后台运行命令\u0026一起使用 如果不将 nohup 命令的输出重定向，输出将附加到当前目录的 nohup.out 文件中。 ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:9:0","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"三剑客 ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:10:0","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"grep 菜鸟教程 查找文件里符合条件的行并显示前n行，该行以及后m行 1 grep -B n -A m pattern file ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:10:1","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"awk 菜鸟教程 AWK 是一种处理文本文件的语言，是一个强大的文本分析工具 常见用法，提取符合正则表达式的行的某些字段 action 通常是print $n，$n是内建变量表示选择第n个字段 pattern也可以是布尔表达式 awk '{[pattern] action}' filenames\r# 输出第二列包含 \"th\"，并打印第二列与第四列\r$ awk '$2 ~ /th/ {print $2,$4}' log.txt\r# 输出包含 \"re\" 的行\r$ awk '/re/ ' log.txt\r# 忽略大小写\r$ awk 'BEGIN{IGNORECASE=1} /this/' log.txt\r# 过滤第一列大于2的行\r$ awk '$1==2 {print $1,$3}' log.txt #命令 不使用print默认输出整行 awk脚本 BEGIN{ 这里面放的是执行前的语句 } END {这里面放的是处理完所有的行后要执行的语句 } {这里面放的是处理每一行时要执行的语句} ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:10:2","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"sed 菜鸟教程 以行为单位编辑文本 sed会修改源文件内容，所以尽量使用管道来实现不修改原文内容 1 nl testfile | sed '2,5d' 其中nl是给每行添加行号后输出，另外也可以使用cat 1 sed [-hnV][-e\u003cscript\u003e][-f\u003cscript文件\u003e][文本文件] -n或–quiet或–silent 仅显示script处理后的结果 动作说明： a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行) c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行 d ：删除，因为是删除啊，所以 d 后面通常不接任何东东 i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行) p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行 s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正则表达式！例如 1,20s/old/new/g 就是啦 ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:10:3","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"sort 菜鸟教程 从第n个字段将文本文件内容行加以排序并输出 1 sort file -k n ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:11:0","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"wc 统计指定文件中的字节数、字数、行数，并将统计结果显示输出。 1 wc test.txt 显示顺序为行数，单词数和字节数 ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:12:0","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"计划任务 ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:13:0","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"at系列，只执行一次 at - 将任务排队，在指定的时间执行。 atq - 查看待执行的任务队列。 atrm - 从队列中删除待执行的任务：atrm +at的id号 绝对时间定制任务：At 绝对时间 相对时间定制任务：at 5pm+3days ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:13:1","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"crontab -e : 执行文字编辑器来设定时程表，内定的文字编辑器是 VI，如果你想用别的文字编辑器，则请先设定 VISUAL 环境变数来指定使用那个文字编辑器(比如说 setenv VISUAL joe) -r : 删除目前的时程表 -l : 列出目前的时程表 时间格式如下： 1 2 # f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。 f1 f2 f3 f4 f5 [user-name] program 在 /etc/crontab 中添加环境变量，在可执行命令之前添加命令 . /etc/profile;/bin/sh，使得环境变量生效，例如： 1 20 03 * * * . /etc/profile;/bin/sh /var/www/runoob/test.sh 和crontab相关的文件在/etc目录下，通过修改/etc目录下的crontab文件也能够定制计划任务 @reboot标记的条目表示开机运行 1 @reboot /home/ok/auto_run_script.sh ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:13:2","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"管道和重定向的坑 labuladong 博客 管道符连接的多个命令是并行执行的 对同一个文件进行读写 1 2 # 先把数据写入临时文件，然后覆盖原始文件 cat file.txt | head -n 2 \u003e temp.txt \u0026\u0026 mv temp.txt file.txt ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:14:0","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"update-alternatives 简书 蚂蚁少儿编程 update-alternatives 命令用于处理 Linux 系统中软件版本的切换，使其多版本共存。通过软链接的方式对版本进行管理。 该命令很简单但是作用很大，最典型的用法就是linux中的python版本管理，当然也可以用anaconda，但是update-alternative还可以用于其他软件的版本管理 display 参数显示关于 Python 替换组的信息:update-alternatives --display python config 参数选择候选项:update-alternatives --config python install 参数用于添加一个命令的link值:update-alternatives --install /usr/bin/python python /usr/bin/python2.7 2 remove 参数用于删除一个命令的link值，其附带的slave也将一起删除:update-alternatives –remove python /usr/bin/python2.7 ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:15:0","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"信号相关命令 CSDN Happinesspills linux之信号 kill -l（前31个信号为常规信号，其余为实时信号）查看系统定义的信号列表 man 7 signal 查看信号的详细信息 ulimit -a 列出所有的参数选项 kill 可以使用程序名，：kill %python 可以使用ps命令、管道、grep和awk发送关闭信号：kill $(ps -a | grep chrome | awk '{print $1}') CSDN 鸣凯维 linux下kill指令默认信号,Linux基础命令之kill命令 默认信号是SIGTERM 使用pkill可以使用进程名发送信号，基于正则匹配的方式，比如kill fire会将名字匹配fire的进程关闭，类似上面的组合命令但是更简单，推荐使用pkill ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:16:0","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"常用信号 SIGINT：程序终止信号。当用户按下CRTL+C时通知前台进程组终止进程。 SIGKILL：用来立即结束程序的运行。不能被捕捉、阻塞或忽略，只能执行默认动作。 ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:16:1","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"vim 复制粘贴 v选定复制文字 d剪切，dd剪切1行 y复制 p粘贴 ?\u003csearch_string\u003e u撤销 ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:17:0","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"source 执行一遍shell脚本 通常用于覆盖配置：source ~/.bashrc ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:18:0","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"passwd 配置密码，配合sudo配置root密码 ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:19:0","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"iperf测试网络状态 服务端 iperf -s 客户端 iperf -c 10.0.0.1 ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:20:0","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"dpkg 菜鸟教程Linux 常用命令集合 安装debian系列操作系统的.deb软件，ubuntu是基于debian的 1 2 3 4 #安装 sudo dpkg -i /path/to/package.deb # 卸载 sudo dpkg -r /path/to/package.deb ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:21:0","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"systemd 阮一峰的网络日志 systemd命令组\rsystemctl为系统的启动和管理提供一套完整的解决方案 ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:22:0","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"系统管理 systemctl是 Systemd 的主命令，用于管理系统 sudo systemctl reboot：重启系统 sudo systemctl poweroff：关闭系统，切断电源 sudo systemctl halt：CPU停止工作 sudo systemctl suspend：暂停系统 sudo systemctl rescue：启动进入救援状态（单用户状态） systemd-analyze命令用于查看启动耗时 systemd-analyze：查看启动耗时 systemd-analyze blame：查看每个服务的启动耗时 systemd-analyze critical-chain：显示瀑布状的启动过程流 systemd-analyze critical-chain atd.service：显示指定服务的启动流 hostnamectl命令用于查看当前主机的信息 hostnamectl：显示当前主机的信息 sudo hostnamectl set-hostname xxx：设置主机名 loginctl命令用于查看当前登录的用户 loginctl list-sessions：列出当前session loginctl list-users：列出当前登录用户 loginctl show-user xxx：列出显示指定用户的信息 ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:22:1","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"Unit Systemd 可以管理所有系统资源。不同的资源统称为 Unit（单位） systemctl list-units命令可以查看当前系统的所有 Unit：systemctl list-units --all systemctl status命令用于查看系统状态和单个 Unit 的状态 systemctl status：显示系统状态 systemctl status bluetooth.service：显示单个 Unit 的状态 systemctl -H root@rhel7.example.com status httpd.service：显示远程主机的某个 Unit 的状态 启动和停止 Unit（主要是 service） sudo systemctl start apache.service：立即启动一个服务 sudo systemctl stop apache.service：立即停止一个服务 sudo systemctl restart apache.service：重启一个服务 sudo systemctl kill apache.service：杀死一个服务的所有子进程 sudo systemctl daemon-reload：重载所有修改过的配置文件 sudo systemctl reload apache.service：重新加载一个服务的配置文件 systemctl show httpd.service：显示某个 Unit 的所有底层参数 Unit 之间存在依赖关系：A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B systemctl list-dependencies –all nginx.service：列出一个 Unit 的所有依赖 ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:22:2","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"Unit 的配置文件 每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit Systemd 默认从目录/etc/systemd/system/读取配置文件，但是里面存放的大部分文件都是符号链接，指向目录/usr/lib/systemd/system/，真正的配置文件存放在那个目录，systemctl enable和systemctl disable命令用于在上面两个目录之间，建立和撤销符号链接关系（只有配置了WantedBy或RequiredBy的install区块的unit）。 你自己定义的unit配置文件可以手动添加到/etc/systemd/system/目录，来让systemd读取 配置文件的后缀名，就是该 Unit 的种类，比如sshd.socket，如果省略，Systemd 默认后缀名为.service systemctl list-unit-files命令用于列出所有配置文件，–type参数列出指定类型 配置文件的状态，一共有四种：enabled已建立启动链接；disabled没建立启动链接；static该配置文件没有[Install]部分（无法执行），只能作为其他配置文件的依赖；masked该配置文件被禁止建立启动链接 配置文件的格式： 1 2 3 4 5 6 7 8 9 [Unit] Description=ATD daemon [Service] Type=forking ExecStart=/usr/bin/atd [Install] WantedBy=multi-user.target [Unit]区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系 [Service]区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块 [Install]通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动（systemd开机默认会启动/etc/systemd/system里面的unit，配置了WantedBy或RequiredBy的unit在enable的时候会和前面说的一样自动建立符号链接，这样就能开机启动了） ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:22:3","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"Target systemctl list-unit-files –type=target：查看当前系统的所有 Target systemctl list-dependencies multi-user.target：查看一个 Target 包含的所有 Unit systemctl get-default：查看启动时的默认 Target sudo systemctl set-default multi-user.target：设置启动时的默认 Target sudo systemctl isolate multi-user.target：关闭前一个 Target 里面所有不属于后一个 Target 的进程，启动后一个Target Target 与 传统 init RunLevel 的对应关系如下 1 2 3 4 5 6 7 8 9 Traditional runlevel New target name Symbolically linked to... Runlevel 0 | runlevel0.target -\u003e poweroff.target Runlevel 1 | runlevel1.target -\u003e rescue.target Runlevel 2 | runlevel2.target -\u003e multi-user.target Runlevel 3 | runlevel3.target -\u003e multi-user.target Runlevel 4 | runlevel4.target -\u003e multi-user.target Runlevel 5 | runlevel5.target -\u003e graphical.target Runlevel 6 | runlevel6.target -\u003e reboot.target 默认的 RunLevel（在/etc/inittab文件设置）现在被默认的 Target 取代，位置是/etc/systemd/system/default.target 启动脚本的位置，以前是/etc/init.d目录，符号链接到不同的 RunLevel 目录 （比如/etc/rc3.d、/etc/rc5.d等），现在则存放在/lib/systemd/system和/etc/systemd/system目录 配置文件的位置，以前init进程的配置文件是/etc/inittab，各种服务的配置文件存放在/etc/sysconfig目录。现在的配置文件主要存放在/lib/systemd目录，在/etc/systemd目录里面的修改可以覆盖原始设置 ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:22:4","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"日志管理 可以只用journalctl一个命令，查看所有日志（内核日志和应用日志） sudo journalctl：查看所有日志（默认情况下 ，只保存本次启动的日志） sudo journalctl -k：查看内核日志（不显示应用日志） sudo journalctl -b -0：查看系统本次启动的日志 sudo journalctl -b -1：查看上一次启动的日志（需更改设置） sudo journalctl -f：实时滚动显示最新日志 sudo journalctl _PID=1：查看指定进程的日志 journalctl -u nginx.service -u php-fpm.service –since today：合并显示多个 Unit 的日志 ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:22:5","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"alias 设置命令的别名，对于很长且常用的命令可以在.bashrc文件使用这个命令来定义别名 1 2 3 alias fatebash=\"docker container exec -it 2fe0497f6846 /bin/bash\" alias fatestart=\"docker container start 2fe0497f6846\" alias fatestop=\"docker container stop 2fe0497f6846\" CSDN weixin_33898876 alias默认不支持传参，可以使用alias定义一个函数来实现传参 1 alias tcstart='new() { /root/bin/tc-single-start \"$1\"; /root/bin/tclog \"$1\"; }; new' ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:23:0","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"export 在当前bash导出环境变量，当放到.bashrc文件时则每次启动bash都有该环境变量 1 export a=\"xxx\" ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:24:0","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"free 查看内存使用情况 1 free ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:25:0","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"fdisk 此命令用于磁盘管理 查看所有磁盘使用情况 1 fdisk -l ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:26:0","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"df 此命令用于管理文件系统 查看文件系统的挂载点以及挂载点存储使用情况 1 df -h / ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:27:0","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"nautilus 打开文件资源管理器，常用命令:nautilus `pwd` ","date":"2023-01-29","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:28:0","tags":["linux"],"title":"操作系统-linux-常用命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Golang"],"content":"godoc github官网 github中文文档 ants是一个开源的go协程池(goruntine池)。使用很方便。 ","date":"2023-01-28","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/ants/:0:0","tags":["go第三方库"],"title":"go第三方库-Ants","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/ants/"},{"categories":["Golang"],"content":"简单使用 使用ants默认的协程池 1 2 //提交需要执行的函数 ants.Submit(syncCalculateSum) 通常和sync.waitgroup一起使用。在main里面使用wg.Add()和wg.Wait，然后在函数中使用wg.Done()。 ","date":"2023-01-28","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/ants/:1:0","tags":["go第三方库"],"title":"go第三方库-Ants","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/ants/"},{"categories":["Golang"],"content":"自定义池 自定义一个协程池，支持选项模式配置，具体看官网 1 2 3 4 5 6 // Set 10000 the size of goroutine pool p, _ := ants.NewPool(10000) //提交任务 p.Submit(func(){}) //动态调整 goroutine 池容量 pool.Tune(1000) // Tune its capacity to 1000 ","date":"2023-01-28","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/ants/:2:0","tags":["go第三方库"],"title":"go第三方库-Ants","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/ants/"},{"categories":["Golang"],"content":"释放和重启pool 协程池需要被释放，通常和defer配合使用 1 2 //释放 Pool pool.Release() 之前销毁的池可以通过重启来重新激活 1 2 //重启 Pool pool.Reboot() ","date":"2023-01-28","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/ants/:3:0","tags":["go第三方库"],"title":"go第三方库-Ants","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/ants/"},{"categories":["Golang"],"content":"通过函数构造池 直接生成专门调用某个函数的协程池 1 2 3 4 p, _ := ants.NewPoolWithFunc(10, func(i interface{}) { myFunc(i) wg.Done() }) 调用协程 1 p.Invoke(int32(i)) ","date":"2023-01-28","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/ants/:4:0","tags":["go第三方库"],"title":"go第三方库-Ants","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/ants/"},{"categories":["Golang"],"content":"go语言中文网 godoc go语言中文网有很多文档缺少内容比如string.Builder就没有，godoc绝对详尽，推荐阅读godoc ","date":"2023-01-28","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/sync/:0:0","tags":["go标准库"],"title":"go标准库-Sync","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/sync/"},{"categories":["Golang"],"content":"type Once 使用该类型对象多次调用Do方法只执行一次 func (o *Once) Do(f func()) 1 2 var once Once once.Do(func() { config.init(filename) }) ","date":"2023-01-28","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/sync/:1:0","tags":["go标准库"],"title":"go标准库-Sync","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/sync/"},{"categories":["Golang"],"content":"type Mutex 互斥锁，可以由不同的线程加锁和解锁 func (m *Mutex) Lock() func (m *Mutex) Unlock() ","date":"2023-01-28","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/sync/:2:0","tags":["go标准库"],"title":"go标准库-Sync","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/sync/"},{"categories":["Golang"],"content":"type RWMutex 读写互斥锁，可以被多个读取者持有或唯一写入者持有 func (rw *RWMutex) Lock() func (rw *RWMutex) Unlock() func (rw *RWMutex) RLock() func (rw *RWMutex) RUnlock() ","date":"2023-01-28","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/sync/:3:0","tags":["go标准库"],"title":"go标准库-Sync","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/sync/"},{"categories":["Golang"],"content":"type WaitGroup WaitGroup用于等待一组线程的结束。父线程调用Add方法来设定应等待的线程的数量。每个被等待的线程在结束时应调用Done方法。同时，主线程里可以调用Wait方法阻塞至所有线程结束。 func (wg *WaitGroup) Add(delta int) func (wg *WaitGroup) Done() func (wg *WaitGroup) Wait() ","date":"2023-01-28","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/sync/:4:0","tags":["go标准库"],"title":"go标准库-Sync","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/sync/"},{"categories":["Golang"],"content":"Map CSDN 一把把把把住了 read 和 dirty 两个字段将读写分离 读取时会先查询 read，不存在再查询 dirty，写入时则只写入 dirty 读取 read 并不需要加锁，而读或写 dirty 都需要加锁 misses 字段来统计 read 被穿透的次数（被穿透指需要读 dirty 的情况），超过一定次数则将 dirty 数据同步到 read 上 对于删除数据则直接通过标记来延迟删除 sync.Map 使用方法： 1 2 3 4 5 6 7 8 9 10 11 12 var ma sync.Map// 该类型是开箱即用，只需要声明既可 ma.Store(\"key\", \"value\") // 存储值 ma.Delete(\"key\") //删除值 ma.LoadOrStore(\"key\", \"value\")// 获取值，如果没有则存储 fmt.Println(ma.Load(\"key\"))//获取值 //遍历 ma.Range(func(key, value interface{}) bool { fmt.Printf(\"key:%s ,value:%s \\n\", key, value) //如果返回：false，则退出循环， return true }) ","date":"2023-01-28","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/sync/:5:0","tags":["go标准库"],"title":"go标准库-Sync","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/sync/"},{"categories":["Golang"],"content":"sync/atomic子包 atomic包提供了底层的原子级内存操作，对于同步算法的实现很有用 常用函数 func LoadInt32(addr int64) (val int32): 原子性的获取addr的值 func StoreInt32(addr int64, val int32): 原子性的将val的值保存到addr func AddInt32(addr int32, delta int32) (new int32): 原子性的将val的值添加到addr并返回新值 func SwapInt32(addr int32, new int32) (old int32): 原子性的将val的值添加到addr并返回新值 ","date":"2023-01-28","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/sync/:6:0","tags":["go标准库"],"title":"go标准库-Sync","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/sync/"},{"categories":["通用技术"],"content":"同源策略 MDN 浏览器的同源策略 当一个请求url的协议,域名,端口三者之间任意一个与当前的url不同都即为跨域 跨域的安全限制，主要是针对浏览器端来说的，服务器端是不存在跨域安全限制的 ","date":"2023-01-25","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/:1:0","tags":[],"title":"通用技术-跨域问题","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"},{"categories":["通用技术"],"content":"解决跨域 cors:在后端响应中添加Access-Control-Allow-Origin响应头 go原生解决办法 1 2 3 4 5 6 7 8 9 10 resp.Header().Set(\"Content-Type\", \"application/json\") resp.Header().Set(\"Access-Control-Allow-Origin\", \"*\") //允许访问所有域 // 必须，设置服务器支持的所有跨域请求的方法 resp.Header().Set(\"Access-Control-Allow-Methods\", \"POST, GET, PUT, DELETE, OPTIONS\") // 服务器支持的所有头信息字段，不限于浏览器在\"预检\"中请求的字段 resp.Header().Set(\"Access-Control-Allow-Headers\", \"content-type\") // 可选，设置XMLHttpRequest的响应对象能拿到的额外字段 resp.Header().Set(\"Access-Control-Expose-Headers\", \"Access-Control-Allow-Headers, Token\") // 可选，是否允许后续请求携带认证信息Cookir，该值只能是true，不需要则不设置 resp.Header().Set(\"Access-Control-Allow-Credentials\", \"true\") ","date":"2023-01-25","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/:2:0","tags":[],"title":"通用技术-跨域问题","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"},{"categories":["云原生"],"content":"k8s官网 k8s官网文档 k8s官网教程 k8s easydoc github yeasy/docker_practice及其最新版本电子书 ","date":"2023-01-17","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:0:0","tags":["k8s"],"title":"云原生-k8s-个人笔记","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["云原生"],"content":"查看k8s集群所有内容 1 kubectl get all ","date":"2023-01-17","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:1:0","tags":["k8s"],"title":"云原生-k8s-个人笔记","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["云原生"],"content":"以yaml文件删除deployment，service和pod 1 kubctl delete -f xxx.yaml ","date":"2023-01-17","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:2:0","tags":["k8s"],"title":"云原生-k8s-个人笔记","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["云原生"],"content":"容器网络接口(cni)，容器运行时接口(cri)和容器存储接口(csi) cni官方文档 cri官方文档1 cri官方文档2 csi官方文档 CSDN Spring_java_gg 知乎 A7kaou 这三个是谷歌为了扩展k8s功能制定的标准，符合这些标准的容器都可以接入k8s，而不是只有docker能接入，另外这三个标准也废弃掉了docker shim组件（用于屏蔽docker具有的k8s不需要的功能，如创建网络创建卷等）。 cri目前还没使用，目前仍然使用的是docker cri ","date":"2023-01-17","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:3:0","tags":["k8s"],"title":"云原生-k8s-个人笔记","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["操作系统"],"content":"本系列笔记为作者在跟随小林coding学习的时候做的笔记。感谢小林大大。 Linux命令 ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/linux%E5%91%BD%E4%BB%A4/:0:0","tags":["小林coding系列"],"title":"操作系统-小林coding-Linux命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/linux%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"如何查看网络的性能指标 通常是以 4 个指标来衡量网络的性能: 带宽，表示链路的最大传输速率，单位是 b/s （比特 / 秒），带宽越大，其传输能力就越强 延时，表示请求数据包发送后，收到对端响应，所需要的时间延迟。不同的场景有着不同的含义，比如可以表示建立 TCP 连接所需的时间延迟，或一个数据包往返所需的时间延迟 吞吐率，表示单位时间内成功传输的数据量，单位是 b/s（比特 / 秒）或者 B/s（字节 / 秒），吞吐受带宽限制，带宽越大，吞吐率的上限才可能越高 PPS，全称是 Packet Per Second（包 / 秒），表示以网络包为单位的传输速率，一般用来评估系统对于网络的转发能力 一些其他常用的性能指标 网络的可用性，表示网络能否正常通信 并发连接数，表示 TCP 连接数量 丢包率，表示所丢失数据包数量占所发送数据组的比率 重传率，表示重传网络包的比例 ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/linux%E5%91%BD%E4%BB%A4/:1:0","tags":["小林coding系列"],"title":"操作系统-小林coding-Linux命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/linux%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"网络配置如何看 ifconfig 或者 ip 命令，建议使用ip addr ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/linux%E5%91%BD%E4%BB%A4/:1:1","tags":["小林coding系列"],"title":"操作系统-小林coding-Linux命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/linux%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"socket 信息如何查看 netstat 或者 ss 1 2 3 netstat -nlp ss -ltnp linux进程到tcp中间一定有一层socket，tcp与socket的对应关系为： ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/linux%E5%91%BD%E4%BB%A4/:1:2","tags":["小林coding系列"],"title":"操作系统-小林coding-Linux命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/linux%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"网络吞吐率和 PPS 如何查看 sar命令 sar -n DEV，显示网口的统计数据 sar -n EDEV，显示关于网络错误的统计数据 sar -n TCP，显示 TCP 的统计数据 ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/linux%E5%91%BD%E4%BB%A4/:1:3","tags":["小林coding系列"],"title":"操作系统-小林coding-Linux命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/linux%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"连通性和延时如何查看 ping ping -c 5 192.168.171.3 ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/linux%E5%91%BD%E4%BB%A4/:1:4","tags":["小林coding系列"],"title":"操作系统-小林coding-Linux命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/linux%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"如何从日志分析 PV、UV 分析日志的时候，先用 ls -lh 命令查看日志文件的大小 如果日志文件数据量太大， cat 命令执行会影响线上环境，加重服务器的负载，严重的话，可能导致服务器无响应 这时使用 scp 命令将文件传输到闲置的服务器再分析 1 scp sourcefile destinationdir 可以上传也可以下载，-r参数可以传输目录 ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/linux%E5%91%BD%E4%BB%A4/:2:0","tags":["小林coding系列"],"title":"操作系统-小林coding-Linux命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/linux%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"慎用 cat 最新的日志可以用tail命令查询 1 tail -n 5 xxx.log -f参数查看实时数据 ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/linux%E5%91%BD%E4%BB%A4/:2:1","tags":["小林coding系列"],"title":"操作系统-小林coding-Linux命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/linux%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"PV 分析 PV 的全称叫 Page View，用户访问一个页面就是一次 PV 见原文 ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/linux%E5%91%BD%E4%BB%A4/:2:2","tags":["小林coding系列"],"title":"操作系统-小林coding-Linux命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/linux%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"UV 分析 UV 的全称是 Uniq Visitor，它代表访问人数 见原文 ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/linux%E5%91%BD%E4%BB%A4/:2:3","tags":["小林coding系列"],"title":"操作系统-小林coding-Linux命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/linux%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"本系列笔记为作者在跟随小林coding学习的时候做的笔记。感谢小林大大。 进程管理 ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/:0:0","tags":["小林coding系列"],"title":"操作系统-小林coding-进程管理","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"categories":["操作系统"],"content":"进程、线程基础知识 ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/:1:0","tags":["小林coding系列"],"title":"操作系统-小林coding-进程管理","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"categories":["操作系统"],"content":"进程 运行中的程序，就被称为「进程」（Process） 中断：阻塞进程释放CPU 多个程序、交替执行 并行：同一时刻多个进程同时执行 并发：同一时刻单个进程执行，但是一段时间内多个进程交替执行 进程的状态 描述进程没有占用实际的物理内存空间的情况，这个状态就是挂起状态 导致进程挂起的原因不只是因为进程所使用的内存空间不在物理内存，还包括如下情况： 通过 sleep 让进程间歇性挂起，其工作原理是设置一个定时器，到期后唤醒进程 用户希望挂起一个程序的执行，比如在 Linux 中用 Ctrl+Z 挂起进程 进程的控制结构 进程控制块（process control block，PCB）：进程存在的唯一标识 信息：进程描述信息，进程控制和管理信息，资源分配清单，CPU 相关信息 PCB 如何组织的：链表的方式进行组织，把具有相同状态的进程链在一起，组成各种队列 进程的控制 创建、终止、阻塞、唤醒 进程的上下文切换 进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源 ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/:1:1","tags":["小林coding系列"],"title":"操作系统-小林coding-进程管理","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"categories":["操作系统"],"content":"线程 为什么使用线程 进程间通信开销大 进程维护切换开销大 什么是线程 线程是进程当中的一条执行流程。 同一个进程内多个线程之间共享代码段、数据段、打开的文件等资源，但每个线程各自都有一套独立的寄存器和栈，确保线程的控制流是相对独立的 线程的优点： 一个进程中可以同时存在多个线程 各个线程之间可以并发执行 各个线程之间可以共享地址空间和文件等资源 线程的缺点：当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃（这里是针对 C/C++ 语言和goruntine，Java语言中的线程奔溃不会造成进程崩溃） 举个例子，游戏的用户设计不应该使用多线程的方式，否则一个用户挂了，会影响其他同个进程的线程 线程与进程的比较 线程相比进程能减少开销 线程的上下文切换 线程是调度的基本单位，而进程则是资源拥有的基本单位 当两个线程不属于同一个进程，切换的过程就跟进程上下文切换一样 当两个线程是属于同一个进程，只需要切换线程的私有数据、寄存器等不共享的数据 线程的实现 主要有三种线程的实现方式: 用户线程（User Thread）：在用户空间实现的线程，可扩展不支持线程技术的操作系统，切换块，但系统调用阻塞会影响同进程的线程，线程时间片分配不由操作系统控制无法打断，多线程进程和少线程进程分的时间片一样多 内核线程（Kernel Thread）：在内核中实现的线程，由内核管理的线程，系统调用不会影响同进程线程，多线程进程获得更多时间片，但进程和线程上下文都由内核维护，线程的状态切换都需要系统调用开销大 轻量级进程（LightWeight Process）：内核支持的用户线程，一个进程可有一个或多个 LWP，每个 LWP 是跟内核线程一对一映射的，也就是 LWP 都是由一个内核线程支持，而且 LWP 是由内核管理并像普通进程一样被调度。可以实现多对一，一对一，多对多用户线程和内核线程的对应关系 存储线程控制块（Thread Control Block, TCB）的进程表在用户空间就是用户线程实现，在内核空间就是内核线程实现 ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/:1:2","tags":["小林coding系列"],"title":"操作系统-小林coding-进程管理","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"categories":["操作系统"],"content":"进程间有哪些通信方式 每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。 有六种进程间通信方式 ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/:2:0","tags":["小林coding系列"],"title":"操作系统-小林coding-进程管理","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"categories":["操作系统"],"content":"管道 匿名管道 linux的|运算符就使用了匿名管道 1 int pipe(int fd[2]) 创建的子进程会复制父进程的文件描述符 匿名管道的通信范围是存在父子关系的进程 命名管道 命名管道可以在不相关的进程间也能相互通信 命名管道其实就是提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信 ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/:2:1","tags":["小林coding系列"],"title":"操作系统-小林coding-进程管理","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"categories":["操作系统"],"content":"共享内存 多个进程拿出一块自己虚拟地址空间来映射到相同的物理内存中 ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/:2:2","tags":["小林coding系列"],"title":"操作系统-小林coding-进程管理","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"categories":["操作系统"],"content":"信号量 信号量是一个整型的计数器，用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据 信号量表示资源的数量，控制信号量的方式有两种原子操作： P 操作：信号量减 1，如果信号量 \u003c 0，表明资源已被占用，进程阻塞等待；如果信号量 \u003e= 0，表明还有资源可使用，进程继续执行 V 操作：信号量加上 1，如果信号量 \u003c= 0，表明当前有阻塞中的进程，将进程唤醒运行；如果信号量 \u003e 0，表明当前没有阻塞中的进程 ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/:2:3","tags":["小林coding系列"],"title":"操作系统-小林coding-进程管理","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"categories":["操作系统"],"content":"信号 异常情况下的工作模式 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。可以通过 kill -l 命令查看所有信号 运行在 shell 终端的进程，可以通过键盘输入某些组合键的时候，给进程发送信号 Ctrl+C 产生 SIGINT 信号，表示终止该进程 Ctrl+Z 产生 SIGTSTP 信号，表示停止该进程，但还未结束 如果进程在后台运行，可以通过 kill 命令的方式给进程发送信号 kill -9 1050 ，表示给 PID 为 1050 的进程发送 SIGKILL 信号，用来立即结束该进程 信号是进程间通信机制中唯一的异步通信机制 用户进程对信号的处理方式： 执行默认操作 捕捉信号：为信号定义一个信号处理函数，收到信号执行该函数 忽略信号：不希望处理某些信号时，忽略该信号，不做任何处理。SIGKILL 和 SEGSTOP无法捕捉和忽略，它们用于在任何时候中断或结束某一进程 ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/:2:4","tags":["小林coding系列"],"title":"操作系统-小林coding-进程管理","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"categories":["操作系统"],"content":"Socket Socket跨网络与不同主机上的进程之间通信 根据创建 socket 类型的不同，通信的方式也就不同，主要有3类：TCP，UDP和本地 TCP UDP 本地 在同一台主机上进程间通信 本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是绑定一个本地文件，这也就是它们之间的最大区别 ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/:2:5","tags":["小林coding系列"],"title":"操作系统-小林coding-进程管理","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"categories":["操作系统"],"content":"怎么避免死锁 ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/:3:0","tags":["小林coding系列"],"title":"操作系统-小林coding-进程管理","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"categories":["操作系统"],"content":"死锁的概念 死锁：多个线程都在等待对方释放锁 条件： 互斥条件：多个线程不能同时使用同一个资源 持有并等待条件：线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1 不可剥夺条件：在自己使用完之前不能被其他线程获取 环路等待条件：多个线程获取资源的顺序构成了环形链 ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/:3:1","tags":["小林coding系列"],"title":"操作系统-小林coding-进程管理","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"categories":["操作系统"],"content":"什么是悲观锁、乐观锁 ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/:4:0","tags":["小林coding系列"],"title":"操作系统-小林coding-进程管理","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"categories":["操作系统"],"content":"互斥锁与自旋锁 互斥锁加锁失败后，线程会释放 CPU ，给其他线程 自旋锁加锁失败后，线程会忙等待，直到它拿到锁 被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁 在单核 CPU 上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/:4:1","tags":["小林coding系列"],"title":"操作系统-小林coding-进程管理","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"categories":["操作系统"],"content":"读写锁 读写锁适用于能明确区分读操作和写操作的场景 读写锁在读多写少的场景，能发挥出优势 ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/:4:2","tags":["小林coding系列"],"title":"操作系统-小林coding-进程管理","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"categories":["操作系统"],"content":"乐观锁与悲观锁 前面提到的互斥锁、自旋锁、读写锁，都是属于悲观锁 悲观锁：访问共享资源前，先要上锁 乐观锁：结束操作时检查是否有其他线程修改资源 乐观锁全程并没有加锁，所以它也叫无锁编程 只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁 ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/:4:3","tags":["小林coding系列"],"title":"操作系统-小林coding-进程管理","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"categories":["操作系统"],"content":"本系列笔记为作者在跟随小林coding学习的时候做的笔记。感谢小林大大。 内存管理 ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/:0:0","tags":["小林coding系列"],"title":"操作系统-小林coding-内存管理","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"categories":["操作系统"],"content":"为什么要有虚拟内存 操作系统为每个进程分配独立的「虚拟地址」。 操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。 程序所使用的内存地址叫做虚拟内存地址（Virtual Memory Address） 实际存在硬件里面的空间地址叫物理内存地址（Physical Memory Address） 映射过程主要有两种方式，分别是内存分段和内存分页 ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/:1:0","tags":["小林coding系列"],"title":"操作系统-小林coding-内存管理","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"categories":["操作系统"],"content":"内存分段 分段机制下的虚拟地址由两部分组成，段选择因子和段内偏移量 虚拟地址是通过段表与物理地址进行映射的 不足：内存碎片，内存交换的效率低（需要将整段写入换出） ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/:1:1","tags":["小林coding系列"],"title":"操作系统-小林coding-内存管理","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"categories":["操作系统"],"content":"内存分页 分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小（页） 虚拟地址与物理地址之间通过页表来映射 内存管理单元 （MMU）将虚拟内存地址转换成物理地址 当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。 采用了分页，页与页之间是紧密排列的，所以不会有外部碎片。内存分页机制会有内部内存碎片。 内存空间不够操作系统将正在运行的进程中「最近没被使用」的内存页面暂时写在硬盘上，称为换出（Swap Out）。需要的时候，再加载进来，称为换入（Swap In）。 一次性写入磁盘只有少数的一个页或者几个页，内存交换的效率相对段式较高。只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。 在分页机制下，虚拟地址分为两部分，页号和页内偏移 内存地址转换三个步骤： 虚拟内存地址，切分成页号和偏移量 根据页号，从页表里面，查询对应的物理页号 拿物理页号，加上前面的偏移量，就得到了物理内存地址 简单的分页进程的页表空间开销会很大 ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/:1:2","tags":["小林coding系列"],"title":"操作系统-小林coding-内存管理","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"categories":["操作系统"],"content":"多级页表 局部性原理 对于 64 位的系统，两级分页肯定不够了，就变成了四级目录 ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/:1:3","tags":["小林coding系列"],"title":"操作系统-小林coding-内存管理","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"categories":["操作系统"],"content":"TLB 把最常访问的几个页表项存储到访问速度更快的硬件 TLB（Translation Lookaside Buffer） ，通常称为页表缓存、转址旁路缓存、快表等 ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/:1:4","tags":["小林coding系列"],"title":"操作系统-小林coding-内存管理","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"categories":["操作系统"],"content":"段页式内存管理 先将程序划分为多个有逻辑意义的段 再把每个段划分为多个页 逻辑地址结构就由段号、段内页号和页内位移三部分组成 ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/:1:5","tags":["小林coding系列"],"title":"操作系统-小林coding-内存管理","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"categories":["操作系统"],"content":"Linux 内存布局 Linux 内存主要采用的是页式内存管理，但同时也不可避免地涉及了段机制 Linux 系统中操作系统本身和应用程序每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下）。所以，地址空间都是线性地址空间（虚拟地址），这相当于屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护。 虚拟地址空间内部被分为内核空间和用户空间两部分，不同位数的系统，地址空间的范围也不同 内核空间与用户空间的区别： 用户态，只能访问用户空间内存 内核态才可以访问内核空间的内存 每个虚拟内存中的内核地址，其实关联的都是相同的物理内存 用户空间分布的情况 代码段，包括二进制可执行代码 数据段，包括已初始化的静态常量和全局变量 BSS 段，包括未初始化的静态变量和全局变量 堆段，包括动态分配的内存，从低地址开始向上增长 文件映射段，包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关 (opens new window)） 栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。系统也提供了参数，以便我们自定义大小 代码段下面还有一段内存空间的（灰色部分），这一块区域是「保留区」。较小数值的地址不是一个合法地址，例如，我们通常在 C 的代码里会将无效的指针赋值为 NULL。因此，这里会出现一段不可访问的内存保留区，防止程序因为出现 bug，导致读或写了一些小内存地址的数据，而使得程序跑飞。 ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/:1:6","tags":["小林coding系列"],"title":"操作系统-小林coding-内存管理","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"categories":["操作系统"],"content":"虚拟内存有什么作用 运行超过物理内存大小的程序 进程隔离 标记属性的比特控制内存访问 ","date":"2023-01-15","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/:1:7","tags":["小林coding系列"],"title":"操作系统-小林coding-内存管理","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%9E%97coding/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"categories":["操作系统"],"content":"ubuntu官方文档 ubuntu 18.04 server官方文档 linux265 ","date":"2023-01-13","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%91%BD%E4%BB%A4/:0:0","tags":["linux"],"title":"操作系统-linux-服务器命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"scp 上传本地aa.log文件到服务器目录home下 1 scp ~/Downloads/aa.log user@192.168.31.68:/home/ 将服务器目录/home/aa.log 文件 下载到本地Downloads 目录下 1 scp user@192.168.31.68:/home/aa.log ~/Downloads/ 文件夹：-r参数 与windows互传文件 如果windows没有开启ssh服务那么无法使用下面的命令 1 2 scp user@172.16.10.23:/e:/video/test.mkv ./scpTest/ scp /root/test.mkv user@172.16.10.23:/e:/video/ 只有启动了ssh服务的系统才能用user@172.16.10.23:/e:/video/test.mkv这样的形式 ","date":"2023-01-13","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%91%BD%E4%BB%A4/:1:0","tags":["linux"],"title":"操作系统-linux-服务器命令","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Golang"],"content":"godoc github 官方文档 Modd 是一种开发人员工具，可触发命令并管理守护进程以响应文件系统更改。 ","date":"2023-01-10","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/modd/:0:0","tags":["go第三方库"],"title":"go第三方库-Modd","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/modd/"},{"categories":["Golang"],"content":"安装 1 go install github.com/cortesi/modd/cmd/modd@latest ","date":"2023-01-10","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/modd/:1:0","tags":["go第三方库"],"title":"go第三方库-Modd","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/modd/"},{"categories":["Golang"],"content":"使用 go项目热重载主要使用文件监视模式，即文件修改后触发花括号里的命令执行 命令有两种类型：运行和终止的准备命令（例如编译、运行测试套件或运行 linter），以及运行和保持运行的守护程序命令（例如数据库或网络服务器）。守护进程在它们的块被触发后被发送一个信号（默认情况下为SIGHUP（但是一般配置为SIGKILL或者SIGTERM关闭守护进程）） 默认情况下，modd 使用内置的 POSIX-like shell解释命令 在项目根目录上生成一个modd.conf文件 里面的文件监视示例如下： **/*.go !**/*_test.go {\rprep: go install ./cmd/devd\rdaemon +sigterm: devd -m ./tmp\r} ","date":"2023-01-10","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/modd/:2:0","tags":["go第三方库"],"title":"go第三方库-Modd","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/modd/"},{"categories":["Golang"],"content":"godoc godoc官方文档 github官方文档 example见github ","date":"2023-01-09","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/go-queue/:0:0","tags":["go第三方库"],"title":"go第三方库-Go Queue","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/go-queue/"},{"categories":["Golang"],"content":"dq ","date":"2023-01-09","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/go-queue/:1:0","tags":["go第三方库"],"title":"go第三方库-Go Queue","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/go-queue/"},{"categories":["Golang"],"content":"consumer example 1 2 3 4 5 6 7 8 9 consumer := dq.NewConsumer(dq.DqConf{ Redis: redis.RedisConf{ Host: \"localhost:6379\", Type: redis.NodeType, }, }) consumer.Consume(func(body []byte) { fmt.Println(string(body)) }) ","date":"2023-01-09","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/go-queue/:1:1","tags":["go第三方库"],"title":"go第三方库-Go Queue","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/go-queue/"},{"categories":["Golang"],"content":"producer example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 producer := dq.NewProducer([]dq.Beanstalk{ { Endpoint: \"localhost:11300\", Tube: \"tube\", }, { Endpoint: \"localhost:11300\", Tube: \"tube\", }, }) for i := 1000; i \u003c 1005; i++ { _, err := producer.Delay([]byte(strconv.Itoa(i)), time.Second*5) if err != nil { fmt.Println(err) } } ","date":"2023-01-09","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/go-queue/:1:2","tags":["go第三方库"],"title":"go第三方库-Go Queue","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/go-queue/"},{"categories":["Golang"],"content":"kq kq不支持创建topic ","date":"2023-01-09","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/go-queue/:2:0","tags":["go第三方库"],"title":"go第三方库-Go Queue","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/go-queue/"},{"categories":["Golang"],"content":"consumer example config.json 1 2 3 4 5 6 7 8 9 Name: kq Brokers: - 127.0.0.1:19092 - 127.0.0.1:19092 - 127.0.0.1:19092 Group: adhoc Topic: kq Offset: first Consumers: 1 go文件 1 2 3 4 5 6 7 8 9 var c kq.KqConf conf.MustLoad(\"config.json\", \u0026c) q := kq.MustNewQueue(c, kq.WithHandle(func(k, v string) error { fmt.Printf(\"=\u003e %s\\n\", v) return nil })) defer q.Stop() q.Start() ","date":"2023-01-09","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/go-queue/:2:1","tags":["go第三方库"],"title":"go第三方库-Go Queue","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/go-queue/"},{"categories":["Golang"],"content":"producer example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 type message struct { Key string `json:\"key\"` Value string `json:\"value\"` Payload string `json:\"message\"` } pusher := kq.NewPusher([]string{ \"127.0.0.1:19092\", \"127.0.0.1:19092\", \"127.0.0.1:19092\", }, \"kq\") ticker := time.NewTicker(time.Millisecond) for round := 0; round \u003c 3; round++ { select { case \u003c-ticker.C: count := rand.Intn(100) m := message{ Key: strconv.FormatInt(time.Now().UnixNano(), 10), Value: fmt.Sprintf(\"%d,%d\", round, count), Payload: fmt.Sprintf(\"%d,%d\", round, count), } body, err := json.Marshal(m) if err != nil { log.Fatal(err) } fmt.Println(string(body)) if err := pusher.Push(string(body)); err != nil { log.Fatal(err) } } } cmdline.EnterToContinue() ","date":"2023-01-09","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/go-queue/:2:2","tags":["go第三方库"],"title":"go第三方库-Go Queue","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/go-queue/"},{"categories":["Golang"],"content":"go-zero官网 go-zero官网博客 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%AE%98%E6%96%B9%E5%8D%9A%E5%AE%A2/:0:0","tags":["go-zero"],"title":"golang-go-zero-官方博客","uri":"/posts/golang/go-zero/%E5%AE%98%E6%96%B9%E5%8D%9A%E5%AE%A2/"},{"categories":["Golang"],"content":"缓存设计 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%AE%98%E6%96%B9%E5%8D%9A%E5%AE%A2/:1:0","tags":["go-zero"],"title":"golang-go-zero-官方博客","uri":"/posts/golang/go-zero/%E5%AE%98%E6%96%B9%E5%8D%9A%E5%AE%A2/"},{"categories":["Golang"],"content":"持久层缓存 缓存只删除不更新 行记录始终只存储一份，即主键对应行记录 唯一索引仅缓存主键值，不直接缓存行记录（参考mysql索引思想） 防缓存穿透设计，缓存中没有的添加*记录，并使用Once查询数据库，默认一分钟 不缓存多行记录 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%AE%98%E6%96%B9%E5%8D%9A%E5%AE%A2/:1:1","tags":["go-zero"],"title":"golang-go-zero-官方博客","uri":"/posts/golang/go-zero/%E5%AE%98%E6%96%B9%E5%8D%9A%E5%AE%A2/"},{"categories":["Golang"],"content":"业务层缓存 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%AE%98%E6%96%B9%E5%8D%9A%E5%AE%A2/:1:2","tags":["go-zero"],"title":"golang-go-zero-官方博客","uri":"/posts/golang/go-zero/%E5%AE%98%E6%96%B9%E5%8D%9A%E5%AE%A2/"},{"categories":["Golang"],"content":"进程内缓存工具collection.Cache 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 初始化 cache，其中 WithLimit 可以指定最大缓存的数量 c, err := collection.NewCache(time.Minute, collection.WithLimit(10000)) if err != nil { panic(err) } // 设置缓存 c.Set(\"key\", user) // 获取缓存，ok：是否存在 v, ok := c.Get(\"key\") // 删除缓存 c.Del(\"key\") // 获取缓存，如果 key 不存在的，则会调用 func 去生成缓存 v, err := c.Take(\"key\", func() (interface{}, error) { return user, nil }) ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%AE%98%E6%96%B9%E5%8D%9A%E5%AE%A2/:1:3","tags":["go-zero"],"title":"golang-go-zero-官方博客","uri":"/posts/golang/go-zero/%E5%AE%98%E6%96%B9%E5%8D%9A%E5%AE%A2/"},{"categories":["Golang"],"content":"并发编程 mapreduce官方文档 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%AE%98%E6%96%B9%E5%8D%9A%E5%AE%A2/:2:0","tags":["go-zero"],"title":"golang-go-zero-官方博客","uri":"/posts/golang/go-zero/%E5%AE%98%E6%96%B9%E5%8D%9A%E5%AE%A2/"},{"categories":["Golang"],"content":"简单使用Finish函数 并发执行多个函数。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func productDetail(uid, pid int64) (*ProductDetail, error) { var pd ProductDetail err := mr.Finish(func() (err error) { pd.User, err = userRpc.User(uid) return }, func() (err error) { pd.Store, err = storeRpc.Store(pid) return }, func() (err error) { pd.Order, err = orderRpc.Order(pid) return }) if err != nil { log.Printf(\"product detail error: %v\", err) return nil, err } return \u0026pd, nil } ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%AE%98%E6%96%B9%E5%8D%9A%E5%AE%A2/:2:1","tags":["go-zero"],"title":"golang-go-zero-官方博客","uri":"/posts/golang/go-zero/%E5%AE%98%E6%96%B9%E5%8D%9A%E5%AE%A2/"},{"categories":["Golang"],"content":"复杂使用：MapReduce 并发对多个对象执行mapreduce 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 func checkLegal(uids []int64) ([]int64, error) { r, err := mr.MapReduce(func(source chan\u003c- interface{}) { for _, uid := range uids { source \u003c- uid } }, func(item interface{}, writer mr.Writer, cancel func(error)) { uid := item.(int64) ok, err := check(uid) if err != nil { cancel(err) } if ok { writer.Write(uid) } }, func(pipe \u003c-chan interface{}, writer mr.Writer, cancel func(error)) { var uids []int64 for p := range pipe { uids = append(uids, p.(int64)) } writer.Write(uids) }) if err != nil { log.Printf(\"check error: %v\", err) return nil, err } return r.([]int64), nil } func check(uid int64) (bool, error) { // do something check user legal return true, nil } 调用cancel立即返回nil, error ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%AE%98%E6%96%B9%E5%8D%9A%E5%AE%A2/:2:2","tags":["go-zero"],"title":"golang-go-zero-官方博客","uri":"/posts/golang/go-zero/%E5%AE%98%E6%96%B9%E5%8D%9A%E5%AE%A2/"},{"categories":["Golang"],"content":"流处理 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%AE%98%E6%96%B9%E5%8D%9A%E5%AE%A2/:3:0","tags":["go-zero"],"title":"golang-go-zero-官方博客","uri":"/posts/golang/go-zero/%E5%AE%98%E6%96%B9%E5%8D%9A%E5%AE%A2/"},{"categories":["Golang"],"content":"fx 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func outputStream(ch chan int) { fx.From(func(source chan\u003c- interface{}) { for c := range ch { source \u003c- c } }).Walk(func(item interface{}, pipe chan\u003c- interface{}) { count := item.(int) pipe \u003c- count }).Filter(func(item interface{}) bool { itemInt := item.(int) if itemInt%2 == 0 { return true } return false }).ForEach(func(item interface{}) { fmt.Println(item) }) } ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%AE%98%E6%96%B9%E5%8D%9A%E5%AE%A2/:3:1","tags":["go-zero"],"title":"golang-go-zero-官方博客","uri":"/posts/golang/go-zero/%E5%AE%98%E6%96%B9%E5%8D%9A%E5%AE%A2/"},{"categories":["Golang"],"content":"mysql ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%AE%98%E6%96%B9%E5%8D%9A%E5%AE%A2/:4:0","tags":["go-zero"],"title":"golang-go-zero-官方博客","uri":"/posts/golang/go-zero/%E5%AE%98%E6%96%B9%E5%8D%9A%E5%AE%A2/"},{"categories":["Golang"],"content":"go-zero官网 go-zero详细文档 本系列为作者阅读公众号微服务实践的文章做的笔记 另外go-zero作者kevwan大佬的learnku博客也是同步更新的 原文地址 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/:0:0","tags":["go-zero"],"title":"golang-go-zero-微服务实践-微服务实战系列","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/"},{"categories":["Golang"],"content":"工程结构 每个服务目录下我们又会分为多个服务，主要会有如下几类服务： api - 对外的BFF服务，接受来自客户端的请求，暴露HTTP接口 rpc - 对内的微服务，仅接受来自内部其他微服务或者BFF的请求，暴露gRPC接口 rmq - 负责进行流式任务处理，上游一般依赖消息队列，比如kafka等 admin - 也是对内的服务，区别于rpc，更多的是面向运营侧的且数据权限较高，通过隔离可带来更好的代码级别的安全，直接提供HTTP接口 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/:1:0","tags":["go-zero"],"title":"golang-go-zero-微服务实践-微服务实战系列","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/"},{"categories":["Golang"],"content":"日志定义 1 2 3 4 5 //关闭Stat日志 logx.DisableStat() //设置日志等级 logx.SetLevel(logx.ErrorLevel) ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/:2:0","tags":["go-zero"],"title":"golang-go-zero-微服务实践-微服务实战系列","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/"},{"categories":["Golang"],"content":"服务依赖 yaml配置中给依赖rpc或注册中心设置NonBlock实现不等待依赖启动 1 2 3 4 5 6 ReplyRPC: Etcd: Hosts: - 127.0.0.1:2379 Key: reply.rpc NonBlock: true ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/:3:0","tags":["go-zero"],"title":"golang-go-zero-微服务实践-微服务实战系列","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/"},{"categories":["Golang"],"content":"并行调用 mapreduce官方文档 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/:4:0","tags":["go-zero"],"title":"golang-go-zero-微服务实践-微服务实战系列","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/"},{"categories":["Golang"],"content":"图片上传 在yaml配置文件里面配置第三方OSS的三个属性 1 2 3 OSSEndpoint: https://oss-cn-hangzhou.aliyuncs.com AccessKeyID: xxxxxxxxxxxxxxxxxxxxxxxx AccessKeySecret: xxxxxxxxxxxxxxxxxxxxxxxx 在config.go里面添加接收参数 1 2 3 4 5 6 type Config struct { rest.RestConf OSSEndpoint string AccessKeyID string AccessKeySecret string } 在svcCtx里面添加oss客户端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type ServiceContext struct { Config config.Config OssClient *oss.Client } func NewServiceContext(c config.Config) *ServiceContext { oc, err := oss.New(c.OSSEndpoint, c.AccessKeyID, c.AccessKeySecret) if err != nil { panic(err) } return \u0026ServiceContext{ Config: c, OssClient: oc, } } 之后就可以在logic里面使用oss客户端上传图片了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func (l *UploadImageLogic) UploadImage() (resp *types.UploadImageResponse, err error) { file, header, err := l.r.FormFile(imageFileName) if err != nil { return nil, err } defer file.Close() bucket, err := l.svcCtx.OssClient.Bucket(bucketName) if err != nil { return nil, err } if err = bucket.PutObject(header.Filename, file); err != nil { return nil, err } return \u0026types.UploadImageResponse{Success: true}, nil } 上传图片前需要先自行创建bucket ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/:5:0","tags":["go-zero"],"title":"golang-go-zero-微服务实践-微服务实战系列","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/"},{"categories":["Golang"],"content":"缓存代码怎么写 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/:6:0","tags":["go-zero"],"title":"golang-go-zero-微服务实践-微服务实战系列","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/"},{"categories":["Golang"],"content":"基本使用 goctl生成model时添加-c参数 yaml配置文件 1 2 3 CacheRedis: - Host: 127.0.0.1:6379 Type: node svc添加字段 1 CategoryModel: model.NewCategoryModel(conn, c.CacheRedis) ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/:6:1","tags":["go-zero"],"title":"golang-go-zero-微服务实践-微服务实战系列","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/"},{"categories":["Golang"],"content":"缓存雪崩 两种类型 大量的数据同时过期：避免大量的数据设置相同的过期时间，在过期时间上加一个较小的随机数 Redis出现了宕机：让数据库支持熔断，压力较大时丢弃部分请求 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/:6:2","tags":["go-zero"],"title":"golang-go-zero-微服务实践-微服务实战系列","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/"},{"categories":["Golang"],"content":"缓存击穿 热点数据过期失效：每次查询缓存的时候使用Expire给缓存续期，不存在时singleflight查询数据库 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/:6:3","tags":["go-zero"],"title":"golang-go-zero-微服务实践-微服务实战系列","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/"},{"categories":["Golang"],"content":"缓存穿透 访问的数据既不在缓存中，也不在数据库中：缓存一个空值，避免每次都透传到数据库 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/:6:4","tags":["go-zero"],"title":"golang-go-zero-微服务实践-微服务实战系列","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/"},{"categories":["Golang"],"content":"缓存一致性保证 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/:7:0","tags":["go-zero"],"title":"golang-go-zero-微服务实践-微服务实战系列","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/"},{"categories":["Golang"],"content":"先删缓存再更新数据库 删除和更新之间被其他线程读取会留存旧值：延时双删，更新完数据库的值后，sleep一小段时间，再进行一次缓存删除操作 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/:7:1","tags":["go-zero"],"title":"golang-go-zero-微服务实践-微服务实战系列","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/"},{"categories":["Golang"],"content":"先更新数据库再删除缓存 推荐方式，删除缓存的动作很快 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/:7:2","tags":["go-zero"],"title":"golang-go-zero-微服务实践-微服务实战系列","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/"},{"categories":["Golang"],"content":"重试机制 使用消息队列来保证正确删除缓存 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/:7:3","tags":["go-zero"],"title":"golang-go-zero-微服务实践-微服务实战系列","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/"},{"categories":["Golang"],"content":"并发读写 由于读取不在缓存中的数据的过程是读取数据库然后插入缓存，所以可能会出现抹去修改的情况：将读取缓存的set cache操作换成add cache，只有在缓存不存在的时候才成功写入 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/:7:4","tags":["go-zero"],"title":"golang-go-zero-微服务实践-微服务实战系列","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/"},{"categories":["Golang"],"content":"优化高并发 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/:8:0","tags":["go-zero"],"title":"golang-go-zero-微服务实践-微服务实战系列","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/"},{"categories":["Golang"],"content":"本地缓存 go-zero的collection中提供了Cache来实现本地缓存的功能，Cache提供了Get和Set方法 1 localCache, err := collection.NewCache(localCacheExpire) ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/:8:1","tags":["go-zero"],"title":"golang-go-zero-微服务实践-微服务实战系列","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/"},{"categories":["Golang"],"content":"自动识别热点数据 滑动窗口统计请求次数，超过阈值升级为本地缓存 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/:8:2","tags":["go-zero"],"title":"golang-go-zero-微服务实践-微服务实战系列","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/"},{"categories":["Golang"],"content":"处理每秒上万次的下单请求 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/:9:0","tags":["go-zero"],"title":"golang-go-zero-微服务实践-微服务实战系列","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/"},{"categories":["Golang"],"content":"处理热点数据 优化：在内存中缓存热点数据 限制：限制单用户的请求次数，超过限制直接返回错误 隔离：服务隔离，即秒杀功能独立为一个服务，使用单独的Redis集群和单独的Mysql ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/:9:1","tags":["go-zero"],"title":"golang-go-zero-微服务实践-微服务实战系列","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/"},{"categories":["Golang"],"content":"流量削峰 消息队列 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/:9:2","tags":["go-zero"],"title":"golang-go-zero-微服务实践-微服务实战系列","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/"},{"categories":["Golang"],"content":"保证消息只被消费一次 kafka是能够保证\"At Least Once\"的机制的，消息不会丢失，但有可能会导致重复消费 保证在消息的生产和消费的过程是幂等的，不要出现相对加减，直接赋值 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/:9:3","tags":["go-zero"],"title":"golang-go-zero-微服务实践-微服务实战系列","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/"},{"categories":["Golang"],"content":"极致优化秒杀性能 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/:10:0","tags":["go-zero"],"title":"golang-go-zero-微服务实践-微服务实战系列","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/"},{"categories":["Golang"],"content":"批量数据聚合 批量数据聚合：减少网络IO和磁盘IO成本，将多条数据（如100条）聚合后进行处理。之前是1条对应一次网络IO和磁盘IO，现在就是100条对应1次 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/:10:1","tags":["go-zero"],"title":"golang-go-zero-微服务实践-微服务实战系列","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/"},{"categories":["Golang"],"content":"降低消息的消费延迟 增加消费者的数量 在一个消费者中增加消息处理的并行度 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/:10:2","tags":["go-zero"],"title":"golang-go-zero-微服务实践-微服务实战系列","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/"},{"categories":["Golang"],"content":"保证不会超卖 分布式锁 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/:10:3","tags":["go-zero"],"title":"golang-go-zero-微服务实践-微服务实战系列","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/"},{"categories":["Golang"],"content":"go-zero官网 go-zero详细文档 本系列为作者阅读公众号微服务实践的文章做的笔记 另外go-zero作者kevwan大佬的learnku博客也是同步更新的 原文地址 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E7%BB%99rpc%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9Bhttp%E6%8E%A5%E5%8F%A3/:0:0","tags":["go-zero"],"title":"golang-go-zero-微服务实践-给rpc服务提供http接口","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E7%BB%99rpc%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9Bhttp%E6%8E%A5%E5%8F%A3/"},{"categories":["Golang"],"content":"提供rpc接口 按rpc开发流程构建rpc服务，一键生成。 编写logic实现相关功能 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E7%BB%99rpc%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9Bhttp%E6%8E%A5%E5%8F%A3/:1:0","tags":["go-zero"],"title":"golang-go-zero-微服务实践-给rpc服务提供http接口","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E7%BB%99rpc%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9Bhttp%E6%8E%A5%E5%8F%A3/"},{"categories":["Golang"],"content":"提供http接口 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E7%BB%99rpc%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9Bhttp%E6%8E%A5%E5%8F%A3/:2:0","tags":["go-zero"],"title":"golang-go-zero-微服务实践-给rpc服务提供http接口","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E7%BB%99rpc%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9Bhttp%E6%8E%A5%E5%8F%A3/"},{"categories":["Golang"],"content":"proto文件 新建一个proto（推荐）或者修改原来的proto。如果原来的proto为sum.proto你可以新建一个和sum-api.proto，在原来proto的基础上添加下面这一行 1 import \"google/api/annotations.proto\"; ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E7%BB%99rpc%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9Bhttp%E6%8E%A5%E5%8F%A3/:2:1","tags":["go-zero"],"title":"golang-go-zero-微服务实践-给rpc服务提供http接口","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E7%BB%99rpc%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9Bhttp%E6%8E%A5%E5%8F%A3/"},{"categories":["Golang"],"content":"生成proto descriptor文件 1 protoc --include_imports --proto_path=. --descriptor_set_out=sum.pb sum-api.proto ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E7%BB%99rpc%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9Bhttp%E6%8E%A5%E5%8F%A3/:2:2","tags":["go-zero"],"title":"golang-go-zero-微服务实践-给rpc服务提供http接口","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E7%BB%99rpc%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9Bhttp%E6%8E%A5%E5%8F%A3/"},{"categories":["Golang"],"content":"修改internal/config/config.go和yaml config.go 1 2 3 4 type Config struct { zrpc.RpcServerConf Gateway gateway.GatewayConf } yaml 1 2 3 4 5 6 7 8 Gateway: Name: gateway Port: 8081 Upstreams: - Grpc: Endpoints: - localhost:8080 ProtoSet: sum.pb ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E7%BB%99rpc%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9Bhttp%E6%8E%A5%E5%8F%A3/:2:3","tags":["go-zero"],"title":"golang-go-zero-微服务实践-给rpc服务提供http接口","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E7%BB%99rpc%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9Bhttp%E6%8E%A5%E5%8F%A3/"},{"categories":["Golang"],"content":"修改main 1 2 3 4 5 6 7 8 9 gw := gateway.MustNewServer(c.Gateway) group := service.NewServiceGroup() group.Add(s) group.Add(gw) defer group.Stop() fmt.Printf(\"Starting rpc server at %s...\\n\", c.ListenOn) fmt.Printf(\"Starting gateway at %s:%d...\\n\", c.Gateway.Host, c.Gateway.Port) group.Start() 相应的http请求都是post，数据放到json结构体 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E7%BB%99rpc%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9Bhttp%E6%8E%A5%E5%8F%A3/:2:4","tags":["go-zero"],"title":"golang-go-zero-微服务实践-给rpc服务提供http接口","uri":"/posts/golang/go-zero/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/%E7%BB%99rpc%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9Bhttp%E6%8E%A5%E5%8F%A3/"},{"categories":["Golang"],"content":"go-zero官网 go-zero详细文档 go-zero looklook github 本系列为作者跟着Mikaelemmmm的b站教学视频学习时做的笔记 looklook文档 Mikaelemmmm哥用爱发电，希望大家给looklook项目点个star ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/:0:0","tags":["go-zero"],"title":"golang-go-zero-教程-Looklook","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/"},{"categories":["Golang"],"content":"项目架构图和业务架构图 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/:1:0","tags":["go-zero"],"title":"golang-go-zero-教程-Looklook","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/"},{"categories":["Golang"],"content":"zerolooklook使用的中间件 zeromicro/go-queue里面的dq，kq和rabbitmq dq基于redis，kq基于kafka，rabbitmq基于rabbitmq。都是封装好的消息队列使用很方便。 dq的asynq可以做延时任务，基于cron库，调用schedule模块来布置定时任务。用于分布式高可用，防止单点故障（相对直接使用cron布置任务） ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/:2:0","tags":["go-zero"],"title":"golang-go-zero-教程-Looklook","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/"},{"categories":["Golang"],"content":"looklook架构讲解 线上部署 cdn=》防火墙（可以是云服务自带的防火墙直接配）=》负载均衡=》nginx集群=》k8s集群（api：使用goctl生成的k8s yaml文件会暴露出访问端口，直接把端口配置到nginx里面，另外api内部调用rpc的服务；rpc服务不暴露端口给外面，仅在k8s集群内部的网段开放服务，供api调用和调用内部中间件；mq，job，schedule也只被rpc调用不暴露给外面）=》使用filebeat来获取日志并发给kafka=》kafka将存储日志消息=》go-stash消费并过滤日志消息并push到elasticsearch jeager做链路监控，prometheus做服务器监控，grafana查看Prometheus监控信息 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/:3:0","tags":["go-zero"],"title":"golang-go-zero-教程-Looklook","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/"},{"categories":["Golang"],"content":"项目目录讲解 app里面是所有的业务 common里面放常用的定制组件 deploy是部署相关的文件 doc是项目的文档 docker-compose.yaml和docker-compose-env.yaml分别是业务容器和环境容器的docker-compose文件 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/:4:0","tags":["go-zero"],"title":"golang-go-zero-教程-Looklook","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/"},{"categories":["Golang"],"content":"部署过程 见项目文档 启动过程中es可能会启动比较慢，依赖es的kibana，jeager也起不来。 mysql在windows可能因为权限起不来 日志收集使用filebeat搜集容器文件夹内容，然后输出给kafka，所以需要进入kafka创建3个topic，对应业务架构里面支付成功通知所有订阅者（2个）和项目架构的log搜集（1个）。 1 2 3 4 docker exec -it kafka /bin/sh cd /opt/kafka/bin/ ./kafka-topics.sh --create --zookeeper zookeeper:2181 --replication-factor 1 -partitions 1 --topic looklook-log ./kafka-topics.sh --create --zookeeper zookeeper:2181 --replication-factor 1 -partitions 1 --topic payment-update-paystatus-topic mysql的容器初次使用时需要配置允许远程连接 1 2 3 4 5 docker exec -it mysql mysql -uroot -p ##输入密码：PXDN93VRKUm8TeE7 use mysql; update user set host='%' where user='root'; FLUSH PRIVILEGES; 并在mysql中导入sql文件来构建表 modd的img需要你配置modd.conf，配置很简单 1 2 3 4 5 #usercenter app/usercenter/cmd/rpc/**/*.go { prep: go build -o data/server/usercenter-rpc -v app/usercenter/cmd/rpc/usercenter.go daemon +sigkill: ./data/server/usercenter-rpc -f app/usercenter/cmd/rpc/etc/usercenter.yaml } app/usercenter/cmd/rpc/**/*.go表示这些文件变化就出发下面的代码块 代码块里面按格式写就可以重新构建项目，实现热重载 查看looklook容器日志 1 docker logs -f looklook go-stash可能会比kafka启动的早所以如果日志收集出问题可以选择重启一下go-stash ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/:5:0","tags":["go-zero"],"title":"golang-go-zero-教程-Looklook","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/"},{"categories":["Golang"],"content":"定时任务 app/mqueue/scheduler/logic/settleRecordJob.go 1 2 3 4 5 6 7 8 9 10 func (l *MqueueScheduler) settleRecordScheduler() { task := asynq.NewTask(jobtype.ScheduleSettleRecord, nil) // every one minute exec entryID, err := l.svcCtx.Scheduler.Register(\"*/1 * * * *\", task) if err != nil { logx.WithContext(l.ctx).Errorf(\"!!!MqueueSchedulerErr!!! ====\u003e 【settleRecordScheduler】 registered err:%+v , task:%+v\",err,task) } fmt.Printf(\"【settleRecordScheduler】 registered an entry: %q \\n\", entryID) } ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/:6:0","tags":["go-zero"],"title":"golang-go-zero-教程-Looklook","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/"},{"categories":["Golang"],"content":"自定义jwt验证不通过响应 在生成server的语句里面添加选项WithUnauthorizedCallback 1 2 3 server := rest.MustNewServer(c.RestConf, rest.WithUnauthorizedCallback(func(w http.ResponseWriter, r *http.Request, err error) { w.WriteHeader(200) })) 但是通常前端来处理返回给用户的结果，后端只需要直接将错误代码发给前端。 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/:7:0","tags":["go-zero"],"title":"golang-go-zero-教程-Looklook","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/"},{"categories":["Golang"],"content":"微信支付api 这个api可以直接用，线上测试没问题 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/:8:0","tags":["go-zero"],"title":"golang-go-zero-教程-Looklook","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/"},{"categories":["Golang"],"content":"技术栈过多的问题 Mikaelmmmm希望做一个大而全的后端项目。 如果觉得技术栈太多，可以在docker-compose里面将不熟悉的内容都注释掉，不跑一些中间件。looklook的模块划分的很好，把相关的代码注释掉即可。 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/:9:0","tags":["go-zero"],"title":"golang-go-zero-教程-Looklook","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/"},{"categories":["Golang"],"content":"官方文档笔记 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/:10:0","tags":["go-zero"],"title":"golang-go-zero-教程-Looklook","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/"},{"categories":["Golang"],"content":"1.开发环境部署 项目介绍 本项目开发环境推荐docker-compose，使用直链方式，测试、线上部署使用k8s app：所有业务代码包含api、rpc以及mq（消息队列、延迟队列、定时任务） common：通用组件 error、middleware、interceptor、tool、ctxdata等 data：该项目包含该目录依赖所有中间件(mysql、es、redis、grafana等)产生的数据。 deploy： filebeat: docker部署filebeat配置 go-stash：go-stash配置 nginx: nginx网关配置 prometheus ： prometheus配置 goctl: 该项目goctl的template doc : 该项目系列文档 modd.conf : modd热加载配置文件 技术栈 k8s，go-zero，nginx网关，filebeat，kafka，go-stash，elasticsearch，kibana，prometheus，grafana，jaeger，go-queue，asynq，asynqmon，dtm，docker，docker-compose，mysql，redis，modd，jenkins，gitlab，harbor ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/:10:1","tags":["go-zero"],"title":"golang-go-zero-教程-Looklook","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/"},{"categories":["Golang"],"content":"nginx网关 容器内部nginx端口是8081，使用docker暴露出去8888映射端口8081，这样外部通过8888来访问网关 使用location来匹配每个服务 1 2 3 4 5 6 7 8 9 10 11 12 13 14 server{ listen 8081; access_log /var/log/nginx/looklook.com_access.log; error_log /var/log/nginx/looklook.com_error.log; location ~ /order/ { proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://looklook:1001; } } 通过go-zero自带的jwt鉴权之后，我们可以在ctx中拿到userId， 1 2 3 4 func (l *DetailLogic) Detail(req types.UserInfoReq) (*types.UserInfoResp, error) { userId := ctxdata.GetUidFromCtx(l.ctx) ...... } ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/:10:2","tags":["go-zero"],"title":"golang-go-zero-教程-Looklook","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/"},{"categories":["Golang"],"content":"鉴权服务 go-zero官方文档 go-zero从jwt token解析后会将用户生成token时传入的kv原封不动的放在http.Request的Context中，因此我们可以通过Context就可以拿到你想要的值 在desc/api文件中定义go-zero自带的jwt中间件 @server(\r...\rjwt: JwtAuth\r)\rservice usercenter {\r......\r} 会在 go-zero-looklook/app/usercenter/cmd/api/internal/handler/routes.go里面添加一句 1 2 3 4 5 6 7 8 9 10 11 12 13 // Code generated by goctl. DO NOT EDIT. package handler ........ server.AddRoutes( []rest.Route{ ... }, rest.WithJwt(serverCtx.Config.JwtAuth.AccessSecret), ... ) } 用户发起请求资源 -\u003e nginx网关-\u003e匹配到对应服务模块 -\u003e auth模块-\u003eidentity-api -\u003eidentity-rpc -\u003e 用户请求的资源 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/:10:3","tags":["go-zero"],"title":"golang-go-zero-教程-Looklook","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/"},{"categories":["Golang"],"content":"用户服务 model中定义了Trans方法暴露事务给logic 在usercenter-rpc注册成功之后，需要请求token给前端登陆，直接在rigister内部生成获取token的logic实例并调用它的方法 1 2 3 4 5 6 7 8 //2、Generate the token, so that the service doesn't call rpc internally generateTokenLogic :=NewGenerateTokenLogic(l.ctx,l.svcCtx) tokenResp,err:=generateTokenLogic.GenerateToken(\u0026usercenter.GenerateTokenReq{ UserId: userId, }) if err != nil { return nil, errors.Wrapf(ErrGenerateTokenError, \"GenerateToken userId : %d\", userId) } 详见官网文档 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/:10:4","tags":["go-zero"],"title":"golang-go-zero-教程-Looklook","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/"},{"categories":["Golang"],"content":"民宿服务 详见官网文档 【小技巧】 mapreduce 【小技巧】model cache、singleflight ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/:10:5","tags":["go-zero"],"title":"golang-go-zero-教程-Looklook","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/"},{"categories":["Golang"],"content":"订单服务 详见官网文档 这里写了延迟队列的用法，rpc创建订单的同时生成一个asynq延迟消息，延迟消息时间到了就在go-zero-looklook/app/mqueue/cmd/job/internal/logic/closeOrder.go中进行处理，这里会查询order rpc该订单的状态，如果已经支付则消费消息直接返回nil，否则修改订单消息为取消。 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/:10:6","tags":["go-zero"],"title":"golang-go-zero-教程-Looklook","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/"},{"categories":["Golang"],"content":"支付服务 详见官网文档 这里查询order-rpc获取订单详情，并根据返回的totalPrice，description和openid（注册的时候获取，userId对应openid）生成微信预支付订单并返回给前端 当前端拿着微信预处理订单发起支付，用户输入密码支付成功后，微信服务器会回调服务器，回调地址在配置中填写 1 2 3 WxPayConf: ... NotifyUrl : http://xxx.xxx.com/payment/v1/thirdPayment/thirdPaymentWxPayCallback 这里生成微信订单使用的时第三方库wechatpay-apiv3/wechatpay-go github.com/wechatpay-apiv3/wechatpay-go/services/payments/jsapi 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 3、create wechat pay pre pay order wxPayClient, err := svc.NewWxPayClientV3(l.svcCtx.Config) if err != nil { return nil, err } jsApiSvc := jsapi.JsapiApiService{Client: wxPayClient} // Get the prepay_id, as well as the parameters and signatures needed to invoke the payment resp, _, err := jsApiSvc.PrepayWithRequestPayment(l.ctx, jsapi.PrepayRequest{ Appid: core.String(l.svcCtx.Config.WxMiniConf.AppId), Mchid: core.String(l.svcCtx.Config.WxPayConf.MchId), Description: core.String(description), OutTradeNo: core.String(createPaymentResp.Sn), Attach: core.String(description), NotifyUrl: core.String(l.svcCtx.Config.WxPayConf.NotifyUrl), Amount: \u0026jsapi.Amount{ Total: core.Int64(totalPrice), }, Payer: \u0026jsapi.Payer{ Openid: core.String(openId), }, }, ) if err != nil { return nil, errors.Wrapf(ErrWxPayError, \"Failed to initiate WeChat payment pre-order err : %v , userId: %d , orderSn:%s\", err, userId, orderSn) } 微信回调回来之后，调用verifyAndUpdateState 将流水单号改为已支付。 verifyAndUpdateState方法，查询单号是否存在，比对回调回来的金额与创建时候金额是否一致。这里不用在校验签名了，前一步的sdk已经做了处理了 支付回调成功之后，会给用户发送一个入驻码，去了商家那里要展示这个码，商家通过后台核对码，其实就是美团的样子，我们去美团下单，美团会给你个码，用户拿着这个码去入住或者消费等。 verifyAndUpdateState调用了rpc的UpdateTradeState方法，核心做了两件事情，第一是更新支付状态，第二通过go-queue向消息队列(kafka)发送了一条日志消息 UpdateHomestayOrderTradeState更改订单状态，在发送一条asynq给mqueue-job队列，让mqueue-job发送微信小程序模版消息给用户 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/:10:7","tags":["go-zero"],"title":"golang-go-zero-教程-Looklook","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/"},{"categories":["Golang"],"content":"消息-延迟-定时队列 asynq特点 直接基于redis，一般项目都有redis，而asynq本身就是基于redis所以可以少维护一个中间件 支持消息队列、延迟队列、定时任务调度 ， 因为希望项目支持定时任务而asynq直接就支持 有webui界面，每个任务都可以暂停、归档、通过ui界面查看成功失败、监控 go-queue特点：kafka的吞吐量高 如何使用 自己使用serviceGroup改造，目录结构还是延续api的基本差不多, 将handler改成了listen ， 将logic换成了mqs 。 main中不使用MustNewServer方法，使用c.SetUp()然后serviceGroup := service.NewServiceGroup() 接下来就是go-zero的serivceGroup管理服务了，serviceGroup是用来管理一组service的，那service其实就是一个接口 1 2 3 4 5 // Service is the interface that groups Start and Stop methods. Service interface { Starter //Start Stopper //Stop } 只要你的服务实现了这2个接口，就可以加入到serviceGroup统一管理 把所有的mq都实现这个接口，然后统一放到都 list.Mqs中，在启动服务即可 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/:10:8","tags":["go-zero"],"title":"golang-go-zero-教程-Looklook","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/"},{"categories":["Golang"],"content":"分布式事务 本项目服务划分相对独立一些，所以目前没有使用到分布式事务 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/:10:9","tags":["go-zero"],"title":"golang-go-zero-教程-Looklook","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/"},{"categories":["Golang"],"content":"错误处理 grpc的err对应的错误码其实就是一个uint32 ， 我们自己定义错误用uint32然后在rpc的全局拦截器返回时候转成grpc的err，就可以了 所以我们自己定义全局错误码在app/common/xerr ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/:10:10","tags":["go-zero"],"title":"golang-go-zero-教程-Looklook","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/"},{"categories":["Golang"],"content":"日志收集 filebeat,kafka,go-stash和elk直接配置好容器并挂载好容器内配置就好了 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/:10:11","tags":["go-zero"],"title":"golang-go-zero-教程-Looklook","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/"},{"categories":["Golang"],"content":"链路追踪 go-zero底层已经帮我们把代码跟链路追踪对接的代码已经写好了，默认支持jaeger、zinpink。我们只需要在我们的业务代码配置中，也就是你的业务配置的yaml中配置参数即可。 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/:10:12","tags":["go-zero"],"title":"golang-go-zero-教程-Looklook","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/"},{"categories":["Golang"],"content":"服务监控 go-zero已经在代码中给我们集成好了prometheus。当我们启动api、rpc都会额外启动一个goroutine 提供prometheus的服务 order-mq这种使用serviceGroup管理的服务，在启动文件main中要显示调用一下SetUp才可以，api、rpc不需要，配置都一样 配置步骤 配置prometheus与grafana：容器和容器内配置 业务配置：只需要在业务配置文件中配置即可 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/:10:13","tags":["go-zero"],"title":"golang-go-zero-教程-Looklook","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/"},{"categories":["Golang"],"content":"部署环境搭建 gitlab : 放代码，可以做ci jenkins：做cd发布项目 harbor : 镜像仓库 k8s : 运行服务 ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/:10:14","tags":["go-zero"],"title":"golang-go-zero-教程-Looklook","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/"},{"categories":["Golang"],"content":"发布服务到k8s ","date":"2023-01-08","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/:10:15","tags":["go-zero"],"title":"golang-go-zero-教程-Looklook","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/looklook/"},{"categories":["云原生"],"content":"docker 官网 docker 官方文档 docker 参考文档 dockerfile 参考 ","date":"2023-01-07","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:0:0","tags":["docker"],"title":"云原生-docker-个人笔记","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["云原生"],"content":"镜像重命名 镜像不能重命名，只能复制一份镜像重新命名。 1 docker tag oldimagename:xxx newimagename:yyy 然后删除原来的镜像 1 2 3 4 5 6 docker image rm oldimagename //或者先找到image的id，然后再删除 docker image ls docker image rm zzzzz 对同一个版本的镜像打不同的tag是可以的 ","date":"2023-01-07","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:1:0","tags":["docker"],"title":"云原生-docker-个人笔记","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["云原生"],"content":"vscode镜像管理 强烈推荐使用vscode的docker插件来管理镜像，以及使用remote插件来远程登录和修改镜像文件 百度文库 ","date":"2023-01-07","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:2:0","tags":["docker"],"title":"云原生-docker-个人笔记","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["云原生"],"content":"container name属性 docker-compose中的container name container name其实相当于给容器取一个别名，因为你可以使用container name对应的名称访问容器，也可以使用原名访问容器。 另外network中的alias属性也可以定义别名 ","date":"2023-01-07","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:3:0","tags":["docker"],"title":"云原生-docker-个人笔记","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["云原生"],"content":"Docker build上下文 博客园 拾月凄辰 1 docker build -f xxx -t yyy:zzz aaa xxx为dockerfile文件路径，yyy为img名称，zzz为tag名称，aaa为上下文 ","date":"2023-01-07","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:4:0","tags":["docker"],"title":"云原生-docker-个人笔记","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["云原生"],"content":"Portainer密码重置 博客园 Alive9 1 docker ps -a 找到容器id，停止portainer容器 1 docker stop portainerid 找到Portainer容器挂载信息 1 docker inspect portainerid 找到\"Mounts\"下\"volume\"绑定的\"Source\"地址 执行命令重置密码 1 docker run --rm -v /dockerpath:/data portainer/helper-reset-password 启动容器，根据提示的密码登录portainer修改密码 1 docker start portainerid ","date":"2023-01-07","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:5:0","tags":["docker"],"title":"云原生-docker-个人笔记","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["云原生"],"content":"ADD和COPY COPY 和 ADD 都是 Dockerfile 中的指令，有着类似的作用。主要区别是ADD有一个自动解压的功能。 脚本之家 ","date":"2023-01-07","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:6:0","tags":["docker"],"title":"云原生-docker-个人笔记","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["云原生"],"content":"alpine镜像 alpine是基于arch最小的linux镜像，3.14版本只有5Mb 1 2 3 4 # 下载镜像 docker pull alpine # 新建并启动容器 docker run -it docker.io/alpine sh 它使用apk安装软件 1 2 apk update apk add curl ","date":"2023-01-07","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:7:0","tags":["docker"],"title":"云原生-docker-个人笔记","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["云原生"],"content":"容器间通信 外界无法与容器内主机未发布的端口进行通信，容器可以与外界进行通信。同一个网络下的容器之间的任何端口都可以直接通信 dockerfile中的 EXPOSE 指令并不发布端口，更像是制作镜像的人给创建容器的人的文档。expose可以指定端口监听TCP还是UDP（80/tcp,80/udp），不指定协议默认为TCP。 真正发布端口是在创建容器时使用-p进行的，使用-P发布docker镜像里面EXPOSE指定的端口 ","date":"2023-01-07","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:8:0","tags":["docker"],"title":"云原生-docker-个人笔记","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["云原生"],"content":"docker配置代理 CSDN Rory602 Docker 配置网络代理 ","date":"2023-01-07","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:9:0","tags":["docker"],"title":"云原生-docker-个人笔记","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["云原生"],"content":"Dockerd 代理 在执行docker pull时，是由守护进程dockerd来执行。因此，代理需要配在dockerd的环境中。而这个环境，则是受systemd所管控，因此实际是systemd的配置。创建配置文件。 1 2 sudo mkdir -p /etc/systemd/system/docker.service.d sudo touch /etc/systemd/system/docker.service.d/proxy.conf 添加内容 [Service]\rEnvironment=\"HTTP_PROXY=http://proxy.example.com:8080/\"\rEnvironment=\"HTTPS_PROXY=http://proxy.example.com:8080/\"\rEnvironment=\"NO_PROXY=localhost,127.0.0.1,.example.com\" 重启docker服务 1 2 3 # 重启docker daemon sudo systemctl daemon-reload sudo systemctl restart docker 查看配置是否成功 1 systemctl show --property=Environment docker ","date":"2023-01-07","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:9:1","tags":["docker"],"title":"云原生-docker-个人笔记","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["云原生"],"content":"Container 代理 所有容器代理，配置~/.docker/config.json添加内容 1 2 3 4 5 6 7 8 9 10 11 { \"proxies\": { \"default\": { \"httpProxy\": \"http://proxy.example.com:8080\", \"httpsProxy\": \"http://proxy.example.com:8080\", \"noProxy\": \"localhost,127.0.0.1,.example.com\" } } } 单个容器配置代理直接使用-e注入环境变量 ","date":"2023-01-07","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:9:2","tags":["docker"],"title":"云原生-docker-个人笔记","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["云原生"],"content":"Docker Build 代理 虽然 docker build 的本质，也是启动一个容器，但是环境会略有不同，用户级配置无效。在构建时，需要注入 http_proxy 等参数。 1 2 3 4 5 docker build . \\ --build-arg \"HTTP_PROXY=http://proxy.example.com:8080/\" \\ --build-arg \"HTTPS_PROXY=http://proxy.example.com:8080/\" \\ --build-arg \"NO_PROXY=localhost,127.0.0.1,.example.com\" \\ -t your/image:tag ","date":"2023-01-07","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:9:3","tags":["docker"],"title":"云原生-docker-个人笔记","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["云原生"],"content":"资源隔离 CSDN solihawk namespace：不同容器用户进程，网络，交互，目录，用户隔离 cgroup：CPU、内存、磁盘隔离 ","date":"2023-01-07","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:10:0","tags":["docker"],"title":"云原生-docker-个人笔记","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["Golang"],"content":"go-zero官网 go-zero详细文档 本系列为作者跟着Mikaelemmmm的b站教学视频学习时做的笔记 zero基于zrpc，zrpc基于grpc rpc没有handler，直接就是logic ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/:0:0","tags":["go-zero"],"title":"golang-go-zero-教程-Rpc","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/"},{"categories":["Golang"],"content":"protobuf语法 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/:1:0","tags":["go-zero"],"title":"golang-go-zero-教程-Rpc","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/"},{"categories":["Golang"],"content":"语法版本 1 syntax = \"proto3\"; ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/:1:1","tags":["go-zero"],"title":"golang-go-zero-教程-Rpc","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/"},{"categories":["Golang"],"content":"proto包名 1 package pb; ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/:1:2","tags":["go-zero"],"title":"golang-go-zero-教程-Rpc","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/"},{"categories":["Golang"],"content":"生成的go文件目录 相对路径必须加./ 1 option go_package = \"./pb\"; ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/:1:3","tags":["go-zero"],"title":"golang-go-zero-教程-Rpc","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/"},{"categories":["Golang"],"content":"传递参数 1 2 3 message GetUserInfoReq { int64 id = 1; } ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/:1:4","tags":["go-zero"],"title":"golang-go-zero-教程-Rpc","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/"},{"categories":["Golang"],"content":"rpc服务调用 1 2 3 service usercenter { rpc GetUserInfo(GetUserInfoReq) returns (GetUserInfoResp); } ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/:1:5","tags":["go-zero"],"title":"golang-go-zero-教程-Rpc","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/"},{"categories":["Golang"],"content":"goctl构建命令 1 goctl rpc protoc user.proto --go_out=../ --go-grpc_out=../ --zrpc_out=../ --style=goZero ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/:2:0","tags":["go-zero"],"title":"golang-go-zero-教程-Rpc","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/"},{"categories":["Golang"],"content":"目录结构 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/:3:0","tags":["go-zero"],"title":"golang-go-zero-教程-Rpc","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/"},{"categories":["Golang"],"content":"main文件 逻辑与api大致相同，只是起的服务不是http服务而是rpc服务 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/:3:1","tags":["go-zero"],"title":"golang-go-zero-教程-Rpc","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/"},{"categories":["Golang"],"content":"etc/config.yaml rpc配置文件 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/:3:2","tags":["go-zero"],"title":"golang-go-zero-教程-Rpc","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/"},{"categories":["Golang"],"content":"internal/config/config.go rpc配置文件对应的配置对象 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/:3:3","tags":["go-zero"],"title":"golang-go-zero-教程-Rpc","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/"},{"categories":["Golang"],"content":"internal/svc 他也是使用svcCtx来放置依赖 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/:3:4","tags":["go-zero"],"title":"golang-go-zero-教程-Rpc","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/"},{"categories":["Golang"],"content":"internal/logic 业务逻辑，rpc没有handler ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/:3:5","tags":["go-zero"],"title":"golang-go-zero-教程-Rpc","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/"},{"categories":["Golang"],"content":"pb目录 .pb.go文件放序列化的结构体 _gprc.pb.go文件放grpc生成的方法 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/:3:6","tags":["go-zero"],"title":"golang-go-zero-教程-Rpc","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/"},{"categories":["Golang"],"content":"客户端目录 每定义一个service都会生成一个客户端目录目录名和service名一致，目录中只有一个.go文件文件名和service名一致，这个文件用于api或其他rpc服务调用本rpc的服务 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/:3:7","tags":["go-zero"],"title":"golang-go-zero-教程-Rpc","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/"},{"categories":["Golang"],"content":"postman调试grpc 在APIs里面导入.proto文件 然后在collections里面新建rpc collection 并新建grpc请求，选择你导入的API ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/:4:0","tags":["go-zero"],"title":"golang-go-zero-教程-Rpc","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/"},{"categories":["Golang"],"content":"Proto编写注意事项 尽量使用原生的proto数据类型，比如int64，string等。 对于时间戳可以直接使用int64，在后端直接time.Unix(in.xxxtime)就可以直接转化为数据库对应的时间格式time.time。从数据库读出来的时间是time.time可以直接使用xxxtime.Unix()就可以拿到int64的值。 尽量使用具体的类型，尽量不要去使用any类型。 文件拆分：可以把message分类放文件夹里面，然后import。import文件之后需要使用包名.类型名来定义类型。拆分的proto文件需要手动使用protoc对每一个proto生成go文件，goctrl最后对有service的proto文件生成代码。 1 protoc -I ./ --go_out=paths=source_relative:. --go-grpc_out=paths=source_relative:. userModel.proto 另外相同结构尽量使用组合方式进行复用。 关于使用grpcui，由于main里面会有 1 2 3 4 5 6 7 8 9 10 11 func main() { ... s := zrpc.MustNewServer(c.RpcServerConf, func(grpcServer *grpc.Server) { pb.RegisterUsercenterServer(grpcServer, server.NewUsercenterServer(ctx)) if c.Mode == service.DevMode || c.Mode == service.TestMode { reflection.Register(grpcServer) } }) ... } 而grpcui需要执行reflection.Register(grpcServer)，所以我们需要在yaml中配置服务模式Mode为dev或者test，才能使用grpcui，但是我推荐使用postman进行测试 1 2 3 ... Mode: dev ... ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/:5:0","tags":["go-zero"],"title":"golang-go-zero-教程-Rpc","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/"},{"categories":["Golang"],"content":"RPC使用Model 和api是一模一样的，直接把Model放到svcCtx，然后直接在logic里面使用 业务体量小的时候可以直接让api使用Model就行，当业务量起来了开发微服务就将Model的业务放到rpc上。想要严格只能由rpc调用Model，则直接将Model放到rpc的internal目录中，这样就只有rpc能够直接使用Model，之后再通过rpc 接口暴露使用Model的方法供api调用。 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/:6:0","tags":["go-zero"],"title":"golang-go-zero-教程-Rpc","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/"},{"categories":["Golang"],"content":"rpc拦截器 rpc没有middleware只有拦截器 分为客户端拦截器和服务端拦截器 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/:7:0","tags":["go-zero"],"title":"golang-go-zero-教程-Rpc","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/"},{"categories":["Golang"],"content":"服务端拦截器 直接在main中调用s.AddUnaryInterceptors方法注册拦截器 1 2 3 4 5 6 7 8 func main() { ... s.AddUnaryInterceptors(func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp interface{}, err error) { }) ... s.Start() } 这个拦截器方法可以放到一个单独的位置，只要main能够导入即可。 拦截器的逻辑是：如果直接return则相当于直接丢弃，想要处理请求则需要调用resp，err:=handle(ctx,req)，该函数和api middleware的next(w,r)是一样的，所以可以在拦截器中实现处理后的逻辑。最后需要return resp,err 1 2 3 4 5 6 7 8 9 10 11 12 13 func TestServerInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp interface{}, err error) { fmt.Println(\"TestServerInterceptor ====\u003e \") fmt.Printf(\"req ====\u003e %+v \\n\", req) fmt.Printf(\"info ====\u003e %+v \\n\", info) resp, err = handler(ctx, req) fmt.Printf(\"resp ====\u003e %+v \\n\", resp) return resp, err } ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/:7:1","tags":["go-zero"],"title":"golang-go-zero-教程-Rpc","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/"},{"categories":["Golang"],"content":"客户端拦截器 api中的拦截器 在svcCtx工厂函数中给zrpc.MustNewClient函数传递第二个参数，该参数为拦截器函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func NewServiceContext(c config.Config) *ServiceContext { return \u0026ServiceContext{ ... UserRpcClient: usercenter.NewUsercenter(zrpc.MustNewClient(c.UserRpcConf, zrpc.WithUnaryClientInterceptor(func(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error { //拦截前 err := invoker(ctx, method, req, reply, cc, opts...) if err != nil { return err } //拦截后 return nil }))), } } 该函数也可以放到别的地方，只要svcCtx的工厂函数能够引用到，该函数只返回一个错误参数 里面需要调用err := invoker(ctx, method, req, reply, cc, opts…)函数，该函数和中间件的next函数以及rpc拦截器的handle函数功能一样，在该调用之前就是调用前的逻辑，后面的就是拦截后的逻辑 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/:7:2","tags":["go-zero"],"title":"golang-go-zero-教程-Rpc","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/"},{"categories":["Golang"],"content":"metadata传值 一般在拦截器里面实现，也可以在其他地方实现。这里展示拦截器实现过程 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/:8:0","tags":["go-zero"],"title":"golang-go-zero-教程-Rpc","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/"},{"categories":["Golang"],"content":"客户端拦截器添加metadata 1 2 3 //拦截前 md := metadata.New(map[string]string{\"username\": \"zhangsan\"}) ctx = metadata.NewOutgoingContext(ctx, md) ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/:8:1","tags":["go-zero"],"title":"golang-go-zero-教程-Rpc","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/"},{"categories":["Golang"],"content":"服务端logic读取metadata 1 2 3 4 if md, ok := metadata.FromIncomingContext(l.ctx); ok { tmp := md.Get(\"username\") fmt.Printf(\"tmp: %+v\\n\", tmp) } ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/:8:2","tags":["go-zero"],"title":"golang-go-zero-教程-Rpc","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/"},{"categories":["Golang"],"content":"metadata是map[string]string还是map[string][]string MD的源码定义是map[string][]string，但是它的new工厂函数传入参数是map[string]string，但是它还有Get，Set方法，它们分别传入返回的值都是map[string][]strring。所以只是New的时候需要传入map[string]string，其他操作都是map[string][]string。 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/:8:3","tags":["go-zero"],"title":"golang-go-zero-教程-Rpc","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/"},{"categories":["Golang"],"content":"rpc启动源码解析 见b站视频 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/:9:0","tags":["go-zero"],"title":"golang-go-zero-教程-Rpc","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/rpc/"},{"categories":["Golang"],"content":"go-zero官网 go-zero详细文档 本系列为作者跟着Mikaelemmmm的b站教学视频学习时做的笔记 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/log/:0:0","tags":["go-zero"],"title":"golang-go-zero-教程-Log","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/log/"},{"categories":["Golang"],"content":"配置 etc/yaml里面配置Log 1 2 Log: 选项：值 internal/config/config.go添加Logx.LogConf字段 1 2 3 4 type Config struct { ... Log logx.LogConf } zero-looklook将日志打印到console、file。然后使用filebeat将内容发送到kafka，go-stash（go-stash比log-stash开销更低效率更高，万总的项目）消费kafka中的日志并存入elasticsearch中，最后使用kibana来查看日志 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/log/:1:0","tags":["go-zero"],"title":"golang-go-zero-教程-Log","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/log/"},{"categories":["Golang"],"content":"常见配置项 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //打印前缀 ServiceName string `json:\",optional\"` //模式，打印到控制台，文件或k8s的volume Mode string `json:\",default=console,options=[console,file,volume]\"` //json将全部放一行（上线项目一般使用），plain将日志和java一样一行一行存（开发过程中使用方便查看） Encoding string `json:\",default=json,options=[json,plain]\"` //针对file模式设置输出文件 Path string `json:\",default=logs\"` //记录日志最低等级，从低到高 Level string `json:\",default=info,options=[debug,info,error,severe]\"` //保存几天的日志自动生成日志压缩文件 Compress bool `json:\",optional\"` //保留几天日志 KeepDays int `json:\",optional\"` 日志堆栈处理的时候需要使用github.com/pkg/errors第三方库，这个并不是标准errors库 errors.Wrap(errors.New(string),string)来返回一个堆栈错误信息，将返回的err通过logx.Errorf(“err:%+v”, err)打印出来 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/log/:1:1","tags":["go-zero"],"title":"golang-go-zero-教程-Log","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/log/"},{"categories":["Golang"],"content":"日志等级 日志等级为info能输出一般的所有的日志。 stat日志没隔一段时间记录CPU和服务状态，其实是没启动一个服务都会自动启动一个goroutine来监控自己 stat禁用在main中调用 1 logx.DisableStat() ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/log/:1:2","tags":["go-zero"],"title":"golang-go-zero-教程-Log","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/log/"},{"categories":["Golang"],"content":"go-zero官网 go-zero详细文档 本系列为作者跟着Mikaelemmmm的b站教学视频学习时做的笔记 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/templete/:0:0","tags":["go-zero"],"title":"golang-go-zero-教程-Templete","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/templete/"},{"categories":["Golang"],"content":"生成templete –home后面跟的是输出的目录 1 goctl template init --home $HOME/template 不使用–home会在~/.goctl/（foctl版本）目录里面生成，不同版本的的goctl会使用不同版本的模板。后续不使用–home选项就会默认使用该模板。 如果没有在~/.goctl/（foctl版本）目录生成模板目录并且没有使用–home选项，则使用goctl下载目录里面的template文件 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/templete/:1:0","tags":["go-zero"],"title":"golang-go-zero-教程-Templete","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/templete/"},{"categories":["Golang"],"content":"修改template 直接编辑生成的templete文件 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/templete/:2:0","tags":["go-zero"],"title":"golang-go-zero-教程-Templete","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/templete/"},{"categories":["Golang"],"content":"goctl使用修改的templete文件 给任意goctl命令添加–home 选项指定templete目录 1 goctl rpc new greet --home $HOME/template 不使用–home默认使用~/.goctl/（foctl版本）目录里模板 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/templete/:3:0","tags":["go-zero"],"title":"golang-go-zero-教程-Templete","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/templete/"},{"categories":["Golang"],"content":"模板内容 通常每一个文件对应生成代码的一部分，除了有一个文件将其他文件整合到一起 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/templete/:4:0","tags":["go-zero"],"title":"golang-go-zero-教程-Templete","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/templete/"},{"categories":["Golang"],"content":"模板里的变量哪里来的 在你下载的goctl源码里面的model/sql/gen目录下有与每个tpl文件对应的go文件，其中使用template标准库的Execute()函数生成模板，该函数的参数可以被tpl通过{{.xxx}}使用。 不要去修改goctl源码，上面这段文字只是为了了解原理。要修改直接在生成的template目录修改tpl文件。 不要去生成的模板目录里面添加tpl，因为goctl里面写死了有哪些tpl，你新增的并不会生成 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/templete/:4:1","tags":["go-zero"],"title":"golang-go-zero-教程-Templete","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/templete/"},{"categories":["Golang"],"content":"生成的模板目录放哪里 建议放到项目里面 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/templete/:4:2","tags":["go-zero"],"title":"golang-go-zero-教程-Templete","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/templete/"},{"categories":["Golang"],"content":"go-zero官网 go-zero详细文档 本系列为作者跟着Mikaelemmmm的b站教学视频学习时做的笔记 go-zero官方mysql博客 go-zero官方缓存设计之持久层缓存博客 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/model/:0:0","tags":["go-zero"],"title":"golang-go-zero-教程-Model","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/model/"},{"categories":["Golang"],"content":"指令 通过sql或表生成model 1 2 3 goctl model mysql ddl -src=\"./*.sql\" -dir=\"./sql/model\" -c --style=goZero $ goctl model mysql datasource -url=\"user:password@tcp(127.0.0.1:3306)/database\" -table=\"*\" -dir=\"./model\" --style=goZero M哥推荐使用navcat先生成表再通过表生成sql和model 这里我构建好了sql之后使用，注意这里没有cache所以没有-c选项： 1 goctl model mysql ddl -src=\"./sql/*.sql\" -dir=\"./GenModel\" --style=goZero ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/model/:1:0","tags":["go-zero"],"title":"golang-go-zero-教程-Model","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/model/"},{"categories":["Golang"],"content":"Model文件 生成的文件放到哪里都行，只要能够在svcCtx里面引入即可。 引入中间件通常分两步：第一步是写入中间件配置到etc/.yaml中并在internal/config/config.go文件中添加与之对应的字段。第二步是在svcCtx的结构体中添加中间件客户端的字段，然后再在New函数中返回一个客户端，引入示例： 修改yaml 1 2 DB: DataSource: root:xxxxxx@tcp(127.0.0.1:3306)/zero-demo?charset=utf8mb4\u0026parseTime=true\u0026loc=Asia%2FShanghai 修改config.go，给Config结构体添加相应字段 1 2 3 DB struct { DataSource string } 添加中间件客户端到svcCtx结构体字段 1 2 3 4 type ServiceContext struct { Config config.Config UserModel model.UserModel } 给svcCtx的New函数添加相应的字段值 1 2 3 4 5 6 func NewServiceContext(c config.Config) *ServiceContext { return \u0026ServiceContext{ Config: c, UserModel: model.NewUserModel(sqlx.NewMysql(c.DB.DataSource), nil), } } 之后就可以在handler和logic里面使用它们了 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/model/:2:0","tags":["go-zero"],"title":"golang-go-zero-教程-Model","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/model/"},{"categories":["Golang"],"content":"FindOne函数 返回两个值，第一个时model绑定的数据库条目对象，可以直接通过.访问数据库字段，第二个是错误 1 2 3 4 5 6 7 8 9 10 11 12 user, err := l.svcCtx.UserModel.FindOne(l.ctx, req.UserId) if err != nil \u0026\u0026 err != model.ErrNotFound { return nil, errors.New(\"查询数据失败\") } if user == nil { return nil, errors.New(\"用户不存在\") } return \u0026types.UserInfoResp{ UserId: user.Id, Nickname: user.Nickname, }, nil ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/model/:2:1","tags":["go-zero"],"title":"golang-go-zero-教程-Model","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/model/"},{"categories":["Golang"],"content":"源码分析 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/model/:3:0","tags":["go-zero"],"title":"golang-go-zero-教程-Model","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/model/"},{"categories":["Golang"],"content":"template默认生成文件userModel_gen.go 不要修改这个文件，对这个文件的修改是在模板template中进行的 变量Var 1 2 3 4 5 6 7 8 //结构体字段名切片 userFieldNames = builder.RawFieldNames(\u0026User{}) //结构体字段使用`,`连接，用于sql语句select 字段生成 userRows = strings.Join(userFieldNames, \",\") //清除了默认生成字段的select字段 userRowsExpectAutoSet = strings.Join(stringx.Remove(userFieldNames, \"`id`\", \"`update_at`\", \"`updated_at`\", \"`update_time`\", \"`create_at`\", \"`created_at`\", \"`create_time`\"), \",\") //清除默认生成字段的update字段 userRowsWithPlaceHolder = strings.Join(stringx.Remove(userFieldNames, \"`id`\", \"`update_at`\", \"`updated_at`\", \"`update_time`\", \"`create_at`\", \"`created_at`\", \"`create_time`\"), \"=?,\") + \"=?\" 对于有缓存的Model 1 2 3 4 //缓存的主键前缀，通常在使用 cacheUserDataIdPrefix = \"cache:userData:id:\" //缓存的普通索引前缀 cacheUserMobilePrefix = \"cache:user:mobile:\" go-zero针对单条数据做缓存 接口 1 2 3 4 5 6 7 userModel interface { Insert(ctx context.Context, data *User) (sql.Result, error) FindOne(ctx context.Context, id int64) (*User, error) FindOneByMobile(ctx context.Context, mobile string) (*User, error) Update(ctx context.Context, data *User) error Delete(ctx context.Context, id int64) error } 表结构体 User结构体对应表结构 defaultUserModel是userModel接口的实现，其具有默认生成的方法 1 2 3 4 5 6 7 8 9 10 defaultUserModel struct { sqlc.CachedConn table string } User struct { Id int64 `db:\"id\"` Nickname string `db:\"nickname\"` Mobile string `db:\"mobile\"` } 函数 一个工厂函数，用于创建defaultUserModel对象 不带缓存Model 1 2 3 4 5 6 func newUserDataModel(conn sqlx.SqlConn) *defaultUserDataModel { return \u0026defaultUserDataModel{ conn: conn, table: \"`user_data`\", } } 带缓存Model 1 2 3 4 5 6 func newUserDataModel(conn sqlx.SqlConn, c cache.CacheConf) *defaultUserDataModel { return \u0026defaultUserDataModel{ CachedConn: sqlc.NewConn(conn, c), table: \"`user_data`\", } } 方法 接口中方法在defaultUserModel对象的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 //删除条目 func (m *defaultUserModel) Delete(ctx context.Context, id int64) error { //通过FindOne确定是否有该id的条目，如果没有直接返回数据库给出的错误 data, err := m.FindOne(ctx, id) if err != nil { return err } //如果有该条目 //生成缓存查询字段 userIdKey := fmt.Sprintf(\"%s%v\", cacheUserIdPrefix, id) //生成数据库查询字段 userMobileKey := fmt.Sprintf(\"%s%v\", cacheUserMobilePrefix, data.Mobile) //执行带缓存命令，该命令内部自动识别执行数据库操作，并执行相应的缓存操作，只需要写数据库的逻辑即可 _, err = m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) { query := fmt.Sprintf(\"delete from %s where `id` = ?\", m.table) return conn.ExecCtx(ctx, query, id) }, userIdKey, userMobileKey) return err } //通过主键查询 func (m *defaultUserModel) FindOne(ctx context.Context, id int64) (*User, error) { //缓存查询字段 userIdKey := fmt.Sprintf(\"%s%v\", cacheUserIdPrefix, id) //接收的结构体，当不是查询一个的时候可以使用QueryRowsCtx接收一个切片，详见源码或文档 var resp User //执行QueryRowCtx查询 err := m.QueryRowCtx(ctx, \u0026resp, userIdKey, func(ctx context.Context, conn sqlx.SqlConn, v interface{}) error { query := fmt.Sprintf(\"select %s from %s where `id` = ? limit 1\", userRows, m.table) return conn.QueryRowCtx(ctx, v, query, id) }) switch err { case nil: return \u0026resp, nil case sqlc.ErrNotFound: return nil, ErrNotFound default: return nil, err } } //插入条目 func (m *defaultUserModel) Insert(ctx context.Context, data *User) (sql.Result, error) { //生成缓存主键查询字段 userIdKey := fmt.Sprintf(\"%s%v\", cacheUserIdPrefix, data.Id) //生成缓存mobile索引查询字段 userMobileKey := fmt.Sprintf(\"%s%v\", cacheUserMobilePrefix, data.Mobile) //使用ExecCtx函数执行sql查询，其内部封装了缓存操作 ret, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) { query := fmt.Sprintf(\"insert into %s (%s) values (?, ?)\", m.table, userRowsExpectAutoSet) return conn.ExecCtx(ctx, query, data.Nickname, data.Mobile) }, userIdKey, userMobileKey) return ret, err } //更新条目 func (m *defaultUserModel) Update(ctx context.Context, newData *User) error { //查询是否有该主键条目 data, err := m.FindOne(ctx, newData.Id) if err != nil { return err } //生成缓存主键","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/model/:3:1","tags":["go-zero"],"title":"golang-go-zero-教程-Model","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/model/"},{"categories":["Golang"],"content":"索引优化 只有唯一索引可以生成默认优化 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/model/:3:2","tags":["go-zero"],"title":"golang-go-zero-教程-Model","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/model/"},{"categories":["Golang"],"content":"事务 查看sqlc的源码有如下方法 1 2 3 func (cc CachedConn) TransactCtx(ctx context.Context, fn func(context.Context, sqlx.Session) error) error { return cc.db.TransactCtx(ctx, fn) } 使用该方法来实现事务原子性，第一个参数是ctx可用于做链路追踪，第二个参数是一个函数表示事务过程，在这个函数中调用的语句当返回err为nil的时候提交，否则回滚到函数执行之前的状态。 我们的可以在Model中封装这个方法来实现在logic中使用事务。 1 2 3 4 5 6 //暴露给logic开启事务 func (m *defaultUserDataModel) TransCtx(ctx context.Context, fn func(ctx context.Context, s sqlx.Session) error) error { return m.TransactCtx(ctx, func(ctx context.Context, s sqlx.Session) error { return fn(ctx, s) }) } 默认生成Model的Insert不支持传入session，为了使用一个事务以实现原子性，需要重写Insert函数，接收一个sqlx.Session参数，并将默认执行sql的对象修改为传入的sqlx.Session对象 1 2 3 4 5 6 7 8 9 func (m *defaultUserModel) TransInsert(ctx context.Context, session sqlx.Session, data *User) (sql.Result, error) { userIdKey := fmt.Sprintf(\"%s%v\", cacheUserIdPrefix, data.Id) userMobileKey := fmt.Sprintf(\"%s%v\", cacheUserMobilePrefix, data.Mobile) ret, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) { query := fmt.Sprintf(\"insert into %s (%s) values (?, ?)\", m.table, userRowsExpectAutoSet) return session.ExecCtx(ctx, query, data.Nickname, data.Mobile) }, userIdKey, userMobileKey) return ret, err } 另外需要使用同一个session去执行db操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 if err := l.svcCtx.UserModel.TransCtx(l.ctx, func(ctx context.Context, session sqlx.Session) error { user := \u0026model.User{} user.Mobile = req.Mobile user.Nickname = req.Nickname //添加user dbResult, err := l.svcCtx.UserModel.TransInsert(ctx, session, user) if err != nil { return err } userId, _ := dbResult.LastInsertId() //添加userData userData := \u0026model.UserData{} userData.UserId = userId userData.Data = \"xxxx\" if _, err := l.svcCtx.UserDataModel.TransInsert(ctx, session, userData); err != nil { return err } return nil }); err != nil { fmt.Println(err) return nil, errors.New(\"创建用户失败\") } 其实只用这么一个Insert函数就可以了，判断一下如果传入的session为nil，则不使用session直接使用新的conn TransactCtx源码首先在函数体中开启事务，最后使用defer recover来实现回滚，当执行sql时出现panic或者err时候回滚该事务 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/model/:3:3","tags":["go-zero"],"title":"golang-go-zero-教程-Model","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/model/"},{"categories":["Golang"],"content":"自定义model文件userModel.go 该文件是用于自己添加model方法的文件，该文件中的UserModel继承了默认生成文件中的userModel 类型type 1 2 3 4 5 6 7 8 9 10 type ( // UserModels是一个接口，在这里添加自定义方法声明 UserModel interface { userModel } //customUserModel因为继承了userModel_gen.go中的defaultUserModel它能够使用默认给defaultUserModel生成的所有方法，在这里添加新的自定义方法实现 customUserModel struct { *defaultUserModel } ) 默认生成函数 1 2 3 4 5 6 //UserModel工厂函数 func NewUserModel(conn sqlx.SqlConn, c cache.CacheConf) UserModel { return \u0026customUserModel{ defaultUserModel: newUserModel(conn, c), } } ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/model/:3:4","tags":["go-zero"],"title":"golang-go-zero-教程-Model","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/model/"},{"categories":["Golang"],"content":"缓存的使用 对于主键字段缓存，会缓存整个结构体信息，而对于单索引字段（除全文索引）则缓存主键字段值。 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/model/:4:0","tags":["go-zero"],"title":"golang-go-zero-教程-Model","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/model/"},{"categories":["Golang"],"content":"类型转换规则 见文档 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/model/:5:0","tags":["go-zero"],"title":"golang-go-zero-教程-Model","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/model/"},{"categories":["Golang"],"content":"Cache和DB的自定义使用 userModel_gen.go 1 2 3 4 defaultUserModel struct { sqlc.CachedConn table string } cachesql.go 1 2 3 4 CachedConn struct { db sqlx.SqlConn cache cache.Cache } 所以我们可以使用.db和.cache来使用db和cache的方法 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/model/:6:0","tags":["go-zero"],"title":"golang-go-zero-教程-Model","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/model/"},{"categories":["Golang"],"content":"db sqlconn.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 SqlConn interface { Session // RawDB is for other ORM to operate with, use it with caution. // Notice: don't close it. RawDB() (*sql.DB, error) Transact(fn func(Session) error) error TransactCtx(ctx context.Context, fn func(context.Context, Session) error) error } Session interface { Exec(query string, args ...interface{}) (sql.Result, error) ExecCtx(ctx context.Context, query string, args ...interface{}) (sql.Result, error) Prepare(query string) (StmtSession, error) PrepareCtx(ctx context.Context, query string) (StmtSession, error) QueryRow(v interface{}, query string, args ...interface{}) error QueryRowCtx(ctx context.Context, v interface{}, query string, args ...interface{}) error QueryRowPartial(v interface{}, query string, args ...interface{}) error QueryRowPartialCtx(ctx context.Context, v interface{}, query string, args ...interface{}) error QueryRows(v interface{}, query string, args ...interface{}) error QueryRowsCtx(ctx context.Context, v interface{}, query string, args ...interface{}) error QueryRowsPartial(v interface{}, query string, args ...interface{}) error QueryRowsPartialCtx(ctx context.Context, v interface{}, query string, args ...interface{}) error } ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/model/:6:1","tags":["go-zero"],"title":"golang-go-zero-教程-Model","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/model/"},{"categories":["Golang"],"content":"cache cache.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 Cache interface { // Del deletes cached values with keys. Del(keys ...string) error // DelCtx deletes cached values with keys. DelCtx(ctx context.Context, keys ...string) error // Get gets the cache with key and fills into v. Get(key string, val interface{}) error // GetCtx gets the cache with key and fills into v. GetCtx(ctx context.Context, key string, val interface{}) error // IsNotFound checks if the given error is the defined errNotFound. IsNotFound(err error) bool // Set sets the cache with key and v, using c.expiry. Set(key string, val interface{}) error // SetCtx sets the cache with key and v, using c.expiry. SetCtx(ctx context.Context, key string, val interface{}) error // SetWithExpire sets the cache with key and v, using given expire. SetWithExpire(key string, val interface{}, expire time.Duration) error // SetWithExpireCtx sets the cache with key and v, using given expire. SetWithExpireCtx(ctx context.Context, key string, val interface{}, expire time.Duration) error // Take takes the result from cache first, if not found, // query from DB and set cache using c.expiry, then return the result. Take(val interface{}, key string, query func(val interface{}) error) error // TakeCtx takes the result from cache first, if not found, // query from DB and set cache using c.expiry, then return the result. TakeCtx(ctx context.Context, val interface{}, key string, query func(val interface{}) error) error // TakeWithExpire takes the result from cache first, if not found, // query from DB and set cache using given expire, then return the result. TakeWithExpire(val interface{}, key string, query func(val interface{}, expire time.Duration) error) error // TakeWithExpireCtx takes the result from cache first, if not found, // query from DB and set cache using given expire, then return the result. TakeWithExpireCtx(ctx context.Context, val interface{}, key string, query func(val interface{}, expire time.Duration) error) error } ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/model/:6:2","tags":["go-zero"],"title":"golang-go-zero-教程-Model","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/model/"},{"categories":["Golang"],"content":"总结 总结一下，对于带缓存model和不带缓存model的方法都在core/stores/sqlc/cachedsql.go和core/stores/sqlx/sqlconn.go文件中 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/model/:7:0","tags":["go-zero"],"title":"golang-go-zero-教程-Model","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/model/"},{"categories":["Golang"],"content":"cachedsql 类型 ExecFn func(conn sqlx.SqlConn) (sql.Result, error)：数据库执行函数 IndexQueryFn func(conn sqlx.SqlConn, v interface{}) (interface{}, error)：使用唯一索引的查询语句 PrimaryQueryFn func(conn sqlx.SqlConn, v, primary interface{}) error：使用主键查询的语句 QueryFn func(conn sqlx.SqlConn, v interface{}) error：普通查询语句 CachedConn 变量 db sqlx.SqlConn cache cache.Cache 方法 func (cc CachedConn) DelCache(keys …string) error：删除cache中的键值对 func (cc CachedConn) GetCache(key string, v interface{}) error：获取cache中键对应的值 func (cc CachedConn) Exec(exec ExecFn, keys …string) (sql.Result, error)：对给定的keys执行exec func (cc CachedConn) ExecNoCache(q string, args …interface{}) (sql.Result, error)：直接对数据库执行q语句，不修改缓存 func (cc CachedConn) QueryRow(v interface{}, key string, query QueryFn) error：如果key在缓存中直接返回，否则执行查询语句 func (cc CachedConn) QueryRowIndex(v interface{}, key string, keyer func(primary interface{}) string,indexQuery IndexQueryFn, primaryQuery PrimaryQueryFn) error func (cc CachedConn) QueryRowNoCache(v interface{}, q string, args …interface{}) error ；直接查询数据库，不影响缓存 func (cc CachedConn) QueryRowsNoCache(v interface{}, q string, args …interface{}) error：直接查数据库，不影响缓存 func (cc CachedConn) SetCache(key string, v interface{}) error：设置缓存 func (cc CachedConn) Transact(fn func(sqlx.Session) error) error：开启事务 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/model/:7:1","tags":["go-zero"],"title":"golang-go-zero-教程-Model","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/model/"},{"categories":["Golang"],"content":"sqlconn Session interface 方法 Exec(query string, args …interface{}) (sql.Result, error)：执行语句 Prepare(query string) (StmtSession, error)：预编译语句 QueryRow(v interface{}, query string, args …interface{}) error：查询一条记录 QueryRowPartial(v interface{}, query string, args …interface{}) error：查询一条记录的部分字段 QueryRows(v interface{}, query string, args …interface{}) error：查询多条记录 QueryRowsPartial(v interface{}, query string, args …interface{}) error：查询多条记录的部分字段 SqlConn interface 方法 Session Exec(query string, args …interface{}) (sql.Result, error)：执行语句 RawDB() (*sql.DB, error)：返回原始DB，可以用于启动其他orm Transact(func(session Session) error) error：开启事务 StmtSession interface 方法 Close() error Exec(args …interface{}) (sql.Result, error) QueryRow(v interface{}, args …interface{}) error QueryRowPartial(v interface{}, args …interface{}) error QueryRows(v interface{}, args …interface{}) error QueryRowsPartial(v interface{}, args …interface{}) error ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/model/:7:2","tags":["go-zero"],"title":"golang-go-zero-教程-Model","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/model/"},{"categories":["Golang"],"content":"go-zero官网 go-zero详细文档 本系列为作者跟着Mikaelemmmm的b站教学视频学习时做的笔记 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/:0:0","tags":["go-zero"],"title":"golang-go-zero-教程-Api","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/"},{"categories":["Golang"],"content":"api文件 编写api文件，语法和go差不多，api文法官网 type定义api接口参数类型，tag为json表示json体参数，form表示url参数，path表示url变量 1 2 3 4 5 6 7 8 9 10 type ( UserInfoReq { UserId int64 `json:\"userId\"` } UserInfoResq { UserId int64 `json:\"userId\"` Nickname string `json:\"nickname\"` } ) server表示接下来service块的配置，server group将service块里面的api生成的go文件一起放到一个名称为group值的目录，prefix为路由前缀，比如group为user，那么一般设置为user-api/v1等。service表示你的服务，一个api文件的service名称必须一致。handler是处理器，相当于HandleFunc。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @server( //jwt: Auth group: user prefix : userapi/v1 ) service user-api { @doc \"获取用户信息\" @handler userInfo get /users/info (UserInfoReq) returns (UserInfoResq) @doc \"修改用户信息\" @handler userUpdate get /users/update (UserUpdateReq) returns (UserUpdateResq) } 构建命令 1 goctl api go -api user.api -dir ../ -style goZero 执行构建命令时对于notedit文件比如types里面的go文件将会重写，其他的文件以api文件里面的@handler为粒度进行新增，以存在的不会进行修改（其实就是忽略已存在文件）。 api文件可以import，一般type部分太多可以拆到其他文件。 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/:1:0","tags":["go-zero"],"title":"golang-go-zero-教程-Api","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/"},{"categories":["Golang"],"content":"main文件 main文件的名称为group名.go 查看该文件main函数上面有一个-f的flag配置项。默认使用etc里面的yaml配置文件，在启动服务的时候使用-f可以使用指定的配置文件 main语句 1 var configFile = flag.String(\"f\", \"etc/user-api.yaml\", \"the config file\") 后续按照main的逻辑讲其他文件或文件夹 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/:2:0","tags":["go-zero"],"title":"golang-go-zero-教程-Api","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/"},{"categories":["Golang"],"content":"载入配置文件 main语句 1 2 var c config.Config conf.MustLoad(*configFile, \u0026c) etc/.yaml配置文件，默认生成配置有 1 2 3 Name: user-api Host: 0.0.0.0 Port: 8888 分别表示服务名跟api文件的service名称匹配，监听地址（0.0.0.0表示设备的所有网卡）和端口号 zero自带的配置对象可以直接查看config对应的结构体来查看配置项 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/:2:1","tags":["go-zero"],"title":"golang-go-zero-教程-Api","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/"},{"categories":["Golang"],"content":"生成一个服务对象 main 1 2 server := rest.MustNewServer(c.RestConf) defer server.Stop() ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/:2:2","tags":["go-zero"],"title":"golang-go-zero-教程-Api","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/"},{"categories":["Golang"],"content":"将依赖配置到ctx main 1 ctx := svc.NewServiceContext(c) 将配置文件的依赖配置到ctx（svc/serviceContext.go的ServiceContext结构体），后续使用的中间件需要配置到该结构体中，比如kafka，redis以及model命令生成的model对象之类的 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/:2:3","tags":["go-zero"],"title":"golang-go-zero-教程-Api","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/"},{"categories":["Golang"],"content":"注册路由 main 1 handler.RegisterHandlers(server, ctx) 该函数在internal/handler/routes.go中，由api文件生成配置路由，前缀也在该函数中声明 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/:2:4","tags":["go-zero"],"title":"golang-go-zero-教程-Api","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/"},{"categories":["Golang"],"content":"启动服务 main 1 server.Start() ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/:2:5","tags":["go-zero"],"title":"golang-go-zero-教程-Api","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/"},{"categories":["Golang"],"content":"internal/handler目录 该目录除了routes.go文件，其他的都是按api中定义的@server.group字符串分组 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/:3:0","tags":["go-zero"],"title":"golang-go-zero-教程-Api","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/"},{"categories":["Golang"],"content":"Handler函数 相当于java的controller 首先进行参数解析 1 2 3 4 5 var req types.UserInfoReq if err := httpx.Parse(r, \u0026req); err != nil { httpx.Error(w, err) return } 然后生成对应的logic类型，这里同时传递了ctx，所以ctx的依赖在logic里也能够使用 1 l := user.NewUserInfoLogic(r.Context(), svcCtx) ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/:3:1","tags":["go-zero"],"title":"golang-go-zero-教程-Api","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/"},{"categories":["Golang"],"content":"internal/logic目录 这里就是写真正的业务逻辑了，中间件都放svcCtx中，这个会由handler传递进来所以都能访问 logic函数传入的请求和返回的响应分别对应type里面的类型，可以直接使用Req.xxx来访问传入的数据 返回值其实为两个值，第一个是api定义并生成的type.go里面的结构体，另一个是标准库errors里的error对象。当出错时可以返回err告诉handler。 每一个logic都是一个工厂模型，在internal里面可以在任意地方生成一个logic对象，然后通过调用logic的方法来执行logic代码 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/:4:0","tags":["go-zero"],"title":"golang-go-zero-教程-Api","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/"},{"categories":["Golang"],"content":"middleware ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/:5:0","tags":["go-zero"],"title":"golang-go-zero-教程-Api","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/"},{"categories":["Golang"],"content":"server粒度middleware 1 2 3 4 5 6 @server( //jwt: Auth group: user prefix : userapi/v1 :TmstMiddlewareiddleware ) goctrl api构建之后会在internal中生成一个middleware文件夹，里面是你定义的middleware函数 另外internal/handler目录里面的routes.go是这样使用middleware的 1 2 3 rest.WithMiddlewares( []rest.Middleware{serverCtx.TestMiddleware}, ... 所以middleware也需要导入到svcCtx，导入过程如下 先修改svcCtx结构体 1 2 3 4 type ServiceContext struct { ... TestMiddleware rest.Middleware } 再修改New函数 1 2 3 4 5 6 func NewServiceContext(c config.Config) *ServiceContext { return \u0026ServiceContext{ ... TestMiddleware: middleware.NewTestMiddleware().Handle, } } 然后路由中就不会报错了 接下来就可以修改middleware的内部逻辑了 1 2 3 4 5 6 7 func (m *TestMiddleware) Handle(next http.HandlerFunc) http.HandlerFunc { return func(w http.ResponseWriter, r *http.Request) { fmt.Println(\"come in testMiddleware before\") next(w, r) fmt.Println(\"come in testMiddleware end\") } } ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/:5:1","tags":["go-zero"],"title":"golang-go-zero-教程-Api","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/"},{"categories":["Golang"],"content":"全局中间件 全局中间件通常放在app/common/middleware目录中，比如jwt全局中间件，一个中间件其实就是一个返回http.HandleFunc对象的函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 type GlobalMiddleware struct{ 可加字段 } func NewGlobalMiddleware(/*可加参数*/) *GlobalMiddleware { return \u0026GlobalMiddleware{/*补全字段*/} } func (m *GlobalMiddleware) Handle(next http.HandlerFunc) http.HandlerFunc { return func(w http.ResponseWriter, r *http.Request) { //可使用CommonJwtAuthMiddleware对象m的参数 fmt.Println(\"global before\") next(w, r) fmt.Println(\"global end\") } } main中使用如下方式添加全局中间件 1 2 3 4 5 6 7 8 9 func main() { ... server := rest.MustNewServer(c.RestConf) defer server.Stop() ... server.Use(middleware.NewCommonJwtAuthMiddleware().Handle) ... server.Start() } 全局中间件比局部中间件更早执行 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/:5:2","tags":["go-zero"],"title":"golang-go-zero-教程-Api","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/"},{"categories":["Golang"],"content":"整体源码分析 zero里面有很多基于golang …语法糖的选项模式 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/:6:0","tags":["go-zero"],"title":"golang-go-zero-教程-Api","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/"},{"categories":["Golang"],"content":"conf.MustLoad(*configFile, \u0026c) 读取config.yaml。 如果在config.yaml中使用环境变量则在main中给该函数配置选项conf.UseEnv() 1 conf.MustLoad(*configFile, \u0026c, conf.UseEnv()) 这样就可以在yaml文件里面使用${envName}格式的变量来绑定环境变量 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/:6:1","tags":["go-zero"],"title":"golang-go-zero-教程-Api","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/"},{"categories":["Golang"],"content":"server := rest.MustNewServer(c.RestConf) Setup()：日志，Prometheus，链路追踪，metrics ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/:6:2","tags":["go-zero"],"title":"golang-go-zero-教程-Api","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/"},{"categories":["Golang"],"content":"api调用rpc ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/:7:0","tags":["go-zero"],"title":"golang-go-zero-教程-Api","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/"},{"categories":["Golang"],"content":"配置 rpc配置 rpc的yaml文件需要配置直连，Etcd或者K8s，选择的方式要和api对应。这里展示Etcd，Etcd使用Key来查询服务 1 2 3 4 Etcd: Hosts: - 0.0.0.0:2379 Key: user.rpc api配置 internal/config/config.go中config结构体添加zrpc.RpcClientConf字段 1 2 3 4 type Config struct { ... UserRpcConf zrpc.RpcClientConf } etc/.yaml文件添加配置，下面的代码展示的是ETCD的配置方式，除了这个方式还有直连EndPoint和K8s。 Etcd使用Key来查询服务 1 2 3 4 5 UserRpcConf: Etcd: Hosts: - 0.0.0.0:2379 Key: user.rpc 然后在svcCtx中添加rpc生成的rpc客户端字段，在本例中为usercenter/usercenter.go文件中的Usercenter接口，并且在svcCtx工厂函数中使用rpc中usercenter的工厂函数给该字段赋初值。由于工厂函数需要一个zrpc客户端，所以通过zrpc.MustNewClient(c.UserRpcConf)使用yaml配置生成一个zrpc客户端 1 2 3 4 5 6 7 8 9 10 11 12 type ServiceContext struct { ... UserRpcClient usercenter.Usercenter } func NewServiceContext(c config.Config) *ServiceContext { return \u0026ServiceContext{ ... UserRpcClient: usercenter.NewUsercenter(zrpc.MustNewClient(c.UserRpcConf)), } } 之后就能在api的logic里面调用rpc了 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/:7:1","tags":["go-zero"],"title":"golang-go-zero-教程-Api","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/"},{"categories":["Golang"],"content":"调用 对于pb中定义的service可以直接通过svcCtx的Client直接调用，传入2个参数：ctx和pb生成的Req结构体对象指针。返回的结果为pb定义的Resp结构体对象指针。所以fo-zero的rpc调用非常方便 1 2 3 4 5 6 userResp, err := l.svcCtx.UserRpcClient.GetUserInfo(l.ctx, \u0026pb.GetUserInfoReq{ Id: req.UserId, }) if err != nil { return nil, err } ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/:7:2","tags":["go-zero"],"title":"golang-go-zero-教程-Api","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/"},{"categories":["Golang"],"content":"官方支持的api与rpc对接的三种方式 直连，Etcd和K8s 除了这三种在go-zero team里面的zero-contrib里面还有consul，nacos，polaris等注册中心的连接方式 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/:8:0","tags":["go-zero"],"title":"golang-go-zero-教程-Api","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/"},{"categories":["Golang"],"content":"Etcd rpc的配置 rpc的yaml文件配置 1 2 3 4 Etcd: Hosts: - 0.0.0.0:2379 Key: user.rpc 具体的Etcd配置可以看config.go里面的RpcServerConf.Etcd相关的字段 api的配置 api的yaml文件配置需要与rpc中的Key对应才能实现服务发现。 1 2 3 4 5 UserRpcConf: Etcd: Hosts: - 0.0.0.0:2379 Key: user.rpc 这里的UserRpcConf再etc/config.go中使用zrpc.RpcClientConf类型来接收，这个配置字段是作为后面生成rpc客户端实例的时候的配置信息 1 2 3 4 type Config struct { ... UserRpcConf zrpc.RpcClientConf } api调用rpc时是需要rpc生成的客户端目录里面的go文件（一个客户端与一个proto里面的service对应，里面有调用service里面rpc方法的方法）来进行调用的，所以在svcCtx中需要添加rpc客户端字段（其实是一个接口）。 1 2 3 4 type ServiceContext struct { ... UserRpcClient usercenter.Usercenter } 详见调用 rpc注册到etcd后可以使用如下命令查看etcd注册的服务 1 etcdctl get --prefix \"\" ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/:8:1","tags":["go-zero"],"title":"golang-go-zero-教程-Api","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/"},{"categories":["Golang"],"content":"直连 好处是简单，坏处是不可扩展，开发一般使用直连 直连rpc不需要配置（如果之前配置的Etcd也会优先走直连，但是如果Etcd服务没起来也无法启动rpc，所以不要同时配置多个模式），直接配置api即可 1 2 3 UserRpcConf: Endpoints: - 0.0.0.0:8080 EndPoints对应是一个字符串数组，所以直连也有负载均衡。go-zero都是使用P2C算法来进行负载均衡的。 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/:8:2","tags":["go-zero"],"title":"golang-go-zero-教程-Api","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/"},{"categories":["Golang"],"content":"K8s rpc不需要配置，但是需要写k8s的yaml文件，并将rpc装载到k8s pod中 api需要配置yaml文件，将rpc设置为Target（k8s连接），值为k8s集群地址，比如下面这个例子，k8s://表示k8s协议，go-zero-looklook表示k8s集群地址，basic-rpc-svc:9001是k8s yaml文件里面写的服务名称和端口号 1 2 UserRpcConf: Target: k8s://go-zero-looklook/basic-rpc-svc:9001 部署过程 使用goctl生成rpc和api的dockerfile 1 goctl docker -go user.go 生成rpc、api镜像同时推送到镜像仓库 生成镜像需要将build上下文必须是具有gomod文件的目录，即上下文必须是项目根目录，goctl有标记rpc或api文件相对根目录的相对路径，所以不用担心将整个项目构建 1 go build -t xxxx:yyy -f path/to/Dockerfile . 另外还有一种简单的方法 1 goctl docker -go .\\service\\user\\rpc\\user.go 其余内容见bilibili和looklook文档。等我熟悉了k8s再来总结相关内容，Mikaelemmmm哥讲到k8s架构图我直接蒙圈。 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/:8:3","tags":["go-zero"],"title":"golang-go-zero-教程-Api","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/"},{"categories":["Golang"],"content":"api参数校验集成第三方库 默认go-zero的参数校验比较简单，可以使用第三方validator库 使用方法也很简单，给结构体添加tag. 1 2 3 4 5 6 type User struct { FirstName string `validate:\"required\"` LastName string `validate:\"required\"` Age uint8 `validate:\"gte=0,lte=130\"` Email string `validate:\"required,email\"` } 校验时候先生成validator对象。 1 v:=validator.New() 直接调用validator.Struct(\u0026xxx)返回err，err会记录出错的地方，详见文档 1 2 3 err:=v.Struct(\u0026user) err:=v.StructCtx(r.Context,\u0026user) 与go-zero结合的时候将校验的tag加到api文件里面，不要在生成的文件里面添加，因为下次生成会覆盖之前生成的文件。如果不想每次api构建后自己都得再写一遍validator校验逻辑，可以修改模板。 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/:9:0","tags":["go-zero"],"title":"golang-go-zero-教程-Api","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/"},{"categories":["Golang"],"content":"go-zero 自带jwt鉴权 api文件设置jwt：xxx yaml配置文件配置xxx的相关配置 1 2 3 Auth: AccessSecret: $AccessSecret AccessExpire: $AccessExpire 后续通过jwt鉴权的请求携带的jwt信息可以在其他地方被访问 1 2 3 4 func (l *SearchLogic) Search(req types.SearchReq) (*types.SearchReply, error) { logx.Infof(\"userId: %v\",l.ctx.Value(\"userId\"))// 这里的key和生成jwt token时传入的key一致 return \u0026types.SearchReply{}, nil } 详见looklook ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/:10:0","tags":["go-zero"],"title":"golang-go-zero-教程-Api","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/"},{"categories":["Golang"],"content":"api的兼容性 定义或修改API的时候一定要考虑向前兼容： 增加新的API接口协议 请求参数添加字段，需要保证新老客户端对该字段的处理方式不同 响应结果添加字段，该字段信息只会在新版本客户端中展示 如下几种情况是向前不兼容的： 删除或重命名服务、字段、方法 修改字段类型 修改现有请求的可见行为，客户端通常依赖于API行为和语义，即使这样的行为没有被明确支持或记录。因此，在大多数情况下，修改API数据的行为或语义将被消费者视为是破坏性的 给资源消息添加 读取/写入 字段 ","date":"2023-01-06","objectID":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/:11:0","tags":["go-zero"],"title":"golang-go-zero-教程-Api","uri":"/posts/golang/go-zero/%E6%95%99%E7%A8%8B/api/"},{"categories":["Golang"],"content":"godoc github官网 该库是Mikaelemmmm大佬写的通过sql直接生成pb的go程序 ","date":"2023-01-05","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/sql2pb/:0:0","tags":["go第三方库"],"title":"go第三方库-Sql2pb","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/sql2pb/"},{"categories":["Golang"],"content":"安装 1 go get -u github.com/Mikaelemmmm/sql2pb@latest ","date":"2023-01-05","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/sql2pb/:1:0","tags":["go第三方库"],"title":"go第三方库-Sql2pb","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/sql2pb/"},{"categories":["Golang"],"content":"使用 1 sql2pb -go_package ./pb -host localhost -package pb -password root -port 3306 -schema usercenter -service_name usersrv -user root \u003e usersrv.proto 使用goctl的话需要让-service_name 和输出文件名一致 生成数据库表对应的message，另外生成增改删查的rpc函数 ","date":"2023-01-05","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/sql2pb/:2:0","tags":["go第三方库"],"title":"go第三方库-Sql2pb","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/sql2pb/"},{"categories":["通用技术"],"content":"CSDN billgates_wanbin ","date":"2023-01-04","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/:0:0","tags":[],"title":"通用技术-限流算法","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/"},{"categories":["通用技术"],"content":"计数限流 保存一个计数器，处理了一个请求，计数器加一，一个请求处理完毕之后计数器减一 每次请求来的时候看看计数器的值，如果超过阈值就拒绝 ","date":"2023-01-04","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/:1:0","tags":[],"title":"通用技术-限流算法","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/"},{"categories":["通用技术"],"content":"固定窗口限流算法 维护一个计数器，将单位时间段当做一个窗口，计数器记录这个窗口接收请求的次数，到下一个时间窗口将计数器归零 每次请求来的时候看看计数器的值，如果超过阈值就拒绝 ","date":"2023-01-04","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/:2:0","tags":[],"title":"通用技术-限流算法","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/"},{"categories":["通用技术"],"content":"滑动窗口限流 基于固定窗口限流算法，记录每个请求被接收的时间，计数器只统计时间窗口之内的请求数，超过阈值则拒绝 ","date":"2023-01-04","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/:3:0","tags":[],"title":"通用技术-限流算法","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/"},{"categories":["通用技术"],"content":"漏桶算法 将请求作为水滴，以恒定速率漏流水滴(处理请求)，当桶中请求超过桶容量就会溢出(拒绝) ","date":"2023-01-04","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/:4:0","tags":[],"title":"通用技术-限流算法","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/"},{"categories":["通用技术"],"content":"令牌桶算法 基于漏桶算法，令牌管理员根据限流大小匀速往桶里放令牌，当桶满了就丢弃放入的令牌，每个请求都需要获取令牌才能处理，无法获取令牌的请求会被丢弃。 ","date":"2023-01-04","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/:5:0","tags":[],"title":"通用技术-限流算法","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/"},{"categories":["Golang"],"content":"godoc godoc 官方文档 ","date":"2023-01-04","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/sqlx/:0:0","tags":["go第三方库"],"title":"go第三方库-Sqlx","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/sqlx/"},{"categories":["Golang"],"content":"godoc godoc 官方文档 ","date":"2023-01-04","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/redis/:0:0","tags":["go第三方库"],"title":"go第三方库-Redis","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/redis/"},{"categories":["Golang"],"content":"新建客户端 1 2 3 4 5 6 rdb := redis.NewClient(\u0026redis.Options{ Addr: \":6379\", }) rdb.AddHook(redisHook{}) rdb.Ping() ","date":"2023-01-04","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/redis/:1:0","tags":["go第三方库"],"title":"go第三方库-Redis","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/redis/"},{"categories":["Golang"],"content":"执行命令 1 2 3 4 5 6 7 8 9 10 11 12 13 //process方法 Get := func(rdb *redis.Client, key string) *redis.StringCmd { cmd := redis.NewStringCmd(\"get\", key) rdb.Process(cmd) return cmd } v, err := Get(rdb, \"key_does_not_exist\").Result() fmt.Printf(\"%q %s\", v, err) //Do方法 v, err := rdb.Do(\"get\", \"key_does_not_exist\").Text() fmt.Printf(\"%q %s\", v, err) ","date":"2023-01-04","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/redis/:2:0","tags":["go第三方库"],"title":"go第三方库-Redis","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/redis/"},{"categories":["Golang"],"content":"其他具体例子 见文档 ","date":"2023-01-04","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/redis/:3:0","tags":["go第三方库"],"title":"go第三方库-Redis","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/redis/"},{"categories":["Golang"],"content":"godoc gorilla godoc 官方文档 nhooyr github官网 nhooyr godoc 官方文档 ","date":"2023-01-04","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/websocket/:0:0","tags":["go第三方库"],"title":"go第三方库-Websocket","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/websocket/"},{"categories":["Golang"],"content":"gorilla 该库已经不被维护 ","date":"2023-01-04","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/websocket/:1:0","tags":["go第三方库"],"title":"go第三方库-Websocket","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/websocket/"},{"categories":["Golang"],"content":"升级http协议 1 2 3 4 5 6 7 8 9 10 11 12 13 var upgrader = websocket.Upgrader{ ReadBufferSize: 1024, WriteBufferSize: 1024, } func handler(w http.ResponseWriter, r *http.Request) { conn, err := upgrader.Upgrade(w, r, nil) if err != nil { log.Println(err) return } ... Use conn to send and receive messages. } 读取和写入 1 2 3 4 5 6 7 8 9 10 11 for { messageType, p, err := conn.ReadMessage() if err != nil { log.Println(err) return } if err := conn.WriteMessage(messageType, p); err != nil { log.Println(err) return } } ","date":"2023-01-04","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/websocket/:1:1","tags":["go第三方库"],"title":"go第三方库-Websocket","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/websocket/"},{"categories":["Golang"],"content":"数据消息 WebSocket 协议区分文本和二进制数据消息。TextMessage 和 BinaryMessage 整数常量来标识两种数据消息类型。 ReadMessage 和 NextReader 方法返回接收到的消息的类型。WriteMessage 和 NextWriter 方法的 messageType 参数指定发送消息的类型。 ","date":"2023-01-04","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/websocket/:1:2","tags":["go第三方库"],"title":"go第三方库-Websocket","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/websocket/"},{"categories":["Golang"],"content":"控制消息 三种类型的控制消息：close、ping 和 pong。WriteControl、WriteMessage 或 NextWriter 方法向对等方发送控制消息。 SetPingHandler 方法设置的处理程序函数来处理接收到的 ping 消息。默认的 ping 处理程序向对等方发送一条 pong 消息。 SetPongHandler 方法设置的处理函数来处理接收到的 pong 消息。默认的 pong 处理程序什么都不做。 ","date":"2023-01-04","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/websocket/:1:3","tags":["go第三方库"],"title":"go第三方库-Websocket","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/websocket/"},{"categories":["Golang"],"content":"nhooyr ","date":"2023-01-04","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/websocket/:2:0","tags":["go第三方库"],"title":"go第三方库-Websocket","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/websocket/"},{"categories":["Golang"],"content":"服务器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 http.HandlerFunc(func (w http.ResponseWriter, r *http.Request) { c, err := websocket.Accept(w, r, nil) if err != nil { // ... } defer c.Close(websocket.StatusInternalError, \"the sky is falling\") ctx, cancel := context.WithTimeout(r.Context(), time.Second*10) defer cancel() var v interface{} err = wsjson.Read(ctx, c, \u0026v) if err != nil { // ... } log.Printf(\"received: %v\", v) c.Close(websocket.StatusNormalClosure, \"\") }) ","date":"2023-01-04","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/websocket/:2:1","tags":["go第三方库"],"title":"go第三方库-Websocket","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/websocket/"},{"categories":["Golang"],"content":"客户 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ctx, cancel := context.WithTimeout(context.Background(), time.Minute) defer cancel() c, _, err := websocket.Dial(ctx, \"ws://localhost:8080\", nil) if err != nil { // ... } defer c.Close(websocket.StatusInternalError, \"the sky is falling\") err = wsjson.Write(ctx, c, \"hi\") if err != nil { // ... } c.Close(websocket.StatusNormalClosure, \"\") ","date":"2023-01-04","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/websocket/:2:2","tags":["go第三方库"],"title":"go第三方库-Websocket","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/websocket/"},{"categories":["数据库"],"content":"菜鸟教程 NoSQL（非关系型数据库）的一种，文档数据库 ","date":"2023-01-02","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/%E7%AE%80%E4%BB%8B/:0:0","tags":["MongoDB"],"title":"数据库-MongoDB-简介","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/%E7%AE%80%E4%BB%8B/"},{"categories":["数据库"],"content":"三个概念 数据库（database）：存放集合 集合（collection）；存放统一结构类型文档 文档（document）：最小单位 ","date":"2023-01-02","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/%E7%AE%80%E4%BB%8B/:1:0","tags":["MongoDB"],"title":"数据库-MongoDB-简介","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/%E7%AE%80%E4%BB%8B/"},{"categories":["数据库"],"content":"基本指令 show dbs\\database：显示当前所有数据库 use 数据库名：进入到指定的数据库中（可以不存在） db：表示我们当前所处的数据库 show collections：显示我们数据库中所有的集合 ","date":"2023-01-02","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/%E7%AE%80%E4%BB%8B/:2:0","tags":["MongoDB"],"title":"数据库-MongoDB-简介","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/%E7%AE%80%E4%BB%8B/"},{"categories":["数据库"],"content":"CRUD操作 ","date":"2023-01-02","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/%E7%AE%80%E4%BB%8B/:3:0","tags":["MongoDB"],"title":"数据库-MongoDB-简介","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/%E7%AE%80%E4%BB%8B/"},{"categories":["数据库"],"content":"插入文档 db.collection.insert(doc)：向collection集合中插入一个或多个（使用数组json）文档，数据库会自动给未指定_id属性的文档添加该属性 db.collection.insertMany()：传入并插入多个对象文档 ","date":"2023-01-02","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/%E7%AE%80%E4%BB%8B/:3:1","tags":["MongoDB"],"title":"数据库-MongoDB-简介","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/%E7%AE%80%E4%BB%8B/"},{"categories":["数据库"],"content":"查询文档： db.collection.find({属性：值})：查满足条件的所有文档，返回一个数组 db.collection.findOne({属性：值})：返回一个文档 db.stus.find({}).count()：查询所有结果的数量 db.COLLECTION_NAME.find().sort({KEY:1})排序 db.COLLECTION_NAME.find().limit(NUMBER) limit方法 db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER) skip方法（相当于mysql的offset） ","date":"2023-01-02","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/%E7%AE%80%E4%BB%8B/:3:2","tags":["MongoDB"],"title":"数据库-MongoDB-简介","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/%E7%AE%80%E4%BB%8B/"},{"categories":["数据库"],"content":"修改文档 db.collection.update(查询条件，新对象):默认替换一个对象 想要不替换可以使用下列键的对象：$set修改指定文档属性，$unset删除指定文档属性 1 2 3 db.stus.update( {\"_id\" : ObjectId(\"5f86edc1048d21081bd45f3b\")}, {$set:{gender:\"男\",address:\"流沙河\"}}) db.collection.updateMany()：同时修改多个符合条件的文档 db.collection.updateOne()：修改一个符合条件的文档 db.collection.replaceOne()：替换一个符合条件的文档 内嵌文档可以则可以通过\".“的形式来查询属性 1 db.user.find(\"hobby.movies\"：\"hero\")； ","date":"2023-01-02","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/%E7%AE%80%E4%BB%8B/:3:3","tags":["MongoDB"],"title":"数据库-MongoDB-简介","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/%E7%AE%80%E4%BB%8B/"},{"categories":["数据库"],"content":"删除文档 db.collection.remove()接收和find一样的条件参数，默认删除多个。如果第二个参数为true则只删除一个 db.collection.drop（）：删除集合（如果是最后一个集合，会删除数据库） ","date":"2023-01-02","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/%E7%AE%80%E4%BB%8B/:3:4","tags":["MongoDB"],"title":"数据库-MongoDB-简介","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/%E7%AE%80%E4%BB%8B/"},{"categories":["数据库"],"content":"文档间的关系 内嵌对象或引用实现一对一，一对多，多对多 ","date":"2023-01-02","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/%E7%AE%80%E4%BB%8B/:4:0","tags":["MongoDB"],"title":"数据库-MongoDB-简介","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"godoc casbin官网 ","date":"2023-01-01","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/casbin/:0:0","tags":["go第三方库"],"title":"go第三方库-Casbin","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/casbin/"},{"categories":["Golang"],"content":"基础知识 Casbin 是一个强大和高效的开放源码访问控制库，它支持各种 访问控制模型 以强制全面执行授权。 ","date":"2023-01-01","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/casbin/:1:0","tags":["go第三方库"],"title":"go第三方库-Casbin","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/casbin/"},{"categories":["Golang"],"content":"开始使用 新建一个Casbin enforcer Casbin使用配置文件来设置访问控制模型（Enforcer）， model.conf 存储了我们的访问模型（ Model），policy.csv 存储的是我们具体的用户权限配置（Adapter）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 使用MySQL数据库初始化一个Xorm适配器，Adapter a, err := xormadapter.NewAdapter(\"mysql\", \"mysql_username:mysql_password@tcp(127.0.0.1:3306)/casbin\") if err != nil { log.Fatalf(\"error: adapter: %s\", err) } //Model m, err := model.NewModelFromString(` [request_definition] r = sub, obj, act [policy_definition] p = sub, obj, act [policy_effect] e = some(where (p.eft == allow)) [matchers] m = r.sub == p.sub \u0026\u0026 r.obj == p.obj \u0026\u0026 r.act == p.act `) if err != nil { log.Fatalf(\"error: model: %s\", err) } //Enforcer e, err := casbin.NewEnforcer(m, a) if err != nil { log.Fatalf(\"error: enforcer: %s\", err) } 也可以使用文件 1 e, err := casbin.NewEnforcer(\"path/to/model.conf\", \"path/to/policy.csv\") 检查权限 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 sub := \"alice\" // 想要访问资源的用户。 obj: = \"data1\" // 将被访问的资源。 act := \"read\" // 用户对资源执行的操作。 ok, err := e.Enforce(sub, obj, act) if err != nil { // 处理err } if ok == true { // 允许alice读取data1 } else { // 拒绝请求，抛出异常 } 批量，返回slice 1 results, err := e.BatchEnforce([[] []interface{}{\"alice\", \"data1\", \"read\"}, {\"bob\", datata2\", \"write\"}, {\"jack\", \"data3\", \"read\"}}) 获得分配给一个用户的所有角色 1 roles, err := e.GetRolesForUser(\"alice\") ","date":"2023-01-01","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/casbin/:1:1","tags":["go第三方库"],"title":"go第三方库-Casbin","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/casbin/"},{"categories":["Golang"],"content":"访问控制模型 ","date":"2023-01-01","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/casbin/:2:0","tags":["go第三方库"],"title":"go第三方库-Casbin","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/casbin/"},{"categories":["Golang"],"content":"Model 的语法(PERM) Request定义 [request_definition] 定义了 e.Enforce(…) 函数中的参数 [request_definition]\rr = sub, obj, act Policy定义 [policy_definition]是策略的定义，与Request的定义没有关系，相当于adapter中的条目的形参 [policy_definition]\rp = sub, obj, act\rp2 = sub, act 策略对应的adapter内容，有一个eft字段，该字段省略时默认为allow，在adapter里面只能定义为allow和deny 匹配器 [matchers] 是策略匹配器的定义 将r与policy里面的条目匹配，当一个条目p匹配的时候返回p.eft给effect。 [matchers]\rm = r.sub == p.sub \u0026\u0026 r.obj == p.obj \u0026\u0026 r.act == p.act 匹配器中，可以使用算术运算符如 +, -, * , / ，也可以使用逻辑运算符如：\u0026\u0026，||，！ Policy effect定义 [policy_effect]部分是对policy生效范围的定义 [policy_effect]\re = some(where (p.eft == allow)) 如果e为真则返回true给enforcer ","date":"2023-01-01","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/casbin/:2:1","tags":["go第三方库"],"title":"go第三方库-Casbin","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/casbin/"},{"categories":["Golang"],"content":"函数 match内置函数 自定义函数签名，接收字符串返回bool 1 func KeyMatchFunc(args ...interface{}) (interface{}, error) enforcer中注册函数 1 e.AddFunction(\"my_func\", KeyMatchFunc) match部分使用函数 [matchers]\rm = r.sub == p.sub \u0026\u0026 my_func(r.obj, p.obj) \u0026\u0026 r.act == p.act ","date":"2023-01-01","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/casbin/:2:2","tags":["go第三方库"],"title":"go第三方库-Casbin","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/casbin/"},{"categories":["Golang"],"content":"RBAC [role_definition]\rg = _, _ # 角色或资源 在match中使用的函数 m = g(r.sub, p.sub) \u0026\u0026 r.obj == p.obj \u0026\u0026 r.act == p.act g(r.sub, p.sub)会被翻译为r.sub==p.sub||gg(r.sub)==p.sub其中gg(r.sub)的结果是g条目中的第二个数据 [role_definition]\rg = _, _, _ # 多商户 [matchers]\rm = g(r.sub, p.sub, r.dom) \u0026\u0026 r.dom == p.dom \u0026\u0026 r.obj == p.obj \u0026\u0026 r.act == p.act g(r.sub, p.sub, r.dom)会被翻译为r.sub==p.sub||gg(r.sub，r.dom)==p.sub其中gg(r.sub，r.dom)的结果是g条目中的第二个数据 ","date":"2023-01-01","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/casbin/:2:3","tags":["go第三方库"],"title":"go第三方库-Casbin","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/casbin/"},{"categories":["Golang"],"content":"存储 ","date":"2023-01-01","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/casbin/:3:0","tags":["go第三方库"],"title":"go第三方库-Casbin","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/casbin/"},{"categories":["Golang"],"content":"Model 的存储 model 不是动态组件，不应该在运行时进行修改，没有save API 从 .CONF 文件中加载 model 1 e := casbin.NewEnforcer(\"examples/rbac_model.conf\", \"examples/rbac_policy.csv\") 从代码加载 model 1 2 3 4 5 6 7 // 从Go代码初始化模型 m := model.NewModel() m.AddDef(\"r\", \"r\", \"sub, obj, act\") m.AddDef(\"p\", \"p\", \"sub, obj, act\") m.AddDef(\"g\", \"g\", \"_, _\") m.AddDef(\"e\", \"e\", \"some(where (p.eft == allow))\") m.AddDef(\"m\", \"m\", \"g(r.sub, p.sub) \u0026\u0026 r.obj == p.obj \u0026\u0026 r.act == p.act\") 从字符串加载的 model 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 text := ` [request_definition] r = sub, obj, act [policy_definition] p = sub, obj, act [role_definition] g = _, _ [policy_effect] e = some(where (p.eft == allow)) [matchers] m = g(r.sub, p.sub) \u0026\u0026 r.obj == p.obj \u0026\u0026 r.act == p.act ` m, _ := model.NewModelFromString(text) ","date":"2023-01-01","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/casbin/:3:1","tags":["go第三方库"],"title":"go第三方库-Casbin","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/casbin/"},{"categories":["Golang"],"content":"Policy的存储 从 CSV 文件载入策略 p, alice, data1, read\rp, bob, data2, write\rp, data2_admin, data2, read 适配器 API 见官网 LoadPolicy() SavePolicy() AddPolicy() RemovePolicy() RemoveFilteredPolicy() 数据库存储格式 id ptype v0 v1 v2 v3 v4 v5 见官网 ","date":"2023-01-01","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/casbin/:3:2","tags":["go第三方库"],"title":"go第三方库-Casbin","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/casbin/"},{"categories":["云原生"],"content":"k8s官网 k8s官网文档 k8s官网教程 k8s easydoc github yeasy/docker_practice及其最新版本电子书 ","date":"2022-12-31","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/%E6%95%99%E7%A8%8B/:0:0","tags":["k8s"],"title":"云原生-k8s-教程","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/%E6%95%99%E7%A8%8B/"},{"categories":["云原生"],"content":"注意事项 minikube使用kubctl时要在kubctl前面添加minikube，所以可以在.bashrc里面添加 1 alias kubectl=\"minikube kubectl --\" 另外需要在.bashrc里面添加no_proxy环境变量，具体设置见官网 curl和谷歌浏览器并不会识别.bashrc里面的环境变量，所以你需要在curl后面添加--noproxy \"*\"来访问k8s的服务service ","date":"2022-12-31","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/%E6%95%99%E7%A8%8B/:1:0","tags":["k8s"],"title":"云原生-k8s-教程","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/%E6%95%99%E7%A8%8B/"},{"categories":["云原生"],"content":"概念 ","date":"2022-12-31","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/%E6%95%99%E7%A8%8B/:2:0","tags":["k8s"],"title":"云原生-k8s-教程","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/%E6%95%99%E7%A8%8B/"},{"categories":["云原生"],"content":"概述 Kubernetes 组件 Kubernetes 组件 ","date":"2022-12-31","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/%E6%95%99%E7%A8%8B/:2:1","tags":["k8s"],"title":"云原生-k8s-教程","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/%E6%95%99%E7%A8%8B/"},{"categories":["云原生"],"content":"教程 ","date":"2022-12-31","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/%E6%95%99%E7%A8%8B/:3:0","tags":["k8s"],"title":"云原生-k8s-教程","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/%E6%95%99%E7%A8%8B/"},{"categories":["云原生"],"content":"你好，Minikube 安装好minikube后使用该命令启动minikube服务 1 minikube start 创建 Minikube 集群 使用 URL 打开仪表板 1 minikube dashboard --url node-pod-container 创建管理 Pod 的 Deployment（在控制平面的结构，和Pod对应） 1 kubectl create deployment hello-node --image=registry.k8s.io/e2e-test-images/agnhost:2.39 -- /agnhost netexec --http-port=8080 查看 Deployment 1 kubectl get deployments 查看 Pod 1 kubectl get pods 查看集群事件 1 kubectl get events 查看 kubectl 配置 1 kubectl config view 创建 Service 将 Pod 暴露为 Kubernetes Service，使得外部网络可以访问里面的容器 kubectl expose 命令将 Pod 暴露给公网 1 kubectl expose deployment hello-node --type=LoadBalancer --port=8080 查看创建的 Service 1 kubectl get services 支持负载均衡器的云服务平台将提供一个外部 IP 来访问该服务。 在 Minikube 上，LoadBalancer 使得服务可以通过命令 minikube service 访问。 访问服务 1 minikube service hello-node 启用插件 列出当前支持的插件 1 minikube addons list 启用插件 1 minikube addons enable metrics-server 查看创建的 Pod 和 Service 1 kubectl get pod,svc -n kube-system 禁用 metrics-server 1 minikube addons disable metrics-server 清理 1 2 3 4 5 6 kubectl delete service hello-node kubectl delete deployment hello-node minikube stop minikube delete ","date":"2022-12-31","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/%E6%95%99%E7%A8%8B/:3:1","tags":["k8s"],"title":"云原生-k8s-教程","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/%E6%95%99%E7%A8%8B/"},{"categories":["云原生"],"content":"Kubernetes 基础 创建集群 Kubernetes 协调一个高可用计算机集群，每个计算机作为独立单元互相连接工作 Kubernetes 以更高效的方式跨集群自动分发和调度应用容器 集群图 Master 负责管理整个集群 Node 是一个虚拟机或者物理机，它在 Kubernetes 集群中充当工作机器的角色。Node 使用 Master 暴露的 Kubernetes API 与 Master 通信。 使用 kubectl 创建 Deployment Deployment 指挥 Kubernetes 如何创建和更新应用程序的实例。创建 Deployment 后，Kubernetes master 将应用程序实例调度到集群中的各个节点上。 Kubernetes Deployment 控制器会持续监视这些实例。 如果托管实例的节点关闭或被删除，则 Deployment 控制器会将该实例替换为集群中另一个节点上的实例。 这提供了一种自我修复机制来解决机器故障维护问题。 查看 pod 和工作节点 Pod 是 Kubernetes 抽象出来的，表示一组一个或多个应用程序容器（如 Docker），以及这些容器的一些共享资源。这些资源包括: 共享存储，当作卷 网络，作为唯一的集群 IP 地址 有关每个容器如何运行的信息，例如容器镜像版本或要使用的特定端口 Pod是 Kubernetes 平台上的原子单元。当我们在 Kubernetes 上创建 Deployment 时，该 Deployment 会在其中创建包含容器的 Pod （而不是直接创建容器）。每个 Pod 都与调度它的工作节点绑定，并保持在那里直到终止（根据重启策略）或删除。 如果工作节点发生故障，则会在集群中的其他可用工作节点上调度相同的 Pod。 一个 pod 总是运行在 工作节点。工作节点是 Kubernetes 中的参与计算的机器，可以是虚拟机或物理计算机，具体取决于集群。每个工作节点由主节点管理。工作节点可以有多个 pod ，Kubernetes 主节点会自动处理在集群中的工作节点上调度 pod 。 主节点的自动调度考量了每个工作节点上的可用资源。 每个 Kubernetes 工作节点至少运行: Kubelet，负责 Kubernetes 主节点和工作节点之间通信的过程; 它管理 Pod 和机器上运行的容器。 容器运行时（如 Docker）负责从仓库中提取容器镜像，解压缩容器以及运行应用程序。 使用 kubectl 进行故障排除 kubectl get - 列出资源 kubectl describe - 显示有关资源的详细信息 kubectl logs - 打印 pod 和其中容器的日志 kubectl exec - 在 pod 中的容器上执行命令 公开地暴露你的应用 Pod 实际上拥有 生命周期。 当一个工作 Node 挂掉后, 在 Node 上运行的 Pod 也会消亡。 ReplicaSet 会自动地通过创建新的 Pod 驱动集群回到目标状态，以保证应用程序正常运行。 Kubernetes 中的服务(Service)是一种抽象概念，它定义了 Pod 的逻辑集和访问 Pod 的协议。 尽管每个 Pod 都有一个唯一的 IP 地址，但是如果没有 Service ，这些 IP 不会暴露在集群外部。 Service 也可以用在 ServiceSpec 标记type的方式暴露： ClusterIP (默认) - 在集群的内部 IP 上公开 Service 。这种类型使得 Service 只能从集群内访问。 NodePort - 使用 NAT 在集群中每个选定 Node 的相同端口上公开 Service 。使用\u003cNodeIP\u003e:\u003cNodePort\u003e 从集群外部访问 Service。是 ClusterIP 的超集。 LoadBalancer - 在当前云中创建一个外部负载均衡器(如果支持的话)，并为 Service 分配一个固定的外部IP。是 NodePort 的超集。（常用） ExternalName - 通过返回带有该名称的 CNAME 记录，使用任意名称(由 spec 中的externalName指定)公开 Service。不使用代理。这种类型需要kube-dns的v1.7或更高版本。 Service 通过一组 Pod 路由通信。Service 是一种抽象，它允许 Pod 死亡并在 Kubernetes 中复制，而不会影响应用程序。在依赖的 Pod (如应用程序中的前端和后端组件)之间进行发现和路由是由Kubernetes Service 处理的。 Service 匹配一组 Pod 是使用 标签(Label)和选择器(Selector), 它们是允许对 Kubernetes 中的对象进行逻辑操作的一种分组原语。标签(Label)是附加在对象上的键/值对，可以以多种方式使用: 指定用于开发，测试和生产的对象 嵌入版本标签 使用 Label 将对象进行分类 标签(Label)可以在创建时或之后附加到对象上。他们可以随时被修改。 缩放你的应用 扩展 Deployment 将创建新的 Pods，并将资源调度请求分配到有可用资源的节点上，收缩 会将 Pods 数量减少至所需的状态。 执行滚动更新 滚动更新 允许通过使用新的实例逐步更新 Pod 实例，零停机进行 Deployment 更新。 默认情况下，更新期间不可用的 pod 的最大值和可以创建的新 pod 数都是 1。这两个选项都可以配置为（pod）数字或百分比。 ","date":"2022-12-31","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/%E6%95%99%E7%A8%8B/:3:2","tags":["k8s"],"title":"云原生-k8s-教程","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/%E6%95%99%E7%A8%8B/"},{"categories":["云原生"],"content":"配置 使用 ConfigMap 来配置 Redis 官网详细文档 真实世界的案例：使用 ConfigMap 来配置 Redis 首先创建一个配置模块为空的 ConfigMap，一个yaml文件： example-redis-config.yaml 1 2 3 4 5 6 apiVersion: v1 kind: ConfigMap metadata: name: example-redis-config data: redis-config: \"\" 应用上面创建的 ConfigMap 以及 Redis pod 清单： 1 2 3 4 #应用ConfigMap kubectl apply -f example-redis-config.yaml #使用Redis pod清单创建Redis pod kubectl apply -f https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/pods/config/redis-pod.yaml redis pod清单 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 apiVersion: v1 kind: Pod metadata: name: redis spec: containers: - name: redis image: redis:5.0.4 command: - redis-server - \"/redis-master/redis.conf\" env: - name: MASTER value: \"true\" ports: - containerPort: 6379 resources: limits: cpu: \"0.1\" volumeMounts: - mountPath: /redis-master-data name: data - mountPath: /redis-master name: config volumes: - name: data emptyDir: {} - name: config configMap: name: example-redis-config items: - key: redis-config path: redis.conf spec.volumes[1] 创建一个名为 config 的卷 spec.volumes[1].items[0] 下的 key 和 path 会将来自 example-redis-config ConfigMap 中的 redis-config 密钥公开在 config 卷上一个名为 redis.conf 的文件中 config 卷被 spec.containers[0].volumeMounts[1] 挂载在 /redis-master 这样做的最终效果是将上面 example-redis-config 配置中 data.redis-config 的数据作为 Pod 中的 /redis-master/redis.conf 公开 检查创建的对象 1 kubectl get pod/redis configmap/example-redis-config 查看ConfigMap详细信息 1 kubectl describe configmap/example-redis-config 博客园 浅尝辄止~ yaml文件中的特殊符号|和\u003e 使用 kubectl exec 进入 pod，运行 redis-cli 工具检查当前配置 1 kubectl exec -it redis -- redis-cli 查看 maxmemory 127.0.0.1:6379\u003e CONFIG GET maxmemory 查看 maxmemory-policy 127.0.0.1:6379\u003e CONFIG GET maxmemory-policy 向 example-redis-config ConfigMap 添加一些配置： 1 2 3 4 5 6 7 8 apiVersion: v1 kind: ConfigMap metadata: name: example-redis-config data: redis-config: | maxmemory 2mb maxmemory-policy allkeys-lru 应用更新的 ConfigMap 1 kubectl apply -f example-redis-config.yaml 确认 ConfigMap 已更新 1 kubectl describe configmap/example-redis-config 重新建立pod 1 2 kubectl delete pod redis kubectl apply -f https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/pods/config/redis-pod.yaml 之后再检查redis配置就成功了 ","date":"2022-12-31","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/%E6%95%99%E7%A8%8B/:3:3","tags":["k8s"],"title":"云原生-k8s-教程","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/%E6%95%99%E7%A8%8B/"},{"categories":["云原生"],"content":"安全 在集群级别应用 Pod 安全标准 需要安装有KinD和kubectl 创建一个没有应用 Pod 安全标准的集群 1 kind create cluster --name psa-wo-cluster-pss --image kindest/node:v1.24.0 详见官网 ","date":"2022-12-31","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/%E6%95%99%E7%A8%8B/:3:4","tags":["k8s"],"title":"云原生-k8s-教程","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/%E6%95%99%E7%A8%8B/"},{"categories":["云原生"],"content":"无状态应用程序 公开外部 IP 地址以访问集群中应用程序 为一个在五个 pod 中运行的应用程序创建服务 在集群中运行 Hello World 应用程序 1 kubectl apply -f https://k8s.io/examples/service/load-balancer-example.yaml 显示有关 Deployment 的信息 1 2 kubectl get deployments hello-world kubectl describe deployments hello-world 显示有关 ReplicaSet 对象的信息 1 2 kubectl get replicasets kubectl describe replicasets 创建公开 Deployment 的 Service 对象 1 kubectl expose deployment hello-world --type=LoadBalancer --name=my-service 显示有关 Service 的信息 1 kubectl get services my-service 显示有关 Service 的详细信息 1 kubectl describe services my-service 显示的endpoints是pod内部地址。要验证这些是 Pod 地址，请输入以下命令： 1 kubectl get pods --output=wide 使用外部 IP 地址（LoadBalancer Ingress）访问 Hello World 应用程序 1 curl --noproxy \"*\" http://\u003cexternal-ip\u003e:\u003cport\u003e 清理现场 删除 Service 1 kubectl delete services my-service 删除正在运行 Hello World 应用程序的 Deployment、ReplicaSet 和 Pod 1 kubectl delete deployment hello-world ","date":"2022-12-31","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/%E6%95%99%E7%A8%8B/:3:5","tags":["k8s"],"title":"云原生-k8s-教程","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/%E6%95%99%E7%A8%8B/"},{"categories":["云原生"],"content":"有状态的应用 StatefulSet 基础 Service 与 Pod 的 DNS Service 与 Pod 的 DNS Kubernetes 为 Service 和 Pod 创建 DNS 记录。 可以使用一致的 DNS 名称而非 IP 地址访问 Service。 无头服务（Headless Services） 无头服务（Headless Services） 不需要或不想要负载均衡，以及单独的 Service IP。指定 Cluster IP（spec.clusterIP）的值为 “None” 来创建 Headless Service。 持久卷 持久卷 持久卷（PersistentVolume，PV） 是集群中的一块存储，可以由管理员事先制备， 或者使用存储类（Storage Class）来动态制备。 持久卷是集群资源，就像节点也是集群资源一样。 持久卷申领（PersistentVolumeClaim，PVC） 表达的是用户对存储的请求。概念上与 Pod 类似。 Pod 会耗用节点资源，而 PVC 申领会耗用 PV 资源。PVC 申领可以请求特定的大小和访问模式 （例如，可以要求 PV 卷能够以 ReadWriteOnce、ReadOnlyMany 或 ReadWriteMany 模式之一来挂载） StatefulSet StatefulSet StatefulSet 是用来管理有状态应用的工作负载 API 对象。 StatefulSet 用来管理某 Pod 集合的部署和扩缩， 并为这些 Pod 提供持久存储和持久标识符。 和 Deployment 类似， StatefulSet 管理基于相同容器规约的一组 Pod。和 Deployment 不同的是， StatefulSet 为它们的每个 Pod 维护了一个有粘性的 ID，这些 Pod 是基于相同的规约来创建的， 但是不能相互替换：无论怎么调度，每个 Pod 都有一个永久不变的 ID。 如果希望使用存储卷为工作负载提供持久存储，可以使用 StatefulSet 作为解决方案的一部分。 创建 StatefulSet。 web.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 apiVersion: v1 kind: Service metadata: name: nginx labels: app: nginx spec: ports: - port: 80 name: web clusterIP: None selector: app: nginx --- apiVersion: apps/v1 kind: StatefulSet metadata: name: web spec: serviceName: \"nginx\" replicas: 2 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: registry.k8s.io/nginx-slim:0.8 ports: - containerPort: 80 name: web volumeMounts: - name: www mountPath: /usr/share/nginx/html volumeClaimTemplates: - metadata: name: www spec: accessModes: [ \"ReadWriteOnce\" ] resources: requests: storage: 1Gi 监视StatefulSet 的 Pod 的创建情况 1 kubectl get pods -w -l app=nginx 在另一个终端中，使用 kubectl apply 来创建定义在 web.yaml 中的 Headless Service 和 StatefulSe 1 kubectl apply -f web.yaml 获取 nginx Service 1 kubectl get service nginx 获取 web StatefulSet 1 kubectl get statefulset web 顺序创建 Pod 对于一个拥有 n 个副本的 StatefulSet，Pod 被部署时是按照 {0..n-1} 的序号顺序创建的 StatefulSet 中的 Pod StatefulSet 中的每个 Pod 拥有一个唯一的顺序索引和稳定的网络身份标识 获取 StatefulSet 的 Pod 1 kubectl get pods -l app=nginx 这个标志基于 StatefulSet 控制器分配给每个 Pod 的唯一顺序索引，Pod 名称的格式为 \u003cstatefulset 名称\u003e-\u003c序号索引\u003e。 使用稳定的网络身份标识 每个 Pod 都拥有一个基于其顺序索引的稳定的主机名，显示主机名 1 for i in 0 1; do kubectl exec \"web-$i\" -- sh -c 'hostname'; done 通过对 Pod 的主机名执行 nslookup，你可以检查这些主机名在集群内部的 DNS 地址 1 kubectl run -i --tty --image busybox:1.28 dns-test --restart=Never --rm 这将启动一个新的 Shell。在新 Shell 中运行 1 2 # 在 dns-test 容器 Shell 中运行以下命令 nslookup web-0.nginx 退出容器 Shell:exit 在一个终端中监视 StatefulSet 的 Pod 1 kubectl get pod -w -l app=nginx 在另一个终端中使用 kubectl delete 删除 StatefulSet 中所有的 Pod 1 kubectl delete pod -l app=nginx StatefulSet 将重启它们。Pod 的序号、主机名、SRV 条目和记录名称没有改变，但和 Pod 相关联的 IP 地址可能发生改变 写入稳定的存储 获取 web-0 和 web-1 的 PersistentVolumeClaims 1 kubectl get pvc -l app=nginx StatefulSet 控制器创建了两个 PersistentVolumeClaims， 绑定到两个 PersistentVolumes。这里是动态制备 PersistentVolume 卷，所有的 PersistentVolume 卷都是自动创建和绑定的。 NginX Web 服务器默认会加载位于 /usr/share/nginx/html/index.html 的 index 文件。 StatefulSet spec 中的 volumeMounts 字段保证了 /usr/share/nginx/html 文件夹由一个 PersistentVolume 卷支持。 Pod 的主机名写入它们的 index.html 文件并验证 NginX Web 服务器使用该主机名提供服务。 1 2 3 for i in 0 1; do kubectl exec \"web-$i\" -- sh -c 'echo \"$(hostname)\" \u003e /usr/share/nginx/html/index.html'; done for i in 0 1; do kubectl exec -i -t \"web-$i\" -- curl http://localhost/; **done** 在一个终端监视 StatefulSet 的 Pod 1 kubectl get pod -w -l app=nginx 在另一个终端删除 StatefulSet 所有的 Pod 1 kubectl delete pod -l app=nginx 等待所有 Pod 变成 Running 和 Ready 状态 验证所有 Web 服务器在继续使用它们的主机名提供服务 1 for i in 0 1; do kubectl exec -i -t \"web-$i\" -- curl http://localhost/; done 返回结果和之前配置的一样，说明虽然 web-0 和 web-1 被重新调度了，但它们仍然继续监听各自的主机名，因为和它们的 PersistentVolumeClaim 相关联的 PersistentVolume 卷被重新挂载到了各自的 volumeMount 上。 扩容/缩容 StatefulSet kubectl scale 或者 kubectl patch 来扩容/缩容一个 StatefulSet 扩容 在一个终端窗口监视 StatefulSet 的 Pod 1 kubectl get pods -w -l app=nginx 在另一个终端窗口使用 kubectl scale 扩展副本数为 5 1 kubectl scale sts web --replicas=5 缩容 在另一个终端使用 kubectl patch 将 StatefulSet 缩容回三个副本 1 kubectl patch sts web -p '{\"spec\"","date":"2022-12-31","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/%E6%95%99%E7%A8%8B/:3:6","tags":["k8s"],"title":"云原生-k8s-教程","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/%E6%95%99%E7%A8%8B/"},{"categories":["云原生"],"content":"Services 使用源 IP 运行在 Kubernetes 集群中的应用程序通过 Service 抽象发现彼此并相互通信，它们也用 Service 与外部世界通信。本文解释了发送到不同类型 Service 的数据包的源 IP 会发生什么情况，以及如何根据需要切换此行为。 术语表 NAT：网络地址转换 Source NAT：替换数据包上的源 IP；在本页面中，这通常意味着替换为节点的 IP 地址 Destination NAT：替换数据包上的目标 IP；在本页面中，这通常意味着替换为 Pod 的 IP 地址 VIP：一个虚拟 IP 地址，例如分配给 Kubernetes 中每个 Service 的 IP 地址 Kube-proxy：一个网络守护程序，在每个节点上协调 Service VIP 管理 示例使用一个小型 nginx Web 服务器，服务器通过 HTTP 标头返回它接收到的请求的源 IP。 1 kubectl create deployment source-ip-app --image=registry.k8s.io/echoserver:1.4 Type=ClusterIP 类型 Service 的源 IP 在 iptables 模式（默认）下运行 kube-proxy，则从集群内发送到 ClusterIP 的数据包永远不会进行源 NAT。 可以通过在运行 kube-proxy 的节点上获取 http://localhost:10249/proxyMode 来查询 kube-proxy 模式。 查看节点ip 1 kubectl get nodes -o=wide 查看节点代理模式 1 curl http://$节点ip:10249/proxyMode 输出为：iptables 在源 IP 应用程序上创建 Service 来测试源 IP 保留 1 kubectl expose deployment source-ip-app --name=clusterip --port=80 --target-port=8080 查看服务 1 kubectl get svc clusterip 从同一集群中的 Pod 中访问 ClusterIP： 1 kubectl run busybox -it --image=busybox:1.28 --restart=Never --rm 打开一个控制台，在该 Pod 中运行命令： 1 2 # 从 “kubectl run” 的终端中运行 ip addr 使用 wget 查询本地 Web 服务器 # 将 “10.0.170.92” 替换为 Service 中名为 “clusterip” 的 IPv4 地址\rwget -qO - 10.0.170.92 不管客户端 Pod 和服务器 Pod 位于同一节点还是不同节点，client_address 始终是客户端 Pod 的 IP 地址 Type=NodePort 类型 Service 的源 IP 默认情况下，发送到 Type=NodePort 的 Service 的数据包会经过源 NAT 处理。 创建一个 NodePort 的 Service 来测试这点 1 kubectl expose deployment source-ip-app --name=nodeport --port=80 --target-port=8080 --type=NodePort 设置环境变量 1 2 NODEPORT=$(kubectl get -o jsonpath=\"{.spec.ports[0].nodePort}\" services nodeport) NODES=$(kubectl get nodes -o jsonpath='{ $.items[*].status.addresses[?(@.type==\"InternalIP\")].address }') 从集群外部访问 Service 1 for node in $NODES; do curl -s $node:$NODEPORT | grep -i client_address; done 这些并不是正确的客户端 IP，它们是集群的内部 IP。 客户端发送数据包到 node2:nodePort node2 使用它自己的 IP 地址替换数据包的源 IP 地址（SNAT） node2 将数据包上的目标 IP 替换为 Pod IP 数据包被路由到 node1，然后到端点 Pod 的回复被路由回 node2 Pod 的回复被发送回给客户端 为避免这种情况，Kubernetes 有一个特性可以保留客户端源 IP。 如果将 service.spec.externalTrafficPolicy 设置为 Local， kube-proxy 只会将代理请求代理到本地端点，而不会将流量转发到其他节点。 这种方法保留了原始源 IP 地址。如果没有本地端点，则发送到该节点的数据包将被丢弃， 因此你可以在任何数据包处理规则中依赖正确的源 IP，你可能会应用一个数据包使其通过该端点。 设置 service.spec.externalTrafficPolicy 字段如下 1 kubectl patch svc nodeport -p '{\"spec\":{\"externalTrafficPolicy\":\"Local\"}}' 现在，重新运行测试 1 for node in $NODES; do curl --connect-timeout 1 -s $node:$NODEPORT | grep -i client_address; done 只从运行端点 Pod 的节点得到了回复，这个回复有正确的客户端 IP 客户端将数据包发送到没有任何端点的 node2:nodePort 数据包被丢弃 客户端发送数据包到必有端点的 node1:nodePort node1 使用正确的源 IP 地址将数据包路由到端点 Type=LoadBalancer 类型 Service 的源 IP 默认情况下，发送到 Type=LoadBalancer 的 Service 的数据包经过源 NAT处理，因为所有处于 Ready 状态的可调度 Kubernetes 节点对于负载均衡的流量都是符合条件的。 因此，如果数据包到达一个没有端点的节点，系统会将其代理到一个带有端点的节点，用该节点的 IP 替换数据包上的源 IP 你可以通过负载均衡器上暴露 source-ip-app 进行测试 1 kubectl expose deployment source-ip-app --name=loadbalancer --port=80 --target-port=8080 --type=LoadBalancer 打印 Service 的 IP 地址 1 kubectl get svc loadbalancer 接下来，发送请求到 Service 的 的外部 IP 1 curl --noproxy \"*\" serviceip minikube 会使得 LoadBalancer 则会出现 External-IP 一直处于 pending 官方给出的解决办法是添加tunnel，百度 青柠姑娘17，详见官网 这里也需要注意curl不使用代理–noproxy “*” 将相同的 service.spec.externalTrafficPolicy 字段设置为 Local， 故意导致健康检查失败，从而强制没有端点的节点把自己从负载均衡流量的可选节点列表中删除。 清理现场 删除 Service： 1 kubectl delete svc -l app=source-ip-app 删除 Deployment、ReplicaSet 和 Pod： 1 kubectl delete deployment source-ip-app 使用 Service 连接到应用 Kubernetes 连接容器的模型 Kubernetes 假设 Pod 可与其它 Pod 通信，不管它们在哪个主机上。 Kubernetes 给每一个 Pod 分配一个集群私有 IP 地址，所以没必要在 Pod 与 Pod 之间创建连接或将容器的端口映射到主机端口。 这意味着同一个 Pod 内的所有容器能通过 localhost 上的端口互相连通，集群中的所有 Pod 也不需要通过 NAT 转换就能够互相看到。 在集群中暴露 Pod run-my-nginx.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 apiVersion: apps/v1 kind: Deployment metadata: name: my-nginx spec: selector: matchLabels: run: my-nginx replicas: 2 template: metadata: labels: run: my-nginx spec: containers: - name: my-nginx image: nginx ports: - containerPort: 80 容器端口的规约containerPort: 80使得可以从集群中任何一个节点来访问它。检查节点，该 Pod 正在运行： 1 2 kubectl apply -f ./run-my-nginx.yaml kubectl get pods -l run=my-nginx -o wide 检查 Pod 的 IP 地址： 1 kubectl ge","date":"2022-12-31","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/%E6%95%99%E7%A8%8B/:3:7","tags":["k8s"],"title":"云原生-k8s-教程","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/k8s/%E6%95%99%E7%A8%8B/"},{"categories":["数据结构与算法"],"content":"本系列笔记为作者在跟随labuladong的算法小抄学习的时候结合golang做的笔记。感谢东哥。另外根据东哥对算法的分类法，将自己平时记的笔记也写到这里面。 第三章：必知必会算法技巧 使用golang做题与使用其他语言做题有一些不同，golang原生的语法中的slice和map支持很多数据结构的简单构造如队列或栈，但是golang并没有提供C++ STL、Java Collection这样丰富的数据结构库，go标准库的container库仅提供了list，ring和heap（优先队列，必须掌握）。这三个库可以实现所有的数据结构但是过于复杂的数据结构实现过程会花很多时间。对于复杂的数据结构可以使用第三方库GODS来提高做题效率，比如红黑树。 解题函数通常分为两部分：数据初始化函数部分和solution函数部分，这两部分也可以内联到解题函数中 递归方法有两种减少空间复杂度的办法，使用全局变量或者在solution函数中定义递归函数。 OI Wiki官网 OI Wiki动态规划 ","date":"2022-12-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第三章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"其他算法 ","date":"2022-12-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/:1:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第三章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"雪花算法和uuid CSDN YmaxU UUID 形式为8-4-4-4-12的32个16位字符 本地生成，没有网络消耗，入数据库的性能较差 雪花算法 Twitter提出 雪花算法为什么不用自增id 博客园 ZeroGirl 数据库自增id在数据库分库分表后，在数据流较大时容易冲突，UUid将机器id也加入进去就不存在这个问题了。 主键应越短越好，无序会造成每一次UUID数据的插入都会对主键地城的b+树进行很大的修改。 ","date":"2022-12-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/:1:1","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第三章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"工具函数 ","date":"2022-12-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/:2:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第三章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"Max，Min工具函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func Max(s ...int)int{ tmp:=math.MinInt for _,v:=range s{ if tmp\u003cv{tmp=v} } return tmp } func Min(s ...int)int{ tmp:=math.MaxInt for _,v:=range s{ if tmp\u003ev{tmp=v} } return tmp } ","date":"2022-12-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/:2:1","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第三章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"Gcd工具函数 辗转相除法求两数的最小公因数 1 2 3 4 5 6 func Gcd(a,b int)int{ for a!=0{ a,b=b%a,a } return b } ","date":"2022-12-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/:2:2","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第三章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"AbsInt工具函数 防止覆盖math.Abs(float)函数 1 2 3 4 func AbsInt(i int)int{ if i\u003c0{i=-i} return i } ","date":"2022-12-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/:2:3","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第三章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"工具变量 ","date":"2022-12-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/:3:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第三章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"方向向量 1 2 3 4 5 6 var dir=[][]int{ {1,0}, {0,1}, {-1,0}, {0,-1}, } ","date":"2022-12-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/:3:1","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第三章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"省略自己定义全局变量 直接在solution函数里面通过定义匿名函数来使用函数内的局部变量，从而避免自己再一次定义全局变量。 1 2 3 4 5 6 func solution(){ fn:=func (){ ... } ... } 如果要定义递归函数 1 2 3 4 5 6 7 8 9 func solution(){ var fn func() fn=func (){ ... fn() ... } ... } ","date":"2022-12-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/:4:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第三章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"二维遍历复用逻辑代码 如果我们在遍历多维数组时不使用方向向量，那么对于每一个方向我们都需要写出单独的逻辑来进行处理，这样可能会出现代码冗余，我们可以使用方向向量加上循环逻辑来避免冗余，实现代码复用，在循环逻辑里面通过循环变量来添加不同方向上单独的逻辑。 1 2 3 4 5 6 7 8 9 10 //方向向量 dirs:=[][]int{{0,1},{1,0},{0,-1},{-1,0}} //循环逻辑 for i,v:=range dirs{ ... if i==n{ ... } } 当每一个方向都是单独的逻辑的时候可以不使用这种方法。这种方法主要是为了复用相同的逻辑。 ","date":"2022-12-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/:5:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第三章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"减少逻辑复杂度 当逻辑比较复杂时，可能是因为你考虑的逻辑粒度太细了，有的情况不会出现，那么我们就把逻辑粒度变大一点，不会出现的情况不要去管。 比如你寻找链表中点时，如果逻辑粒度太细，慢指针走一步后到了nil怎么办，快指针走一步后到了nil怎么办，快指针走两步后到了nil怎么办。这样就太复杂了。在这个场景下，只会出现慢指针走一步快指针走两步的情况，如果不满足则直接跳出循环即可。这样你的逻辑就只需要考虑这一种情况 1 2 3 4 for slow.Next!=nil\u0026\u0026fast.Next!=nil\u0026\u0026fast.Next.Next!=nil{ slow=slow.Next fast=fast.Next.Next } ","date":"2022-12-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/:6:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第三章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"尽量使用range写法 go range语法能减少很多代码，并实现和C++ for 三段式一样的效果。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 for i:=0;i\u003clen(xxx);i++{ xxx[i]... ... } //很明显，当xxx比较长的时候range写法更简介，也更容易理解 for i,v:=range xxx{ v... ... } //可以自定义起始点 for i,v:=range xxx[k:]{ v... ... } for 三段式主要用于从后面往前遍历的过程，range语法只能进行顺序遍历。 ","date":"2022-12-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/:7:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第三章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"对不存在的key查询 当map的key不存在的时候，它的返回值为这个类型的默认返回值。 由此可以引申出，对于查询kv对后在原来的基础上进行修改的map，可以不判断是否存在直接赋值 比如统计一串数字中每种数字的个数 1 2 3 m:=map[int]int for _,v := range nums{m[v]++} ","date":"2022-12-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/:8:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第三章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"数组可以进行等号运算 数组元素可以进行相等比较时，数组也可以进行相等比较，且比较时间复杂度为O（1） map不能直接比较相等，可以使用reflect.DeepEqual函数进行逐个元素比较，但时间复杂度为O(n) 所以对于一些计数问题，使用数组可以直接判断是否相等，比如leetcode 567. 字符串的排列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func checkInclusion(s1 string, s2 string) bool { a1,a2:=[256]int{},[256]int{} l1,l2:=len(s1),len(s2) for _,v:=range s1{a1[v]++} for i:=0;i\u003cl1\u0026\u0026i\u003cl2;i++{a2[s2[i]]++} for i:=l1;i\u003cl2;i++{ if a1==a2{return true} a2[s2[i]]++ a2[s2[i-l1]]-- } if a1==a2{return true} return false } 特别注意定义以数组为键的map时使用[xxx]int，xxx必须为确定值，不能为[...]int（定义数组时可以使用） 1 a := map[[26]int]int{} ","date":"2022-12-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/:9:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第三章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"ACM模式读取字符串输入 非常重要 使用bufio的Reader对象r来读取os.Stdin，通过ReadString(’\\n’)方法获取一行字符串 使用fmt包的Fscan系列函数读取r（因为r也实现了io.Reader接口）来扫描值:fmt.Fscanf(r,\"%d\\n\",\u0026a)。推荐仅使用Fscanf函数 上面的方法都可以通过err是否为EOF来判断是否读完输入 fmt包Scan打头的函数都不要用，因为和r一起使用后它的读写指针指向的是哪一个字节是不确定的 ","date":"2022-12-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/:10:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第三章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"添加虚拟头节点或者虚拟行列统一解题逻辑 对于一维的问题，因为有很多复杂的边界，为了统一解题逻辑，可以添加虚拟头节点，这样就可以忽略头部边界条件，统一解题逻辑，只考虑尾部的边界条件 对于二维的问题，可以在头部添加虚拟行和虚拟列 往后数n个节点可以这样，先将fast和slow都设置为dummy，然后将fast往后走n次即可 ","date":"2022-12-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/:11:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第三章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"前缀和+哈希表解决子数组问题 CSDN 暗夜猎手-大魔王 主要用于解决连续子数组问题 前缀和快速计算子数组的和 通过哈希表优化查询前缀和时间复杂度为O(1) leetcode 面试题 17.05. 字母与数字 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 func findLongestSubarray(array []string) []string { l:=len(array) presum:=make([]int,l+1) sum:=0 for i,v:=range array{ if unicode.IsDigit(rune(v[0])){ sum++ }else{sum--} presum[i+1]=sum } //fmt.Println(presum) ans:=math.MinInt var ansi,ansj int m:=make(map[int]int) for j,v:=range presum{ if i,has:=m[v];has{ if ans\u003cj-i{ ans=j-i ansi=i ansj=j } }else{m[v]=j} } //fmt.Println(ans,ansi,ansj) if ans==math.MinInt{return nil} return array[ansi:ansj] } ","date":"2022-12-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/:12:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第三章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"序列中只有一个数字出现k次 除了一个数字出现k次外，其他数字出现m次，m不可整除k 位运算，记录每个位出现1的次数，当次数除以m不能除尽时，对于目标数字在该位上为1 ","date":"2022-12-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/:13:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第三章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"二进制枚举子集 使用一个整数的二进制来表示问题的状态，每一位是否为1表示元素是否在当前状态。 这样可以直接通过将整数加1来枚举所有问题状态 1 2 3 for mask=1;mask\u003c1\u003c\u003cn;mask++{ ... } bilibili 灵茶山艾府 集合和二进制是一一对应的 ","date":"2022-12-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/:14:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第三章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"要求空间复杂度为O(1)的数组题 通常这种题需要将数组索引到元素进行一个hash映射，比如41. 缺失的第一个正数，就是实现一个索引到元素的hash函数hash(i)=i+1 ","date":"2022-12-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/:15:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第三章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"枚举子字符串 通常字串由两个端点确定，可以确定左端点位置枚举右端点或者确定右端点位置枚举左端点 ","date":"2022-12-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/:16:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第三章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"查询热门的字符串 查询热门的字符串 字典法，trie树法 ","date":"2022-12-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/:17:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第三章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"复制一倍，断环成链 1 2 3 4 l:=len(ring) nums:=make([]int,l+l) copy(nums,ring) copy(nums[l:],ring) ","date":"2022-12-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/:18:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第三章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"随机算法 ","date":"2022-12-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/:19:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第三章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"洗牌算法 随机打乱一个数组 1 2 3 4 l:=len(s) for i:=0;i\u003cl;i++{ s.Swap(i,i+rand.Intn(l-i)) } ","date":"2022-12-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/:19:1","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第三章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"蓄水池抽样算法 抽样 1 2 3 4 5 6 7 8 9 10 l:=len(s) ans:=make([]int,k) for i:=0;i\u003ck\u0026\u0026i\u003cl;i++{ ans[i]=s[i] } for i:=k;i\u003cl;i++{ r:=rand.Intn(i) if r\u003ck{s.Swap(i,r)} } 简书 邱simple leetcode 你的发香散得匆忙 给定一个数据流，数据流长度N很大，且N直到处理完所有数据之前都不可知，请问如何在只遍历一遍数据（O(N)）的情况下，能够随机选取出m个不重复的数据。 将第1到第m个数据加入ans数组中。 从第m+1个数据开始，对每一个数据x随机获取一个1到m+1的数k，当k属于[1,m]时，使用x换出ans[k] ans数组为最后结果 任何一个数据被选择的概率时m/N ","date":"2022-12-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/:19:2","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第三章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"高效寻找素数 素数筛 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 var primes []bool func countPrimes(n){ primes=make([]bool,n+1) count:=0 for i:=2;i\u003c=n;i++{primes[i]=true} for i:=2;i\u003c=n;i++{ if primes[i]!=true{continue} count++ tmp:=i for tmp\u003c=n{ primes[tmp]=false tmp+=i } } return count } ","date":"2022-12-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/:20:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第三章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"高效进行模幂运算 ","date":"2022-12-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/:21:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第三章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"如何处理 mod 运算 (a * b) % k = (a % k)(b % k) % k ","date":"2022-12-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/:21:1","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第三章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"如何高效求幂 快速幂 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var base int func mypow(a,k int)int{ if k==0 {return 1} if k==1 {return a} a %= base if k\u00261==1{ tmp:=mypow(a,k-1)%base return tmp*a }else{ tmp:=mypow(a,k/2)%base return tmp*tmp } } ","date":"2022-12-30","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/:21:2","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第三章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"本系列笔记为作者在跟随labuladong的算法小抄学习的时候结合golang做的笔记。感谢东哥。另外根据东哥对算法的分类法，将自己平时记的笔记也写到这里面。 ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:0:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"第零章：核心框架汇总 ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:1:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"双指针技巧 秒杀链表和数组题目，快慢指针，左右指针 当你需要创造一条新链表的时候，可以使用虚拟头结点简化边界情况的处理 反转链表的某个区间 [l,r)区间，l,r为*ListNode 1 2 3 4 5 6 7 8 9 10 11 var next *ListNode //current是反转起点 prev,current,next:=nil,l,nil //终止条件，即反转中点的下一个节点 for current!=r{ next=current.Next current.Next=prev prev=current current=next } //此时current和next都为r 最长回文子串 中间往两边扩展 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 func longestPalindrome(s string) string { if s == \"\" { return \"\" } ss=s ll=len(s) ml, mr := 0, 0 for i := 0; i \u003c ll; i++ { l1, r1 := expand(i, i) l2, r2 := expand(i, i + 1) if r1 - l1 \u003e mr - ml { ml, mr = l1, r1 } if r2 - l2 \u003e mr - ml { ml, mr = l2, r2 } } return ss[ml:mr+1] } var ss string var ll int func expand(l, r int) (int, int) { for l\u003e=0\u0026\u0026r\u003cll\u0026\u0026ss[l] == ss[r]{ l-- r++ } return l + 1, r - 1 } ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:1:1","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"排序 快速排序框架 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func sort(s []int,l int,r int){ // 通过交换元素构建分界点 p p:=partition(s,l,r) sort(s,l,p-1) sort(s,p+1,r) } func partition(s []int,l int,r int)int{ tmp:=s[l] for l\u003cr{ for l\u003cr\u0026\u0026s[r]\u003e=tmp{r--} s[l]=s[r] for l\u003cr\u0026\u0026s[l]\u003c=tmp{l++} s[r]=s[l] } s[l]=tmp return l } 归并排序框架 1 2 3 4 5 6 7 8 func sort(s []int,l int,r int){ mid:=l+(r-l)/2 sort(s,l,mid) sort(s,mid+1,r) merge(s,l,mid,r) } ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:1:2","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"二叉树 中后序框架 1 2 3 4 5 6 7 8 9 func traverse(root *TreeNode){ if root==nil{return} //前序位置 traverse(root.Left) //中序位置 traverse(root.Right) //后序位置 } 层序遍历 使用一个list辅助，go里可以使用slice的append内置函数和子切片简单实现，但是并不建议这样做，会造成内存泄露，可以使用container.list，使用也很简单 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func levelTraverse(root *TreeNode){ if root==nil{return} q:=[]*TreeNode{root} for len(q)!=0{ tmp:=q[0] //处理 q=q[1:] q=append(q,tmp.Left,tmp.Right) } } //container/list func levelTraverse(root *TreeNode){ if root==nil{return} q:=list.New() for q.Len()!=0{ tmp:=q.Remove(q.Front()).(*TreeNode) q.PushBack(tmp.Left) q.PushBack(tmp.Right) } } ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:1:3","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"动态规划 动态规划就是聪明的穷举 「最优子结构」：能够只通过子问题的最值得到原问题的最值 「重叠子问题」：子问题存在重复计算，相当于递归树上有相同的节点，使用「备忘录」或者「DP table」来优化（具备这个性质的问题即使没有最优子结构性质，依然可以用备忘录来加速解题过程） 明确 base case（问题的最简单形式） -\u003e 明确「状态」（问题的描述）-\u003e 明确「选择」 -\u003e 根据选择得到从子问题父问题的状态转移方程 定义状态时注意状态要有「无后效性」：已经求解的子问题不受后续阶段的影响 通常DP可以分为两类：自顶向下的动态规划（递归函数实现），自底向上的动态规划（递推算法）。两种方法是同时存在的，并且都需要DP Table优化，它们的状态转移方程是统一的。 这里的选择是修改问题状态的动作，其实就是状态转移方程求最值的参数，每个参数都是一个选择，表示父问题如何从子问题的结果得到自己的结果。比如股票买卖就是我今天是否卖出，买卖就是选择 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 var dp_table [状态1][状态2][...] //状态初始化 func init(){} //自顶向下 func dp(i,j){ for 选择 in 所有可能的选择: result = 求最值(result,从子问题选择后的结果) } //自底向上 func solution(){ for 状态1 in 状态1的所有取值: for 状态2 in 状态2的所有取值: ... dp[状态1][状态2][...] = 求最值(所有选择的结果) } 对于特定遍历顺序的DP可以进行空间优化，比如状态转移方程每次只需要2个子问题的状态，那么就可以把不需要的状态丢弃，仅保持最新的子问题状态 ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:1:4","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"回溯法 回溯法解决所有的排列，组合，子集问题 回溯的关键是选择 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ans:=[]int onpath:=[]int visited:=[]bool func backtrack(当前位置){ if 满足条件{ ans=append(ans,onpath) return } for 选择 := 当前位置.选择列表{ 做选择（添加当前位置） backtrack(选择后的位置) 撤销选择（取消当前位置） } } ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:1:5","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"BFS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var ans *Node func BFS(root *Node,target int){ q:=[]*Node{root} for len(q)!=0{ tmp:=q[0] q=q[1:] if tmp满足条件{ tmp处理 } c:=tmp.children for i:=0;i\u003clen(c);i++{ q=append(q,c[i]) } } } 对于需要避免走回头路的可以使用map或者数组来标记visited ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:1:6","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"二分搜索 寻找一个数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func binarySearch(s []int,t int)int{ l,r,mid:=0,len(s)-1,0 for l\u003c=r{ mid=l+(r-l)/2 if s[mid]\u003ct{ l=mid+1 }else if s[mid]\u003et{ r=mid-1 }else{ return mid } } return -1 } 寻找左侧边界的二分搜索 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func left_bound(s []int,t int)int{ l,r,mid:=0,len(s)-1,0 for l\u003c=r{ mid=l+(r-l)/2 if s[mid]\u003ct{ l=mid+1 }else if s[mid]\u003et{ r=mid-1 }else{ //需注意位置，这里改变的是r r=mid-1 } } //需注意位置，往左边找考虑最右边的情况，这里判断l if l==len(s){return -1} //需注意位置，这里判断l，如果没找到l是插入位置 if s[l]==t{return l}else{return -1} } 寻找右侧边界的二分查找 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func right_bound(s []int,t int)int{ l,r,mid:=0,len(s)-1,0 for l\u003c=r{ mid=l+(r-l)/2 if s[mid]\u003ct{ l=mid+1 }else if s[mid]\u003et{ r=mid-1 }else{ //需注意位置，这里改变的是r l=mid+1 } } //需注意位置，往右边找考虑在最左边的情况，这里判断l-1 if l-1\u003c0{return -1} //需注意位置，这里判断l-1 if s[l-1]==t{return l-1}else{return -1} } ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:1:7","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"滑动窗口 重要，左闭右开 1 2 3 4 5 6 7 8 9 l,r:=0,0 for r\u003clen(s){ 入滑动窗口处理s[r] r++ for l满足增大条件{ 出滑动窗口处理s[l] l++ } } ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:1:8","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"单调队列 单调队列是一种特殊的滑动窗口，他保证滑动窗口内的元素具有单调的性质，单调上升或单调下降 1 2 3 4 5 6 7 8 9 l,r:=0,0 for r\u003clen(s){ 入滑动窗口处理s[r] r++ for l满足增大条件||s[l]\u003cs[r]{ 出滑动窗口处理s[l] l++ } } ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:1:9","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"股票买卖 状态：天数i，允许交易最大次数k，持有状态[0，1] 选择：sell，buy，rest 在buy的时候减小k，因为交易是从buy开始的 1 2 3 4 5 dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) max( 今天选择 rest, 今天选择 sell ) dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) max( 今天选择 rest, 今天选择 buy ) ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:1:10","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"时空复杂度分析 Big O 表示法 O(g(n))= {f(n): 存在正常量c和n_0，使得对所有n ≥ n_0，有0 ≤ f(n) ≤ c*g(n)} 只保留增长速率最快的项，其他的项可以省略 Big O 记号表示复杂度的「上界」 非递归算法分析 空间复杂度：分配的数组空间大小 时间复杂度：循环相乘，顺序相加，取最大的加数 数据结构分析 摊还（平均）时间复杂度：算N个操作总的时间复杂度然后除以N 比如一个单调栈，每个元素都进栈出栈一次，所以总的时间复杂度是O(2N)，除以N就是O(2)，取常数复杂度所以是O(1) 递归算法分析 递归算法的时间复杂度 = 递归树的节点个数 x 每个节点的时间复杂度 递归算法的空间复杂度 = 递归树的高度(递归栈的空间消耗) + 算法申请的存储空间 ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:1:11","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"解法代码分层 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //解题函数 func getans(nums []int){ //数据初始化 a,l=0,len(nums) b=make([]slice,l) //委托solution求解 solution(nums) return ans } //全局变量 var ( a int l int b []int ans int ) //solution函数，该函数也可以内联到解题函数中 func solution(nums []int){ //具体算法 } //工具函数，如递归 func traverse(){ //具体算法 } ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:1:12","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"递归Debug 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //全局变量 var count int func printIndent(n int){ for i:=0;i\u003cn;i++{fmt.Print(\" \")} } func dp(){ count++ //每个fmt.println()之前调用printIndent(count) printIndent(count) fmt.Println(xxx) count-- } ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:1:13","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"一个方法解决n和问题 2和问题，排序+对撞指针 n和问题，排序+穷举（减小问题规模）+对撞指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 func KSum(nums []int, target int,k int) [][]int { l:=len(nums) sort.Ints(nums) onpath:=make([]int,0,k-2) ans:=make([][]int,0) var rec func (int,int,int) rec=func (i,t,n int){ //fmt.Println(onpath,len(onpath),n) if i\u003e=l{return} if n==2{ left,right:=i,l-1 for left\u003cright{ if nums[left]+nums[right]\u003ct{ left++ for left\u003cright\u0026\u0026(left==0||nums[left]==nums[left-1]){left++} }else if nums[left]+nums[right]\u003et{ right-- for right\u003eleft\u0026\u0026(right==l||nums[right]==nums[right+1]){right--} }else{ tmp:=make([]int,k-2,k) copy(tmp,onpath) tmp=append(tmp,nums[left],nums[right]) ans=append(ans,tmp) left++ right-- for left\u003cright\u0026\u0026(left==0||nums[left]==nums[left-1]){left++} for right\u003eleft\u0026\u0026(right==l-1||nums[right]==nums[right+1]){right--} } } }else { for i\u003cl{ onpath=append(onpath,nums[i]) rec(i+1,n-1,t-nums[i]) onpath=onpath[:len(onpath)-1] i++ for i\u003cl\u0026\u0026(i==0||nums[i]==nums[i-1]){i++} } } } rec(0,target,k) return ans } n数之和只需要将n传递给函数中的k即可 ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:1:14","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"第一章：手把手刷数据结构 ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:2:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"前缀和数组 频繁查询某个区间的累加和 1 2 3 4 5 6 7 8 9 var preSum []int //构造过程也可以内联到解题函数中 func NumArray(s []int){ preSum=make([]int,len(s)+1) for i:=1;i\u003clen(preSum);i++{ preSum[i]=preSum[i-1]+s[i-1] } } ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:2:1","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"差分数组 快速进行区间增减的操作 1 2 3 4 5 6 7 8 9 10 var diff []int //构造过程也可以内联到解题函数中 func NumArray(s []int){ diff=make([]int,len(s)) diff[0]=s[0] for i:=1;i\u003clen(diff);i++{ diff[i]=s[i]-s[i-1] } } ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:2:2","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"常数时间删除-查找数组中的任意元素 解决办法：valToIndex哈希表+数组 常数时间删除：哈希表查询索引，数组中将该索引与最后一个元素互换，删除最后一个元素，哈希表修改最后一个元素的键值对并删除被删索引的键值对 常数时间查询：哈希表查询索引，数组随机访问 ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:2:3","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"最近公共祖先（Lowest Common Ancestor，简称 LCA） 1 2 3 4 5 6 7 8 9 10 func find(root *TreeNode,t1 int,t2 int)*TreeNode{ if root==nil{return nil} if root.Val==t1||root.Val==t2{return root}11- l:=find(root.Left,t1,t2) r:=find(root.Right,t1,t2) if l!=nil\u0026\u0026r!=nil{return root} if l!=nil{return l}else{return r} } ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:2:4","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"计算完全二叉树的节点数 一棵完全二叉树的两棵子树，至少有一棵是满二叉树，满二叉树的节点数为2^h-1个(h为树高，root为第1层) 时间复杂度 O(logN*logN) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func countNodes(root *TreeNode){ l,r,hl,hr,ret:=root,root,0,0,0 for l!=nil{ hl++ l=l.Left } for r!=nil{ hr++ r=r.Right } if hl==hr{ ret=1\u003c\u003chl-1 }else{ ret=1+countNodes(root.Left,root.Right) } return ret } ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:2:5","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"多叉树遍历 1 2 3 4 5 6 7 8 9 10 11 func traverse(root *TreeNode){ if root==nil{return} //先序处理 c:=root.Children for i:=0;i\u003clen(c);i++{ traverse(c[i]) } //后序处理 } ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:2:6","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"DFS图遍历（仅展示邻接表，通常都是邻接表，[][]int） 多叉树基础上添加visited数组和onpath数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 var ( visited []bool onpath []bool l int ) //初始化过程也可以内联到解题函数中 func init(graph [][]int){ l=len(graph) visited=make([]bool,l) onpath=make([]bool,0,l) } func tarverse(graph [][]int,n int){ if visited[n] {return} visited[n]=true onpath[n]=true //前序处理位置 c:=graph[n] for i:=0;i\u003clen(c);i++{ traverse(c[i]) } //后序处理位置 onpath=false } for traverseGraph(graph [][]int){ init(graph) for i:=0;i\u003cl;i++{ traverse(i) } } ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:2:7","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"环检测 DFS 修改图遍历中的traverse函数，添加hascycle全局变量(go中bool零值为false) 1 2 3 4 5 6 7 8 9 var hascycle bool func tarverse(graph [][]int,n int){ if onpath[n]{hascycle=true} if visited[n]||hascycle { return } ... } 当题目给的是边的序列和节点总数时使用建图函数： 1 2 3 4 5 6 7 8 9 10 11 12 var graph [][]int func buildGraph(edge [][]int,l int){ graph=make([][]int,l) for i:=0;i\u003cl;i++{ graph[i]=make([][]int,0) } for i:=0;i\u003clen(edge);i++{ graph[edge[i][0]]=append(graph[edge[i][0]],edge[i][1]) } } BFS 添加入度数组indegree，建图函数修改 1 2 3 4 5 6 7 8 9 10 var indegree []int func buildGraph(){ ... indegree = make([]int,l) for i:=0;i\u003clen(edge);i++{ graph[edge[i][0]]=append(graph[edge[i][0]],edge[i][1]) indegree[edge[i][1]]++ } } 使用一个队列将入度为0的节点放入队列中，每取一个节点就把依赖该节点的其他节点入度减1，然后把入度为0的未访问过节点加入队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func canFinish(){ ans:=make([]int,0,l) list:=make([]int,0,l) for i:=0;i\u003cl;i++{ if indegree[i]==0{list=append(list,i)} } for len(list)\u003e0{ c:=graph[list[0]] list=list[1:] for i:=0;i\u003clen(c);i++{ indegree[c[i]]-- if indegree[c[i]]==0{ list=append(list,c[i]) } } } for i:=0;i\u003cl;i++{ if indegree[i]!=0{ hascycle=true break } } return hascycle } ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:2:8","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"并查集 1 2 3 4 5 6 7 8 9 10 11 func validTree(n int,edges [][]int)bool{ uf:=NewUF(n) for i:=0;i\u003clen(edge);i++{ u,v:=edges[i][0],edges[i][1] if uf.connected(u,v){ return false } uf.Union(u,v) } return uf.Count()==1 } ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:2:9","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"拓扑排序 DFS 图DFS后序遍历的序列反转就是拓扑排序 后续遍历等子节点都装到序列后才装父节点，所以它的反转就是父节点都装到序列后再装子节点，这个正好是拓扑排序的定义：一个任务必须等到它依赖的所有任务都完成之后才能开始开始执行。 需要配合环检测，有环的图不能进行拓扑排序，所以在返回结果前需要判断是否有环 BFS 与环检测一样，在每次弹出list[0]之前将list[0]加入ans数组 ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:2:10","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"二分图判定 图DFS遍历，遍历过程中染色节点，当visited为true时不直接返回，而是进行判断是否染色冲突 ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:2:11","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"并查集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 type UF struct{ parent []int //父节点数组 count int //连通分量数 } func NewUF(n int) *UF{ ret:=\u0026UF{} ret.count=n ret.parent=make([]int,n) for i:=0;i\u003cn;i++{ ret.parent[i]=i } return ret } func (uf *UF)Find(x int)int{ for uf.parent[x]!=x{ //路径优化 uf.parent[x]=find(uf.parent[x]) } return uf.parent[x] } func (uf *UF)Union(p,q int){ rootP:=uf.Find(p) rootQ:=uf.Find(q) if rootP==rootQ{return} uf.parent[rootQ]=rootP uf.count-- } func (uf *UF)Connected(p,q int)bool{ rootP:=uf.Find(p) rootQ:=uf.Find(q) return rootP==rootQ } func (uf *UF)Count(p,q int)int{ return uf.count } ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:2:12","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"KRUSKAL 最小生成树算法 边权值贪心 结合并查集环检测算法和边权重排序，这里边为一个形式为[from,to,weight]的int数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func minimumCost(n int,connections [][]int){ uf:=NewUF(n+1) sort.Slice(connections,func (i,j int){ return connections[2]\u003cconnection[2] }) //最小权重和 mst:=0 for edge:=range connections{ u,v,w:=edge[0],edge[1],edge[2] if uf.Connected(u,v){ continue } mst+=w uf.Union(u,v) } //节点0未使用，所以是2 if uf.Count()==2{ return mst } return -1 } ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:2:13","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"PRIM 最小生成树算法 切分贪心 切分定理 切分：将一幅图分为两个不重叠且非空的节点集合 切分定理：对于任意一种「切分」，其中权重最小的那条「横切边」一定是构成最小生成树的一条边 PRIM算法 见原文 ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:2:14","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"DIJKSTRA 算法 从某个点开始带优先级的BFS，查询从开始节点到其他节点的最短路径和最小路径和 见原文 ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:2:15","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"单调栈 单调递增 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 type S []int func (s *S)Pop()int{ l:=len(*s) if l\u003c0{return -1} ret:=(*s)[l-1] *s=*s[:l-1] return ret } func (s *S)Push(x int){ l:=len(*s) for s[l-1]\u003ex\u0026\u0026l!=0{ s.Pop() l-- } *s=append(*s,x) } 自己总结的模板，单调递增 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 l:=len(heights) stack:=make([]int,0,l) chuliluoji:=func(i,x int){ ... } for i,v:=range heights{ x:=... for len(s)\u003e0\u0026\u0026s[s[len(s)-1]]\u003ev{ chuliluoji(i,x) s=s[:len(s)-1] } s=append(s,i) } x:=... for len(s)\u003e0{ chuliluoji(l,x) s=s[:len(s)-1] } ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:2:16","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"优先队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 type PriorityQueue struct { sort.IntSlice } func (h *PriorityQueue) Push(x interface{}) { h.IntSlice = append(h.IntSlice, x.(int)) } func (h *PriorityQueue) Pop() interface{} { l := len(h.IntSlice) ret := h.IntSlice[l-1] h.IntSlice = h.IntSlice[:l-1] return ret } func (h *PriorityQueue) HPush(x int) { heap.Push(h, x) } func (h *PriorityQueue) HPop() int { return heap.Pop(h).(int) } ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:2:17","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"最短路径：BF,SPFA和Floyd算法 ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:3:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"BF松弛算法 单源最短路径 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 var graph [][]int var minPath []int var preNode []int var l func bfs(s int)bool{ minPath,preNode=make([]int,l),make([]int,l) for i:=0;i\u003cl;i++{ minPath[i]=math.MaxInt preNode[i]=-1 } minPath[s]=0 //松弛l-1轮 for i:=0;i\u003cl-1;i++{ //每轮松弛所有边 for u:=0;u\u003cl;u++{ for _,V:=range graph[u]{ v,w:=V[0],V[1] tmp:=Add(minPath[u],w) if minPath[v]\u003etmp{ minPath[v]=tmp preNode[v]=u } } } } //松弛第l轮，如果还有改变表示有负环，返回错误 for u:=0;u\u003cl;u++{ for _,V:=range graph[u]{ v,w:=V[0],V[1] tmp:=Add(minPath[u],w) if minPath[v]\u003etmp{ return false } } } return true } func Add(a,b int){ if a==math.MaxInt||b==math.MaxInt{return math.MaxInt} return a+b } ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:3:1","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"SPFA算法 BF队列优化，额外需要一个记录顶点入队次数的数组（不能超过l-1次，每条边松弛不超过l-1次）。使用优先队列还能进行优化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import aq \"github.com/emirpasic/gods/queues/arrayqueue\" var graph [][]int var minPath []int var preNode []int var eqTime []int var l func spfa(s int)bool{ minPath,preNode,eqTime=make([]int,l),make([]int,l),make([]int,l) for i:=0;i\u003cl;i++{ minPath[i]=math.MaxInt preNode[i]=-1 } minPath[s]=0 queue := aq.New() queue.Enqueue(s) eqTime[s]++ for !queue.Empty(){ u,_:=queue.Dequeue() for _,V:=range graph[u]{ v,w:=V[0],V[1] tmp:=Add(minPath[u],w) if minPath[v]\u003etmp{ minPath[v]=tmp preNode[v]=u queue.Enqueue(v) //入队次数超过l-1，出现负环，返回错误 eqTime[v]++ if eqTime\u003e=l{ return false } } } } return true } func Add(a,b int){ if a==math.MaxInt||b==math.MaxInt{return math.MaxInt} return a+b } ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:3:2","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"Floyd算法 全源最短路径，使用邻接矩阵，O（n^3） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 var graph [][]int var minPath [][]int var l int func floyd(s int)bool{ minPath=make([][]int,l) for i:=0;i\u003cl;i++{ minPath=make([]int,l) for j:=0;j\u003cl;j++{ minPath[i][j]=math.MaxInt } } //枚举顶点K for k:=0;k\u003cl;k++{ //对任意一条路径i，j选k为中点 for i:=0;i\u003cl;i++{ for j:=0;j\u003cl;j++{ tmp:=Add(minPath[i][k],minPath[k][j]) if minPath\u003etmp{ minPath[i][j]=tmp } } } } } func Add(a,b int){ if a==math.MaxInt||b==math.MaxInt{return math.MaxInt} return a+b } ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:3:3","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"KMP ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:4:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"getNextVal 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func getNext(p []byte) []int{ i, j, l := 1, 0, len(p) next = make([]int, l) for i \u003c l { if j == 0 || p[i] == p[j] { next[i] = j i++ j++ } else { j = next[j] } } return next } ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:4:1","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"KMP 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func KMP(s []byte, p []byte, next []int) int { i, j, ls, lp := 0, 0, len(s), len(p) for i \u003c ls \u0026\u0026 j \u003c lp { if j == 0 || s[i] == p[j] { i++ j++ } else { j = next[j] } } if j == lp { return i - lp } else { return -1 } } ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:4:2","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["数据结构与算法"],"content":"固定滑动窗口框架 leetcode 2379 得到 K 个黑块的最少涂色次数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func minimumRecolors(blocks string, k int) int { ans:=math.MaxInt tmp:=0 //1. 设置两个指针分别指向滑动窗口的两端，左闭右开 i,j,l:=0,0,len(blocks) //2. 先读取窗口大小的元素 for i\u003ck\u0026\u0026i\u003cl{ if blocks[i]=='W'{tmp++} i++ } //3. 进行一次窗口判断 if ans\u003etmp{ans=tmp} //4. 窗口移动并进行窗口判断 for i\u003cl{ if blocks[i]=='W'{tmp++} if blocks[j]=='W'{tmp--} i++ j++ if ans\u003etmp{ans=tmp} } return ans } ","date":"2022-12-29","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/:5:0","tags":["labuladong系列"],"title":"数据结构与算法-labuladong-第零章和第一章","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/labuladong/%E7%AC%AC%E9%9B%B6%E7%AB%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["Golang"],"content":"go语言中文网 godoc go语言中文网有很多文档缺少内容比如string.Builder就没有，godoc绝对详尽，推荐阅读godoc godoc strings ","date":"2022-12-28","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/strings/:0:0","tags":["go标准库"],"title":"go标准库-Strings","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/strings/"},{"categories":["Golang"],"content":"常用function func Trim(s string, cutset string) string：返回将s前后端所有cutset包含的utf-8码值都去掉的字符串。 func TrimLeft(s string, cutset string) string func TrimRight(s string, cutset string) string func TrimSpace(s string) string：返回将s前后端所有空白（unicode.IsSpace指定）都去掉的字符串。 func TrimPrefix(s, prefix string) string：返回去除s可能的前缀prefix的字符串。 func TrimSuffix(s, suffix string) string：返回去除s可能的后缀suffix的字符串。 func ToLower(s string) string：返回将所有字母都转为对应的小写版本的拷贝 func ToUpper(s string) string：返回将所有字母都转为对应的大写版本的拷贝 func Count(s, sep string) int：返回字符串s中有几个不重复的sep子串 func Repeat(s string, count int) string：返回将s字符串重复count遍的字符串 func Index(s, substr string) int：返回s中第一个和substr一样的子串索引值，没有为-1 func Fields(s string) []string：返回将字符串按照空白（unicode.IsSpace确定，可以是一到多个连续的空白字符）分割的多个字符串。 func FieldsFunc(s string, f func(rune) bool) []string：在每次满足 f(c) 的 Unicode 代码点 c 处拆分字符串 s 并返回 s 切片数组。如果 s 中的所有代码点都满足 f(c) 或字符串为空，则返回一个空切片。 func Split(s, sep string) []string：用去掉s中出现的sep的方式进行分割，会分割到结尾，并返回生成的所有片段组成的切片（每一个sep都会进行一次切割，即使两个sep相邻，也会进行两次切割）。如果sep为空字符，Split会将s切分成每一个unicode码值一个字符串。 func SplitAfter(s, sep string) []string：带sep的分割，置于字段的后面 func Join(a []string, sep string) string：将一系列字符串连接为一个字符串，之间用sep来分隔。 ","date":"2022-12-28","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/strings/:1:0","tags":["go标准库"],"title":"go标准库-Strings","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/strings/"},{"categories":["Golang"],"content":"type Builder struct Builder 用于使用 Write 方法有效地构建字符串。 1 2 3 4 5 6 var b strings.Builder for i := 3; i \u003e= 1; i-- { fmt.Fprintf(\u0026b, \"%d...\", i) } b.WriteString(\"ignition\") fmt.Println(b.String()) 常用方法 func (b *Builder) Len() int func (b *Builder) Reset() func (b *Builder) String() string func (b *Builder) Write(p []byte) (int, error) func (b *Builder) WriteByte(c byte) error func (b *Builder) WriteString(s string) (int, error) ","date":"2022-12-28","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/strings/:2:0","tags":["go标准库"],"title":"go标准库-Strings","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/strings/"},{"categories":["计算机网络"],"content":"本系列笔记为作者在跟随小林coding学习的时候做的笔记。感谢小林大大。 ","date":"2022-12-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/ip%E7%AF%87/:0:0","tags":["小林coding系列"],"title":"计算机网络-小林coding-IP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/ip%E7%AF%87/"},{"categories":["计算机网络"],"content":"IP 基础知识全家桶 ","date":"2022-12-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/ip%E7%AF%87/:1:0","tags":["小林coding系列"],"title":"计算机网络-小林coding-IP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/ip%E7%AF%87/"},{"categories":["计算机网络"],"content":"前菜 —— IP 基本认识 网络层实现主机与主机之间的通信，也叫点对点（end to end）通信 MAC 的作用则是实现「直连」的两个设备之间通信，而 IP 则负责在「没有直连」的两个网络之间进行通信传输 源IP地址和目标IP地址在传输过程中是不会变化的（前提：没有使用 NAT 网络），只有源 MAC 地址和目标 MAC 一直在变化 ","date":"2022-12-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/ip%E7%AF%87/:1:1","tags":["小林coding系列"],"title":"计算机网络-小林coding-IP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/ip%E7%AF%87/"},{"categories":["计算机网络"],"content":"主菜 —— IP 地址的基础知识 32 位 IP 地址以每 8 位为组，共分为 4 组，每组以「.」隔开 IP 地址的分类 网络号和主机号 广播地址:主机号全 1 在本网络内广播的叫做本地广播 在不同网络之间的广播叫做直接广播 无分类地址 CIDR a.b.c.d/x，其中 /x 表示前 x 位属于网络号， x 的范围是 0 ~ 32 子网掩码：将子网掩码和 IP 地址按位计算 AND，就可得到网络号 子网划分：将主机地址分为两个部分（子网网络地址和子网主机地址） 公有 IP 地址与私有 IP 地址 IP 地址与路由控制 环回地址是不会流向网络：127.0.0.1 作为环回地址，localhost 的主机名。数据包不会流向网络。 IP 分片与重组 数据包大小大于 MTU 时， IP 数据包就会被分片 某个分片丢失，则会造成整个 IP 数据报作废 TCP 引入 MSS 在 TCP 层进行分片不由 IP 层分片，对于 UDP 尽量不要发送一个大于 MTU 的数据报文 IPv6 基本认识 128位，每 16 位作为一组，每组用冒号 「:」隔开 IPv6 自动分配IP地址，即插即用。 IPv6 包头包首部长度采用固定的值 40 字节，去掉了包头校验和，简化了首部结构，减轻了路由器负荷，大大提高了传输的性能。 IPv6 有应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能，大大提升了安全性。 IPv4 首部与 IPv6 首部 ","date":"2022-12-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/ip%E7%AF%87/:1:2","tags":["小林coding系列"],"title":"计算机网络-小林coding-IP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/ip%E7%AF%87/"},{"categories":["计算机网络"],"content":"点心 —— IP 协议相关技术 DNS DHCP NAT NAT 穿透技术 客户端主动从 NAT 设备获取公有 IP 地址，然后自己建立端口映射条目，然后用这个条目对外通信，不需要 NAT 设备来进行转换 ICMP ","date":"2022-12-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/ip%E7%AF%87/:1:3","tags":["小林coding系列"],"title":"计算机网络-小林coding-IP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/ip%E7%AF%87/"},{"categories":["计算机网络"],"content":"ping 的工作原理 ","date":"2022-12-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/ip%E7%AF%87/:2:0","tags":["小林coding系列"],"title":"计算机网络-小林coding-IP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/ip%E7%AF%87/"},{"categories":["计算机网络"],"content":"IP协议的助手 —— ICMP 协议 ","date":"2022-12-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/ip%E7%AF%87/:2:1","tags":["小林coding系列"],"title":"计算机网络-小林coding-IP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/ip%E7%AF%87/"},{"categories":["计算机网络"],"content":"ping —— 查询报文类型的使用 使用了 ICMP 里面的 ECHO REQUEST（类型为 8 ） 和 ECHO REPLY （类型为 0） ","date":"2022-12-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/ip%E7%AF%87/:2:2","tags":["小林coding系列"],"title":"计算机网络-小林coding-IP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/ip%E7%AF%87/"},{"categories":["计算机网络"],"content":"traceroute —— 差错报文类型的使用 故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器 故意设置不分片，从而确定路径的 MTU ","date":"2022-12-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/ip%E7%AF%87/:2:3","tags":["小林coding系列"],"title":"计算机网络-小林coding-IP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/ip%E7%AF%87/"},{"categories":["计算机网络"],"content":"断网了，还能 ping 通 127.0.0.1 吗？ 能ping通，回环地址数据包直接交给软件本地网卡触发软中断，不交给真网卡 图中右边是tcp数据包，画错了 ","date":"2022-12-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/ip%E7%AF%87/:3:0","tags":["小林coding系列"],"title":"计算机网络-小林coding-IP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/ip%E7%AF%87/"},{"categories":["计算机网络"],"content":"ping回环地址和ping本机地址有什么区别 ping回环地址和ping本机地址没有区别，都走 lo0，本地回环接口，也就是前面提到的**“假网卡”** ","date":"2022-12-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/ip%E7%AF%87/:3:1","tags":["小林coding系列"],"title":"计算机网络-小林coding-IP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/ip%E7%AF%87/"},{"categories":["计算机网络"],"content":"127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗 如果服务器 listen 的是 0.0.0.0，那么此时用127.0.0.1和本机地址都可以访问到服务 0.0.0.0会监听本机的所有网卡，如果使用固定网卡地址只能监听该网卡地址的数据包，详见通用技术本地测试地址的区别 ","date":"2022-12-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/ip%E7%AF%87/:3:2","tags":["小林coding系列"],"title":"计算机网络-小林coding-IP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/ip%E7%AF%87/"},{"categories":["Golang"],"content":"go语言中文网 godoc go语言中文网有很多文档缺少内容比如string.Builder就没有，godoc绝对详尽，推荐阅读godoc json.Marsheal()方法序列化一个具有channel或func字段的结构体会返回错误 json.Marsheal()方法不会序列化私有字段 CSDNweixin_30507269 json转换结构体遇到指针字段时会自动连接到指针对应的结构体。最终生成的字符串会包含连接到的对象。 ","date":"2022-12-25","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/json/:0:0","tags":["go标准库"],"title":"go标准库-Json","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/json/"},{"categories":["计算机网络"],"content":"本系列笔记为作者在跟随小林coding学习的时候做的笔记。感谢小林大大。 ","date":"2022-12-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/tcp%E7%AF%87/:0:0","tags":["小林coding系列"],"title":"计算机网络-小林coding-TCP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/tcp%E7%AF%87/"},{"categories":["计算机网络"],"content":"TCP 三次握手与四次挥手面试题 ","date":"2022-12-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/tcp%E7%AF%87/:1:0","tags":["小林coding系列"],"title":"计算机网络-小林coding-TCP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/tcp%E7%AF%87/"},{"categories":["计算机网络"],"content":"TCP 基本认识 TCP 头格式 http头格式\r为什么需要 TCP 协议？ TCP 工作在哪一层？ IP无连接不可靠，TCP实现有连接可靠传输 传输层 什么是 TCP ？ TCP 是面向连接的、可靠的、基于字节流的传输层通信协议 面向连接：「一对一」 可靠的：保证报文到达接收端 字节流：应用层消息可能会被操作系统「分组」成多个的 TCP 报文，需要应用层协议规定消息的边界 什么是 TCP 连接？ Socket：由 IP 地址和端口号组成 序列号：用来解决乱序问题等 窗口大小：用来做流量控制 如何唯一确定一个 TCP 连接呢？ TCP 四元组可以唯一的确定一个连接：源地址，源端口，目的地址，目的端口 ","date":"2022-12-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/tcp%E7%AF%87/:1:1","tags":["小林coding系列"],"title":"计算机网络-小林coding-TCP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/tcp%E7%AF%87/"},{"categories":["计算机网络"],"content":"TCP 连接建立 TCP 三次握手过程是怎样的 TCP三次握手\r如何在 Linux 系统中查看 TCP 状态？ netstat -napt 为什么是三次握手？不是两次、四次？ 避免历史连接(首要原因) 避免历史连接\r同步双方初始序列号 避免资源浪费 什么是 SYN 攻击？如何避免 SYN 攻击？ 短时间伪造不同 IP 地址的 SYN 报文占满服务端的半连接队列，后续再在收到 SYN 报文就会丢弃 TCP 三次握手的时候，Linux 内核会维护两个队列 半连接队列，也称 SYN 队列 全连接队列，也称 accept 队列 ","date":"2022-12-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/tcp%E7%AF%87/:1:2","tags":["小林coding系列"],"title":"计算机网络-小林coding-TCP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/tcp%E7%AF%87/"},{"categories":["计算机网络"],"content":"TCP 连接断开 TCP 四次挥手过程是怎样的？ 图里面先关闭连接的是客户端，后关闭的是服务端，这顺序可以反过来 主动关闭连接的，才有 TIME_WAIT 状态 为什么挥手需要四次？ tcp是全双工通信 为什么 TIME_WAIT 等待的时间是 2MSL？ MSL 是 Maximum Segment Lifetime，报文最大生存时间，任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。 发送过去FIN还要接收ACK，一来一回需要等待 2 倍的时间，至少允许报文丢失一次触发超时重传 为什么需要 TIME_WAIT 状态？ 保证「被动关闭连接」的一方，能被正确的关闭（主要） 防止历史连接中的数据，被后面相同四元组的连接错误的接收 ","date":"2022-12-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/tcp%E7%AF%87/:1:3","tags":["小林coding系列"],"title":"计算机网络-小林coding-TCP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/tcp%E7%AF%87/"},{"categories":["计算机网络"],"content":"Socket 编程 accept 发生在三次握手的哪一步 客户端调用 close 了，连接是断开的流程是什么？ ","date":"2022-12-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/tcp%E7%AF%87/:1:4","tags":["小林coding系列"],"title":"计算机网络-小林coding-TCP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/tcp%E7%AF%87/"},{"categories":["计算机网络"],"content":"TCP 重传、滑动窗口、流量控制、拥塞控制 ","date":"2022-12-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/tcp%E7%AF%87/:2:0","tags":["小林coding系列"],"title":"计算机网络-小林coding-TCP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/tcp%E7%AF%87/"},{"categories":["计算机网络"],"content":"重传机制 超时重传 RTT 指的是数据发送时刻到接收到确认的时刻的差值，也就是包的往返时间。 超时重传时间 RTO 的值应该略大于报文往返 RTT 的值 快速重传 SACK 方法 SACK（ Selective Acknowledgment）， 选择性确认，SACK字段记录在ACK后面的已收到的字节 Duplicate SACK SACK 字段标记重复接收字节 ","date":"2022-12-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/tcp%E7%AF%87/:2:1","tags":["小林coding系列"],"title":"计算机网络-小林coding-TCP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/tcp%E7%AF%87/"},{"categories":["计算机网络"],"content":"滑动窗口 Window字段告诉发送端自己还有多少缓冲区可以接收数据。 发送方的滑动窗口 SND.WND：表示发送窗口的大小（大小是由接收方指定的） SND.UNA（Send Unacknoleged）：指向已发送但未收到确认的第一个字节的序列号 SND.NXT：指向未发送但可发送范围的第一个字节的序列号 可用窗口大小 = SND.WND -（SND.NXT - SND.UNA） 接收方的滑动窗口 RCV.WND：表示接收窗口的大小 RCV.NXT：指向期望从发送方发送来的下一个数据字节的序列号 ","date":"2022-12-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/tcp%E7%AF%87/:2:2","tags":["小林coding系列"],"title":"计算机网络-小林coding-TCP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/tcp%E7%AF%87/"},{"categories":["计算机网络"],"content":"流量控制 操作系统缓冲区与滑动窗口的关系 先收缩窗口，过段时间再减少缓存 窗口关闭 窗口大小为 0 阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭 TCP 连接一方收到对方的零窗口通知时启动持续计时器，计时器超时发送窗口探测 ( Window probe ) 报文获取接收窗口大小，如果接收窗口仍然为 0，那么收到这个报文的一方就会重新启动持续计时器 窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 RST 报文来中断连接。 糊涂窗口综合症 接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症 解决办法： 让接收方不通告小窗口：「窗口大小」小于 min( MSS，缓存空间/2 ) ，也就是小于 MSS 与 1/2 缓存大小中的最小值时，就会向发送方通告窗口为 0 让发送方避免发送小数据： Nagle 算法（延时处理），只在下面两个条件下发送数据：1.窗口大小 \u003e= MSS 并且 数据大小 \u003e= MSS。2.收到之前发送数据的 ack 回包。 两个都用上才能避免糊涂窗口综合症 ","date":"2022-12-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/tcp%E7%AF%87/:2:3","tags":["小林coding系列"],"title":"计算机网络-小林coding-TCP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/tcp%E7%AF%87/"},{"categories":["计算机网络"],"content":"拥塞控制 目的：避免「发送方」的数据填满整个网络 拥塞窗口 cwnd是发送方维护的一个的状态变量，根据网络的拥塞程度动态变化的。 接收窗口 rwnd 发送窗口的值是swnd = min(cwnd, rwnd) 慢启动 发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1 （指数性的增长），图中纵坐标的单位是MSS，横坐标是传输轮数 慢启动门限 ssthresh （slow start threshold） cwnd \u003c ssthresh 时，使用慢启动算法 cwnd \u003e= ssthresh 时，就会使用「拥塞避免算法」 拥塞避免算法 每当收到一个 ACK 时，cwnd 增加 1/cwnd 拥塞发生 超时重传 ssthresh 设为 cwnd/2 cwnd 重置为 1 （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1） 重新开始慢启动 快速重传 收到3个一样的ACK cwnd = cwnd/2 ; ssthresh = cwnd; 接着快速恢复算法（但是先加3，因为快速重传收到了3个ACK） ","date":"2022-12-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/tcp%E7%AF%87/:2:4","tags":["小林coding系列"],"title":"计算机网络-小林coding-TCP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/tcp%E7%AF%87/"},{"categories":["云原生"],"content":"docker 官网 docker 官方文档 docker 参考文档 dockerfile 参考 ","date":"2022-12-25","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E6%A6%82%E8%BF%B0/:0:0","tags":["docker"],"title":"云原生-docker-概述","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E6%A6%82%E8%BF%B0/"},{"categories":["云原生"],"content":"docker docker 命令官方文档 ","date":"2022-12-25","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E6%A6%82%E8%BF%B0/:1:0","tags":["docker"],"title":"云原生-docker-概述","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E6%A6%82%E8%BF%B0/"},{"categories":["云原生"],"content":"Dockerfile dockerfile 参考 Dockerfile 不等同于 Shell 脚本，不要使用cd命令使用WORKDIR关键字切换img内命令执行环境 格式 1 2 # Comment INSTRUCTION arguments 指令不区分大小写，但约定大写 关键字 FROM [--platform=\u003cplatform\u003e] \u003cimage\u003e[@\u003cdigest\u003e] [AS \u003cname\u003e]:指定基础img，AS关键字用于多阶段构建，即在该img编译文件，然后COPY到最终目标镜像COPY --from=\u003cname\u003e， RUN \u003ccommand\u003e:shell形式，在默认shell中运行，解释为/bin/sh -c command，可以用\\跨行，可以对变量进行替换，如$HOME。–mount创建文件系统挂载。–network控制命令在哪个网络环境种运行 RUN [\"executable\", \"param1\", \"param2\"]:exec形式，直接执行，解释为executable param1 param2，不能对变量进行替换。 CMD [\"executable\",\"param1\",\"param2\"]:exec形式，也能为ENTRYPOINT提供参数。一个Dockerfile只能有一个CMD指令（如果多个只有最后一个生效） CMD command param1 param2:shell形式 LABEL \u003ckey\u003e=\u003cvalue\u003e \u003ckey\u003e=\u003cvalue\u003e \u003ckey\u003e=\u003cvalue\u003e ...:给img添加元数据 EXPOSE \u003cport\u003e [\u003cport\u003e/\u003cprotocol\u003e...]:作为告诉img使用者可监听端口的文档，可以指定tcp还是udp ENV \u003ckey\u003e=\u003cvalue\u003e ...:设置环境变量，与ARG不同，设置的环境变量会在生成的img生效，docker run命令或compose.yaml文件声明的环境变量会覆盖这些环境变量 ADD [--chown=\u003cuser\u003e:\u003cgroup\u003e] [--chmod=\u003cperms\u003e] [\"\u003csrc\u003e\",... \"\u003cdest\u003e\"]:复制文件，目录或url文件到dest，匹配规则参照go filepath.Match，可以包含通配符，dest支持绝对路径和相对路径，自动解压压缩文件，src必须在构建上下文中（docker build是将上下文目录和子目录发送给docker守护进程） COPY [--chown=\u003cuser\u003e:\u003cgroup\u003e] [--chmod=\u003cperms\u003e] [\"\u003csrc\u003e\",... \"\u003cdest\u003e\"]:和ADD功能类似，可以接收一个选项--from=\u003cname\u003e，该选项可以使用先前构建的img（FROM .. AS \u003cname\u003e）里的文件，而不是构建上下文。 ENTRYPOINT [\"executable\", \"param1\", \"param2\"]:exec形式，该命令和CMD一样，当同时有两个命令时CMD给ENTRYPOINT提供参数，docker run -d也能提供参数。只有最后一条该指令生效。 ENTRYPOINT command param1 param2:shell形式，不接受run或CMD的参数，作为子命令启动。 VOLUME [\"/data\"]:指定一个具名挂载点，docker run会创建一个新的挂载点 USER \u003cuser\u003e[:\u003cgroup\u003e]:设置用户名和所在用户组，后续的RUN，CMD和ENTRYPOINT都是该用户执行的 WORKDIR /path/to/workdir:设置指令执行的容器内工作目录，如果不存在则创建 ARG \u003cname\u003e[=\u003cdefault value\u003e]:定义变量，可以具有默认值，和ENV类似，但仅在构建时生效，多阶段构建仅在声明行所在img生效，可以通过docker build的–build-arg选项给变量赋值 ","date":"2022-12-25","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E6%A6%82%E8%BF%B0/:1:1","tags":["docker"],"title":"云原生-docker-概述","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E6%A6%82%E8%BF%B0/"},{"categories":["云原生"],"content":"docker常用命令： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #登录远程仓库 -p Password，-u Username docker login [OPTIONS] [SERVER] #从远程仓库登出 docker logout [SERVER] #img相关命令 docker image COMMAND #container相关命令 docker container COMMAND #context相关命令 docker context COMMAND # 卷相关命令 docker volume #network相关命令 docker network COMMAND #显示系统范围的信息 docker info 对于后面5个相关命令统一的命令有： create 创建 ls 列出 -f 过滤，后面跟aa=bb，aa是具有的属性名，bb是属性值，也可以和一起grep使用 rm 移除 inspect 查看某一个实例的详细信息 prune 移除未使用的实例 image 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 新建一个容器并启动容器，通常和it参数一起使用，--interactive , -i ， 即使没有被 attach 仍然保持 STDIN 打开，--tty,-t ，分配伪 TTY，docker create的时候也通常和it参数一起使用 docker container run [OPTIONS] IMAGE [COMMAND] [ARG...] # Path上下文构建img，--file , -f参数指定Dockerfile (Default is 'PATH/Dockerfile') docker image build [OPTIONS] PATH | URL | - # 从远程仓库获取img docker image pull [OPTIONS] NAME[:TAG|@DIGEST] # 将本地img推送到远程仓库 docker image push [OPTIONS] NAME[:TAG] # 将一个或多个img保存位一个tar压缩文件，-o指定保持位置 docker image save [OPTIONS] IMAGE [IMAGE...] # 导入save保存的img压缩文件 docker image import [OPTIONS] file|URL|- [REPOSITORY[:TAG]] # 给本地img打tag docker image tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG] container 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # 将当前容器作为一个新版本的img或者创建一个新的img docker container commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] # 拷贝文件到容器 docker container cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|- # 容器中启动命令，启动一个终端：docker container exec -it CONTAINER /bin/bash docker container exec [OPTIONS] CONTAINER COMMAND [ARG...] # 将容器导出为一个tar压缩文件，-o指定导出位置 docker container export [OPTIONS] CONTAINER # 查看容器日志 docker container logs [OPTIONS] CONTAINER # 设置容器端口映射 docker container port CONTAINER [PRIVATE_PORT[/PROTO]] # 启动容器 docker container start [OPTIONS] CONTAINER [CONTAINER...] # 查看容器状态，资源使用统计 docker container stats [OPTIONS] [CONTAINER...] # 停止容器 docker container stop [OPTIONS] CONTAINER [CONTAINER...] # 容器内top，查看容器进程 docker container top CONTAINER [ps OPTIONS] # 杀死一个或多个正在运行的容器 docker container kill [OPTIONS] CONTAINER [CONTAINER...] # 更新一个或多个容器的配置,--restart配置是否自动启动，启动策略见下面链接 docker container update [OPTIONS] CONTAINER [CONTAINER...] 启动策略 network 1 2 3 4 5 # 将容器连接进某个网络 docker network connect [OPTIONS] NETWORK CONTAINER # 将容器和某个网络断开 docker network disconnect [OPTIONS] NETWORK CONTAINER ","date":"2022-12-25","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E6%A6%82%E8%BF%B0/:1:2","tags":["docker"],"title":"云原生-docker-概述","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E6%A6%82%E8%BF%B0/"},{"categories":["云原生"],"content":".dockerignore 官方文档 1 2 3 4 # comment */temp* */*/temp* temp? ","date":"2022-12-25","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E6%A6%82%E8%BF%B0/:1:3","tags":["docker"],"title":"云原生-docker-概述","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E6%A6%82%E8%BF%B0/"},{"categories":["云原生"],"content":"其他详见docker-golang开发 ","date":"2022-12-25","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E6%A6%82%E8%BF%B0/:1:4","tags":["docker"],"title":"云原生-docker-概述","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E6%A6%82%E8%BF%B0/"},{"categories":["云原生"],"content":"docker compose docker把docker compose作为一个插件内置到了docker中，所以之前作为独立程序的docker-compose没有继续维护了。两种命令仍然都是可以使用的，而且用法一样。不过官方推荐使用compose插件。 官方文档 ","date":"2022-12-25","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E6%A6%82%E8%BF%B0/:2:0","tags":["docker"],"title":"云原生-docker-概述","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E6%A6%82%E8%BF%B0/"},{"categories":["云原生"],"content":"常用命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 构建或重构service docker compose build [OPTIONS] [SERVICE...] # 从service容器拷贝文件 docker compose cp [OPTIONS] SERVICE:SRC_PATH DEST_PATH|- # 从service创建容器 docker compose create [OPTIONS] [SERVICE...] # 停止并移除容器，网络 docker compose down [OPTIONS] # 创建并启动一个container docker compose up [OPTIONS] [SERVICE...] 其他常用命令 1 2 # 查看compose文件对应容器启动状态 docker compose -f xxx.yaml ps ","date":"2022-12-25","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E6%A6%82%E8%BF%B0/:2:1","tags":["docker"],"title":"云原生-docker-概述","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E6%A6%82%E8%BF%B0/"},{"categories":["云原生"],"content":"主要功能和用例 开发3个步骤： Dockerfile定义应用程序。 docker compose.yml定义应用程序组织方式 docker compose xxx.yamd up启动，-d在后台启动 docker compose xxx.yaml down关闭 zero-looklook docker compose 示例 ","date":"2022-12-25","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E6%A6%82%E8%BF%B0/:2:2","tags":["docker"],"title":"云原生-docker-概述","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/%E6%A6%82%E8%BF%B0/"},{"categories":["Golang"],"content":"gin官方文档 ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:0:0","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"安装 1 go get -u github.com/gin-gonic/gin ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:1:0","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"快速开始 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import ( \"net/http\" \"github.com/gin-gonic/gin\" ) func main() { r := gin.Default() r.GET(\"/ping\", func(c *gin.Context) { c.JSON(http.StatusOK, gin.H{ \"message\": \"pong\", }) }) r.Run() // listen and serve on 0.0.0.0:8080 (for windows \"localhost:8080\") } ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:2:0","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"API 范例 ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:3:0","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"GET、POST、PUT、PATCH、DELETE 和 OPTIONS 1 2 3 4 5 6 7 router.GET(\"/someGet\", handlefunc) router.POST(\"/somePost\", handlefunc) router.PUT(\"/somePut\", handlefunc) router.DELETE(\"/someDelete\", handlefunc) router.PATCH(\"/somePatch\", handlefunc) router.HEAD(\"/someHead\", handlefunc) router.OPTIONS(\"/someOptions\", handlefunc) ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:3:1","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"路径中的参数 /user/:name中的name 1 name := c.Param(\"name\") ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:3:2","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"查询字符串参数 url中\"?“后的参数 1 2 3 lastname := c.Query(\"lastname\") //带默认值的查询 firstname := c.DefaultQuery(\"firstname\", \"Guest\") ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:3:3","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"多部分/URL 编码形式 post-form类型body的参数 1 2 3 message := c.PostForm(\"message\") //带默认值 nick := c.DefaultPostForm(\"nick\", \"anonymous\") ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:3:4","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"上传文件 单个文件 1 2 3 4 5 file, _ := c.FormFile(\"file\") log.Println(file.Filename) // Upload the file to specific dst. c.SaveUploadedFile(file, dst) 不要相信filename 多个文件 1 2 3 4 5 6 7 8 9 form, _ := c.MultipartForm() files := form.File[\"upload[]\"] for _, file := range files { log.Println(file.Filename) // Upload the file to specific dst. c.SaveUploadedFile(file, dst) } ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:3:5","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"分组路由 1 v1 := router.Group(\"/v1\") 可以对分组再分组，分组具有和router一样的api ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:3:6","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"创建不使用默认中间件的路由 1 2 //r := gin.Default()使用Logger和Recovery 中间件 r := gin.New() ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:3:7","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"使用中间件 1 2 3 r.Use(gin.Logger()) //分组路由也可以使用中间件 v.Use(gin.Logger()) ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:3:8","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"自定义恢复行为 处理过程中panic后自动调用 1 2 3 4 5 6 r.Use(gin.CustomRecovery(func(c *gin.Context, recovered interface{}) { if err, ok := recovered.(string); ok { c.String(http.StatusInternalServerError, fmt.Sprintf(\"error: %s\", err)) } c.AbortWithStatus(http.StatusInternalServerError) })) ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:3:9","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"写日志文件 1 2 3 4 5 6 7 8 9 // 取消日志颜色 gin.DisableConsoleColor() // 将日志写入文件重定向到目标文件 f, _ := os.Create(\"gin.log\") gin.DefaultWriter = io.MultiWriter(f) // 创建路由 router := gin.Default() ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:3:10","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"控制日志输出着色 不着色日志 1 gin.DisableConsoleColor() 始终为日志着色 1 gin.ForceConsoleColor() 配置需要在创建路由之前 ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:3:11","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"模型绑定和验证 将请求体绑定到某个类型，支持JSON、XML、YAML、TOML 和标准格式值 (foo=bar\u0026boo=baz) 需要在所有要绑定的字段上设置相应的绑定标签，例如，从 JSON 绑定时，设置json:“fieldname”。 binding:“required\"指定必须有的字段 必须绑定：Bind, BindJSON, BindXML, BindQuery, BindYAML, BindHeader,BindTOML。绑定错误，请求将被c.AbortWithError(400, err).SetType(ErrorTypeBind)中止。 应该绑定：ShouldBind, ShouldBindJSON, ShouldBindXML, ShouldBindQuery, ShouldBindYAML, ShouldBindHeader, ShouldBindTOML。存在绑定错误，则返回错误（err:=c.ShouldBind(xxx)） ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:3:12","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"自定义验证器 ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:3:13","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"仅绑定查询字符串 “?“后面的参数 1 2 3 4 5 6 type Person struct { Name string `form:\"name\"` Address string `form:\"address\"` } err:=c.ShouldBindQuery(\u0026person) ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:3:14","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"绑定查询字符串或Post数据 1 2 3 4 5 6 7 8 9 type Person struct { Name string `form:\"name\"` Address string `form:\"address\"` Birthday time.Time `form:\"birthday\" time_format:\"2006-01-02\" time_utc:\"1\"` CreateTime time.Time `form:\"createTime\" time_format:\"unixNano\"` UnixTime time.Time `form:\"unixTime\" time_format:\"unix\"` } err:=c.ShouldBind(\u0026person) ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:3:15","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"绑定URI “/:name/:id\"类型的Uri 1 2 3 4 5 6 type Person struct { ID string `uri:\"id\" binding:\"required,uuid\"` Name string `uri:\"name\" binding:\"required\"` } err := c.ShouldBindUri(\u0026person) ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:3:16","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"绑定Header Header中的参数 1 2 3 4 5 6 type testHeader struct { Rate int `header:\"Rate\"` Domain string `header:\"Domain\"` } err := c.ShouldBindHeader(\u0026h) ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:3:17","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"多部分/URL 编码绑定 多种类型绑定 1 2 3 4 5 6 type ProfileForm struct { Name string `form:\"name\" binding:\"required\"` Avatar *multipart.FileHeader `form:\"avatar\" binding:\"required\"` } c.ShouldBind(\u0026form) ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:3:18","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"XML、JSON、YAML、TOML 和 ProtoBuf 渲染 1 2 3 4 5 6 7 8 9 10 11 12 13 c.JSON(http.StatusOK, gin.H{\"message\": \"hey\", \"status\": http.StatusOK}) var msg struct { Name string `json:\"user\"` Message string Number int } msg.Name = \"Lena\" msg.Message = \"hey\" msg.Number = 123 // Note that msg.Name becomes \"user\" in the JSON // Will output : {\"user\": \"Lena\", \"Message\": \"hey\", \"Number\": 123} c.JSON(http.StatusOK, msg) 1 2 3 c.XML(http.StatusOK, gin.H{\"message\": \"hey\", \"status\": http.StatusOK}) c.YAML(http.StatusOK, gin.H{\"message\": \"hey\", \"status\": http.StatusOK}) c.TOML(http.StatusOK, gin.H{\"message\": \"hey\", \"status\": http.StatusOK}) 1 2 3 4 5 6 7 8 9 10 reps := []int64{int64(1), int64(2)} label := \"test\" // The specific definition of protobuf is written in the testdata/protoexample file. data := \u0026protoexample.Test{ Label: \u0026label, Reps: reps, } // Note that data becomes binary data in the response // Will output protoexample.Test protobuf serialized data c.ProtoBuf(http.StatusOK, data) ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:3:19","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"安全JSON 防止 json 劫持 1 c.SecureJSON(http.StatusOK, names) ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:3:20","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"JSONP 从不同域中的服务器请求数据。如果查询参数回调存在，则将回调添加到响应主体。 1 c.JSONP(http.StatusOK, data) ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:3:21","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"提供静态文件 1 2 3 4 5 6 7 //设置静态资源路径 r.Static(\"/assets\", \"./assets\") //设置FS，目录下不存 index.html 文件时，会列出该目录下的所有文件 r.StaticFS(\"/more_static\", http.Dir(\"my_file_system\")) //指定某个具体的文件作为静态资源访问 r.StaticFile(\"/favicon.ico\", \"./resources/favicon.ico\") r.StaticFileFS(\"/more_favicon.ico\", \"more_favicon.ico\", http.Dir(\"my_file_system\")) ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:3:22","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"从文件提供数据 1 2 3 4 5 6 //从默认静态资源寻找文件 c.File(\"local/file.go\") //从某个FS找文件 var fs http.FileSystem = // ... c.FileFromFS(\"fs/file.go\", fs) ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:3:23","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"重定向 HTTP 重定向支持内部和外部位置 1 2 3 4 //外部位置 c.Redirect(http.StatusMovedPermanently, \"http://www.google.com/\") //内部位置 c.Redirect(http.StatusFound, \"/foo\") 路由器重定向 1 2 c.Request.URL.Path = \"/test2\" r.HandleContext(c) ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:3:24","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"自定义中间件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func Logger() gin.HandlerFunc { return func(c *gin.Context) { t := time.Now() // Set example variable c.Set(\"example\", \"12345\") // before request c.Next() // after request latency := time.Since(t) log.Print(latency) // access the status we are sending status := c.Writer.Status() log.Println(status) } } r.Use(Logger()) ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:3:25","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"中间件内的协程 中间件或处理程序中启动新的 Goroutine 时，你不应该使用其中的原始上下文，你必须使用只读副本 1 2 3 4 5 6 7 8 cCp := c.Copy() go func() { // simulate a long task with time.Sleep(). 5 seconds time.Sleep(5 * time.Second) // note that you are using the copied context \"cCp\", IMPORTANT log.Println(\"Done! in path \" + cCp.Request.URL.Path) }() ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:3:26","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"自定义 HTTP 配置 直接使用http.ListenAndServe()使用默认构造的Server对象 1 2 3 4 func main() { router := gin.Default() http.ListenAndServe(\":8080\", router) } 自己新建一个Server对象 1 2 3 4 5 6 7 8 9 10 11 12 func main() { router := gin.Default() s := \u0026http.Server{ Addr: \":8080\", Handler: router, ReadTimeout: 10 * time.Second, WriteTimeout: 10 * time.Second, MaxHeaderBytes: 1 \u003c\u003c 20, } s.ListenAndServe() } ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:3:27","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"HTTPS 单行配置 1 2 3 4 5 6 7 8 9 10 func main() { r := gin.Default() // Ping handler r.GET(\"/ping\", func(c *gin.Context) { c.String(http.StatusOK, \"pong\") }) log.Fatal(autotls.Run(r, \"example1.com\", \"example2.com\")) } 自定义自动证书管理器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func main() { r := gin.Default() // Ping handler r.GET(\"/ping\", func(c *gin.Context) { c.String(http.StatusOK, \"pong\") }) m := autocert.Manager{ Prompt: autocert.AcceptTOS, HostPolicy: autocert.HostWhitelist(\"example1.com\", \"example2.com\"), Cache: autocert.DirCache(\"/var/www/.cache\"), } log.Fatal(autotls.RunWithManager(r, \u0026m)) } ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:3:28","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"使用 Gin 运行多个服务 gin定义的Router(*gin.Engine)其实就是标准net/http包的ServeMux，所以要启动多个服务就需要通过gin定义多个Router，然后使用协程启动定义多个Server对象来启动多个服务。 ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:3:29","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"使用自定义结构绑定表单数据请求 gin会自动查询内嵌结构体的字段来绑定，不需要一定是匿名结构体 1 2 3 4 5 6 7 8 9 10 type StructA struct { FieldA string `form:\"field_a\"` } type StructB struct { NestedStruct StructA FieldB string `form:\"field_b\"` } c.Bind(\u0026b) ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:3:30","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"不要相信所有代理 对于代理过的请求，我们可以设置信任的代理服务器来丢弃不信任的代理过的请求 1 router.SetTrustedProxies([]string{\"192.168.1.2\"}) ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:4:0","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"测试 net/http/httptest包 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func setupRouter() *gin.Engine { r := gin.Default() r.GET(\"/ping\", func(c *gin.Context) { c.String(http.StatusOK, \"pong\") }) return r } func TestPingRoute(t *testing.T) { router := setupRouter() w := httptest.NewRecorder() req, _ := http.NewRequest(http.MethodGet, \"/ping\", nil) router.ServeHTTP(w, req) assert.Equal(t, http.StatusOK, w.Code) assert.Equal(t, \"pong\", w.Body.String()) } ","date":"2022-12-25","objectID":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/:5:0","tags":["gin"],"title":"golang-gin-简介","uri":"/posts/golang/gin/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"go语言中文网 godoc go语言中文网有很多文档缺少内容比如string.Builder就没有，godoc绝对详尽，推荐阅读godoc ","date":"2022-12-24","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/math/:0:0","tags":["go标准库"],"title":"go标准库-Math","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/math/"},{"categories":["Golang"],"content":"math包 ","date":"2022-12-24","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/math/:1:0","tags":["go标准库"],"title":"go标准库-Math","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/math/"},{"categories":["Golang"],"content":"Constants 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 const ( E = 2.71828182845904523536028747135266249775724709369995957496696763 // A001113 Pi = 3.14159265358979323846264338327950288419716939937510582097494459 // A000796 Phi = 1.61803398874989484820458683436563811772030917980576286213544862 // A001622 Sqrt2 = 1.41421356237309504880168872420969807856967187537694807317667974 // A002193 SqrtE = 1.64872127070012814684865078781416357165377610071014801157507931 // A019774 SqrtPi = 1.77245385090551602729816748334114518279754945612238712821380779 // A002161 SqrtPhi = 1.27201964951406896425242246173749149171560804184009624861664038 // A139339 Ln2 = 0.693147180559945309417232121458176568075500134360255254120680009 // A002162 Log2E = 1 / Ln2 Ln10 = 2.30258509299404568401799145468436420760110148862877297603332790 // A002392 Log10E = 1 / Ln10 ) const ( MaxFloat32 = 3.40282346638528859811704183484516925440e+38 // 2**127 * (2**24 - 1) / 2**23 SmallestNonzeroFloat32 = 1.401298464324817070923729583289916131280e-45 // 1 / 2**(127 - 1 + 23) MaxFloat64 = 1.797693134862315708145274237317043567981e+308 // 2**1023 * (2**53 - 1) / 2**52 SmallestNonzeroFloat64 = 4.940656458412465441765687928682213723651e-324 // 1 / 2**(1023 - 1 + 52) ) const ( intSize = 32 \u003c\u003c (^uint(0) \u003e\u003e 63) // 32 or 64 MaxInt = 1\u003c\u003c(intSize-1) - 1 // MaxInt32 or MaxInt64 depending on intSize. MinInt = -1 \u003c\u003c (intSize - 1) // MinInt32 or MinInt64 depending on intSize. MaxInt8 = 1\u003c\u003c7 - 1 // 127 MinInt8 = -1 \u003c\u003c 7 // -128 MaxInt16 = 1\u003c\u003c15 - 1 // 32767 MinInt16 = -1 \u003c\u003c 15 // -32768 MaxInt32 = 1\u003c\u003c31 - 1 // 2147483647 MinInt32 = -1 \u003c\u003c 31 // -2147483648 MaxInt64 = 1\u003c\u003c63 - 1 // 9223372036854775807 MinInt64 = -1 \u003c\u003c 63 // -9223372036854775808 MaxUint = 1\u003c\u003cintSize - 1 // MaxUint32 or MaxUint64 depending on intSize. MaxUint8 = 1\u003c\u003c8 - 1 // 255 MaxUint16 = 1\u003c\u003c16 - 1 // 65535 MaxUint32 = 1\u003c\u003c32 - 1 // 4294967295 MaxUint64 = 1\u003c\u003c64 - 1 // 18446744073709551615 ) ","date":"2022-12-24","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/math/:1:1","tags":["go标准库"],"title":"go标准库-Math","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/math/"},{"categories":["Golang"],"content":"重要函数 func Ceil(x float64) float64：返回不小于x的最小整数（的浮点值） func Floor(x float64) float64：返回不大于x的最大整数（的浮点值） func Trunc(x float64) float64：返回x的整数部分（的浮点值） func Modf(f float64) (int float64, frac float64)：返回f的整数部分和小数部分，结果的正负号都和f相同 func Abs(x float64) float64：返回x的绝对值 func Round(x float64) float64：四舍五入 func Max(x, y float64) float64：返回x和y中最大值 func Min(x, y float64) float64：返回x和y中最小值 func Sqrt(x float64) float64：返回x的二次方根 func Sin(x float64) float64 func Cos(x float64) float64 func Tan(x float64) float64 func Log2 ：求2为底的对数 func Pow(x, y float64) float64：返回x**y ","date":"2022-12-24","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/math/:1:2","tags":["go标准库"],"title":"go标准库-Math","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/math/"},{"categories":["Golang"],"content":"math/rand ","date":"2022-12-24","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/math/:2:0","tags":["go标准库"],"title":"go标准库-Math","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/math/"},{"categories":["Golang"],"content":"func Intn(n int) int 返回一个取值范围在[0,n)的伪随机int值，如果n\u003c=0会panic。 ","date":"2022-12-24","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/math/:2:1","tags":["go标准库"],"title":"go标准库-Math","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/math/"},{"categories":["Golang"],"content":"以时间为种子的随机数 1 2 r := rand.New(rand.NewSource(time.Now().UnixNano())) r.Intn(max) ","date":"2022-12-24","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/math/:2:2","tags":["go标准库"],"title":"go标准库-Math","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/math/"},{"categories":["Golang"],"content":"math/big 该包实现任意精度算术，主要是Float，Int和Rat（复数） ","date":"2022-12-24","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/math/:3:0","tags":["go标准库"],"title":"go标准库-Math","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/math/"},{"categories":["Golang"],"content":"Int 重要函数 func NewInt(x int64 ) * Int：NewInt 分配并返回一个设置为 x 的新 Int 重要方法 func (x * Int ) Cmp(y * Int ) (r int )：比较x和y的值，x\u003cy返回-1，x==y返回0，x\u003ey返回1， func (x * Int ) Int64() int64：返回x的int64表示，无法表示时结果不确定 func (z * Int ) Add(x, y * Int ) * Int：x+y的值给z并返回z func (z * Int ) Mul(x, y * Int ) * Int：x*y的值给z并返回z func (z * Int ) Mod(x, y * Int ) * Int：x%y的值给z并返回z ","date":"2022-12-24","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/math/:3:1","tags":["go标准库"],"title":"go标准库-Math","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/math/"},{"categories":["数据库"],"content":"本系列笔记为作者在跟随小林coding学习的时候做的笔记。感谢小林大大。 ","date":"2022-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E7%BC%93%E5%AD%98%E7%AF%87/:0:0","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-缓存篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E7%BC%93%E5%AD%98%E7%AF%87/"},{"categories":["数据库"],"content":"缓存雪崩、击穿、穿透 ","date":"2022-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E7%BC%93%E5%AD%98%E7%AF%87/:1:0","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-缓存篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E7%BC%93%E5%AD%98%E7%AF%87/"},{"categories":["数据库"],"content":"缓存雪崩 本质：大量请求来到数据库 原因：大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机 解决方法： 大量缓存数据在同一时间过期（失效） 均匀设置过期时间，给过期时间添加随机数 如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存 Redis 故障宕机 服务熔断或请求限流机制 构建 Redis 缓存高可靠集群 ","date":"2022-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E7%BC%93%E5%AD%98%E7%AF%87/:1:1","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-缓存篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E7%BC%93%E5%AD%98%E7%AF%87/"},{"categories":["数据库"],"content":"缓存击穿 本质：大量单一热点数据请求直达数据库 原因：缓存中的某个热点数据过期了 解决办法 互斥锁方案 热点数据不设置过期时间 ","date":"2022-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E7%BC%93%E5%AD%98%E7%AF%87/:1:2","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-缓存篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E7%BC%93%E5%AD%98%E7%AF%87/"},{"categories":["数据库"],"content":"缓存穿透 本质：大量非法请求直达数据库 原因：业务误操作或黑客恶意攻击 解决办法 非法请求的限制 缓存空值或者默认值 使用bloom过滤器快速判断数据是否存在 ","date":"2022-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E7%BC%93%E5%AD%98%E7%AF%87/:1:3","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-缓存篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E7%BC%93%E5%AD%98%E7%AF%87/"},{"categories":["数据库"],"content":"总结 ","date":"2022-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E7%BC%93%E5%AD%98%E7%AF%87/:1:4","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-缓存篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E7%BC%93%E5%AD%98%E7%AF%87/"},{"categories":["数据库"],"content":"数据库和缓存如何保证一致性 所有的问题都是并发导致的，先修改数据库还是先修改缓存，当两个修改请求来时第一个请求先修改了数据库（缓存），第二个请求修改完数据库和缓存，最后第一个请求修改缓存（数据库）就会出现不一致现象。 如果我们的业务对缓存命中率有很高的要求，我们可以采用「更新数据库 + 更新缓存」的方案，因为更新缓存并不会出现缓存未命中的情况 如果对命中率要求不高的话，使用的是更新数据库再删除缓存，go-zero是这样的 ","date":"2022-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E7%BC%93%E5%AD%98%E7%AF%87/:2:0","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-缓存篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E7%BC%93%E5%AD%98%E7%AF%87/"},{"categories":["数据库"],"content":"本系列笔记为作者在跟随小林coding学习的时候做的笔记。感谢小林大大。 ","date":"2022-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AF%87/:0:0","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-高可用篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AF%87/"},{"categories":["数据库"],"content":"主从复制是怎么实现 全量复制、基于长连接的命令传播、增量复制 ","date":"2022-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AF%87/:1:0","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-高可用篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AF%87/"},{"categories":["数据库"],"content":"第一次同步 replicaof命令： 1 2 # 服务器 B 执行这条命令 replicaof \u003c服务器 A 的 IP 地址\u003e \u003c服务器 A 的 Redis 端口号\u003e 第一阶段：建立链接、协商同步: 通过psync命令获取主服务器的 runID 和复制进度 offset 第二阶段分为: 主服务器生成 RDB 文件； 主服务器发送 RDB 文件给从服务器； 「从服务器」加载 RDB 文件； 在此期间将写操作命令写入到 replication buffer 缓冲区 第三阶段：发送replication buffer 缓冲区的写操作 ","date":"2022-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AF%87/:1:1","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-高可用篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AF%87/"},{"categories":["数据库"],"content":"命令传播 完成第一次同步后，维护一个TCP长连接，通过这个连接将写操作命令传播给从服务器。称为基于长连接的命令传播 ","date":"2022-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AF%87/:1:2","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-高可用篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AF%87/"},{"categories":["数据库"],"content":"分摊主服务器的压力 从服务器可以有自己的从服务器 ","date":"2022-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AF%87/:1:3","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-高可用篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AF%87/"},{"categories":["数据库"],"content":"增量复制 网络出问题后又恢复时 psync传输主服务器ID和offset继续同步写命令 ","date":"2022-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AF%87/:1:4","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-高可用篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AF%87/"},{"categories":["数据库"],"content":"哨兵 实现主从节点故障转移 ","date":"2022-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AF%87/:2:0","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-高可用篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AF%87/"},{"categories":["数据库"],"content":"判断主节点故障 每隔1秒给所有主从节点发送ping命令，没有在down-after-milliseconds参数规定的时间内响应则标记为主观下线 哨兵集群（最少需要三台机器来部署哨兵集群）减少误判的情况 当某个哨兵主观下线主节点时，会向其他哨兵询问主节点是否下线，当收到quorum个主观下线结果时，将主节点标记为客观下线。quorum参数通常是哨兵个数除以2加1 ","date":"2022-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AF%87/:2:1","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-高可用篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AF%87/"},{"categories":["数据库"],"content":"主从故障转移的过程 当主节点客观下线时就需要在从节点中选出一个新的主节点，这个过程由一个leader来执行。 标记主节点客观下线的哨兵作为leader候选者，询问其他哨兵是否赞成我作为leader，每个哨兵只能投一次票，拿到Max(半数+1，quorum)的赞成票则得知自己为leader 步骤一：选出新主节点 从节点中选一个节点转换为新主节点 步骤二：将从节点指向新主节点 让其他从节点修改复制目标为新主节点 步骤三：通知客户的主节点已更换 通过发布者订阅者机制通知客户端新主节点的ip地址和信息 步骤四：将旧主节点变为从节点 监视旧主节点，上线后转换为从节点 ","date":"2022-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AF%87/:2:2","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-高可用篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AF%87/"},{"categories":["数据库"],"content":"本系列笔记为作者在跟随小林coding学习的时候做的笔记。感谢小林大大。 ","date":"2022-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E5%8A%9F%E8%83%BD%E7%AF%87/:0:0","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-功能篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E5%8A%9F%E8%83%BD%E7%AF%87/"},{"categories":["数据库"],"content":"过期删除策略 设置 key 过期时间的命令: expire \u003ckey\u003e \u003cn\u003e:key 在 n 秒后过期 pexpire \u003ckey\u003e \u003cn\u003e:key 在 n 毫秒后过期 expireat \u003ckey\u003e \u003cn\u003e:key 在某个时间戳（精确到秒）之后过期 pexpireat \u003ckey\u003e \u003cn\u003e:key 在某个时间戳（精确到毫秒）之后过期 设置字符串时顺便添加过期时间：ex选项（秒）和px选项（毫秒） ","date":"2022-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E5%8A%9F%E8%83%BD%E7%AF%87/:1:0","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-功能篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E5%8A%9F%E8%83%BD%E7%AF%87/"},{"categories":["数据库"],"content":"判定 key 已过期 过期字典存储过期时刻 数据结构\r","date":"2022-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E5%8A%9F%E8%83%BD%E7%AF%87/:1:1","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-功能篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E5%8A%9F%E8%83%BD%E7%AF%87/"},{"categories":["数据库"],"content":"过期删除策略 定时删除：由定时事件处理器执行 key 的删除操作 惰性删除：访问key时对过期key进行删除 定期删除：每隔一段时间「随机」取出一定数量的 key 进行检查，并删除过期key ","date":"2022-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E5%8A%9F%E8%83%BD%E7%AF%87/:1:2","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-功能篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E5%8A%9F%E8%83%BD%E7%AF%87/"},{"categories":["数据库"],"content":"Redis 过期删除策略 Redis 选择「惰性删除+定期删除」 惰性删除\r定期删除周期10s，抽取数量写死在代码里20个 定期删除\r","date":"2022-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E5%8A%9F%E8%83%BD%E7%AF%87/:1:3","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-功能篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E5%8A%9F%E8%83%BD%E7%AF%87/"},{"categories":["数据库"],"content":"内存淘汰策略 ","date":"2022-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E5%8A%9F%E8%83%BD%E7%AF%87/:2:0","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-功能篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E5%8A%9F%E8%83%BD%E7%AF%87/"},{"categories":["数据库"],"content":"设置 Redis 最大运行内存 redis.conf 参数 maxmemory \u003cbytes\u003e ","date":"2022-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E5%8A%9F%E8%83%BD%E7%AF%87/:2:1","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-功能篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E5%8A%9F%E8%83%BD%E7%AF%87/"},{"categories":["数据库"],"content":"内存淘汰策略有哪些 不进行数据淘汰的策略：noeviction默认的内存淘汰策略，超过时触发 OOM 进行数据淘汰的策略：淘汰具有过期时间的数据volatile-random，volatile-ttl，volatile-lru，volatile-lfu；所有数据范围内进行淘汰allkeys-random，allkeys-lru，allkeys-lfu Redis 如何实现 LRU 算法：Redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间 Redis 如何实现 LFU 算法：多记录了「数据的访问频次」的信息（随时间递减） ","date":"2022-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E5%8A%9F%E8%83%BD%E7%AF%87/:2:2","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-功能篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E5%8A%9F%E8%83%BD%E7%AF%87/"},{"categories":["数据库"],"content":"本系列笔记为作者在跟随小林coding学习的时候做的笔记。感谢小林大大。 ","date":"2022-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%8C%81%E4%B9%85%E5%8C%96%E7%AF%87/:0:0","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-持久化篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%8C%81%E4%B9%85%E5%8C%96%E7%AF%87/"},{"categories":["数据库"],"content":"AOF 持久化 AOF(Append Only File)：写命令执行完后将命令存储到硬盘中的日志文件 AOF\r默认是不开启，开启需要修改 redis.conf 配置文件 1 2 appendonly yes appendfilename \"appendonly.aof\" ","date":"2022-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%8C%81%E4%B9%85%E5%8C%96%E7%AF%87/:1:0","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-持久化篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%8C%81%E4%B9%85%E5%8C%96%E7%AF%87/"},{"categories":["数据库"],"content":"三种写回策略 redis.conf 配置文件中的 appendfsync 参数 ","date":"2022-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%8C%81%E4%B9%85%E5%8C%96%E7%AF%87/:1:1","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-持久化篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%8C%81%E4%B9%85%E5%8C%96%E7%AF%87/"},{"categories":["数据库"],"content":"AOF 重写机制 AOF 重写机制： AOF 文件的大小超过所设定的阈值后，将每一个当前存储的键值对用一条命令记录到「新的 AOF 文件」，并替换掉现有的 AOF 文件 ","date":"2022-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%8C%81%E4%B9%85%E5%8C%96%E7%AF%87/:1:2","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-持久化篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%8C%81%E4%B9%85%E5%8C%96%E7%AF%87/"},{"categories":["数据库"],"content":"AOF 后台重写 重写 AOF 过程是由后台子进程 bgrewriteaof 来完成的，好处： 避免阻塞主进程； 子进程带有主进程的数据副本（fork命令特性，另外还有仅复制页表的写时复制(Copy On Write)） 2个阻塞父进程的时机： fork复制页表时 子进程或父进程（主要）触发写时复制时拷贝物理内存 bgrewriteaof 子进程会设置AOF 重写缓冲区，存储重写AOF期间主进程执行的命令。主进程会同时将写命令存到 「AOF 缓冲区」和 「AOF 重写缓冲区」 AOF 重写期间，主进程需要执行： 执行客户端发来的命令 将执行后的写命令追加到 「AOF 缓冲区」 将执行后的写命令追加到 「AOF 重写缓冲区」 子进程完成 AOF 重写工作后，向主进程发送一条异步信号。主进程收到信号后执行： 将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中 新的 AOF 的文件进行改名，覆盖现有的 AOF 文件 ","date":"2022-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%8C%81%E4%B9%85%E5%8C%96%E7%AF%87/:1:3","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-持久化篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%8C%81%E4%B9%85%E5%8C%96%E7%AF%87/"},{"categories":["数据库"],"content":"RDB 快照 记录某一个瞬间的内存数据，记录的是实际数据 AOF 文件的内容是操作命令 RDB 文件的内容是二进制数据 ","date":"2022-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%8C%81%E4%B9%85%E5%8C%96%E7%AF%87/:2:0","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-持久化篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%8C%81%E4%B9%85%E5%8C%96%E7%AF%87/"},{"categories":["数据库"],"content":"快照怎么用 save（阻塞主进程） 和 bgsave（不阻塞主进程） 生成 RDB 文件 900 秒之内，对数据库进行了至少 1 次修改 save 900 1 通常可能设置至少 5 分钟才保存一次快照 ","date":"2022-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%8C%81%E4%B9%85%E5%8C%96%E7%AF%87/:2:1","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-持久化篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%8C%81%E4%B9%85%E5%8C%96%E7%AF%87/"},{"categories":["数据库"],"content":"save执行过程中数据能被修改吗 写时复制技术（Copy-On-Write, COW），交给子进程来构建 RDB 文件，主线程还是可以继续工作 极端情况下，如果所有的共享内存都被修改，则此时的内存占用是原先的 2 倍可能会占满内存 ","date":"2022-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%8C%81%E4%B9%85%E5%8C%96%E7%AF%87/:2:2","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-持久化篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%8C%81%E4%B9%85%E5%8C%96%E7%AF%87/"},{"categories":["数据库"],"content":"RDB 和 AOF 合体 混合使用 AOF 日志和内存快照，也叫混合持久化 aof-use-rdb-preamble yes ","date":"2022-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%8C%81%E4%B9%85%E5%8C%96%E7%AF%87/:2:3","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-持久化篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%8C%81%E4%B9%85%E5%8C%96%E7%AF%87/"},{"categories":["数据库"],"content":"大key 避免使用大key 在复制页表时以及写时复制时降低AOF效率 进而引发客户端超时阻塞 引发网络阻塞 阻塞工作线程（del） 内存分布不均 ","date":"2022-12-23","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%8C%81%E4%B9%85%E5%8C%96%E7%AF%87/:3:0","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-持久化篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%8C%81%E4%B9%85%E5%8C%96%E7%AF%87/"},{"categories":["中间件"],"content":"官方文档 CSDN luslin1711 CSDN 乾坤鸟 Docker安装Kafka教程（超详细） ","date":"2022-12-23","objectID":"/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/:0:0","tags":["kafka"],"title":"中间件-Kafka","uri":"/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/"},{"categories":["中间件"],"content":"简介 Kafka 结合了三个关键功能 发布（写入）和订阅（读取）事件流。 持久可靠地存储事件 流。 在事件发生时或回顾性 地处理事件流。 Kafka 是一个分布式系统，由通过高性能TCP 网络协议进行通信的服务器和客户端组成。可以部署在本地和云环境中的裸机硬件、虚拟机和容器上。 服务器（Broker）：Kafka 作为一个或多个服务器集群运行，可以跨越多个数据中心或云区域。 客户端：它们允许您编写分布式应用程序和微服务，即使在出现网络问题或机器故障的情况下，也能以容错的方式并行、大规模地读取、写入和处理事件流。 ","date":"2022-12-23","objectID":"/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/:1:0","tags":["kafka"],"title":"中间件-Kafka","uri":"/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/"},{"categories":["中间件"],"content":"主要概念和术语 事件记录了世界上或您的企业中“发生了某事” 的事实。事件具有键、值、时间戳和可选的元数据标头。比如： 活动键：“爱丽丝” 事件值：“向 Bob 支付了 200 美元” 事件时间戳：“2020 年 6 月 25 日下午 2:06” 生产者是那些向 Kafka 发布（写入）事件的客户端应用程序，而消费者是那些订阅（读取和处理）这些事件的客户端应用程序。 事件被组织并持久存储在主题中。主题类似于文件系统中的文件夹，事件是该文件夹中的文件。 Kafka 中的主题始终是多生产者和多订阅者。 事件在消费后不会被删除。可以配置每个主题保留事件时间，之后旧事件将被丢弃。 主题是分区的，这意味着一个主题分布在位于不同 Kafka 代理上的多个“桶”中。 当一个新事件被发布到一个主题时，它实际上被附加到主题的分区之一。 具有相同事件键（例如，客户或车辆 ID）的事件将写入同一分区，并且 Kafka保证给定主题分区的任何消费者将始终以与写入事件完全相同的顺序读取该分区的事件。 为了使您的数据具有容错性和高可用性，每个主题都可以被复制，甚至可以跨地理区域或数据中心，以便始终有多个代理拥有数据副本。一个常见的生产设置是复制因子 3，即你的数据总是有三个副本。这种复制是在主题分区级别执行的。 Broker Kafka集群包含一个或多个服务器，这种服务器被称为broker Topic 每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处） Partition Partition是物理上的概念，每个Topic包含一个或多个Partition. Producer 负责发布消息到Kafka broker Consumer 消息消费者，向Kafka broker读取消息的客户端。 Consumer Group 每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）。 ","date":"2022-12-23","objectID":"/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/:2:0","tags":["kafka"],"title":"中间件-Kafka","uri":"/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/"},{"categories":["中间件"],"content":"docker安装 见乾坤鸟博客 ","date":"2022-12-23","objectID":"/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/:3:0","tags":["kafka"],"title":"中间件-Kafka","uri":"/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/"},{"categories":["中间件"],"content":"传递的消息是什么 就是一个字符串，一般是序列化的json对象，比如go-zero的kq就是通过方法Push传送对象的 serviceContext.go 1 2 3 4 type ServiceContext struct { ... KqueuePaymentUpdatePayStatusClient *kq.Pusher } updateTradeStateLogic.go 1 2 3 4 func (l *UpdateTradeStateLogic) pubKqPaySuccess(orderSn string,payStatus int64) error{ ... return l.svcCtx.KqueuePaymentUpdatePayStatusClient.Push(string(body)) } ","date":"2022-12-23","objectID":"/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/:4:0","tags":["kafka"],"title":"中间件-Kafka","uri":"/posts/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/"},{"categories":["通用技术"],"content":"操作系统内核空间安装在最高的地址 大端小端的说法是针对低地址存高字节还是低字节来说的 大端为低地址存高字节 小端为低地址存低字节 ","date":"2022-12-22","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF/:0:0","tags":[],"title":"通用技术-大端小端","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF/"},{"categories":["数据库"],"content":"本系列笔记为作者在跟随小林coding学习的时候做的笔记。感谢小林大大。 redis 命令参考 ","date":"2022-12-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AF%87/:0:0","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-数据类型篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AF%87/"},{"categories":["数据库"],"content":"逻辑数据类型 ","date":"2022-12-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AF%87/:1:0","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-数据类型篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AF%87/"},{"categories":["数据库"],"content":"String int 或 SDS实现 编码方式和ptr指向的数据结构有关 int\rembstr\rraw\r保存文本数据或二进制数据 获取字符串长度的时间复杂度是 O(1) 拼接字符串不会造成缓冲区溢出 value 最多可以容纳的数据长度是 512M（2^28） 常用指令 SET key value:设置 key-value 类型的值 GET key:根据 key 获得对应的 value EXISTS key:判断某个 key 是否存在 STRLEN key:返回 key 所储存的字符串值的长度 DEL key:删除某个 key 对应的值 批量操作 MSET key1 value1 key2 value2:批量设置 key-value 类型的值 MGET key1 key2:批量获取多个 key 对应的 value 字符串的内容为整数的时候可以使用） INCR key:将 key 中储存的数字值增一 INCRBY key n:将key中存储的数字值加 n DECR key:将 key 中储存的数字值减一 DECRBY key n:将key中存储的数字值减 n 过期（默认为永不过期） EXPIRE key n:设置 key 在 n 秒后过期（该方法是针对已经存在的key设置过期时间） TTL key:查看数据还有多久过期 SET key value EX n:设置 key-value 类型的值，并设置该key的过期时间为 n 秒 SETEX key n value:设置 key-value 类型的值，并设置该key的过期时间为 n 秒 不存在就插入 SETNX key value:不存在就插入（not exists） 应用场景:缓存对象（json，mset），常规计数，分布式锁（SETNX）和共享 Session 信息 ","date":"2022-12-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AF%87/:1:1","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-数据类型篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AF%87/"},{"categories":["数据库"],"content":"List 按照插入顺序排序，可以操作头部和尾部 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了 最大长度为 2^32 - 1 list\r常用命令 LPUSH key value [value …]:将一个或多个值value依次插入到key列表最左边 RPUSH key value [value …]:将一个或多个值value依次插入到key列表最右边 LPOP key:移除并返回key列表的最左元素 RPOP key:移除并返回key列表的最右元素 LRANGE key start stop:返回列表key中从左往右索引为[start,stop]区间内的元素，索引从0开始 BLPOP key [key …] timeout:从key列表左边弹出一个元素，没有元素就阻塞timeout秒，timeout=0一直阻塞 BRPOP key [key …] timeout:从key列表右边弹出一个元素，没有元素就阻塞timeout秒，timeout=0一直阻塞 RPOPLPUSH source destination 应用场景:消息队列 消息保序：使用 LPUSH + RPOP 阻塞读取：使用 BRPOP 重复消息处理：生产者自行实现全局唯一 ID 消息的可靠性：使用 BRPOPLPUSH 消息队列\r","date":"2022-12-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AF%87/:1:2","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-数据类型篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AF%87/"},{"categories":["数据库"],"content":"Hash Hash 是一个键值对（key - value）集合 hash\r元素个数最大为512个，所有值小于64Byte使用压缩列表 否则使用哈希表 常用命令 HSET key field value:哈希表key存储一个的键值对(field,value) HGET key field:获取哈希表key中field键的值 HMSET key field value [field value…]:哈希表key中存储多个键值对 HMGET key field [field …]:批量获取哈希表key中多个field键的值 HDEL key field [field …]:删除哈希表key中的field键值对 HLEN key:返回哈希表key中field的数量 HGETALL key:返回哈希表key中所有的键值对 HINCRBY key field n:为哈希表key中field键的值加上增量n 应用场景：缓存对象，购物车 ","date":"2022-12-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AF%87/:1:3","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-数据类型篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AF%87/"},{"categories":["数据库"],"content":"Set Set是无序并唯一的值集合 最多2^32-1个元素 小于512个元素，使用整数集合实现 否则使用哈希表实现 常用命令 SADD key member [member …]:往集合key中存入元素member，元素存在则忽略 SREM key member [member …]:从集合key中删除元素member SMEMBERS key:获取集合key中所有元素 SCARD key:获取集合key中的元素个数 SISMEMBER key member:判断member元素是否存在于集合key中 SRANDMEMBER key [count]:从集合key中随机选出count个元素，元素不从key中删除 SPOP key [count]:从集合key中随机选出count个元素，元素从key中删除 Set运算操作 SINTER key [key …]:返回交集运算的结果 SINTERSTORE destination key [key …]:将交集结果存入新集合destination中 SUNION key [key …]:返回并集运算的结果 SUNIONSTORE destination key [key …]:将并集结果存入新集合destination中 SDIFF key [key …]:返回差集运算的结果 SDIFFSTORE destination key [key …]:将差集结果存入新集合destination中 应用场景：点赞，共同关注 ","date":"2022-12-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AF%87/:1:4","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-数据类型篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AF%87/"},{"categories":["数据库"],"content":"Zset Zset 类型（有序集合类型）相比于 Set 类型多了一个排序属性 score（分值），分值可以重复 每个存储元素相当于有两个值组成的，一个是有序集合的元素值，一个是排序值 Zset\r元素小于128个，每个元素值小于64字节时用listpack实现 否则使用跳表实现 常用命令 ZADD key score member [[score member]…]:插入带score分值的member元素 ZREM key member [member…]:删除member元素 ZSCORE key member:member元素的分值 ZCARD key:元素个数 ZINCRBY key increment member:元素member的分值加上increment ZRANGE key start stop [WITHSCORES]:升序获取分值排名start到stop的元素，以排名以0开始 ZREVRANGE key start stop [WITHSCORES]:降序获取分值排名start到stop的元素，以排名以0开始 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]:升序获取分数值在[min,max]区间的元素 ZRANGEBYLEX key min max [LIMIT offset count]:按字典序升序获取元素值在[min,max]区间的元素 Zset 运算操作（没有支持差集运算） ZUNIONSTORE destkey numberkeys key [key…]:并集计算，相同key的分值score相加 ZINTERSTORE destkey numberkeys key [key…]:交集计算，相同key的分值score相加 应用场景：排行榜，电话、姓名排序 ","date":"2022-12-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AF%87/:1:5","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-数据类型篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AF%87/"},{"categories":["数据库"],"content":"物理结构 type，标识该对象是什么类型的对象（String 对象、 List 对象、Hash 对象、Set 对象和 Zset 对象） encoding，标识该对象使用了哪种底层的数据结构 ptr，指向底层数据结构的指针 ","date":"2022-12-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AF%87/:2:0","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-数据类型篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AF%87/"},{"categories":["数据库"],"content":"SDS O（1）复杂度获取字符串长度 二进制安全，可存储包含 “\\0” 的数据 不会发生缓冲区溢出，Redis自动判断alloc - len，当判断出缓冲区大小不够用时，Redis 会自动扩大 SDS 的空间大小 小于 1 MB翻倍扩容，超过 1 MB 则 newlen + 1MB 节省内存空间，取消结构体在编译过程中的优化对齐，按照实际占用字节数进行对齐 ","date":"2022-12-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AF%87/:2:1","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-数据类型篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AF%87/"},{"categories":["数据库"],"content":"链表 ","date":"2022-12-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AF%87/:2:2","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-数据类型篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AF%87/"},{"categories":["数据库"],"content":"压缩列表 ","date":"2022-12-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AF%87/:2:3","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-数据类型篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AF%87/"},{"categories":["数据库"],"content":"哈希表 Redis 采用了「链式哈希」来解决哈希冲突 渐进式 rehash 步骤: 给「哈希表 2」 分配空间，一般翻一倍大小 在 rehash 期间，新增、删除、查找或者更新操作会顺便将「哈希表 1 」中索引位置上的所有 key-value 迁移到「哈希表 2」 上 「哈希表 1 」的所有 key-value 迁移到「哈希表 2」时释放「哈希表 1 」，并将「哈希表 2」设置为「哈希表 1 」 rehash条件：负载因子=哈希表已保存键值对数/哈希表大小 负载因子大于等于1且没有进行持久化操作（记录RDB快照或AOF重写）时 负载因子大于等于5时 ","date":"2022-12-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AF%87/:2:4","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-数据类型篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AF%87/"},{"categories":["数据库"],"content":"整数集合 整数集合升级:当新元素需要使用更大的编码方式时，先扩容，然后将旧元素重新赋值，最后添加新元素 ","date":"2022-12-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AF%87/:2:5","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-数据类型篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AF%87/"},{"categories":["数据库"],"content":"跳表 跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表 为什么用跳表而不用平衡树： 内存占用少 范围查找简单 不需要调整子树 ","date":"2022-12-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AF%87/:2:6","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-数据类型篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AF%87/"},{"categories":["数据库"],"content":"quicklist ","date":"2022-12-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AF%87/:2:7","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-数据类型篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AF%87/"},{"categories":["数据库"],"content":"listpack listpack 没有压缩列表中记录前一个节点长度的字段了 ","date":"2022-12-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AF%87/:2:8","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-数据类型篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AF%87/"},{"categories":["数据库"],"content":"本系列笔记为作者在跟随小林coding学习的时候做的笔记。感谢小林大大。 Redis 是一种基于内存的数据库，读写速度非常快，常用于缓存，消息队列、分布式锁等场景。 单线程操作保证原子性 ","date":"2022-12-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%9D%A2%E8%AF%95%E7%AF%87/:0:0","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-面试篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%9D%A2%E8%AF%95%E7%AF%87/"},{"categories":["数据库"],"content":"Redis 与 Memcached 区别 Redis 支持的数据类型更丰富 Redis 支持数据的持久化 Redis 原生支持集群模式 Redis 支持发布订阅模型、Lua 脚本、事务等功能 ","date":"2022-12-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%9D%A2%E8%AF%95%E7%AF%87/:1:0","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-面试篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%9D%A2%E8%AF%95%E7%AF%87/"},{"categories":["数据库"],"content":"为什么用 Redis 作为 MySQL 的缓存 Redis 具备高性能：基于内存 Redis 具备高并发：单机QPS（Query Per Second，每秒钟处理完请求的次数）10w以上，单机mysql不到1w ","date":"2022-12-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%9D%A2%E8%AF%95%E7%AF%87/:2:0","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-面试篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%9D%A2%E8%AF%95%E7%AF%87/"},{"categories":["数据库"],"content":"Redis 数据结构 常见的有五种数据类型： 底层实现 ","date":"2022-12-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%9D%A2%E8%AF%95%E7%AF%87/:3:0","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-面试篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%9D%A2%E8%AF%95%E7%AF%87/"},{"categories":["数据库"],"content":"Redis 线程模型 ","date":"2022-12-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%9D%A2%E8%AF%95%E7%AF%87/:4:0","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-面试篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%9D%A2%E8%AF%95%E7%AF%87/"},{"categories":["数据库"],"content":"Redis 程序是单线程吗？ Redis 单线程指的是「接收客户端请求-\u003e解析请求 -\u003e进行数据读写等操作-\u003e发送数据给客户端」这个过程是由一个线程（主线程）来完成 Redis 程序并不是单线程的，会启动后台线程完成关闭文件、AOF 刷盘、释放内存等任务 ","date":"2022-12-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%9D%A2%E8%AF%95%E7%AF%87/:4:1","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-面试篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%9D%A2%E8%AF%95%E7%AF%87/"},{"categories":["数据库"],"content":"Redis 为什么这么快 大部分操作都在内存中完成，采用了高效的数据结构，Redis 瓶颈可能是机器的内存大小或者网络带宽，而并非 CPU 单线程模型避免了多线程之间的竞争 I/O 多路复用机制，一个线程处理多个 IO 流，减少开销 ","date":"2022-12-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%9D%A2%E8%AF%95%E7%AF%87/:4:2","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-面试篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%9D%A2%E8%AF%95%E7%AF%87/"},{"categories":["数据库"],"content":"Redis 6.0 之后为什么引入了多线程 Redis 的性能瓶颈有时会出现在网络 I/O 的处理上，使用多线程加速网络 I/O 的处理 但是对于命令的执行，Redis 仍然使用单线程来处理 引入的多线程 I/O 特性对性能提升至少是一倍以上 Redis 6.0 版本之后，Redis 在启动的时候，默认情况下会创建 6 个线程： Redis-server ： Redis的主线程，主要负责执行命令 bio_close_file、bio_aof_fsync、bio_lazy_free：三个后台线程，分别异步处理关闭文件任务、AOF刷盘任务、释放内存任务 io_thd_1、io_thd_2、io_thd_3：三个 I/O 线程，io-threads 默认是 4 ，所以会启动 3（4-1）个 I/O 多线程，用来分担 Redis 网络 I/O 的压力 ","date":"2022-12-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%9D%A2%E8%AF%95%E7%AF%87/:4:3","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-面试篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%9D%A2%E8%AF%95%E7%AF%87/"},{"categories":["数据库"],"content":"Redis 持久化 AOF 日志：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里 RDB 快照：将某一时刻的内存数据，以二进制的方式写入磁盘 混合持久化方式：同时使用 AOF 和 RBD ","date":"2022-12-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%9D%A2%E8%AF%95%E7%AF%87/:5:0","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-面试篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%9D%A2%E8%AF%95%E7%AF%87/"},{"categories":["数据库"],"content":"Redis内存满了会发生什么 在 Redis 的运行内存达到了某个阀值，就会触发内存淘汰机制，这个阀值就是我们设置的最大运行内存，此值在 Redis 的配置文件中可以找到，配置项为 maxmemory ","date":"2022-12-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%9D%A2%E8%AF%95%E7%AF%87/:6:0","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-面试篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%9D%A2%E8%AF%95%E7%AF%87/"},{"categories":["数据库"],"content":"Redis 管道有什么用 将多个命令一起发送给redis执行，解决多个命令执行时的网络等待 ","date":"2022-12-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%9D%A2%E8%AF%95%E7%AF%87/:7:0","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-面试篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%9D%A2%E8%AF%95%E7%AF%87/"},{"categories":["数据库"],"content":"Redis 事务支持回滚吗？ Redis 中并没有提供回滚机制，DISCARD命令也只是情况命令队列 ","date":"2022-12-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%9D%A2%E8%AF%95%E7%AF%87/:8:0","tags":["redis","小林coding系列"],"title":"数据库-redis-小林coding-面试篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%B0%8F%E6%9E%97coding/%E9%9D%A2%E8%AF%95%E7%AF%87/"},{"categories":["数据库"],"content":"本系列笔记为作者在跟随小林coding学习的时候做的笔记。感谢小林大大。 undo log（回滚日志）：Innodb 存储引擎层生成的日志，原子性，用于事务回滚和 MVCC。 redo log（重做日志）：是 Innodb 存储引擎层生成的日志，持久性，用于故障恢复； binlog （归档日志）：Server 层生成的日志，用于数据备份和主从复制； ","date":"2022-12-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E6%97%A5%E5%BF%97%E7%AF%87/:0:0","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-日志篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E6%97%A5%E5%BF%97%E7%AF%87/"},{"categories":["数据库"],"content":"undo log MySQL 会为没有begin和commit的单个语句隐式开启事务 插入一条记录，存记录的主键值，回滚时删掉这个主键值 删除一条记录，存这条记录的所有内容，回滚时插入到表中 更新一条记录，存被更新的列的旧值，回滚时更新为旧值 每条undo日志都有 roll_pointer 指针和trx_id 事务id trx_id 存修改操作的事务 roll_pointer 指针指向被修改的记录。该指针形成的链表就叫版本链 undo log 两大作用： 实现事务回滚，保障事务的原子性 实现 MVCC（多版本并发控制）关键因素之一 ","date":"2022-12-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E6%97%A5%E5%BF%97%E7%AF%87/:1:0","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-日志篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E6%97%A5%E5%BF%97%E7%AF%87/"},{"categories":["数据库"],"content":"Buffer Pool 读取数据需要先从磁盘读取到buffer pool，再从buffer pool读取 修改数据时，仅修改buffer pool，并将响应的页设置为脏页，最后在合适的时候将脏页刷新到磁盘，这也叫做WAL （Write-Ahead Logging）技术 ","date":"2022-12-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E6%97%A5%E5%BF%97%E7%AF%87/:2:0","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-日志篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E6%97%A5%E5%BF%97%E7%AF%87/"},{"categories":["数据库"],"content":"redo log 对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新时就会产生redolog日志，先写脏页再写redolog redo log 和 undo log 区别： redo log 记录事务「完成后」的数据状态，更新之后的值 undo log 记录事务「开始前」的数据状态，更新之前的值 redo log作用： 实现事务的持久性，让 MySQL 有 crash-safe 的能力 将写操作从「随机写」变成了「顺序写」，提升 MySQL 写入磁盘的性能 redo log 不是直接写入磁盘而是写入 redo log buffer，在后续持久化到磁盘 刷盘时机： MySQL 正常关闭 redo log buffer空闲空间少于一半 InnoDB 的后台线程每隔 1 秒 innodb_flush_log_at_trx_commit参数控制每次事务提交时的操作，0不主动触发，1持久化到磁盘，2持久化到page cache（操作系统的页缓存） redo log 文件写满了怎么办 重做日志文件组（redo log Group）由有 2 个 redo log 文件组成，ib_logfile0 和 ib_logfile1 。两个文件循环写。满了就阻塞mysql将脏页写入磁盘，同时清理可以擦除的redolog ","date":"2022-12-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E6%97%A5%E5%BF%97%E7%AF%87/:3:0","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-日志篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E6%97%A5%E5%BF%97%E7%AF%87/"},{"categories":["数据库"],"content":"binlog binlog由服务层生成（可以供其他存储引擎使用），redolog和undolog由innodb存储层生成 一条更新操作后生成一条 binlog，事务提交时将该事务执行过程中产生的所有 binlog 写入 binlog 文件。 binlog 文件只记录所有数据库表结构变更和表数据的修改 主从复制依赖于 binlog。复制的过程是将 binlog 中的数据从主库传输到从库上。该过程默认不需要阻塞主库执行事务（异步） 主从复制过程：主库写 Binlog=》从库同步 Binlog=》从库回放 Binlog 一个主库一般跟 2～3 个从库（1 套数据库，1 主 2 从 1 备主） 主从复制模型： 同步复制：阻塞直到所有从库成功响应，性能太差 异步复制（默认模型）：不阻塞 半同步复制：阻塞直到某一个从库成功响应 binlog日志写到 binlog cache（Server 层的 cache），事务提交的时候再写到 binlog 文件中。一个事务的 binlog 是不能被拆开的 sync_binlog 控制binlog 每次提交事务时的操作 0：只write，不fsync 1：write后立刻fsync N：write，然后提交N个事务后fsync ","date":"2022-12-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E6%97%A5%E5%BF%97%E7%AF%87/:4:0","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-日志篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E6%97%A5%E5%BF%97%E7%AF%87/"},{"categories":["数据库"],"content":"两阶段提交 MySQL 为了避免出现redo log 和 binlog 之间的逻辑不一致的问题，使用了「两阶段提交」来解决 两阶段提交都会存储XID 异常重启通过检查binlog中有没有XID来判断异常时机。如果有则是时刻A，需要进行事务回滚；如果没有则是时刻B，直接将redolog状态修改为commit即可。 ","date":"2022-12-22","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E6%97%A5%E5%BF%97%E7%AF%87/:5:0","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-日志篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E6%97%A5%E5%BF%97%E7%AF%87/"},{"categories":["Golang"],"content":"godoc 作者 EricZhou 博客 github官网 被引用的captcha库github官网 这个包使用base64编码生成的Captcha发送给客户端，之后获取客户端的输入根据id查找答案进行匹配。 不过这个库引用的captcha库说明了这个库可以被先进的OCR识别，所以生产环境还是算了，可以拿来装逼 这个库的关键是使用store接口和driver接口调用base64Captcha.NewCaptcha函数生成一个验证码生成对象Captcha，然后通过Captcha的方法生成base64，store的方法验证字符串 ","date":"2022-12-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/base64captcha/:0:0","tags":["go第三方库"],"title":"go第三方库-Base64Captcha","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/base64captcha/"},{"categories":["Golang"],"content":"store接口 store接口用于存放生成id到base64字符串的映射。base64Captcha.DefaultMemStore为内建stor只能用于单机e。集群部署可以将redis的操作封装到store接口。 store对象通常作为全局变量，因为需要它来进行验证 1 2 3 4 5 6 7 8 9 10 11 type Store interface { // Set sets the digits for the captcha id. Set(id string, value string) // Get returns stored digits for the captcha id. Clear indicates // whether the captcha must be deleted from the store. Get(id string, clear bool) string //Verify captcha's answer directly Verify(id, answer string, clear bool) bool } 使用内建对象： 1 var store = base64Captcha.DefaultMemStore ","date":"2022-12-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/base64captcha/:1:0","tags":["go第三方库"],"title":"go第三方库-Base64Captcha","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/base64captcha/"},{"categories":["Golang"],"content":"driver接口 driver接口用于生成图片和验证答案 1 2 3 4 5 6 7 // Driver captcha interface for captcha engine to to write staff type Driver interface { //DrawCaptcha draws binary item DrawCaptcha(content string) (item Item, err error) //GenerateIdQuestionAnswer creates rand id, content and answer GenerateIdQuestionAnswer() (id, q, a string) } 通常这个我们使用自带的driver，都是结构体可以直接用结构体字面量 base64Captcha.DriverDigit base64Captcha.DriverString base64Captcha.DriverChinese base64Captcha.DriverMath ","date":"2022-12-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/base64captcha/:2:0","tags":["go第三方库"],"title":"go第三方库-Base64Captcha","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/base64captcha/"},{"categories":["Golang"],"content":"Captcha对象 1 2 3 4 5 6 7 8 //生成captcha对象 c := base64Captcha.NewCaptcha(driver, store) //生成图片 id, bs64, err := c.Generate() //验证 store.Verify(id int, VerifyValue string, default bool) ","date":"2022-12-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/base64captcha/:3:0","tags":["go第三方库"],"title":"go第三方库-Base64Captcha","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/base64captcha/"},{"categories":["Golang"],"content":"godoc godoc官网 ","date":"2022-12-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/jwt/:0:0","tags":["go第三方库"],"title":"go第三方库-Jwt","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/jwt/"},{"categories":["Golang"],"content":"生成jwt 声明claim结构体 1 2 3 4 5 6 type Claims struct { ID uint `json:\"id\"` Username string `json:\"username\"` Authority int `json:\"authority\"` jwt.StandardClaims } 使用结构体变量生成tokenClaim过渡对象 1 tokenClaims := jwt.NewWithClaims(jwt.SigningMethodHS256, claims) 给tokenClaim对象加盐（使用服务器密钥）获取token对象 1 token, err := tokenClaims.SignedString(jwtSecret) ","date":"2022-12-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/jwt/:1:0","tags":["go第三方库"],"title":"go第三方库-Jwt","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/jwt/"},{"categories":["Golang"],"content":"解析jwt 使用Claim对象指针和返回服务器密钥的函数解析token获取tokenClaim对象 1 2 3 tokenClaims, err := jwt.ParseWithClaims(token, \u0026Claims{}, func(token *jwt.Token) (interface{}, error) { return jwtSecret, nil }) 使用tokenClaim对象的Claim属性对Claim对象的类型断言获取Claim对象 1 2 3 if claims, ok := tokenClaims.Claims.(*Claims); ok \u0026\u0026 tokenClaims.Valid { return claims, nil } ","date":"2022-12-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/jwt/:2:0","tags":["go第三方库"],"title":"go第三方库-Jwt","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/jwt/"},{"categories":["Golang"],"content":"godoc godoc 官网 gomail的改进版 应用内发送邮件： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 m := mail.NewMessage() m.SetHeader(\"From\", \"alex@example.com\") m.SetHeader(\"To\", \"bob@example.com\", \"cora@example.com\") m.SetAddressHeader(\"Cc\", \"dan@example.com\", \"Dan\") m.SetHeader(\"Subject\", \"Hello!\") m.SetBody(\"text/html\", \"Hello \u003cb\u003eBob\u003c/b\u003e and \u003ci\u003eCora\u003c/i\u003e!\") m.Attach(\"/home/Alex/lolcat.jpg\") d := mail.NewDialer(\"smtp.example.com\", 587, \"user\", \"123456\") d.StartTLSPolicy = mail.MandatoryStartTLS // Send the email to Bob, Cora and Dan. if err := d.DialAndSend(m); err != nil { panic(err) } func NewDialer(host string, port int, username, password string) *Dialer password不要使用自己本来的密码，应该申请授权码，一个是授权码修改更方便，另一个是授权码并不能登录你的账号 ","date":"2022-12-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mail/:0:0","tags":["go第三方库"],"title":"go第三方库-Mail","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mail/"},{"categories":["Golang"],"content":"godoc 官方API 官方文档 李文周博客 ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:0:0","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"模型定义 按照约定定义struct ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:1:0","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"约定 ID 作为主键 结构体名+s 表名 字段名+s 列名 CreatedAt 创建时间 UpdatedAt 更新时间 gorm.Model内嵌以复用开发者提供的代码 1 2 3 4 5 6 7 // gorm.Model 的定义 type Model struct { ID uint `gorm:\"primaryKey\"` CreatedAt time.Time UpdatedAt time.Time DeletedAt gorm.DeletedAt `gorm:\"index\"` } 字段标签 ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:1:1","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"连接到数据库 获取数据库连接 1 2 dsn := \"user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4\u0026parseTime=True\u0026loc=Local\" db, err := gorm.Open(mysql.Open(dsn), \u0026gorm.Config{}) 现有database/sql连接初始化一个新的*gorm.DB 1 2 3 gormDB, err := gorm.Open(mysql.New(mysql.Config{ Conn: sqlDB, }), \u0026gorm.Config{}) ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:2:0","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"连接池 gorm使用database/sql标准库维护连接池 func (db *gorm.DB) DB() (*sql.DB, error) 1 2 3 4 5 6 7 8 9 10 sqlDB, err := db.DB() // SetMaxIdleConns 设置空闲连接池中连接的最大数量 sqlDB.SetMaxIdleConns(10) // SetMaxOpenConns 设置打开数据库连接的最大数量。 sqlDB.SetMaxOpenConns(100) // SetConnMaxLifetime 设置了连接可复用的最大时间。 sqlDB.SetConnMaxLifetime(time.Hour) ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:2:1","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"CRUD接口 ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:3:0","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"创建 完整结构体创建记录 1 result := db.Create(\u0026user) // 通过数据的指针来创建 用指定的字段创建记录: 1 db.Select(\"Name\", \"Age\", \"CreatedAt\").Create(\u0026user) 忽略字段创建记录 1 db.Omit(\"Name\", \"Age\", \"CreatedAt\").Create(\u0026user) 批量插入: 将一个 slice 传递给 Create 方法(也是传递引用)，这将仅生成一句sql来创建 CreateInBatches 分批创建，每一批生成一局sql可以设置批次大小db.CreateInBatches(users, 100) 创建钩子:Model的BeforeSave, BeforeCreate, AfterSave, AfterCreate方法 1 func (u *User) BeforeCreate(tx *gorm.DB) (err error) 可以返回错误取消创建 SkipHooks 会话模式跳过钩子函数 1 DB.Session(\u0026gorm.Session{SkipHooks: true}).Create(\u0026user) 根据 Map 创建： 1 2 3 4 5 6 7 8 9 db.Model(\u0026User{}).Create(map[string]interface{}{ \"Name\": \"jinzhu\", \"Age\": 18, }) // batch insert from `[]map[string]interface{}{}` db.Model(\u0026User{}).Create([]map[string]interface{}{ {\"Name\": \"jinzhu_1\", \"Age\": 18}, {\"Name\": \"jinzhu_2\", \"Age\": 20}, }) 关联创建：创建关联数据时，如果关联值是非零值，这些关联会被 upsert，且它们的 Hook 方法也会被调用 默认值：标签 default 为字段定义默认值 1 2 3 4 5 type User struct { ID int64 Name string `gorm:\"default:galeone\"` Age int64 `gorm:\"default:18\"` } ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:3:1","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"查询 Gorm提供了很多好用的方法，比如查询表中第一个记录等等，但是我认为这些方法都是冗余的没必要去记住（增加学习难度），使用元方法（不可替代），比如Scan()方法和Table()方法一起用可以替代First()，Last(),Take()和Find()，查询结果直接读到第一个参数中，如果是多条记录则使用一个slice来接收。 其实Scan()方法都可以使用Rows()和代替，因为gorm是基于官方database.sql库的。 sql.Row对象的读取方法见Row\u0026Rows 另外这些方法都是可以链式调用的（这些方法都返回一个会话对象，属于同一个会话，并且之前方法添加的条件，在后面方法中仍然生效） ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:4:0","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"Find func (db *DB) Find(dest interface{}, conds …interface{}) (tx *DB)：将查询结果给到dst对象（为一个slice或者实例）,相当于Scan和Table 1 2 3 4 5 6 // Get all records result := db.Find(\u0026users) // SELECT * FROM users; result.RowsAffected // returns found records count, equals `len(users)` result.Error // returns error ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:4:1","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"Where func (db *DB) Where(query interface{}, args …interface{}) (tx *DB)：添加任意查询条件 1 2 3 // Get first matched record db.Where(\"name = ?\", \"jinzhu\").First(\u0026user) // SELECT * FROM users WHERE name = 'jinzhu' ORDER BY id LIMIT 1; ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:4:2","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"Not func (db *DB) Not(query interface{}, args …interface{}) (tx *DB)：添加非条件 1 2 db.Not(\"name = ?\", \"jinzhu\").First(\u0026user) // SELECT * FROM users WHERE NOT name = \"jinzhu\" ORDER BY id LIMIT 1; ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:4:3","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"Or func (db *DB) Or(query interface{}, args …interface{}) (tx *DB)：添加或条件 1 2 db.Where(\"role = ?\", \"admin\").Or(\"role = ?\", \"super_admin\").Find(\u0026users) // SELECT * FROM users WHERE role = 'admin' OR role = 'super_admin'; ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:4:4","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"Select func (db *DB) Select(query interface{}, args …interface{}) (tx *DB)：选择特定字段(与之对应的还有一个Omit，忽略字段) 1 2 db.Select(\"name\", \"age\").Find(\u0026users) // SELECT name, age FROM users; ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:4:5","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"Table与Model From子句 func (db *DB) Table(name string, args …interface{}) (tx *DB)：直接给出表名 func (db *DB) Model(value interface{}) (tx *DB)：根据对象类型或切片对应类型推测表名（注意可以使用切片） ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:4:6","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"Order func (db *DB) Order(value interface{}) (tx *DB)：添加order by条件 1 2 db.Order(\"age desc, name\").Find(\u0026users) // SELECT * FROM users ORDER BY age desc, name; ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:4:7","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"Limit func (db *DB) Limit(limit int) (tx *DB)：添加limit条件，负数取消该会话之前添加的limit条件 1 2 3 db.Limit(10).Find(\u0026users1).Limit(-1).Find(\u0026users2) // SELECT * FROM users LIMIT 10; (users1) // SELECT * FROM users; (users2) ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:4:8","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"Group func (db *DB) Group(name string) (tx *DB)：添加grop by条件，通常和Table()方法一起用，Rows()方法返回一个*sql.Rows对象需要关闭，防止再次被枚举 1 2 3 4 5 rows, err := db.Table(\"orders\").Select(\"date(created_at) as date, sum(amount) as total\").Group(\"date(created_at)\").Rows() defer rows.Close() for rows.Next() { ... } ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:4:9","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"Distinct func (db *DB) Distinct(args …interface{}) (tx *DB)：添加distinct条件 1 db.Distinct(\"name\", \"age\").Order(\"name, age desc\").Find(\u0026results) ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:4:10","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"Joins func (db *DB) Joins(query string, args …interface{}) (tx *DB)：添加Join条件，当该方法先于select()方法调用时为Join预加载，即将全表先进行连接再进行查询 1 2 db.Model(\u0026User{}).Select(\"users.name, emails.email\").Joins(\"left join emails on emails.user_id = users.id\").Scan(\u0026result{}) // SELECT users.name, emails.email FROM `users` left join emails on emails.user_id = users.id ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:4:11","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"Scan func (db *DB) Scan(dest interface{}) (tx *DB)：与Find()方法一样但是不根据结构体读取表名 1 db.Table(\"users\").Select(\"name\", \"age\").Where(\"name = ?\", \"Antonio\").Scan(\u0026result) ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:4:12","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"锁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 db.Clauses(clause.Locking{Strength: \"UPDATE\"}).Find(\u0026users) // SELECT * FROM `users` FOR UPDATE db.Clauses(clause.Locking{ Strength: \"SHARE\", Table: clause.Table{Name: clause.CurrentTable}, }).Find(\u0026users) // SELECT * FROM `users` FOR SHARE OF `users` db.Clauses(clause.Locking{ Strength: \"UPDATE\", Options: \"NOWAIT\", }).Find(\u0026users) // SELECT * FROM `users` FOR UPDATE NOWAIT ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:4:13","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"子查询 子查询：*gorm.DB 对象作为(?)参数，再次证明gorm是一个sql字符串拼接器 1 2 3 4 5 db.Where(\"amount \u003e (?)\", db.Table(\"orders\").Select(\"AVG(amount)\")).Find(\u0026orders) // SELECT * FROM \"orders\" WHERE amount \u003e (SELECT AVG(amount) FROM \"orders\"); db.Table(\"(?) as u\", db.Model(\u0026User{}).Select(\"name\", \"age\")).Where(\"age = ?\", 18).Find(\u0026User{}) // SELECT * FROM (SELECT `name`,`age` FROM `users`) as u WHERE `age` = 18 ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:4:14","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"命名参数 sql.NamedArg 和 map[string]interface{}{} 1 2 3 4 5 db.Where(\"name1 = @name OR name2 = @name\", sql.Named(\"name\", \"jinzhu\")).Find(\u0026user) // SELECT * FROM `users` WHERE name1 = \"jinzhu\" OR name2 = \"jinzhu\" db.Where(\"name1 = @name OR name2 = @name\", map[string]interface{}{\"name\": \"jinzhu\"}).First(\u0026user) // SELECT * FROM `users` WHERE name1 = \"jinzhu\" OR name2 = \"jinzhu\" ORDER BY `users`.`id` LIMIT 1 ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:4:15","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"优化器、索引提示 1 2 3 4 5 6 7 8 9 10 11 12 import \"gorm.io/hints\" //优化器 db.Clauses(hints.New(\"MAX_EXECUTION_TIME(10000)\")).Find(\u0026User{}) // SELECT * /*+ MAX_EXECUTION_TIME(10000) */ FROM `users` //索引提示 db.Clauses(hints.UseIndex(\"idx_user_name\")).Find(\u0026User{}) // SELECT * FROM `users` USE INDEX (`idx_user_name`) db.Clauses(hints.ForceIndex(\"idx_user_name\", \"idx_user_id\").ForJoin()).Find(\u0026User{}) // SELECT * FROM `users` FORCE INDEX FOR JOIN (`idx_user_name`,`idx_user_id`)\" ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:4:16","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"迭代 func (db *DB) ScanRows(rows *sql.Rows, dest interface{}) error ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:4:17","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"FindInBatches 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 每次批量处理 100 条 result := db.Where(\"processed = ?\", false).FindInBatches(\u0026results, 100, func(tx *gorm.DB, batch int) error { for _, result := range results { // 批量处理找到的记录 } tx.Save(\u0026results) tx.RowsAffected // 本次批量操作影响的记录数 batch // Batch 1, 2, 3 // 如果返回错误会终止后续批量操作 return nil }) ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:4:18","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"查询钩子 AfterFind 1 2 3 4 5 6 func (u *User) AfterFind(tx *gorm.DB) (err error) { if u.Role == \"\" { u.Role = \"user\" } return } ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:4:19","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"Scope 像调用自己的方法一样地调用func xxx(db *gorm.DB) *gorm.DB类型函数 1 2 3 4 5 6 7 8 9 10 func AmountGreaterThan1000(db *gorm.DB) *gorm.DB { return db.Where(\"amount \u003e ?\", 1000) } func PaidWithCreditCard(db *gorm.DB) *gorm.DB { return db.Where(\"pay_mode_sign = ?\", \"C\") } db.Scopes(AmountGreaterThan1000, PaidWithCreditCard).Find(\u0026orders) // 查找所有金额大于 1000 的信用卡订单 ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:4:20","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"Count 获取匹配的记录数 1 2 3 var count int64 db.Model(\u0026User{}).Where(\"name = ?\", \"jinzhu\").Or(\"name = ?\", \"jinzhu 2\").Count(\u0026count) // SELECT count(1) FROM users WHERE name = 'jinzhu' OR name = 'jinzhu 2' ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:4:21","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"更新 ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:5:0","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"更新单个列 1 2 3 // 条件更新 db.Model(\u0026User{}).Where(\"active = ?\", true).Update(\"name\", \"hello\") // UPDATE users SET name='hello', updated_at='2013-11-17 21:34:10' WHERE active=true; ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:5:1","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"更新多列 通过Table或者Model获取表，然后调用Update()传入一个表记录对象或者一个map[string]interface{}的对象，将满足条件的记录修改为对象的非nil值，可以配合Select一起使用更新选定字段会，select会更新nil值(所以推荐使用map更新)： 1 2 3 4 // 使用 Map 进行 Select // User's ID is `111`: db.Model(\u0026user).Select(\"name\").Updates(map[string]interface{}{\"name\": \"hello\", \"age\": 18, \"active\": false}) // UPDATE users SET name='hello' WHERE id=111; ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:5:2","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"更新 Hook BeforeSave, BeforeUpdate, AfterSave, AfterUpdate 1 2 3 4 5 6 func (u *User) BeforeUpdate(tx *gorm.DB) (err error) { if u.Role == \"admin\" { return errors.New(\"admin user not allowed to update\") } return } ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:5:3","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"批量更新 添加查询条件更新 ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:5:4","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"阻止全局更新 全局更新需要添加选择条件或者使用原生Sql或者设置session AllowGlobalUpdate为真，否则返回ErrMissingWhereClause错误 1 2 3 4 5 6 7 8 db.Model(\u0026User{}).Where(\"1 = 1\").Update(\"name\", \"jinzhu\") // UPDATE users SET `name` = \"jinzhu\" WHERE 1=1 db.Exec(\"UPDATE users SET name = ?\", \"jinzhu\") // UPDATE users SET name = \"jinzhu\" db.Session(\u0026gorm.Session{AllowGlobalUpdate: true}).Model(\u0026User{}).Update(\"name\", \"jinzhu\") // UPDATE users SET `name` = \"jinzhu\" ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:5:5","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"更新的记录数 更新的记录数使用*gorm的属性查看 1 2 3 4 5 6 // 通过 `RowsAffected` 得到更新的记录数 result := db.Model(User{}).Where(\"role = ?\", \"admin\").Updates(User{Name: \"hello\", Age: 18}) // UPDATE users SET name='hello', age=18 WHERE role = 'admin'; result.RowsAffected // 更新的记录数 result.Error // 更新的错误 ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:5:6","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"使用 SQL 表达式更新 func Expr(expr string, args …interface{}) clause.Expr ：生成sql表达式，作为更新值或者替换?占位符 1 2 3 // product 的 ID 是 `3` db.Model(\u0026product).Update(\"price\", gorm.Expr(\"price * ? + ?\", 2, 100)) // UPDATE \"products\" SET \"price\" = price * 2 + 100, \"updated_at\" = '2013-11-17 21:34:10' WHERE \"id\" = 3; ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:5:7","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"根据子查询进行更新 子查询作为更新值参数，通常子查询的结果是一个值而非多个记录或者多个字段 1 2 db.Model(\u0026user).Update(\"company_name\", db.Model(\u0026Company{}).Select(\"name\").Where(\"companies.id = users.company_id\")) // UPDATE \"users\" SET \"company_name\" = (SELECT name FROM companies WHERE companies.id = users.company_id); ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:5:8","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"不使用 Hook 和时间追踪 UpdateColumn、UpdateColumns不追踪更新时间 1 2 3 4 5 6 7 8 9 10 11 // 更新单个列 db.Model(\u0026user).UpdateColumn(\"name\", \"hello\") // UPDATE users SET name='hello' WHERE id = 111; // 更新多个列 db.Model(\u0026user).UpdateColumns(User{Name: \"hello\", Age: 18}) // UPDATE users SET name='hello', age=18 WHERE id = 111; // 更新选中的列 db.Model(\u0026user).Select(\"name\", \"age\").UpdateColumns(User{Name: \"hello\", Age: 0}) // UPDATE users SET name='hello', age=0 WHERE id = 111; ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:5:9","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"返回修改行的数据 1 2 3 4 5 6 7 8 9 10 // 返回所有列 var users []User DB.Model(\u0026users).Clauses(clause.Returning{}).Where(\"role = ?\", \"admin\").Update(\"salary\", gorm.Expr(\"salary * ?\", 2)) // UPDATE `users` SET `salary`=salary * 2,`updated_at`=\"2021-10-28 17:37:23.19\" WHERE role = \"admin\" RETURNING * // users =\u003e []User{{ID: 1, Name: \"jinzhu\", Role: \"admin\", Salary: 100}, {ID: 2, Name: \"jinzhu.2\", Role: \"admin\", Salary: 1000}} // 返回指定的列 DB.Model(\u0026users).Clauses(clause.Returning{Columns: []clause.Column{{Name: \"name\"}, {Name: \"salary\"}}}).Where(\"role = ?\", \"admin\").Update(\"salary\", gorm.Expr(\"salary * ?\", 2)) // UPDATE `users` SET `salary`=salary * 2,`updated_at`=\"2021-10-28 17:37:23.19\" WHERE role = \"admin\" RETURNING `name`, `salary` // users =\u003e []User{{ID: 0, Name: \"jinzhu\", Role: \"\", Salary: 100}, {ID: 0, Name: \"jinzhu.2\", Role: \"\", Salary: 1000}} ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:5:10","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"检查字段是否有变更 Before Update Hook调用Changed 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func (u *User) BeforeUpdate(tx *gorm.DB) (err error) { // 如果 Role 字段有变更 if tx.Statement.Changed(\"Role\") { return errors.New(\"role not allowed to change\") } if tx.Statement.Changed(\"Name\", \"Admin\") { // 如果 Name 或 Role 字段有变更 tx.Statement.SetColumn(\"Age\", 18) } // 如果任意字段有变更 if tx.Statement.Changed() { tx.Statement.SetColumn(\"RefreshedAt\", time.Now()) } return nil } ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:5:11","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"在 Update 时修改值 Before 钩子中，使用Save变更整个对象，或者使用SetColumn更新一个字段 1 2 3 4 5 6 7 8 9 10 11 12 func (user *User) BeforeSave(tx *gorm.DB) (err error) { if pw, err := bcrypt.GenerateFromPassword(user.Password, 0); err == nil { tx.Statement.SetColumn(\"EncryptedPassword\", pw) } if tx.Statement.Changed(\"Code\") { user.Age += 20 tx.Statement.SetColumn(\"Age\", user.Age) } } db.Model(\u0026user).Update(\"Name\", \"jinzhu\") ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:5:12","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"删除 ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:6:0","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"批量删除 添加条件然后调用Delete(dst)方法,dst为目标表记录对象或对象切片的地址 1 2 db.Where(\"email LIKE ?\", \"%jinzhu%\").Delete(\u0026Email{}) // DELETE from emails where email LIKE \"%jinzhu%\"; ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:6:1","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"Delete Hook BeforeDelete、AfterDelete 1 2 3 4 5 6 func (u *User) BeforeDelete(tx *gorm.DB) (err error) { if u.Role == \"admin\" { return errors.New(\"admin user not allowed to delete\") } return } ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:6:2","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"阻止全局删除 加永真条件，或者使用原生 SQL，或者启用 AllowGlobalUpdate 模式 ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:6:3","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"返回删除行的数据 Clauses(clause.Returning{}) Clauses(clause.Returning{Columns: []clause.Column{{Name: “name”}, {Name: “salary”}}}) ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:6:4","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"软删除 模型包含了gorm.deletedat字段（gorm.Model 已经包含了该字段)将自动配置为软删除 ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:6:5","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"查找被软删除的记录 Unscoped()方法 1 2 db.Unscoped().Where(\"age = 20\").Find(\u0026users) // SELECT * FROM users WHERE age = 20; ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:6:6","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"永久删除 使用Unscoped()方法 1 2 db.Unscoped().Delete(\u0026order) // DELETE FROM orders WHERE id=10; ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:6:7","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"Delete Flag 默认为删除时间 设置方法见官网 ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:6:8","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"SQL 构建器 ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:7:0","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"原生 SQL func (db *DB) Raw(sql string, values …interface{}) (tx *DB) 1 db.Raw(\"SELECT id, name, age FROM users WHERE name = ?\", 3).Scan(\u0026result) func (db *DB) Exec(sql string, values …interface{}) (tx *DB) 1 2 3 4 5 6 db.Exec(\"DROP TABLE users\") db.Exec(\"UPDATE orders SET shipped_at = ? WHERE id IN ?\", time.Now(), []int64{1, 2, 3}) // Exec with SQL Expression db.Exec(\"UPDATE users SET money = ? WHERE name = ?\", gorm.Expr(\"money * ? + ?\", 10000, 1), \"jinzhu\") ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:7:1","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"DryRun 模式 不执行仅生成sql 1 2 3 stmt := db.Session(\u0026Session{DryRun: true}).First(\u0026user, 1).Statement stmt.SQL.String() //=\u003e SELECT * FROM `users` WHERE `id` = $1 ORDER BY `id` stmt.Vars //=\u003e []interface{}{1} ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:7:2","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"ToSQL 返回生成的 SQL 但不执行。 1 2 3 4 sql := DB.ToSQL(func(tx *gorm.DB) *gorm.DB { return tx.Model(\u0026User{}).Where(\"id = ?\", 100).Limit(10).Order(\"age desc\").Find(\u0026[]User{}) }) sql //=\u003e SELECT * FROM \"users\" WHERE id = 100 AND \"users\".\"deleted_at\" IS NULL ORDER BY age desc LIMIT 10 ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:7:3","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"Row \u0026 Rows 获取 *sql.Row 结果 1 2 row := db.Table(\"users\").Where(\"name = ?\", \"jinzhu\").Select(\"name\", \"age\").Row() row.Scan(\u0026name, \u0026age) 获取 *sql.Rows 结果 1 2 3 4 5 6 7 8 // 使用 GORM API 构建 SQL rows, err := db.Model(\u0026User{}).Where(\"name = ?\", \"jinzhu\").Select(\"name, age, email\").Rows() defer rows.Close() for rows.Next() { rows.Scan(\u0026name, \u0026age, \u0026email) // 业务逻辑... } ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:7:4","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"将 sql.Rows 扫描至 model db.ScanRows 1 2 3 4 5 6 7 8 9 10 rows, err := db.Model(\u0026User{}).Where(\"name = ?\", \"jinzhu\").Select(\"name, age, email\").Rows() // (*sql.Rows, error) defer rows.Close() var user User for rows.Next() { // ScanRows 将一行扫描至 user db.ScanRows(rows, \u0026user) // 业务逻辑... } ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:7:5","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"连接 在一条 tcp DB 连接中运行多条 SQL (不是事务) 1 2 3 4 5 db.Connection(func(tx *gorm.DB) error { tx.Exec(\"SET my.role = ?\", \"admin\") tx.First(\u0026User{}) }) ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:7:6","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"子句（Clause） GORM 内部使用 SQL builder 生成 SQL。每个操作（会话），GORM 都会创建一个 *gorm.Statement 对象。所有的 GORM API 都是在为 statement 添加、修改 子句，最后，GORM 会根据这些子句生成 SQL ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:7:7","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"子句构造器 较复杂且我觉得用不到，如果都需要子句构造器了，为什么我不直接使用原生sql（Exex()方法）呢？ ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:7:8","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"关联 开发尽量避免外键的使用 这部分详见官网 ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:8:0","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"Context WithContext 方法 ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:9:0","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"单会话模式 一个会话执行一个sql命令 1 db.WithContext(ctx).Find(\u0026users) ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:9:1","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"持续会话模式 一个会话执行多个sql命令 1 2 3 tx := db.WithContext(ctx) tx.First(\u0026user, 1) tx.Model(\u0026user).Update(\"role\", \"admin\") ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:9:2","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"Context 超时 长 Sql 查询，WithContext传入一个带超时的 context 给 db. 1 2 3 4 ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second) defer cancel() db.WithContext(ctx).Find(\u0026users) ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:9:3","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"Hooks/Callbacks 中的 Context gorm.db.Statement.Context属性 1 2 3 4 5 func (u *User) BeforeCreate(tx *gorm.DB) (err error) { ctx := tx.Statement.Context // ... return } ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:9:4","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"处理错误 GORM 提供链式 API，GORM 会设置 *gorm.DB 的 Error 字段 1 2 3 if result := db.Where(\"name = ?\", \"jinzhu\").First(\u0026user); result.Error != nil { // 处理错误... } ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:10:0","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"ErrRecordNotFound 找不到记录时，GORM 会返回 ErrRecordNotFound 错误 发生多个错误通过 errors.Is 判断错误是否为 ErrRecordNotFound 1 2 3 // 检查错误是否为 RecordNotFound err := db.First(\u0026user, 100).Error errors.Is(err, gorm.ErrRecordNotFound) ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:10:1","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"链式方法 链式方法：将 Clauses 修改或添加到当前 Statement 的方法。Where, Select, Omit, Joins, Scopes, Preload, Raw（Raw不能和其他的一起用） 终结方法：立即执行注册回调的方法，然后生成并执行 SQL。Create, First, Find, Take, Save, Update, Delete, Scan, Row, Rows 新建会话方法：链式方法, Finisher 方法返回的 *gorm.DB 实例已经被加了各种各样的子句，不能安全地再使用，需要新建一个会话。Session（需要使用NewDB选项）、WithContext、Debug。（另外直接用db重新开启一个会话也是可以的） ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:11:0","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"会话 gorm.DB.Session()方法传入一个Session对象地址 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Session 配置 type Session struct { DryRun bool PrepareStmt bool NewDB bool Initialized bool SkipHooks bool SkipDefaultTransaction bool DisableNestedTransaction bool AllowGlobalUpdate bool FullSaveAssociations bool QueryFields bool Context context.Context Logger logger.Interface NowFunc func() time.Time CreateBatchSize int } ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:12:0","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"DryRun 生成 SQL 但不执行 ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:12:1","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"预编译 PreparedStmt提高后续的效率 ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:12:2","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"NewDB NewDB 选项创建一个不带之前条件的新 DB 其余选项见官网 ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:12:3","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"Hook钩子 之前的笔记已经讲过这个内容 详见官网 ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:13:0","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"事务 ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:14:0","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"禁用默认事务 1 2 3 4 5 6 7 8 9 10 // 全局禁用 db, err := gorm.Open(sqlite.Open(\"gorm.db\"), \u0026gorm.Config{ SkipDefaultTransaction: true, }) // 持续会话模式 tx := db.Session(\u0026Session{SkipDefaultTransaction: true}) tx.First(\u0026user, 1) tx.Find(\u0026users) tx.Model(\u0026user).Update(\"Age\", 18) ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:14:1","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"事务 1 2 3 4 5 6 7 8 9 10 11 12 13 14 db.Transaction(func(tx *gorm.DB) error { // 在事务中执行一些 db 操作（从这里开始，您应该使用 'tx' 而不是 'db'） if err := tx.Create(\u0026Animal{Name: \"Giraffe\"}).Error; err != nil { // 返回任何错误都会回滚事务 return err } if err := tx.Create(\u0026Animal{Name: \"Lion\"}).Error; err != nil { return err } // 返回 nil 提交事务 return nil }) ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:14:2","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"嵌套事务 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 db.Transaction(func(tx *gorm.DB) error { tx.Create(\u0026user1) tx.Transaction(func(tx2 *gorm.DB) error { tx2.Create(\u0026user2) return errors.New(\"rollback user2\") // Rollback user2 }) tx.Transaction(func(tx2 *gorm.DB) error { tx2.Create(\u0026user3) return nil }) return nil }) // Commit user1, user3 ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:14:3","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"手动事务 1 2 3 4 5 6 7 8 9 10 11 12 13 // 开始事务 tx := db.Begin() // 在事务中执行一些 db 操作（从这里开始，您应该使用 'tx' 而不是 'db'） tx.Create(...) // ... // 遇到错误时回滚事务 tx.Rollback() // 否则，提交事务 tx.Commit() 同一个事务需要使用同一个Session（即返回的tx） ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:14:4","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"SavePoint、RollbackTo 1 2 3 4 5 6 7 8 tx := db.Begin() tx.Create(\u0026user1) tx.SavePoint(\"sp1\") tx.Create(\u0026user2) tx.RollbackTo(\"sp1\") // Rollback user2 tx.Commit() // Commit user1 ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:14:5","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"迁移 见官网 ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:15:0","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"Logger 定义logger 1 2 3 4 5 6 7 8 9 newLogger := logger.New( log.New(os.Stdout, \"\\r\\n\", log.LstdFlags), // io writer（日志输出的目标，前缀和日志包含的内容——译者注） logger.Config{ SlowThreshold: time.Second, // 慢 SQL 阈值 LogLevel: logger.Silent, // 日志级别 IgnoreRecordNotFoundError: true, // 忽略ErrRecordNotFound（记录未找到）错误 Colorful: false, // 禁用彩色打印 }, ) 会话使用logger 1 2 3 4 5 6 7 8 9 // 全局模式 db, err := gorm.Open(sqlite.Open(\"test.db\"), \u0026gorm.Config{ Logger: newLogger, }) // 新建会话模式 tx := db.Session(\u0026Session{Logger: newLogger}) tx.First(\u0026user) tx.Model(\u0026user).Update(\"Age\", 18) ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:16:0","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"日志级别 Silent、Error、Warn、Info 1 2 3 db, err := gorm.Open(sqlite.Open(\"test.db\"), \u0026gorm.Config{ Logger: logger.Default.LogMode(logger.Silent), }) ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:16:1","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"自定义 Logger 1 2 3 4 5 6 7 type Interface interface { LogMode(LogLevel) Interface Info(context.Context, string, ...interface{}) Warn(context.Context, string, ...interface{}) Error(context.Context, string, ...interface{}) Trace(ctx context.Context, begin time.Time, fc func() (sql string, rowsAffected int64), err error) } ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:16:2","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"迁移 AutoMigrate 用于自动迁移您的 schema，保持您的 schema 是最新的。AutoMigrate 会创建表、缺失的外键、约束、列和索引。 1 2 3 4 5 6 db.AutoMigrate(\u0026User{}) db.AutoMigrate(\u0026User{}, \u0026Product{}, \u0026Order{}) // 创建表时添加后缀 db.Set(\"gorm:table_options\", \"ENGINE=InnoDB\").AutoMigrate(\u0026User{}) ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:17:0","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"常规数据库接口 sql.DB gorm.DB.DB()方法获取一个标准库中的*sql.DB 1 2 // 获取通用数据库对象 sql.DB，然后使用其提供的功能 sqlDB, err := db.DB() ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:18:0","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"连接池 sql.DB可以设置连接池配置 1 2 3 4 5 6 7 8 9 10 11 // 获取通用数据库对象 sql.DB ，然后使用其提供的功能 sqlDB, err := db.DB() // SetMaxIdleConns 用于设置连接池中空闲连接的最大数量。 sqlDB.SetMaxIdleConns(10) // SetMaxOpenConns 设置打开数据库连接的最大数量。 sqlDB.SetMaxOpenConns(100) // SetConnMaxLifetime 设置了连接可复用的最大时间。 sqlDB.SetConnMaxLifetime(time.Hour) ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:18:1","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"设置 Set, Get, InstanceSet, InstanceGet 方法传值给 勾子 或其他方法 Set, Get传递给Session InstanceSet, InstanceGet传递给同一Statement ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:19:0","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"数据库索引 index、uniqueIndex 标签 这些索引将在使用 GORM 进行AutoMigrate 或 Createtable 时创建 ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:20:0","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"唯一索引 uniqueIndex 标签 1 2 3 4 type User struct { Name1 string `gorm:\"uniqueIndex\"` Name2 string `gorm:\"uniqueIndex:idx_name,sort:desc\"` } ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:20:1","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"复合索引 两个字段使用同一个索引名将创建复合索引 1 2 3 4 5 // create composite index `idx_member` with columns `name`, `number` type User struct { Name string `gorm:\"index:idx_member\"` Number string `gorm:\"index:idx_member\"` } 字段优先级:priority ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:20:2","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["Golang"],"content":"复合主键 多个字段设为主键，以创建复合主键 1 2 3 4 5 6 type Product struct { ID string `gorm:\"primaryKey\"` LanguageCode string `gorm:\"primaryKey\"` Code string Name string } autoIncrement关闭整形主键自动加1 1 2 3 4 type Product struct { CategoryID uint64 `gorm:\"primaryKey;autoIncrement:false\"` TypeID uint64 `gorm:\"primaryKey;autoIncrement:false\"` } ","date":"2022-12-19","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/:21:0","tags":["go第三方库"],"title":"go第三方库-Gorm","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gorm/"},{"categories":["前端"],"content":"本系列是作者在跟着Vite官网学习时做的笔记，可能并不详尽，读者可以到官网中查看完整内容。 ","date":"2022-12-18","objectID":"/posts/%E5%89%8D%E7%AB%AF/vite/%E7%AE%80%E4%BB%8B/:0:0","tags":["vite"],"title":"vite-简介","uri":"/posts/%E5%89%8D%E7%AB%AF/vite/%E7%AE%80%E4%BB%8B/"},{"categories":["前端"],"content":"搭建项目 1 npm create vite@latest ","date":"2022-12-18","objectID":"/posts/%E5%89%8D%E7%AB%AF/vite/%E7%AE%80%E4%BB%8B/:1:0","tags":["vite"],"title":"vite-简介","uri":"/posts/%E5%89%8D%E7%AB%AF/vite/%E7%AE%80%E4%BB%8B/"},{"categories":["前端"],"content":"index.html 与项目根目录 项目加载流程： index解析script标签=》main.js导入vue=》app.vue挂载index.html ","date":"2022-12-18","objectID":"/posts/%E5%89%8D%E7%AB%AF/vite/%E7%AE%80%E4%BB%8B/:2:0","tags":["vite"],"title":"vite-简介","uri":"/posts/%E5%89%8D%E7%AB%AF/vite/%E7%AE%80%E4%BB%8B/"},{"categories":["前端"],"content":"命令行界面 package.json 配置项目 script为npm构建命令 1 2 3 4 5 \"scripts\": { \"dev\": \"vite\", \"build\": \"vite build\", \"preview\": \"vite preview\" }, dependencies为依赖包 ","date":"2022-12-18","objectID":"/posts/%E5%89%8D%E7%AB%AF/vite/%E7%AE%80%E4%BB%8B/:3:0","tags":["vite"],"title":"vite-简介","uri":"/posts/%E5%89%8D%E7%AB%AF/vite/%E7%AE%80%E4%BB%8B/"},{"categories":["前端"],"content":"启动项目 安装依赖 1 npm install 启动项目 1 npm run dev ","date":"2022-12-18","objectID":"/posts/%E5%89%8D%E7%AB%AF/vite/%E7%AE%80%E4%BB%8B/:4:0","tags":["vite"],"title":"vite-简介","uri":"/posts/%E5%89%8D%E7%AB%AF/vite/%E7%AE%80%E4%BB%8B/"},{"categories":["前端"],"content":"生成生产环境代码 1 npm run build 本地测试应用 1 npm run preview –port 参数来配置服务的运行端口 1 2 3 4 5 { \"scripts\": { \"preview\": \"vite preview --port 8080\" } } ","date":"2022-12-18","objectID":"/posts/%E5%89%8D%E7%AB%AF/vite/%E7%AE%80%E4%BB%8B/:5:0","tags":["vite"],"title":"vite-简介","uri":"/posts/%E5%89%8D%E7%AB%AF/vite/%E7%AE%80%E4%BB%8B/"},{"categories":["前端"],"content":"部署 在 vite.config.js 中设置正确的 base ","date":"2022-12-18","objectID":"/posts/%E5%89%8D%E7%AB%AF/vite/%E7%AE%80%E4%BB%8B/:6:0","tags":["vite"],"title":"vite-简介","uri":"/posts/%E5%89%8D%E7%AB%AF/vite/%E7%AE%80%E4%BB%8B/"},{"categories":["前端"],"content":"环境变量和模式 ","date":"2022-12-18","objectID":"/posts/%E5%89%8D%E7%AB%AF/vite/%E7%AE%80%E4%BB%8B/:7:0","tags":["vite"],"title":"vite-简介","uri":"/posts/%E5%89%8D%E7%AB%AF/vite/%E7%AE%80%E4%BB%8B/"},{"categories":["前端"],"content":"环境变量 import.meta.env 对象上暴露环境变量 ","date":"2022-12-18","objectID":"/posts/%E5%89%8D%E7%AB%AF/vite/%E7%AE%80%E4%BB%8B/:7:1","tags":["vite"],"title":"vite-简介","uri":"/posts/%E5%89%8D%E7%AB%AF/vite/%E7%AE%80%E4%BB%8B/"},{"categories":["前端"],"content":".env 文件 .env # 所有情况下都会加载\r.env.local # 所有情况下都会加载，但会被 git 忽略\r.env.[mode] # 只在指定模式下加载\r.env.[mode].local # 只在指定模式下加载，但会被 git 忽略 加载的环境变量也会通过 import.meta.env 以字符串形式暴露给客户端源码 ","date":"2022-12-18","objectID":"/posts/%E5%89%8D%E7%AB%AF/vite/%E7%AE%80%E4%BB%8B/:7:2","tags":["vite"],"title":"vite-简介","uri":"/posts/%E5%89%8D%E7%AB%AF/vite/%E7%AE%80%E4%BB%8B/"},{"categories":["前端"],"content":"模式 .env.mod文件，vite build的时候添加–mode mod激活环境变量，默认是production 1 2 # .env.staging VITE_APP_TITLE=My App (staging) 1 vite build --mode staging ","date":"2022-12-18","objectID":"/posts/%E5%89%8D%E7%AB%AF/vite/%E7%AE%80%E4%BB%8B/:8:0","tags":["vite"],"title":"vite-简介","uri":"/posts/%E5%89%8D%E7%AB%AF/vite/%E7%AE%80%E4%BB%8B/"},{"categories":["Golang"],"content":"godoc github官方 客户端支持与大于等于其版本的 Elasticsearch 子包esapi调用 Elasticsearch API ，子包elastictransport通过 HTTP 传输数据 ","date":"2022-12-17","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/go-elasticsearch/:0:0","tags":["go第三方库"],"title":"go第三方库-Go Elasticsearch","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/go-elasticsearch/"},{"categories":["Golang"],"content":"连接服务端 elasticsearch.NewDefaultClient()函数创建具有默认设置的客户端 1 2 3 4 5 6 7 8 9 10 11 12 es, err := elasticsearch.NewDefaultClient() if err != nil { log.Fatalf(\"Error creating the client: %s\", err) } res, err := es.Info() if err != nil { log.Fatalf(\"Error getting response: %s\", err) } defer res.Body.Close() log.Println(res) 关闭响应体并消费它使得 HTTP 传输中重新使用持久 TCP 连接。 调用io.Copy(ioutil.Discard, res.Body)可以清除响应体 可以设置ELASTICSEARCH_URL环境变量，将用于设置集群端点。用逗号分隔多个地址。 以编程方式设置集群端点，将配置对象传递给elasticsearch.NewClient()函数 1 2 3 4 5 6 7 8 cfg := elasticsearch.Config{ Addresses: []string{ \"https://localhost:9200\", \"https://localhost:9201\", }, // ... } es, err := elasticsearch.NewClient(cfg) 配置对象可以包含用户名和密码属性 1 2 3 4 5 cfg := elasticsearch.Config{ // ... Username: \"foo\", Password: \"bar\", } CACert配置属性用于设置签署集群节点证书的自定义证书颁发机构 1 2 3 4 5 6 cert, _ := ioutil.ReadFile(*cacert) cfg := elasticsearch.Config{ // ... CACert: cert, } CertificateFingerprint配置属性设置指纹以验证 HTTPS 连接 1 2 3 4 cfg := elasticsearch.Config{ // ... CertificateFingerprint: fingerPrint, } 传输层配置通过给Transport属性一个http.Transport对象的地址 1 2 3 4 5 6 7 8 9 10 11 cfg := elasticsearch.Config{ Transport: \u0026http.Transport{ MaxIdleConnsPerHost: 10, ResponseHeaderTimeout: time.Second, TLSClientConfig: \u0026tls.Config{ MinVersion: tls.VersionTLS12, // ... }, // ... }, } ","date":"2022-12-17","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/go-elasticsearch/:1:0","tags":["go第三方库"],"title":"go第三方库-Go Elasticsearch","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/go-elasticsearch/"},{"categories":["Golang"],"content":"插入数据 使用esapi来生成不同es请求对象，下面这个对象用于给es插入文档 1 2 3 4 5 6 7 // Set up the request object. req := esapi.IndexRequest{ Index: \"test\", DocumentID: strconv.Itoa(i + 1), Body: bytes.NewReader(data), Refresh: \"true\", } 发送ES请求，res为返回数据包 1 2 3 4 5 // Perform the request with the client. res, err := req.Do(context.Background(), es) if err != nil { log.Fatalf(\"Error getting response: %s\", err) } res.IsError()判断es服务端执行时是否出现错误 res.Body为返回json字符串，可用于json解析 ","date":"2022-12-17","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/go-elasticsearch/:2:0","tags":["go第三方库"],"title":"go第三方库-Go Elasticsearch","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/go-elasticsearch/"},{"categories":["Golang"],"content":"查询 通过查询对象生成json字面量，用于查询 1 2 3 4 5 6 7 8 9 10 11 12 // Build the request body. var buf bytes.Buffer query := map[string]interface{}{ \"query\": map[string]interface{}{ \"match\": map[string]interface{}{ \"title\": \"test\", }, }, } if err := json.NewEncoder(\u0026buf).Encode(query); err != nil { log.Fatalf(\"Error encoding query: %s\", err) } 执行查询 1 2 3 4 5 6 7 8 9 10 11 12 // Perform the search request. res, err = es.Search( es.Search.WithContext(context.Background()), es.Search.WithIndex(\"test\"), es.Search.WithBody(\u0026buf), es.Search.WithTrackTotalHits(true), es.Search.WithPretty(), ) if err != nil { log.Fatalf(\"Error getting response: %s\", err) } defer res.Body.Close() ","date":"2022-12-17","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/go-elasticsearch/:3:0","tags":["go第三方库"],"title":"go第三方库-Go Elasticsearch","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/go-elasticsearch/"},{"categories":["Golang"],"content":"esapi esapi包允许以两种不同的方式调用 Elasticsearch API： 通过创建一个结构，例如IndexRequest，并通过将上下文和客户端传递给它来调用其Do()方法 或者通过调用Search()函数客户端直接使用选项功能，例如WithIndex(). ","date":"2022-12-17","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/go-elasticsearch/:4:0","tags":["go第三方库"],"title":"go第三方库-Go Elasticsearch","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/go-elasticsearch/"},{"categories":["数据库"],"content":"本系列为作者学习ES官网文档时做的笔记 Elasticsearch 是 Elastic Stack 核心的分布式搜索和分析引擎 ","date":"2022-12-17","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E7%AE%80%E4%BB%8B/:0:0","tags":["elasticsearch"],"title":"数据库-elasticsearch-简介","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E7%AE%80%E4%BB%8B/"},{"categories":["数据库"],"content":"向 Elasticsearch 发送请求 REST API : 各种语言客户端或者curl等HTTP工具 Kibana控制台：菜单=》Dev Tools =》Console ","date":"2022-12-17","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E7%AE%80%E4%BB%8B/:1:0","tags":["elasticsearch"],"title":"数据库-elasticsearch-简介","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E7%AE%80%E4%BB%8B/"},{"categories":["数据库"],"content":"添加数据 从数据生成称为索引文档的 JSON 对象添加到 Elasticsearch ","date":"2022-12-17","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E7%AE%80%E4%BB%8B/:2:0","tags":["elasticsearch"],"title":"数据库-elasticsearch-简介","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E7%AE%80%E4%BB%8B/"},{"categories":["数据库"],"content":"添加单个文档 POST _doc：将单个日志条目生成索引文档并添加到 logs-my_app-default数据流，数据流不存在会自动创建 1 2 3 4 5 6 7 POST logs-my_app-default/_doc { \"@timestamp\": \"2099-05-06T16:21:15.000Z\", \"event\": { \"original\": \"192.0.2.42 - - [06/May/2099:16:21:15 +0000] \\\"GET /images/bg.jpg HTTP/1.0\\\" 200 24736\" } } 响应包括 Elasticsearch 为文档生成的元数据： _index对应文档索引名称 _id为该索引文档的唯一标志 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \"_index\" : \".ds-logs-my_app-default-2022.12.17-000001\", \"_type\" : \"_doc\", \"_id\" : \"gBSIHoUBm1dGIH3uyvpV\", \"_version\" : 1, \"result\" : \"created\", \"_shards\" : { \"total\" : 2, \"successful\" : 1, \"failed\" : 0 }, \"_seq_no\" : 0, \"_primary_term\" : 1 } ","date":"2022-12-17","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E7%AE%80%E4%BB%8B/:3:0","tags":["elasticsearch"],"title":"数据库-elasticsearch-简介","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E7%AE%80%E4%BB%8B/"},{"categories":["数据库"],"content":"添加多个文档 POST _bulk：在一个请求中添加多个文档。批量数据必须是换行符分隔的 JSON (NDJSON)。每行必须以换行符 ( \\n) 结尾，包括最后一行。 1 2 3 4 5 PUT logs-my_app-default/_bulk { \"create\": { } } { \"@timestamp\": \"2099-05-07T16:24:32.000Z\", \"event\": { \"original\": \"192.0.2.242 - - [07/May/2020:16:24:32 -0500] \\\"GET /images/hm_nbg.jpg HTTP/1.0\\\" 304 0\" } } { \"create\": { } } { \"@timestamp\": \"2099-05-08T16:25:42.000Z\", \"event\": { \"original\": \"192.0.2.255 - - [08/May/2099:16:25:42 +0000] \\\"GET /favicon.ico HTTP/1.0\\\" 200 3638\" } } ","date":"2022-12-17","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E7%AE%80%E4%BB%8B/:4:0","tags":["elasticsearch"],"title":"数据库-elasticsearch-简介","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E7%AE%80%E4%BB%8B/"},{"categories":["数据库"],"content":"搜索数据 GET _search：进行搜索，body配置搜索选项 ","date":"2022-12-17","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E7%AE%80%E4%BB%8B/:5:0","tags":["elasticsearch"],"title":"数据库-elasticsearch-简介","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E7%AE%80%E4%BB%8B/"},{"categories":["数据库"],"content":"query:搜索过滤 query.match_all:搜索所有文档 1 2 3 4 5 6 7 GET logs-my_app-default/_search { \"query\": { \"match_all\": { } }, ... } query._source:是否包含原始json query.fields:选择字段，响应结果中hits.hits会包含一个field 请求 1 2 3 4 5 6 7 8 9 GET logs-my_app-default/_search { ... \"fields\": [ \"@timestamp\" ], \"_source\": false, ... } 响应 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 { ... \"hits\" : { \"total\" : { \"value\" : 3, \"relation\" : \"eq\" }, \"max_score\" : null, \"hits\" : [ { ... \"fields\" : { \"@timestamp\" : [ \"2099-05-08T16:25:42.000Z\" ] }, ... }, ] } } query.range:特定时间或 IP 范围使用range查询，可以使用日期和数字来定义相对时间范围 1 2 3 4 5 6 7 8 9 10 11 GET logs-my_app-default/_search { \"query\": { \"range\": { \"@timestamp\": { \"gte\": \"2099-05-05\", \"lt\": \"2099-05-08\" } } }, ... 1 2 3 4 5 6 7 8 9 10 11 12 GET logs-my_app-default/_search { \"query\": { \"range\": { \"@timestamp\": { \"gte\": \"now-1d/d\", \"lt\": \"now/d\" } } }, ... } query.bool:组合多个查询，通常使用filter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 GET logs-my_app-default/_search { ... \"query\": { \"bool\": { \"filter\": [ { \"range\": { \"@timestamp\": { \"gte\": \"2099-05-05\", \"lt\": \"2099-05-08\" } } }, { \"range\": { \"source.ip\": { \"gte\": \"192.0.2.0\", \"lte\": \"192.0.2.240\" } } } ] } }, ... ","date":"2022-12-17","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E7%AE%80%E4%BB%8B/:5:1","tags":["elasticsearch"],"title":"数据库-elasticsearch-简介","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E7%AE%80%E4%BB%8B/"},{"categories":["数据库"],"content":"sort:排序 1 2 3 4 5 6 7 8 9 GET logs-my_app-default/_search { ... \"sort\": [ { \"@timestamp\": \"desc\" } ] } ","date":"2022-12-17","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E7%AE%80%E4%BB%8B/:5:2","tags":["elasticsearch"],"title":"数据库-elasticsearch-简介","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E7%AE%80%E4%BB%8B/"},{"categories":["数据库"],"content":"响应 hits.hits：匹配的文档，_source为原始json对象，默认最多为10个文档 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 { ... \"hits\" : { \"total\" : { \"value\" : 3, \"relation\" : \"eq\" }, \"max_score\" : null, \"hits\" : [ { \"_index\" : \".ds-logs-my_app-default-2022.12.17-000001\", \"_type\" : \"_doc\", \"_id\" : \"hRSRHoUBm1dGIH3uQPoI\", \"_score\" : null, \"_source\" : { \"@timestamp\" : \"2099-05-08T16:25:42.000Z\", \"event\" : { \"original\" : \"\"\"192.0.2.255 - - [08/May/2099:16:25:42 +0000] \"GET /favicon.ico HTTP/1.0\" 200 3638\"\"\" } }, \"sort\" : [ 4081940742000 ] }, ... ] } } ","date":"2022-12-17","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E7%AE%80%E4%BB%8B/:5:3","tags":["elasticsearch"],"title":"数据库-elasticsearch-简介","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E7%AE%80%E4%BB%8B/"},{"categories":["数据库"],"content":"runtime_mappings:从非结构化内容中提取字段 见官网 runtime_mappings.xxx.script:提取脚本，支持groovy，js，python等 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 GET logs-my_app-default/_search { \"runtime_mappings\": { \"source.ip\": { \"type\": \"ip\", \"script\": \"\"\" String sourceip=grok('%{IPORHOST:sourceip} .*').extract(doc[ \"event.original\" ].value)?.sourceip; if (sourceip != null) emit(sourceip); \"\"\" } }, ... \"fields\": [ \"@timestamp\", \"source.ip\" ], ... } ","date":"2022-12-17","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E7%AE%80%E4%BB%8B/:6:0","tags":["elasticsearch"],"title":"数据库-elasticsearch-简介","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E7%AE%80%E4%BB%8B/"},{"categories":["数据库"],"content":"aggs:聚合数据 aggs.xxx:将数据汇总为指标、统计数据或其他分析，比如对匹配结果的某个字段求平均值avg等 1 2 3 4 5 6 7 8 9 10 11 12 GET logs-my_app-default/_search { ... \"aggs\": { \"average_response_size\":{ \"avg\": { \"field\": \"http.response.body.bytes\" } } }, ... } 响应中的aggregations记录结果 1 2 3 4 5 6 7 8 { ... \"aggregations\" : { \"average_response_size\" : { \"value\" : 12368.0 } } } ","date":"2022-12-17","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E7%AE%80%E4%BB%8B/:7:0","tags":["elasticsearch"],"title":"数据库-elasticsearch-简介","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E7%AE%80%E4%BB%8B/"},{"categories":["数据库"],"content":"探索更多搜索选项 常用搜索选项 ","date":"2022-12-17","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E7%AE%80%E4%BB%8B/:8:0","tags":["elasticsearch"],"title":"数据库-elasticsearch-简介","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E7%AE%80%E4%BB%8B/"},{"categories":["数据库"],"content":"清理 删除测试数据流及其支持索引 1 DELETE _data_stream/logs-my_app-default ","date":"2022-12-17","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E7%AE%80%E4%BB%8B/:9:0","tags":["elasticsearch"],"title":"数据库-elasticsearch-简介","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E7%AE%80%E4%BB%8B/"},{"categories":["数据库"],"content":"kibana设置中文 在kibana配置文件etc/kibana.yaml中加一个 1 i18n.locale: \"zh-CN\" ","date":"2022-12-17","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E7%AE%80%E4%BB%8B/:10:0","tags":["elasticsearch"],"title":"数据库-elasticsearch-简介","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E7%AE%80%E4%BB%8B/"},{"categories":["前端"],"content":"本系列是作者在跟着Vue官网学习时做的笔记，可能并不详尽，读者可以到官网中查看完整内容。本文只讲解带有\u003cscript setup\u003e组合式API。 ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/4%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/:0:0","tags":["Vue教程"],"title":"Vue-4逻辑复用","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/4%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/"},{"categories":["前端"],"content":"组合式函数 利用 Vue 的组合式 API 来封装和复用有状态逻辑的函数 ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/4%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/:1:0","tags":["Vue教程"],"title":"Vue-4逻辑复用","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/4%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/"},{"categories":["前端"],"content":"鼠标跟踪器示例 见官网 ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/4%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/:1:1","tags":["Vue教程"],"title":"Vue-4逻辑复用","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/4%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/"},{"categories":["前端"],"content":"异步状态示例 见官网 ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/4%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/:1:2","tags":["Vue教程"],"title":"Vue-4逻辑复用","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/4%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/"},{"categories":["前端"],"content":"约定和最佳实践 命名：驼峰命名法命名，并以“use”作为开头 输入参数：unref()兼容ref 1 2 3 4 5 6 7 import { unref } from 'vue' function useFeature(maybeRef) { // 若 maybeRef 确实是一个 ref，它的 .value 会被返回 // 否则，maybeRef 会被原样返回 const value = unref(maybeRef) } 返回值:返回一个包含多个 ref 的非响应式对象，其在组件中结构后保持响应性 副作用：组合式函数中添加 DOM 事件监听器或者请求数据，注意2点 确保在组件挂载后才调用的生命周期钩子中执行 DOM 相关的副作用，例如：onMounted()，确保能访问到 DOM 确保在 onUnmounted() 时清理副作用 使用限制：组合式函数在 \u003cscript setup\u003e应始终被同步地调用，以确定当前正在被执行的到底是哪个组件实例，从而： 将生命周期钩子注册到该组件实例上 将计算属性和监听器注册到该组件实例上，以便在该组件被卸载时停止监听，避免内存泄漏。 ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/4%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/:1:3","tags":["Vue教程"],"title":"Vue-4逻辑复用","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/4%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/"},{"categories":["前端"],"content":"通过抽取组合式函数改善代码结构 抽取组合式函数不仅是为了复用，也是为了代码组织。 ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/4%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/:1:4","tags":["Vue教程"],"title":"Vue-4逻辑复用","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/4%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/"},{"categories":["前端"],"content":"自定义指令 ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/4%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/:2:0","tags":["Vue教程"],"title":"Vue-4逻辑复用","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/4%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/"},{"categories":["前端"],"content":"介绍 在 \u003cscript setup\u003e 中，任何以 v 开头的驼峰式命名的变量都可以被用作一个自定义指令，模板中使用短横线连接 1 2 3 4 5 6 7 8 9 10 \u003cscript setup\u003e // 在模板中启用 v-focus const vFocus = { mounted: (el) =\u003e el.focus() } \u003c/script\u003e \u003ctemplate\u003e \u003cinput v-focus /\u003e \u003c/template\u003e ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/4%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/:2:1","tags":["Vue教程"],"title":"Vue-4逻辑复用","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/4%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/"},{"categories":["前端"],"content":"指令钩子 一个指令的定义对象可以提供几种钩子函数 (都是可选的)： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const myDirective = { // 在绑定元素的 attribute 前 // 或事件监听器应用前调用 created(el, binding, vnode, prevVnode) { // 下面会介绍各个参数的细节 }, // 在元素被插入到 DOM 前调用 beforeMount(el, binding, vnode, prevVnode) {}, // 在绑定元素的父组件 // 及他自己的所有子节点都挂载完成后调用 mounted(el, binding, vnode, prevVnode) {}, // 绑定元素的父组件更新前调用 beforeUpdate(el, binding, vnode, prevVnode) {}, // 在绑定元素的父组件 // 及他自己的所有子节点都更新后调用 updated(el, binding, vnode, prevVnode) {}, // 绑定元素的父组件卸载前调用 beforeUnmount(el, binding, vnode, prevVnode) {}, // 绑定元素的父组件卸载后调用 unmounted(el, binding, vnode, prevVnode) {} } 钩子参数 el：指令绑定到的元素。这可以用于直接操作 DOM。 binding：一个对象，包含以下属性。 value：传递给指令的值 oldValue：之前的值 arg：传递给指令的参数 modifiers：一个包含修饰符的对象 instance：使用该指令的组件实例 dir：指令的定义对象 vnode：代表绑定元素的底层 VNode prevNode：之前的渲染中代表指令所绑定元素的 VNode 自定义指令的参数也可以是动态的 1 \u003cdiv v-example:[arg]=\"value\"\u003e\u003c/div\u003e ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/4%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/:2:2","tags":["Vue教程"],"title":"Vue-4逻辑复用","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/4%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/"},{"categories":["前端"],"content":"简化形式 仅仅需要在 mounted 和 updated 上实现相同的行为 1 2 3 4 app.directive('color', (el, binding) =\u003e { // 这会在 `mounted` 和 `updated` 时都调用 el.style.color = binding.value }) ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/4%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/:2:3","tags":["Vue教程"],"title":"Vue-4逻辑复用","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/4%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/"},{"categories":["前端"],"content":"对象字面量 1 \u003cdiv v-demo=\"{ color: 'white', text: 'hello!' }\"\u003e\u003c/div\u003e 1 2 3 4 app.directive('demo', (el, binding) =\u003e { console.log(binding.value.color) // =\u003e \"white\" console.log(binding.value.text) // =\u003e \"hello!\" }) ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/4%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/:2:4","tags":["Vue教程"],"title":"Vue-4逻辑复用","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/4%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/"},{"categories":["前端"],"content":"在组件上使用 子组件中该指令和透传 attributes 类似。 指令不能通过 v-bind=\"$attrs\" 来传递给一个不同的元素 不推荐在组件上使用自定义指令 ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/4%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/:2:5","tags":["Vue教程"],"title":"Vue-4逻辑复用","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/4%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/"},{"categories":["前端"],"content":"插件 ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/4%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/:3:0","tags":["Vue教程"],"title":"Vue-4逻辑复用","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/4%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/"},{"categories":["前端"],"content":"介绍 1 2 3 4 5 6 7 import { createApp } from 'vue' const app = createApp({}) app.use(myPlugin, { /* 可选的选项 */ }) 1 2 3 4 5 const myPlugin = { install(app, options) { // 配置此应用 } } 常见用法： 通过 app.component() 和 app.directive() 注册一到多个全局组件或自定义指令 通过 app.provide() 使一个资源可被注入进整个应用 向 app.config.globalProperties 中添加一些全局实例属性或方法 一个可能上述三种都包含了的功能库 (例如 vue-router) ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/4%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/:3:1","tags":["Vue教程"],"title":"Vue-4逻辑复用","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/4%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/"},{"categories":["前端"],"content":"编写一个插件 见官网 ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/4%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/:3:2","tags":["Vue教程"],"title":"Vue-4逻辑复用","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/4%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/"},{"categories":["前端"],"content":"本系列是作者在跟着Vue官网学习时做的笔记，可能并不详尽，读者可以到官网中查看完整内容。本文只讲解带有\u003cscript setup\u003e组合式API。 ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:0:0","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"组件注册 ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:1:0","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"全局注册 app.component() 在注册函数中定义组件 1 2 3 4 5 6 7 8 9 10 11 12 import { createApp } from 'vue' const app = createApp({}) app.component( // 注册的名字 'MyComponent', // 组件的实现 { /* ... */ } ) 注册被导入的 .vue 单文件组件： 1 2 3 import MyComponent from './App.vue' app.component('MyComponent', MyComponent) app.component() 方法可以被链式调用： 1 2 3 4 app .component('ComponentA', ComponentA) .component('ComponentB', ComponentB) .component('ComponentC', ComponentC) ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:1:1","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"局部注册 \u003cscript setup\u003e 的单文件组件中，导入的组件可以直接在模板中使用。局部注册的组件在后代组件中并不可用 ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:1:2","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"组件名格式 PascalCase ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:1:3","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"Props defineProps() 宏 1 2 3 4 5 \u003cscript setup\u003e const props = defineProps(['foo']) console.log(props.foo) \u003c/script\u003e 除了数组的形式，可以使用对象的形式： 1 2 3 4 5 // 使用 \u003cscript setup\u003e defineProps({ title: String, likes: Number }) ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:2:0","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"传递 prop 的细节 Prop 名字格式 camelCase 形式 静态 vs. 动态 Prop v-bind 或缩写 : 来进行动态绑定的 props 父组件 1 2 3 4 5 \u003c!-- 根据一个变量的值动态传入 --\u003e \u003cBlogPost :title=\"post.title\" /\u003e \u003c!-- 根据一个更复杂表达式的值动态传入 --\u003e \u003cBlogPost :title=\"post.title + ' by ' + post.author.name\" /\u003e 传递不同的值类型 任何类型的值都可以作为 props 的值被传递 使用一个对象绑定多个 prop 使用没有参数的 v-bind绑定对象，对象的键值对将作为组件的prop ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:2:1","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"单向数据流 props单向绑定，父组件数据改变子组件状态，反之不行 prop 被用于传入初始值；而子组件想在之后将其作为一个局部数据属性：新定义一个局部数据属性，从 props 上获取初始值 需要对传入的 prop 值做进一步的转换：基于该 prop 值定义一个计算属性 更改对象 / 数组类型的 props 对象 / 数组类型的 props可以被子组件修改，因为他们传递的是引用 但是不建议这么做，会增加组件耦合性 ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:2:2","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"Prop 校验 defineProps宏接收对象，props键值对的值也是对象并在对象中配置该prop。 所有 prop 默认都是可选的，除非声明了 required: true 未传递的可选 prop 有一个默认值 undefined。Boolean 类型的未传递 prop 被转换为 false 声明了 default 值，传递 undefined 或者不传递props时都会改为 default 值。 验失败后，Vue 会抛出一个控制台警告 运行时类型检查 type：String，Number，Boolean，Array，Object，Date，Function，Symbol instanceof实现 ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:2:3","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"Boolean 类型转换 boolean类型不需要值。可以把props设置为多种类型。 1 2 3 defineProps({ disabled: [Boolean, Number] }) ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:2:4","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"组件事件 ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:3:0","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"触发与监听事件 子组件 $emit 方法触发自定义事件 1 2 \u003c!-- MyComponent --\u003e \u003cbutton @click=\"$emit('someEvent')\"\u003eclick me\u003c/button\u003e 父组件 v-on (缩写为 @) 来监听事件，也支持事件修饰符 ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:3:1","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"事件参数 子组件可以给 $emit 提供一个额外的参数 1 2 3 \u003cbutton @click=\"$emit('increaseBy', 1)\"\u003e Increase by 1 \u003c/button\u003e 父组件监听事件可以使用内联箭头函数或组件方法的第一个参数接收该值 ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:3:2","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"声明触发的事件 defineEmits() 宏 1 2 3 \u003cscript setup\u003e defineEmits(['inFocus', 'submit']) \u003c/script\u003e ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:3:3","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"事件校验 emit事件也可以使用对象形式 对象中emit键值对中值是一个函数。该函数的参数就是触发事件是的附带参数，返回一个bool值来表明是否合法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u003cscript setup\u003e const emit = defineEmits({ // 没有校验 click: null, // 校验 submit 事件 submit: ({ email, password }) =\u003e { if (email \u0026\u0026 password) { return true } else { console.warn('Invalid submit event payload!') return false } } }) function submitForm(email, password) { emit('submit', { email, password }) } \u003c/script\u003e ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:3:4","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"配合 v-model 使用 v-model:xxx(xxx默认值为value) 会自动转换，转换规则： 1 \u003cComponent v-model:xxx=\"yyy\" /\u003e 转换为 1 2 3 4 \u003cComponent :modelXxx=\"yyy\" @update:modelXxx=\"newXxx =\u003e yyy = newXxx\" /\u003e 所以子组件里面需要实现： xxx 组件属性绑定到 modelXxx 组件props xxx 修改时触发 update:modelXxx 事件 1 2 3 4 5 6 7 8 9 10 11 12 \u003c!-- CustomInput.vue --\u003e \u003cscript setup\u003e defineProps(['modelXxx']) defineEmits(['update:modelXxx']) \u003c/script\u003e \u003ctemplate\u003e \u003cinput :value=\"modelXxx\" @input=\"$emit('update:modelXxx', $event.target.value)\" /\u003e \u003c/template\u003e 实现之后就能在组件上使用v-model:xxx了 可以绑定多个v-model：xxx ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:3:5","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"自定义v-model修饰符 在子组件的defineProps宏中定义一个叫做 xxxModifiers(xxx默认值为model) 的 prop 。子组件中可以通过该prop查询父组件使用的修饰符 父组件 1 \u003cMyComponent v-model:title.capitalize=\"myText\"\u003e 子组件 1 2 3 4 const props = defineProps(['title', 'titleModifiers']) defineEmits(['update:title']) console.log(props.titleModifiers) // { capitalize: true } ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:3:6","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"透传 Attributes ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:4:0","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"Attributes 继承 “透传 attribute”指的是没有被子组件组件props 或 emits 捕获的 attribute 或者 v-on 事件监听器。 template为单元素的子组件会自动将这些属性和事件监听器交给template子元素，并将其跟子元素的属性和事件监听器合并（比如class，style和id） ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:4:1","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"禁用 Attributes 继承 被传递子组件选项中设置 inheritAttrs: false \u003cscript setup\u003e，你需要一个额外的 \u003cscript\u003e 块来书写这个选项声明： 1 2 3 4 5 6 7 8 9 10 \u003cscript\u003e // 使用普通的 \u003cscript\u003e 来声明选项 export default { inheritAttrs: false } \u003c/script\u003e \u003cscript setup\u003e // ...setup 部分逻辑 \u003c/script\u003e 在模板的表达式中，可以通过 $attrs 访问透传的属性 $attrs保留了template原本的格式，@xxx 被转换为 $attrs.onXxx。 ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:4:2","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"多根节点的 Attributes 继承 v-bind=\"$attrs\" 将透传属性显式绑定给某个元素 1 \u003cmain v-bind=\"$attrs\"\u003e...\u003c/main\u003e 多个根节点的组件没有自动 attribute 透传行为 如果没有被显式绑定$attrs，会抛出一个运行时警告 ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:4:3","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"在 JavaScript 中访问透传 Attributes useAttrs() API 访问一个组件的所有透传 attribute： 1 2 3 4 5 \u003cscript setup\u003e import { useAttrs } from 'vue' const attrs = useAttrs() \u003c/script\u003e ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:4:4","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"插槽 Slots ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:5:0","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"插槽内容与出口 给子组件传递模板数据 父组件 1 2 3 \u003cFancyButton\u003e Click me! \u003c!-- 插槽内容 --\u003e \u003c/FancyButton\u003e 子组件 1 2 3 \u003cbutton class=\"fancy-btn\"\u003e \u003cslot\u003e\u003c/slot\u003e \u003c!-- 插槽出口 --\u003e \u003c/button\u003e ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:5:1","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"渲染作用域 插槽内容无法访问子组件的数据 ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:5:2","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"默认内容 当父组件没有给子组件提供插槽内容的时候，使用子组件 \u003cslot\u003e标签里面的内容 ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:5:3","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"具名插槽 子组件带 name 的插槽被称为具名插槽 (named slots) 1 2 3 4 5 6 7 8 9 10 11 \u003cdiv class=\"container\"\u003e \u003cheader\u003e \u003cslot name=\"header\"\u003e\u003c/slot\u003e \u003c/header\u003e \u003cmain\u003e \u003cslot\u003e\u003c/slot\u003e \u003c/main\u003e \u003cfooter\u003e \u003cslot name=\"footer\"\u003e\u003c/slot\u003e \u003c/footer\u003e \u003c/div\u003e 父组件使用含 v-slot:xxx 指令的 \u003ctemplate\u003e 元素传递数据给子组件的xxx具名插槽 1 2 3 4 5 \u003cBaseLayout\u003e \u003ctemplate v-slot:header\u003e \u003c!-- header 插槽的内容放这里 --\u003e \u003c/template\u003e \u003c/BaseLayout\u003e v-slot 简写 # ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:5:4","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"动态插槽名 1 2 3 4 5 6 7 8 9 10 \u003cbase-layout\u003e \u003ctemplate v-slot:[dynamicSlotName]\u003e ... \u003c/template\u003e \u003c!-- 缩写为 --\u003e \u003ctemplate #[dynamicSlotName]\u003e ... \u003c/template\u003e \u003c/base-layout\u003e ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:5:5","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"作用域插槽 子组件使用属性给父组件传数据，类似组件props的反向传输，被称为插槽props 子组件， 1 2 3 4 \u003c!-- \u003cMyComponent\u003e 的模板 --\u003e \u003cdiv\u003e \u003cslot :text=\"greetingMessage\" :count=\"1\"\u003e\u003c/slot\u003e \u003c/div\u003e 父组件 1 2 3 \u003cMyComponent v-slot=\"slotProps\"\u003e {{ slotProps.text }} {{ slotProps.count }} \u003c/MyComponent\u003e slot props可以在父组件中解构。 1 2 3 \u003cMyComponent v-slot=\"{ text, count }\"\u003e {{ text }} {{ count }} \u003c/MyComponent\u003e 具名作用域插槽 子组件：name与具名插槽一样，多了一些插槽props属性 1 \u003cslot name=\"header\" message=\"hello\"\u003e\u003c/slot\u003e 父组件：v-slot:（#）与具名插槽相比给了一个值，可以在模板变量中使用该值能获取子组件传的数据 1 2 3 4 5 6 7 8 9 10 11 12 13 \u003cMyComponent\u003e \u003ctemplate #header=\"headerProps\"\u003e {{ headerProps }} \u003c/template\u003e \u003ctemplate #default=\"defaultProps\"\u003e {{ defaultProps }} \u003c/template\u003e \u003ctemplate #footer=\"footerProps\"\u003e {{ footerProps }} \u003c/template\u003e \u003c/MyComponent\u003e 高级列表组件示例 见官网 无渲染组件 包括了逻辑，不渲染内容，仅通过作用域插槽向父组件传送数据的组件叫无渲染组件 ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:5:6","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"依赖注入 ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:6:0","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"Prop 逐级透传问题 麻烦，使用provide 和 inject ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:6:1","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"Provide (提供) 1 2 3 4 5 \u003cscript setup\u003e import { provide } from 'vue' provide(/* 注入名 */ 'message', /* 值 */ 'hello!') \u003c/script\u003e 值可以是任意类型，通常为响应式状态，以建立后代组件和提供者的响应式联系 ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:6:2","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"应用层 Provide 1 2 3 4 5 import { createApp } from 'vue' const app = createApp({}) app.provide(/* 注入名 */ 'message', /* 值 */ 'hello!') ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:6:3","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"Inject (注入) 1 2 3 4 5 \u003cscript setup\u003e import { inject } from 'vue' const message = inject('message') \u003c/script\u003e 注入默认值 注入时添加一个默认值，当没有提供者时使用默认值 1 2 3 // 如果没有祖先组件提供 \"message\" // `value` 会是 \"这是默认值\" const value = inject('message', '这是默认值') 可以使用工厂函数来创建默认值： 1 const value = inject('key', () =\u003e new ExpensiveClass()) ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:6:4","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"和响应式数据配合使用 建议尽可能将任何对响应式状态的变更都保持在供给方组件中 readonly()确保数据不被注入方修改 1 2 3 4 5 6 \u003cscript setup\u003e import { ref, provide, readonly } from 'vue' const count = ref(0) provide('read-only-count', readonly(count)) \u003c/script\u003e ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:6:5","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"使用 Symbol 作注入名 使用 Symbol 来作为注入名以避免潜在的冲突 在一个单独的文件中导出这些注入名 Symbol 1 2 // keys.js export const myInjectionKey = Symbol() 1 2 3 4 5 6 7 // 在供给方组件中 import { provide } from 'vue' import { myInjectionKey } from './keys.js' provide(myInjectionKey, { /* 要提供的数据 */ }); 1 2 3 4 5 // 注入方组件 import { inject } from 'vue' import { myInjectionKey } from './keys.js' const injected = inject(myInjectionKey) ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:6:6","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"异步组件 ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:7:0","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"基本用法 defineAsyncComponent 方法懒加载 1 2 3 4 5 6 7 8 9 import { defineAsyncComponent } from 'vue' const AsyncComp = defineAsyncComponent(() =\u003e { return new Promise((resolve, reject) =\u003e { // ...从服务器获取组件 resolve(/* 获取到的组件 */) }) }) // ... 像使用其他一般组件一样使用 `AsyncComp` defineAsyncComponent 方法接收一个返回 Promise 的加载函数。这个 Promise 的 resolve 回调方法应该在从服务器获得组件定义时调用。也可以调用 reject(reason) 表明加载失败。 ES 模块动态导入也会返回一个 Promise，所以多数情况下我们会将它和 defineAsyncComponent 搭配使用： 1 2 3 4 5 import { defineAsyncComponent } from 'vue' const AsyncComp = defineAsyncComponent(() =\u003e import('./components/MyComponent.vue') ) AsyncComp仅在页面需要它渲染时才会调用加载内部实际组件的函数，将接收到的 props 和插槽传给内部组件 异步组件也可以使用 app.component() 全局注册 也可以直接在父组件中直接定义它们： 1 2 3 4 5 6 7 8 9 10 11 \u003cscript setup\u003e import { defineAsyncComponent } from 'vue' const AdminPage = defineAsyncComponent(() =\u003e import('./components/AdminPageComponent.vue') ) \u003c/script\u003e \u003ctemplate\u003e \u003cAdminPage /\u003e \u003c/template\u003e ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:7:1","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"加载与错误状态 传入一个带选项的对象而不仅仅是Promis对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const AsyncComp = defineAsyncComponent({ // 加载函数 loader: () =\u003e import('./Foo.vue'), // 加载异步组件时使用的组件 loadingComponent: LoadingComponent, // 展示加载组件前的延迟时间，默认为 200ms delay: 200, // 加载失败后展示的组件 errorComponent: ErrorComponent, // 如果提供了一个 timeout 时间限制，并超时了 // 也会显示这里配置的报错组件，默认值是：Infinity timeout: 3000 }) ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:7:2","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"搭配 Suspense 使用 ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/:7:3","tags":["Vue教程"],"title":"Vue-3深入组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/3%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"CSDN Senora 思否 Caddo 最大区别就是this指向。 普通函数：this指向直接调用者，非严格模式下没有找到直接调用者就指向window（严格模式下this是undefined）。 箭头函数没有prototype(原型)，所以箭头函数本身没有this。 箭头函数内部的this是词法作用域，由上下文确定，this指向在定义的时候继承自外层第一个普通函数的this。函数体内的this对象，就是定义时所在的对象，与使用时所在的对象无关。 ","date":"2022-12-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/%E6%9D%82%E8%AE%B0/js%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%92%8C%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/:0:0","tags":["前端杂记"],"title":"前端-杂记-Js匿名函数和箭头函数的区别","uri":"/posts/%E5%89%8D%E7%AB%AF/%E6%9D%82%E8%AE%B0/js%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%92%8C%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["前端"],"content":"本系列是作者在跟着Vue官网学习时做的笔记，可能并不详尽，读者可以到官网中查看完整内容。本文只讲解带有\u003cscript setup\u003e组合式API。 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:0:0","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"创建一个 Vue 应用 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:1:0","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"应用实例（APP） 组件其实就是一个对象（后面会讲），可以从vue文件导出（这样的组件是可复用的），具有一些特定的属性和方法。 通过一个组件来创建app 1 2 3 4 5 import { createApp } from 'vue' const app = createApp({ /* 根组件选项 */ }) ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:1:1","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"根组件（vue） 创建app的组件叫根组件 1 2 3 import App from './App.vue' const app = createApp(App) ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:1:2","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"挂载应用 app.mount(“xxx”)将app挂载到index.html来渲染页面 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:1:3","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"DOM 中的根组件模板 index.html 1 2 3 \u003cdiv id=\"app\"\u003e \u003cbutton @click=\"count++\"\u003e{{ count }}\u003c/button\u003e \u003c/div\u003e main.js 1 2 3 4 5 6 7 8 9 10 11 import { createApp } from 'vue' const app = createApp({ data() { return { count: 0 } } }) app.mount('#app') 当app的根组件没有 template 选项（组合式API也使用术语选项，但是其实表现为属性）时，Vue 将自动使用#app容器的 innerHTML 作为模板 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:1:4","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"应用配置 app.config对象暴露对应用配置的API，详见官网 app.component(“注册名称”.组件)方法注册应用范围组件：app.component('TodoDeleteButton', TodoDeleteButton)\r","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:1:5","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"多个应用实例 一个页面可以绑定多个app 1 2 3 4 5 6 7 8 9 const app1 = createApp({ /* ... */ }) app1.mount('#container-1') const app2 = createApp({ /* ... */ }) app2.mount('#container-2') ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:1:6","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"模板语法 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:2:0","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"文本插值 template是vue组件的一个选项（属性），和html写法一致 1 \u003cspan\u003eMessage: {{ msg }}\u003c/span\u003e {{ msg }}就是文本插值，会被替换为该组件实例的msg属性值，这种属性一般都是响应式的，js中修改这些属性值会触发页面重新渲染以同步修改 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:2:1","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"原始 HTML 1 2 \u003cp\u003eUsing text interpolation: {{ rawHtml }}\u003c/p\u003e \u003cp\u003eUsing v-html directive: \u003cspan v-html=\"rawHtml\"\u003e\u003c/span\u003e\u003c/p\u003e 指令（其实应该是template元素的属性）由 v- 作为前缀，表明它们是一些由 Vue 提供的特殊 attribute v-html指令在当前组件实例上，将此元素的 innerHTML 与 rawHtml 属性绑定 不推荐使用v-html，容易造成XSS漏洞 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:2:2","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"Attribute 绑定 v-bind 指令：template元素属性值和组件属性值单向绑定（改变组件属性值会触发template元素属性值修改） 1 \u003cdiv v-bind:id=\"dynamicId\"\u003e\u003c/div\u003e 简写： : 1 \u003cdiv :id=\"dynamicId\"\u003e\u003c/div\u003e 布尔型 Attribute： 组件属性为真——template元素具有该属性 组件属性为假——template元素没有该属性 动态绑定多个值： 即通过\"v-bind\"（注意不是\"v-bind:xxx\"）属性给template（后面统称页面）元素绑定组件的一个对象属性，对象属性的每一对键值为页面元素的属性名和绑定值 1 \u003cdiv v-bind=\"objectOfAttrs\"\u003e\u003c/div\u003e ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:2:3","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"使用 JavaScript 表达式 js表达式可以应用于： 在文本插值中 (双大括号) 在任何 Vue 指令 (以 v- 开头的特殊 attribute) attribute 的值中 仅支持单一表达式 可以在表达式中调用函数 仅能够访问到全局对象列表中的全局对象， app.config.globalProperties 可以添加对象到该列表以供其他组件使用 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:2:4","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"指令 Directives v-开头的特殊template元素属性。 参数 Arguments：指令:后面的标识符 动态参数：[]括起来的标识符，应该为组件的一个数据属性 动态参数值应当是一个字符串，或者是 null（显式移除该绑定） 不要使用复杂的动态参数，用计算数学代替 修饰符 Modifiers 以点开头的指令后缀，表示特殊绑定，在执行绑定渲染之前先执行一些其他的任务。 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:2:5","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"响应式基础 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:3:0","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"声明响应式状态 reactive() 函数创建一个响应式对象或数组 1 2 3 import { reactive } from 'vue' const state = reactive({ count: 0 }) 响应式对象其实是 JavaScript Proxy实现的 在 setup() 函数中定义并返回响应式对象或者更新响应式状态的函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import { reactive } from 'vue' export default { setup() { const state = reactive({ count: 0 }) function increment() { state.count++ } // 不要忘记同时暴露 increment 函数 return { state, increment } } } 1 2 3 \u003cbutton @click=\"increment\"\u003e {{ state.count }} \u003c/button\u003e \u003cscript setup\u003e可以省略setup()函数暴露的过程，即js里面定义的响应式对象直接作为组件的属性。 DOM 更新时机：响应式状态改变和DOM（渲染）更新不是同步的，会等到更新周期的“下个时机”更新DOM，在这期间的修改只取最后一次的结果 nextTick()全局API可以让函数在更新完之后执行 1 2 3 4 5 6 7 8 import { nextTick } from 'vue' function increment() { state.count++ nextTick(() =\u003e { // 访问更新后的 DOM }) } 深层响应性:响应式状态内部的对象或数组改变也会更新。可以定义一个浅层响应式对象 响应式代理 vs. 原始对象： reactive() 返回的是一个原始对象的 Proxy，并不相等。 修改原始对象不能触发更新，仅使用reactive()的返回值 对代理对象调用reactive()会返回它自己 响应式对象内的对象仍然是代理 1 2 3 4 5 6 const proxy = reactive({}) const raw = {} proxy.nested = raw console.log(proxy.nested === raw) // false reactive() 的局限性 仅对对象类型有效，对 string、number 和 boolean 这样的 原始类型 无效 通过属性访问进行追踪，必须始终保持对该响应式对象的相同引用。随意地“替换”一个响应式对象将导致对初始引用的响应性连接丢失 1 2 3 4 let state = reactive({ count: 0 }) // 上面的引用 ({ count: 0 }) 将不再被追踪（响应性连接已丢失！） state = reactive({ count: 1 }) ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:3:1","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"用 ref() 定义响应式变量 ref() 方法来允许我们创建可以使用任何值类型的响应式 ref： 1 2 3 import { ref } from 'vue' const count = ref(0) ref() 将传入参数的值包装为一个带 .value 属性的 ref 对象： 1 2 3 4 5 6 7 const count = ref(0) console.log(count) // { value: 0 } console.log(count.value) // 0 count.value++ console.log(count.value) // 1 ref 的 .value 属性也是响应式的，当值为对象类型时，会用 reactive() 自动转换它的 .value ref 可以响应式地替换整个对象，也可以赋值给本地变量 ref 在模板中的解包：详见官网，我个人认为解包这个语法糖会增加vue的学习难度，对于Ref尽量都不要自动解包 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:3:2","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"计算属性 computed()方法接收一个箭头函数，返回值为一个计算属性 ref。计算属性可以用.value访问。计算属性和函数体中使用的属性会建立依赖，他们会同步更新 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:4:0","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"计算属性缓存 vs 方法 相比于在表达式中调用函数，计算属性值会基于其响应式依赖被缓存。一个计算属性仅会在其响应式依赖更新时才重新计算。方法调用总是会在重渲染发生时再次执行函数。 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:4:1","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"可写计算属性 计算属性默认是只读的即只传递一个箭头函数。当传递一个具有getter 和 setter 的对象时为可写计算属性： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u003cscript setup\u003e import { ref, computed } from 'vue' const firstName = ref('John') const lastName = ref('Doe') const fullName = computed({ // getter get() { return firstName.value + ' ' + lastName.value }, // setter set(newValue) { // 注意：我们这里使用的是解构赋值语法 [firstName.value, lastName.value] = newValue.split(' ') } }) \u003c/script\u003e 当你再运行 fullName.value = ‘John Doe’ 时，setter 会被调用而 firstName 和 lastName 会随之更新 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:4:2","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"最佳实践 不要在 getter 中做异步请求或者更改 DOM 避免直接修改计算属性值 尽量不要用可写计算属性 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:4:3","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"Class 与 Style 绑定 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:5:0","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"绑定 HTML class 绑定对象： 1 \u003cdiv :class=\"{ active: isActive }\"\u003e\u003c/div\u003e 值为bool的class对象属性和template属性绑定类似，即真为有该属性，假为没有该属性 :class 指令可以和一般的 class attribute 共存 :class 可以绑定一个返回对象的计算属性 绑定数组 可以给 :class 绑定一个数组来渲染多个 CSS class： 1 \u003cdiv :class=\"[activeClass, errorClass]\"\u003e\u003c/div\u003e 可以使用三元表达式： 1 \u003cdiv :class=\"[isActive ? activeClass : '', errorClass]\"\u003e\u003c/div\u003e 可以在数组中嵌套对象 1 \u003cdiv :class=\"[{ active: isActive }, errorClass]\"\u003e\u003c/div\u003e 在组件上使用 只有一个根元素的组件，根元素会继承组件上的class属性，并与该元素上已有的 class 合并 如果组件有多个根元素，需要通过组件的 $attrs 属性指定哪个根元素来接收这个 class。 1 2 3 \u003c!-- MyComponent 模板使用 $attrs 时 --\u003e \u003cp :class=\"$attrs.class\"\u003eHi!\u003c/p\u003e \u003cspan\u003eThis is a child component\u003c/span\u003e ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:5:1","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"绑定内联样式(style) 绑定对象 1 \u003cdiv :style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"\u003e\u003c/div\u003e 支持 kebab-cased 和camelCase 形式的 CSS 属性 key，推荐使用 camelCase（html不区分大小写，编译器帮忙转换） 可以使用返回样式对象的计算属性 绑定数组 1 \u003cdiv :style=\"[baseStyles, overridingStyles]\"\u003e\u003c/div\u003e 自动前缀 Vue 会为需要浏览器特殊前缀的CSS属性自动加上相应的浏览器前缀 样式多值 1 \u003cdiv :style=\"{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }\"\u003e\u003c/div\u003e 数组仅会渲染浏览器支持的最后一个值。 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:5:2","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"条件渲染 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:6:0","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"v-if 1 \u003ch1 v-if=\"awesome\"\u003eVue is awesome!\u003c/h1\u003e ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:6:1","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"v-else 1 2 3 4 \u003cbutton @click=\"awesome = !awesome\"\u003eToggle\u003c/button\u003e \u003ch1 v-if=\"awesome\"\u003eVue is awesome!\u003c/h1\u003e \u003ch1 v-else\u003eOh no 😢\u003c/h1\u003e 必须跟在一个 v-if 或者 v-else-if 元素后面，否则它将不会被识别 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:6:2","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"v-else-if 和 v-else 类似，必须紧跟在一个 v-if 或一个 v-else-if 元素后面。 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:6:3","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":" 可以将多个元素放到\u003ctemplate\u003e 元素中使用该元素上的条件渲染属性统一进行条件渲染，\u003ctemplate\u003e只是一个不可见的包装器元素，最后渲染的结果并不会包含这个 \u003ctemplate\u003e 元素。 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:6:4","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"v-show 1 \u003ch1 v-show=\"ok\"\u003eHello!\u003c/h1\u003e 具有v-show为false的元素会保留在DOM中，v-if为false的元素不会出现在DOM中，v-show仅切换了display style属性 v-show 不支持在 \u003ctemplate\u003e 元素上使用，也不能和 v-else 搭配使用。 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:6:5","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"v-if vs. v-show v-if 是“真实的”按条件渲染，确保了在切换时，条件区块内的事件监听器和子组件都会被销毁或重建。 v-if 也是惰性的：初次渲染时条件值为 false，不会做任何事。只有当条件首次变为 true 时才被渲染。 v-show 简单许多，始终会被渲染，只有 CSS display 属性会被切换 v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。需要频繁切换，则使用 v-show 较好；条件很少改变，则 v-if 会更合适 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:6:6","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"v-if 和 v-for v-if 和 v-for 同时存在于一个元素上的时候，v-if 会首先被执行。 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:6:7","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"列表渲染 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:7:0","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"v-for v-for 指令的值需要使用 item in items 形式的特殊语法 1 2 3 \u003cli v-for=\"item in items\"\u003e {{ item.message }} \u003c/li\u003e v-for 块中可以完整地访问父作用域内的属性和变量 v-for 也支持使用可选的第二个参数表示当前项的位置索引 1 2 3 \u003cli v-for=\"(item, index) in items\"\u003e {{ parentMessage }} - {{ index }} - {{ item.message }} \u003c/li\u003e 可以在定义 v-for 的变量别名时使用解构，和解构函数参数类似： 1 2 3 4 5 6 7 8 \u003cli v-for=\"{ message } in items\"\u003e {{ message }} \u003c/li\u003e \u003c!-- 有 index 索引时 --\u003e \u003cli v-for=\"({ message }, index) in items\"\u003e {{ message }} {{ index }} \u003c/li\u003e 多层嵌套的 v-for，每个 v-for 作用域都可以访问到父级作用域： 1 2 3 4 5 \u003cli v-for=\"item in items\"\u003e \u003cspan v-for=\"childItem in item.children\"\u003e {{ item.message }} {{ childItem }} \u003c/span\u003e \u003c/li\u003e 可以用of代替in（不推荐，甚至在js里也不推荐，会增加语言学习难度） ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:7:1","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"v-for 与对象 可以使用 v-for 来遍历一个对象的所有属性（使用Object.keys()实现） 1 2 3 4 5 6 7 8 9 10 11 \u003cli v-for=\"value in myObject\"\u003e {{ value }} \u003c/li\u003e \u003cli v-for=\"(value, key) in myObject\"\u003e {{ key }}: {{ value }} \u003c/li\u003e \u003cli v-for=\"(value, key, index) in myObject\"\u003e {{ index }}. {{ key }}: {{ value }} \u003c/li\u003e ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:7:2","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"在 v-for 里使用范围值 类似range(n)，n从1开始迭代 1 \u003cspan v-for=\"n in 10\"\u003e{{ n }}\u003c/span\u003e ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:7:3","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":" 上的 v-for 1 2 3 4 5 6 \u003cul\u003e \u003ctemplate v-for=\"item in items\"\u003e \u003cli\u003e{{ item.msg }}\u003c/li\u003e \u003cli class=\"divider\" role=\"presentation\"\u003e\u003c/li\u003e \u003c/template\u003e \u003c/ul\u003e ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:7:4","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"通过 key 管理状态 key 让 Vue 跟踪每个节点，从而重用和重新排序现有的元素 1 2 3 \u003cdiv v-for=\"item in items\" :key=\"item.id\"\u003e \u003c!-- 内容 --\u003e \u003c/div\u003e key 绑定基础类型。不要用对象。 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:7:5","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"组件上使用 v-for 1 \u003cMyComponent v-for=\"item in items\" :key=\"item.id\" /\u003e ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:7:6","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"数组变化侦测 push()，pop()，shift()，unshift()，splice()，sort()，reverse() 使用这些方法更新响应式数组 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:7:7","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"展示过滤或排序后的结果 将数组排序后再给v-for，可以使用返回数组的计算属性或者函数 注意，reverse() 和 sort()会修改原数组 1 2 - return numbers.reverse() + return [...numbers].reverse() ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:7:8","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"事件处理 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:8:0","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"监听事件 v-on 指令 (简写为 @) 内联事件处理器:内联 JavaScript 语句 方法事件处理器:组件上定义的方法的属性名或是路径 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:8:1","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"内联事件处理器 1 const count = ref(0) 1 2 \u003cbutton @click=\"count++\"\u003eAdd 1\u003c/button\u003e \u003cp\u003eCount is: {{ count }}\u003c/p\u003e ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:8:2","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"方法事件处理器 1 2 3 4 5 6 7 function greet(event) { alert(`Hello ${name.value}!`) // `event` 是 DOM 原生事件 if (event) { alert(event.target.tagName) } } 1 2 \u003c!-- `greet` 是上面定义过的方法名 --\u003e \u003cbutton @click=\"greet\"\u003eGreet\u003c/button\u003e 方法事件处理器会自动接收原生 DOM 事件并触发执行 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:8:3","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"在内联处理器中调用方法 可以在内联事件处理器中调用方法，向方法传入自定义参数以代替原生事件 1 2 3 function say(message) { alert(message) } 1 2 \u003cbutton @click=\"say('hello')\"\u003eSay hello\u003c/button\u003e \u003cbutton @click=\"say('bye')\"\u003eSay bye\u003c/button\u003e ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:8:4","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"在内联事件处理器中访问事件参数 使用$event 变量在内联事件处理器中访问原生 DOM 事件， 或者使用箭头函数 1 2 3 4 5 6 7 8 9 \u003c!-- 使用特殊的 $event 变量 --\u003e \u003cbutton @click=\"warn('Form cannot be submitted yet.', $event)\"\u003e Submit \u003c/button\u003e \u003c!-- 使用内联箭头函数 --\u003e \u003cbutton @click=\"(event) =\u003e warn('Form cannot be submitted yet.', event)\"\u003e Submit \u003c/button\u003e 1 2 3 4 5 6 7 function warn(message, event) { // 这里可以访问原生事件 if (event) { event.preventDefault() } alert(message) } ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:8:5","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"事件修饰符 .stop：停止传递 .prevent：不重新加载页面 .self：忽略来自子元素的事件 .capture：使用 capture 捕获模式 .once：最多被触发一次 .passive：事件默认行为立即发生，不等待绑定函数执行完成 可以链式调用，先调用的对后面的都有效 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:8:6","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"按键修饰符 用于键盘事件，KeyboardEvent.key，key使用kebab-case 1 2 \u003c!-- 仅在 `key` 为 `Enter` 时调用 `submit` --\u003e \u003cinput @keyup.enter=\"submit\" /\u003e 按键别名： .enter .tab .delete (捕获“Delete”和“Backspace”两个按键) .esc .space .up .down .left .right 系统按键修饰符： .ctrl .alt .shift .meta 1 2 3 4 5 \u003c!-- Alt + Enter --\u003e \u003cinput @keyup.alt.enter=\"clear\" /\u003e \u003c!-- Ctrl + 点击 --\u003e \u003cdiv @click.ctrl=\"doSomething\"\u003eDo something\u003c/div\u003e .exact 修饰符:仅允许确定组合的事件 1 2 3 4 5 6 7 8 \u003c!-- 当按下 Ctrl 时，即使同时按下 Alt 或 Shift 也会触发 --\u003e \u003cbutton @click.ctrl=\"onClick\"\u003eA\u003c/button\u003e \u003c!-- 仅当按下 Ctrl 且未按任何其他键时才会触发 --\u003e \u003cbutton @click.ctrl.exact=\"onCtrlClick\"\u003eA\u003c/button\u003e \u003c!-- 仅当没有按下任何系统按键时触发 --\u003e \u003cbutton @click.exact=\"onClick\"\u003eA\u003c/button\u003e ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:8:7","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"鼠标按键修饰符 .left .right .middle ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:8:8","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"表单输入绑定 1 \u003cinput v-model=\"text\"\u003e ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:9:0","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"基本用法 文本：绑定字符串变量 1 2 \u003cp\u003eMessage is: {{ message }}\u003c/p\u003e \u003cinput v-model=\"message\" placeholder=\"edit me\" /\u003e 多行文本：绑定字符串变量 1 2 3 \u003cspan\u003eMultiline message is:\u003c/span\u003e \u003cp style=\"white-space: pre-line;\"\u003e{{ message }}\u003c/p\u003e \u003ctextarea v-model=\"message\" placeholder=\"add multiple lines\"\u003e\u003c/textarea\u003e \u003ctextarea\u003e 中是不支持插值表达式 1 2 3 4 5 \u003c!-- 错误 --\u003e \u003ctextarea\u003e{{ text }}\u003c/textarea\u003e \u003c!-- 正确 --\u003e \u003ctextarea v-model=\"text\"\u003e\u003c/textarea\u003e 复选框:绑定bool或者数组 1 2 \u003cinput type=\"checkbox\" id=\"checkbox\" v-model=\"checked\" /\u003e \u003clabel for=\"checkbox\"\u003e{{ checked }}\u003c/label\u003e 将多个复选框绑定到同一个数组或集合的值： 1 const checkedNames = ref([]) 1 2 3 4 5 6 7 8 9 10 \u003cdiv\u003eChecked names: {{ checkedNames }}\u003c/div\u003e \u003cinput type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\"\u003e \u003clabel for=\"jack\"\u003eJack\u003c/label\u003e \u003cinput type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\"\u003e \u003clabel for=\"john\"\u003eJohn\u003c/label\u003e \u003cinput type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\"\u003e \u003clabel for=\"mike\"\u003eMike\u003c/label\u003e 单选按钮:绑定字符串变量 1 2 3 4 5 6 7 \u003cdiv\u003ePicked: {{ picked }}\u003c/div\u003e \u003cinput type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\" /\u003e \u003clabel for=\"one\"\u003eOne\u003c/label\u003e \u003cinput type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\" /\u003e \u003clabel for=\"two\"\u003eTwo\u003c/label\u003e 选择器：绑定字符串变量或数组 单选 1 2 3 4 5 6 7 8 \u003cdiv\u003eSelected: {{ selected }}\u003c/div\u003e \u003cselect v-model=\"selected\"\u003e \u003coption disabled value=\"\"\u003ePlease select one\u003c/option\u003e \u003coption\u003eA\u003c/option\u003e \u003coption\u003eB\u003c/option\u003e \u003coption\u003eC\u003c/option\u003e \u003c/select\u003e 多选 1 2 3 4 5 6 7 \u003cdiv\u003eSelected: {{ selected }}\u003c/div\u003e \u003cselect v-model=\"selected\" multiple\u003e \u003coption\u003eA\u003c/option\u003e \u003coption\u003eB\u003c/option\u003e \u003coption\u003eC\u003c/option\u003e \u003c/select\u003e option 可以用 v-for 动态渲染 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:9:1","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"值绑定 v-model 绑定的值通常是静态的字符串 (或者对复选框是布尔值) v-bind 可以绑定为非字符串的数据类型，可以将之前绑定静态字符串的value等属性用v-bind绑定 复选框 1 2 3 4 5 \u003cinput type=\"checkbox\" v-model=\"toggle\" true-value=\"yes\" false-value=\"no\" /\u003e true-value 和 false-value 是 Vue 特有的 attributes，仅支持和 v-model 配套使用 可以通过 v-bind 将其绑定为其他动态值 1 2 3 4 5 \u003cinput type=\"checkbox\" v-model=\"toggle\" :true-value=\"dynamicTrueValue\" :false-value=\"dynamicFalseValue\" /\u003e 单选按钮 1 2 \u003cinput type=\"radio\" v-model=\"pick\" :value=\"first\" /\u003e \u003cinput type=\"radio\" v-model=\"pick\" :value=\"second\" /\u003e 选择器选项 1 2 3 4 \u003cselect v-model=\"selected\"\u003e \u003c!-- 内联对象字面量 --\u003e \u003coption :value=\"{ number: 123 }\"\u003e123\u003c/option\u003e \u003c/select\u003e ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:9:2","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"修饰符 .lazy：默认是input 事件后更新数据，该修饰符改为在每次 change 事件后更新数据 .number：输入自动转换为数字，无法被 parseFloat() 处理时将返回原始值。number 修饰符会在输入框有 type=“number” 时自动启用 .trim：自动去除用户输入内容中两端的空格 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:9:3","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"生命周期钩子 直接使用全局API，通常是on+生命周期钩子名称（即图中的红色框），使用camelCase 1 2 3 4 5 6 7 \u003cscript setup\u003e import { onMounted } from 'vue' onMounted(() =\u003e { console.log(`the component is now mounted.`) }) \u003c/script\u003e ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:10:0","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"侦听器(watch) ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:11:0","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"基本示例 侦听数据源类型 全局API watch(数据源，回调函数) 数据源是一个 ref (包括计算属性)、一个响应式对象、一个 getter 函数、或多个数据源组成的数组：不能直接侦听响应式对象的属性值，可以用一个返回该属性的 getter 函数代替 回调函数可以接收old值和new值。且通常是箭头函数。 1 2 3 4 5 6 7 // 提供一个 getter 函数 watch( () =\u003e obj.count, (count) =\u003e { console.log(`count is: ${count}`) } ) ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:11:1","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"深层侦听器 watch侦听响应式对象默认是深层侦听的，响应式对象属性发生改变也会触发回调 侦听getter函数时返回不同的对象时才触发回调，可以显式使用deep选项转换为深层侦听 1 2 3 4 5 6 7 8 watch( () =\u003e state.someObject, (newValue, oldValue) =\u003e { // 注意：`newValue` 此处和 `oldValue` 是相等的 // *除非* state.someObject 被整个替换了 }, { deep: true } ) ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:11:2","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"watchEffect(回调函数) 立即执行回调函数，并追踪函数体中的依赖关系分析出响应源。 watch vs. watchEffect：主要区别是追踪响应式依赖的方式 watch 只追踪明确侦听的数据源。懒加载，定义时不会执行。 watchEffect 在副作用发生期间追踪依赖。定义时会执行。 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:11:3","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"回调的触发时机 Vue 组件更新之前。回调中访问的 DOM 将是被 Vue 更新之前的状态。 flush: ‘post’ 选项指明组件更新后执行 1 2 3 4 5 6 7 watch(source, callback, { flush: 'post' }) watchEffect(callback, { flush: 'post' }) watchPostEffect()集成了该选项 1 2 3 4 5 import { watchPostEffect } from 'vue' watchPostEffect(() =\u003e { /* 在 Vue 更新后执行 */ }) ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:11:4","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"停止侦听器 用同步语句创建的侦听器会在宿主组件卸载时自动停止 异步回调创建的侦听器不会绑定到当前组件上，必须手动停止它，以防内存泄漏 1 2 3 4 5 6 7 8 9 10 11 \u003cscript setup\u003e import { watchEffect } from 'vue' // 它会自动停止 watchEffect(() =\u003e {}) // ...这个则不会！ setTimeout(() =\u003e { watchEffect(() =\u003e {}) }, 100) \u003c/script\u003e 调用 watch 或 watchEffect 返回的函数停止一个侦听器： 1 2 3 4 const unwatch = watchEffect(() =\u003e {}) // ...当该侦听器不再需要时 unwatch() ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:11:5","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"模板引用 通过 ref 属性获取底层 DOM 元素 1 \u003cinput ref=\"input\"\u003e ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:12:0","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"访问模板引用 声明一个同名的 ref 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u003cscript setup\u003e import { ref, onMounted } from 'vue' // 声明一个 ref 来存放该元素的引用 // 必须和模板里的 ref 同名 const input = ref(null) onMounted(() =\u003e { input.value.focus() }) \u003c/script\u003e \u003ctemplate\u003e \u003cinput ref=\"input\" /\u003e \u003c/template\u003e 在组件挂载后才能访问模板引用，否则为null，编程时需要考虑 null 的情况： 1 2 3 4 5 6 7 watchEffect(() =\u003e { if (input.value) { input.value.focus() } else { // 此时还未挂载，或此元素已经被卸载（例如通过 v-if 控制） } }) ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:12:1","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"v-for 中的模板引用 v-for元素ref attribute 使用数组ref绑定，ref数组不保证和html相同 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:12:2","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"函数模板引用 ref attribute 绑定（使用v-bind或者:）为一个函数，组件更新时被调用，第一个参数为DOM元素引用 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:12:3","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"组件上的 ref 引用中获得的值是组件实例 \u003cscript setup\u003e 的组件是默认私有的。一个父组件无法访问到一个使用了子组件中的任何东西，除非子组件在其中通过 defineExpose 宏显式暴露： 1 2 3 4 5 6 7 8 9 10 11 \u003cscript setup\u003e import { ref } from 'vue' const a = 1 const b = ref(2) defineExpose({ a, b }) \u003c/script\u003e 尽量避免使用组件ref，减少组件间的耦合 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:12:4","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"组件基础 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:13:0","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"定义一个组件 .vue 文件：单文件组件 (简称 SFC) 1 2 3 4 5 6 7 8 9 \u003cscript setup\u003e import { ref } from 'vue' const count = ref(0) \u003c/script\u003e \u003ctemplate\u003e \u003cbutton @click=\"count++\"\u003eYou clicked me {{ count }} times.\u003c/button\u003e \u003c/template\u003e ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:13:1","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"使用组件 \u003cscript setup\u003e组件将会以默认导出的形式被暴露给外部，导入的组件都在模板中直接可用。 全局地注册一个组件在当前应用中的任何组件上都可以使用 组件可以被重用任意多次，每一个组件都维护着自己的状态 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:13:2","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"传递 props defineProps 宏：声明的 props 会自动暴露给模板 1 2 3 4 5 6 7 8 \u003c!-- BlogPost.vue --\u003e \u003cscript setup\u003e defineProps(['title']) \u003c/script\u003e \u003ctemplate\u003e \u003ch4\u003e{{ title }}\u003c/h4\u003e \u003c/template\u003e 返回一个对象，其中包含了可以传递给组件的所有 props 1 2 const props = defineProps(['title']) console.log(props.title) 一个组件可以有任意多的 props，默认情况下，所有 prop 都接受任意类型的值 父组件传递数据给子组件： 1 2 3 \u003cBlogPost title=\"My journey with Vue\" /\u003e \u003cBlogPost title=\"Blogging with Vue\" /\u003e \u003cBlogPost title=\"Why Vue is so fun\" /\u003e v-bind 可以传递动态 prop 值 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:13:3","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"监听事件 父组件可以通过 v-on 或 @ 来选择性地监听子组件上抛的事件，就像监听原生 DOM 事件那样。 1 2 3 4 \u003cBlogPost ... @enlarge-text=\"postFontSize += 0.1\" /\u003e 子组件可以通过调用内置的 $emit 方法，通过传入事件名称来抛出一个事件 1 2 3 4 5 6 7 \u003c!-- BlogPost.vue, 省略了 \u003cscript\u003e --\u003e \u003ctemplate\u003e \u003cdiv class=\"blog-post\"\u003e \u003ch4\u003e{{ title }}\u003c/h4\u003e \u003cbutton @click=\"$emit('enlarge-text')\"\u003eEnlarge text\u003c/button\u003e \u003c/div\u003e \u003c/template\u003e 通过 defineEmits 宏来声明需要抛出的事件 1 2 3 4 5 \u003c!-- BlogPost.vue --\u003e \u003cscript setup\u003e defineProps(['title']) defineEmits(['enlarge-text']) \u003c/script\u003e ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:13:4","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"通过插槽来分配内容 子组件中传递HTML内容 父组件： 1 2 3 \u003cAlertBox\u003e Something bad happened. \u003c/AlertBox\u003e 子组件： 1 2 3 4 5 6 7 8 9 10 11 12 \u003ctemplate\u003e \u003cdiv class=\"alert-box\"\u003e \u003cstrong\u003eThis is an Error for Demo Purposes\u003c/strong\u003e \u003cslot /\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle scoped\u003e .alert-box { /* ... */ } \u003c/style\u003e \u003cslot\u003e 元素表示父组件html渲染位置 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:13:5","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"动态组件 通过组件的is属性实现 1 2 \u003c!-- currentTab 改变时组件也改变 --\u003e \u003ccomponent :is=\"tabs[currentTab]\"\u003e\u003c/component\u003e 值可以是： 被注册的组件名 导入的组件对象 \u003cKeepAlive\u003e 组件强制被切换掉的组件仍然保持“存活”的状态 1 2 3 4 \u003c!-- 非活跃的组件将会被缓存！ --\u003e \u003cKeepAlive\u003e \u003ccomponent :is=\"activeComponent\" /\u003e \u003c/KeepAlive\u003e ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:13:6","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"DOM 模板解析注意事项 见官网，没啥必要学，反正都是直接用单文件组件开发 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/:13:7","tags":["Vue教程"],"title":"Vue-2基础","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/2%E5%9F%BA%E7%A1%80/"},{"categories":["前端"],"content":"本系列是作者在跟着Vue官网学习时做的笔记，可能并不详尽，读者可以到官网中查看完整内容。本文只讲解带有\u003cscript setup\u003e组合式API。 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/1%E5%BC%80%E5%A7%8B/:0:0","tags":["Vue教程"],"title":"Vue-1开始","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/1%E5%BC%80%E5%A7%8B/"},{"categories":["前端"],"content":"简介 Vue (发音为 /vjuː/，类似 view) 是一款用于构建用户界面的 JavaScript 框架。 组合式 API (Composition API)：使用导入的 API 函数来描述组件逻辑。在单文件组件中，组合式 API 通常会与 \u003cscript setup\u003e 搭配使用。 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/1%E5%BC%80%E5%A7%8B/:1:0","tags":["Vue教程"],"title":"Vue-1开始","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/1%E5%BC%80%E5%A7%8B/"},{"categories":["前端"],"content":"快速上手 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/1%E5%BC%80%E5%A7%8B/:2:0","tags":["Vue教程"],"title":"Vue-1开始","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/1%E5%BC%80%E5%A7%8B/"},{"categories":["前端"],"content":"创建一个 Vue 应用 确保安装了最新版本的 Node.js，使用官方脚手架（后面更推荐vite）命令开始创建项目。 1 npm init vue@latest 按指引选择可选功能，完成项目创建 开发完后运行： 1 npm run build ./dist 文件夹中会创建一个生产环境的构建版本 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/1%E5%BC%80%E5%A7%8B/:2:1","tags":["Vue教程"],"title":"Vue-1开始","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/1%E5%BC%80%E5%A7%8B/"},{"categories":["前端"],"content":"通过 CDN 使用 Vue 见官网 ","date":"2022-12-15","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/1%E5%BC%80%E5%A7%8B/:2:2","tags":["Vue教程"],"title":"Vue-1开始","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/1%E5%BC%80%E5%A7%8B/"},{"categories":["Golang"],"content":"godoc godoc官方 ","date":"2022-12-15","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/go-zero/:0:0","tags":["go第三方库"],"title":"go第三方库-Go Zero","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/go-zero/"},{"categories":["Golang"],"content":"threading 该库是go-zero开源项目的一个组件，用于协程的并发安全，解决协程运行中panic无法解决的问题。 常用函数： func GoSafe(fn func())：安全启动一个协程执行fn，在协程panic时自动recover func RunSafe(fn func())：使用本协程安全运行fn，自动recover fn中产生的panic ","date":"2022-12-15","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/go-zero/:1:0","tags":["go第三方库"],"title":"go第三方库-Go Zero","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/go-zero/"},{"categories":["Golang"],"content":"godoc godoc官网 重要子包： layers：包含内置于 gopacket 中的用于解码数据包协议的逻辑。 pcap：C 绑定以使用 libpcap 读取离线数据包。 pfring：C 绑定使用 PF_RING 从线路上读取数据包。 afpacket：Linux 的 AF_PACKET 的 C 绑定，用于离线读取数据包。 tcpassembly：TCP 流重组 ","date":"2022-12-14","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gopacket/:0:0","tags":["go第三方库"],"title":"go第三方库-Gopacket","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"基本用法 gopacket 将数据包数据作为 []byte 并将其解码。数据包被解码后可以从数据包中获取包的头信息。 1 2 3 4 5 6 7 8 9 10 11 12 13 // 解码数据包 packet := gopacket.NewPacket(myPacketData, layers.LayerTypeEthernet, gopacket.Default) // 从这个数据包中获取 TCP 层 if tcpLayer := packet.Layer(layers.LayerTypeTCP); tcpLayer != nil { fmt.Println(\"This is a TCP packet!\") // 从这一层获取实际的 TCP 数据 tcp, _ := tcpLayer.(*layers.TCP) fmt.Printf(\"From src port %d to dst port %d\\n\", tcp.SrcPort, tcp.DstPort) } // 迭代所有层，打印出每个层类型 for _, layer := range packet.Layers() { fmt.Println(\"PACKET LAYER :\", layer.LayerType()) } 可以从多个起点解码数据包，允许解码没有完整数据的数据包 1 2 3 4 5 6 // 解码以太网数据包 ethP := gopacket.NewPacket(p1, layers.LayerTypeEthernet, gopacket.Default) // 解码 IPv6 标头及其包含的所有内容 ipP := gopacket.NewPacket(p2, layers.LayerTypeIPv6, gopacket.Default) // 解码 TCP 标头及其有效载荷 tcpP := gopacket.NewPacket(p3, layers.LayerTypeTCP, gopacket.Default) ","date":"2022-12-14","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gopacket/:1:0","tags":["go第三方库"],"title":"go第三方库-Gopacket","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"从源读取数据包 构建一个 PacketSource从某处（文件、接口等）读取数据包并处理它们 构造一个实现 PacketDataSource 接口的对象 将PacketDataSource与选择的解码器一起传递到 NewPacketSource，以创建一个 PacketSource 最常用的方法是 Packets 函数，它返回一个channel，然后将新数据包异步写入该channel，如果 packetSource 到达文件末尾则关闭channel 1 2 3 4 packetSource := ... // 使用 pcap 或 pfring 构造 packet := range packetSource.Packets() { handlePacket(packet) // 对每个数据包做一些事情 } ","date":"2022-12-14","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gopacket/:2:0","tags":["go第三方库"],"title":"go第三方库-Gopacket","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"惰性解码 可选择延迟解码数据包数据，这意味着它仅在需要处理函数调用时才解码数据包层 1 2 3 4 5 6 // 创建一个数据包，但实际上还没有解码任何东西 packet := gopacket.NewPacket(myPacketData, layers.LayerTypeEthernet, gopacket.Lazy) // 将数据包解码到找到的第一个 IPv4 层，但不再进一步。如果没有找到 IPv4 层，整个数据包将被解码以寻找ipv4。 ip4 := packet.Layer(layers.LayerTypeIPv4) // 解码所有层并返回它们。每层解码一次。 layers := packet.Layers() 延迟解码的数据包不是并发安全的。 ","date":"2022-12-14","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gopacket/:3:0","tags":["go第三方库"],"title":"go第三方库-Gopacket","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"NoCopy解码 默认解码结果是原数据包的副本，添加这个选项返回的结果不进行拷贝使用原数据包。 1 p := gopacket.NewPacket(data, layers.LayerTypeEthernet, gopacket.NoCopy) 最快的解码方法是同时使用 Lazy 和 NoCopy，但从上面的许多警告中请注意，对于某些实现，其中一个或两个都可能是危险的。 ","date":"2022-12-14","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gopacket/:4:0","tags":["go第三方库"],"title":"go第三方库-Gopacket","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"指向已知层的指针 在解码期间，某些层作为众所周知的层类型存储在数据包中.可以使用 packet.LinkLayer、packet.NetworkLayer、packet.TransportLayer 和 packet.ApplicationLayer 函数。前三层提供了获取该特定层的 src/dst 地址的方法，而最后一层提供了一个 Payload 函数来获取有效负载数据 1 2 3 4 5 6 7 8 // 从某个来源获取数据包 for packet := range someSource { if app := packet.ApplicationLayer(); app != nil { if strings.Contains(string(app.Payload()), \"magic string\") { fmt.Println(\"Found magic string in a packet!\") } } } 一个特别有用的层是 ErrorLayer，它会在数据包的解析部分出现错误时设置 1 2 3 4 packet := gopacket.NewPacket(myPacketData, layers.LayerTypeEthernet, gopacket.Default) if err := packet.ErrorLayer(); err != nil { fmt.Println(\"Error decoding some part of the packet:\", err) } 请注意，我们不会从 NewPacket 返回错误，因为在进入错误层之前，我们可能已经成功解码了多个层。即使您的 TCP 层格式不正确，您仍然可以正确获取以太网和 IPv4 层。 ","date":"2022-12-14","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gopacket/:5:0","tags":["go第三方库"],"title":"go第三方库-Gopacket","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"Flow和EndPoint gopacket 有两个有用的对象，Flow 和 Endpoint，用于以独立于协议的方式传达数据包来自 A 和去往 B 的事实。通用层类型 LinkLayer、NetworkLayer 和 TransportLayer 都提供提取其Flow信息的方法，不用担心底层的类型 Flow 是一个简单的对象，由两个端点组成，一个源和一个目的地。它详细说明了数据包层的发送方和接收方。 Endpoint是源或目标的可散列表示。例如，对于 LayerTypeIPv4，端点包含 IPv4 数据包的 IP 地址字节。Flow 可以分解为 Endpoints，而 Endpoints 可以组合成 Flows： 1 2 3 4 packet := gopacket.NewPacket(myPacketData, layers.LayerTypeEthernet, gopacket.Lazy) netFlow := packet.NetworkLayer().NetworkFlow() src, dst := netFlow.Endpoints() reverseFlow := gopacket.NewFlow(dst, src) Endpoint 和 Flow 对象都可以用作map的key，=可以比较它们，因此您可以根据端点标准轻松地将所有数据包组合在一起： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 flows := map[gopacket.Endpoint]chan gopacket.Packet packet := gopacket.NewPacket(myPacketData, layers.LayerTypeEthernet, gopacket.Lazy) // 根据目标端口将所有 TCP 数据包发送到通道。 if tcp := packet.Layer(layers.LayerTypeTCP); tcp != nil { flows[tcp.TransportFlow().Dst()] \u003c- packet } // 查找具有相同源和目标网络地址的所有数据包 if net := packet.NetworkLayer(); net != nil { src, dst := net.NetworkFlow().Endpoints() if src == dst { fmt.Println(\"Fishy packet has same network source and dst: %s\", src) } } // 查找所有从 UDP 端口 1000 到 UDP 端口 500 的数据包 interestingFlow := gopacket.FlowFromEndpoints(layers.NewUDPPortEndpoint(1000), layers.NewUDPPortEndpoint(500)) if t := packet.NetworkLayer(); t != nil \u0026\u0026 t.TransportFlow() == interestingFlow { fmt.Println(\"Found that UDP flow I was looking for!\") } 出于负载平衡的目的，Flow 和 Endpoint 都具有 FastHash() 函数，这些函数提供其内容的快速、非加密散列。特别重要的是 Flow FastHash() 是对称的：A-\u003eB 将具有与 B-\u003eA 相同的哈希值。一个示例用法可能是： 1 2 3 4 5 6 7 8 9 10 channels := [8]chan gopacket.Packet for i := 0; i \u003c 8; i++ { channels[i] = make(chan gopacket.Packet) go packetHandler(channels[i]) } for packet := range getPackets() { if net := packet.NetworkLayer(); net != nil { channels[int(net.NetworkFlow().FastHash()) \u0026 0x7] \u003c- packet } } 这使我们能够拆分数据包流，同时仍然确保每个流都能看到流的所有数据包（及其双向相反）。 ","date":"2022-12-14","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gopacket/:6:0","tags":["go第三方库"],"title":"go第三方库-Gopacket","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"实现你自己的解码器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //创建一个layer类型，参数1的值唯一且较大避免冲突， 给它一个名字和一个解码器来使用。 var MyLayerType = gopacket.RegisterLayerType(12345, gopacket.LayerTypeMetadata{Name: \"MyLayerType\", Decoder: gopacket.DecodeFunc(decodeMyLayer)}) //实现自定义layer type MyLayer struct { StrangeHeader []byte payload []byte } func (m MyLayer) LayerType() gopacket.LayerType { return MyLayerType } func (m MyLayer) LayerContents() []byte { return m.StrangeHeader } func (m MyLayer) LayerPayload() []byte { return m.payload } //实现一个解码器。该函数去掉了前4个字节的数据（选择前 4 个字节为包头）。 func decodeMyLayer(data []byte, p gopacket.PacketBuilder) error { // 创建mylayer p.AddLayer(\u0026MyLayer{data[:4], data[4:]}) // 确定如何处理数据包的其余部分 return p.NextDecoder(layers.LayerTypeEthernet) } //最后使用你的解码器 p := gopacket.NewPacket(data, MyLayerType, gopacket.Lazy) ","date":"2022-12-14","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gopacket/:7:0","tags":["go第三方库"],"title":"go第三方库-Gopacket","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"使用 DecodingLayerParser 快速解码 TLDR：DecodingLayerParser 大约需要 NewPacket 的 10% 的时间来解码数据包数据，但仅限于已知的数据包堆栈。 使用 gopacket.NewPacket 或 PacketSource.Packets 的基本解码有点慢，因为它需要分配一个新的数据包和每个相应的层。它的用途非常广泛，可以处理所有已知的层类型，但有时您实际上只关心一组特定的层而不管，因此浪费了多功能性。 DecodingLayerParser 通过将数据包层直接解码为预分配的对象来完全避免内存分配，然后您可以引用这些对象来获取数据包的信息。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func main() { var eth layers.Ethernet var ip4 layers.IPv4 var ip6 layers.IPv6 var tcp layers.TCP parser := gopacket.NewDecodingLayerParser(layers.LayerTypeEthernet, ð, \u0026ip4, \u0026ip6, \u0026tcp) decoded := []gopacket .LayerType{} for packetData := range somewhatGetPacketData() { if err := parser.DecodeLayers(packetData, \u0026decoded); err != nil { fmt.Fprintf(os.Stderr, \"Could not decode layers: %v\\n\", err) continue } for _, layerType := range decoded { 开关 layerType { case layers.LayerTypeIPv6: fmt.Println( “IP6”、ip6.SrcIP、ip6.DstIP) 层。 fmt.Println(\" IP4 \", ip4.SrcIP, ip4.DstIP) } } } } 并不是所有的层都可以被 DecodingLayerParser 使用……只有那些实现了 DecodingLayer 接口的层才可用 ","date":"2022-12-14","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gopacket/:8:0","tags":["go第三方库"],"title":"go第三方库-Gopacket","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"使用 DecodingLayerContainer 进行更快的自定义解码 默认情况下，DecodingLayerParser 使用原生地图来存储和搜索要解码的图层。尽管用途广泛，但在某些情况下，此解决方案可能不是最佳选择。例如，如果您只有几层，则可以通过稀疏数组索引或线性数组扫描来提供更快的操作。 ","date":"2022-12-14","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gopacket/:9:0","tags":["go第三方库"],"title":"go第三方库-Gopacket","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"创建分组数据 除了提供解码数据包数据的能力外，gopacket 还允许您从头开始创建数据包。许多 gopacket 层实现了 SerializableLayer 接口；这些层可以按以下方式序列化为 []byte： 1 2 3 4 5 6 7 8 9 10 ip := \u0026layers.IPv4{ SrcIP: net.IP{1, 2, 3, 4}, DstIP: net.IP{5, 6, 7, 8}, // etc... } buf := gopacket.NewSerializeBuffer() opts := gopacket.SerializeOptions{} // See SerializeOptions for more details. err := ip.SerializeTo(buf, opts) if err != nil { panic(err) } fmt.Println(buf.Bytes()) // prints out a byte slice containing the serialized IPv4 layer. SerializeTo 将给定layer添加到 SerializeBuffer 上，并将当前缓冲区的 Bytes() 切片视为序列化层的有效负载。因此，您可以通过以相反顺序序列化一组layer来序列化整个数据包（例如，有效负载、然后是 TCP、然后是 IP、然后是以太头）。 如果不想让手动按逆序序列化，可以使用SerializeLayers函数，你可以在他的参数中按正常顺序写入需要添加的layer 例如，要生成一个（空的且无用的，因为没有设置任何字段）Ethernet(IPv4(TCP(Payload))) 数据包，您可以运行 1 2 3 4 5 6 7 8 buf := gopacket.NewSerializeBuffer() opts := gopacket.SerializeOptions{} gopacket.SerializeLayers(buf, opts, \u0026layers.Ethernet{}, \u0026layers.IPv4{}, \u0026layers.TCP{}, gopacket.Payload([]byte{1, 2, 3, 4})) packetData := buf.Bytes() ","date":"2022-12-14","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gopacket/:10:0","tags":["go第三方库"],"title":"go第三方库-Gopacket","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"最后 如果您使用 gopacket，肯定要确保导入 gopacket/layers，因为在导入时它会设置所有 LayerType 变量并填充许多有趣的变量/地图（DecodersByLayerName 等）。因此，建议即使您不直接使用任何layers 函数，您仍然可以导入： 1 2 3 import ( _ \"github.com/google/gopacket/layers\" ) ","date":"2022-12-14","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gopacket/:11:0","tags":["go第三方库"],"title":"go第三方库-Gopacket","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"go语言中文网 godoc go语言中文网有很多文档缺少内容比如string.Builder就没有，godoc绝对详尽，推荐阅读godoc github源码 ","date":"2022-12-14","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/http/:0:0","tags":["go标准库"],"title":"go标准库-Http","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/http/"},{"categories":["Golang"],"content":"客户端API ","date":"2022-12-14","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/http/:1:0","tags":["go标准库"],"title":"go标准库-Http","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/http/"},{"categories":["Golang"],"content":"简单请求 1 2 3 4 5 6 resp, err := http.Get(\"http://example.com/\") ... resp, err := http.Post(\"http://example.com/upload\", \"image/jpeg\", \u0026buf) ... resp, err := http.PostForm(\"http://example.com/form\", url.Values{\"key\": {\"Value\"}, \"id\": {\"123\"}}) 请求后需要关闭请求体(类似关闭文件流) 1 2 3 4 5 6 7 resp, err := http.Get(\"http://example.com/\") if err != nil { // handle error } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) // ... ","date":"2022-12-14","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/http/:1:1","tags":["go标准库"],"title":"go标准库-Http","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/http/"},{"categories":["Golang"],"content":"复杂请求 管理HTTP客户端的头域、重定向策略和其他设置，创建一个Client 1 2 3 4 5 6 7 8 9 10 client := \u0026http.Client{ CheckRedirect: redirectPolicyFunc, } resp, err := client.Get(\"http://example.com\") // ... req, err := http.NewRequest(\"GET\", \"http://example.com\", nil) // ... req.Header.Add(\"If-None-Match\", `W/\"wyzzy\"`) resp, err := client.Do(req) // ... 要管理代理、TLS配置、keep-alive、压缩和其他设置，创建一个Transport： 1 2 3 4 5 6 tr := \u0026http.Transport{ TLSClientConfig: \u0026tls.Config{RootCAs: pool}, DisableCompression: true, } client := \u0026http.Client{Transport: tr} resp, err := client.Get(\"https://example.com\") Client和Transport能够被安全并发复用 ","date":"2022-12-14","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/http/:1:2","tags":["go标准库"],"title":"go标准库-Http","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/http/"},{"categories":["Golang"],"content":"Server，Handler，ServeMux和HandlerFunc Handler仅仅是一个定义了ServeHTTP(ResponseWriter, *Request)的接口 Server和ServeMux是两个结构体类型 Server用于定义运行HTTP服务端的参数，Server里面包含一个Handler接口类型。 ServeMux是HTTP请求的多路转接器（如图），实现了Handler接口类型，就和gin框架中的gin.Default的功能是一样的用于注册路由（这里是叫处理器），可以直接使用，甚至DefaultServeMux就只是通过var defaultServeMux ServeMux定义的，我们也可以自己定义。使用HandleFunc(pattern string, handler func(ResponseWriter, *Request))和Handle(pattern string, handler Handler)方法添加处理器，HandleFunc方法会将接收到的函数强制转换为HandlerFunc再调用Handle方法完成注册 HandlerFunc是图中的处理器，其实就是一个函数。type HandlerFunc func(ResponseWriter, *Request) 总结一下写一个web服务器的过程就是： 定义一个ServeMux多路转接器 向ServeMux注册处理器 定义一个Server对象，设置运行HTTP服务端的参数，并把定义的ServeMux作为Server对象的Handler类型字段 调用Server对象的ListenAndServe方法启动服务端 http的 HandleFunc函数和Handle函数会对默认的ServeMux添加处理器。 http的ListenAndServe 函数会生成一个Server对象将默认的ServeMux作为Handler，并启动。 ","date":"2022-12-14","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/http/:2:0","tags":["go标准库"],"title":"go标准库-Http","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/http/"},{"categories":["计算机网络"],"content":"本系列笔记为作者在跟随小林coding学习的时候做的笔记。感谢小林大大。 ","date":"2022-12-13","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/http%E7%AF%87/:0:0","tags":["小林coding系列"],"title":"计算机网络-小林coding-HTTP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/http%E7%AF%87/"},{"categories":["计算机网络"],"content":"HTTP 常见面试题 ","date":"2022-12-13","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/http%E7%AF%87/:1:0","tags":["小林coding系列"],"title":"计算机网络-小林coding-HTTP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/http%E7%AF%87/"},{"categories":["计算机网络"],"content":"HTTP 基本概念 HTTP ：超文本传输协议HyperText Transfer Protocol。专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。 CSDN Ysming88 http报文详解 http请求报文内容：请求行+请求头部+空行+请求数据（体） HTTP 常见的状态码有哪些 「101 Switch Protocols」升级协议，websocket就是使用该方法来从http升级过来的 「204 No Content」响应头没有 body 数据 「206 Partial Content」HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分 「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问 「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问 301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL，尽量使用301，302可能会造成网址劫持，CSDN 一起荡起双桨 「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制 「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错 「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端 「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思 「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误 「503 Service Unavailable」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思 HTTP 常见字段有哪些 Host 字段：客户端请求，指定服务器的域名 Content-Length 字段：服务器回应，表明本次回应的数据长度（单位字节） HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题（HTTP报文可能会被拆分成多个TCP报文，不知道一个HTTP报文的边界在哪） Connection 字段：客户端请求，使用「 HTTP 长连接」机制 HTTP长连接即复用TCP连接，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。 HTTP/1.1 版本的默认连接都是长连接，老版本需要设置该字段为Keep-Alive TCP的Keepalive是它的保活机制，即客户端每隔一段时间（小于服务器的长连接超时时间keepalive_timeout）发送一个保活报文来重置服务端的长连接超时计时器。 Content-Type 字段：服务器回应，本次数据是什么格式，如：Content-Type: text/html; charset=utf-8 客户端请求的时候，可以使用 Accept 字段声明自己可以接受哪些数据格式:Accept: */* Content-Encoding 字段：服务器回应，数据使用了什么压缩格式，如：Content-Encoding: gzip 客户端在请求时，用 Accept-Encoding 字段说明自己可以接受哪些压缩方法 ","date":"2022-12-13","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/http%E7%AF%87/:1:1","tags":["小林coding系列"],"title":"计算机网络-小林coding-HTTP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/http%E7%AF%87/"},{"categories":["计算机网络"],"content":"GET 与 POST GET 的语义是从服务器获取指定的资源。GET 请求的参数位置一般是写在 URL 中，URL 规定只能支持 ASCII， ，浏览器会对 URL 的长度有限制 POST 的语义是根据请求载荷（报文body）对指定的资源做出处理。携带数据的位置一般是写在报文 body 中， body 中的数据可以是任意格式的数据，浏览器不会对 body 大小做限制。 安全和幂等的概念 在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源 所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的 根据RFC规范，GET 方法一般不涉及修改数据是安全且幂等的，POST 涉及修改数据是不安全也不幂等的。可以对 GET 请求的数据做缓存，一般不会缓存 POST 请求 GET 请求可以带 body 吗？ RFC 规范并没有规定 GET 请求不能带 body 的。理论上，任何请求都可以带 body ，URL参数。 ","date":"2022-12-13","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/http%E7%AF%87/:1:2","tags":["小林coding系列"],"title":"计算机网络-小林coding-HTTP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/http%E7%AF%87/"},{"categories":["计算机网络"],"content":"HTTP 缓存技术 两种实现：强制缓存和协商缓存 强制缓存：决定是否使用缓存的主动性在于浏览器这边。两个 HTTP 响应头部（Response Header）字段实现 Cache-Control， 是一个相对时间； Expires，是一个绝对时间； Cache-Control的优先级高于 Expires Cache-Control 来实现强缓存。具体的实现流程如下： 客户端第一次请求访问服务器资源时，服务器在 Response 头部加上 Cache-Control设置过期时间大小； 客户端再次请求访问服务器中的该资源时，先比较时间与 Cache-Control 中设置的过期时间，计算该资源是否过期。没有过期使用缓存，否则重新请求服务器； 服务器再次收到请求后，会设置 Response 头部的 Cache-Control 协商缓存：与服务端协商之后，通过协商结果（304）来判断是否使用本地缓存，两种头部字段实现 请求头添加If-Modified-Since字段（值为上次请求服务器响应的Last-Modified字段值）给服务器。如果在该值之后修改了就返回新数据并将最后修改时间Last-Modified添加到响应头返回200，否则直接返回304。基于时间 请求头添加If-None-Match字段（值为上次请求服务器响应的Etag字段值）给服务器。如果在该资源变化了就返回新数据并将Etag添加到响应头返回200，否则直接返回304。基于唯一标志 Etag 的优先级更高 ","date":"2022-12-13","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/http%E7%AF%87/:1:3","tags":["小林coding系列"],"title":"计算机网络-小林coding-HTTP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/http%E7%AF%87/"},{"categories":["计算机网络"],"content":"HTTP 特性 HTTP/1.1 优点 简单：基本的报文格式 header + body，头部信息 key-value 灵活和易于扩展：请求方法、URI/URL、状态码、头字段组成可以自定义和扩充；下层可以随意变化 应用广泛和跨平台 缺点 无状态：解决方法Cookie，jwt 明文传输：解决方法https 不安全：不验证通信方的身份，无法证明报文的完整性，解决方法https HTTP/1.1 的性能 长连接：复用TCP 管道网络传输：等待响应不阻塞发送请求（响应会按顺序发回来，先收到的请求响应会阻塞后收到的请求响应） 队头阻塞：先进入发送队列的统一TCP请求被阻塞时会阻塞后进的 ","date":"2022-12-13","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/http%E7%AF%87/:1:4","tags":["小林coding系列"],"title":"计算机网络-小林coding-HTTP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/http%E7%AF%87/"},{"categories":["计算机网络"],"content":"HTTP 与 HTTPS 区别 HTTP 明文传输，HTTPS 在 TCP 和 HTTP 之间加入了 SSL/TLS 安全协议加密传输 HTTPS 连接建立更复杂（SSL/TLS握手） HTTP 默认80端口，HTTPS 默认443端口 HTTPS的服务器需要向CA申请证书 HTTPS 解决了 HTTP 哪些问题 窃听（机密性）：信息加密（混合加密） 篡改（完整性）：校验机制（摘要算法+数字签名） 冒充：身份证书（数字证书） TLS流程 TLS流程图\r客户端验证CA流程 证书信任链验证 HTTPS 的应用数据是如何保证完整性的 TLS 在实现上分为握手协议和记录协议两层： TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）； TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议； HTTPS 一定安全可靠吗 当信任了中间人服务器证书，中间人就可以窃听修改 HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全。 抓包工具（如charles）截取 HTTPS 数据工作原理与中间人一致的 ","date":"2022-12-13","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/http%E7%AF%87/:1:5","tags":["小林coding系列"],"title":"计算机网络-小林coding-HTTP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/http%E7%AF%87/"},{"categories":["计算机网络"],"content":"HTTP/1.1、HTTP/2、HTTP/3 演变 ","date":"2022-12-13","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/http%E7%AF%87/:2:0","tags":["小林coding系列"],"title":"计算机网络-小林coding-HTTP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/http%E7%AF%87/"},{"categories":["计算机网络"],"content":"HTTP/1.1 相比 HTTP/1.0 长连接 管道（pipeline）网络传输 ","date":"2022-12-13","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/http%E7%AF%87/:2:1","tags":["小林coding系列"],"title":"计算机网络-小林coding-HTTP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/http%E7%AF%87/"},{"categories":["计算机网络"],"content":"HTTP/2 优化 头部压缩 二进制格式 并发传输 服务器主动推送资源 ","date":"2022-12-13","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/http%E7%AF%87/:2:2","tags":["小林coding系列"],"title":"计算机网络-小林coding-HTTP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/http%E7%AF%87/"},{"categories":["计算机网络"],"content":"HTTP/3 优化 无队头阻塞：HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP 更快的连接建立 连接迁移 ","date":"2022-12-13","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/http%E7%AF%87/:2:3","tags":["小林coding系列"],"title":"计算机网络-小林coding-HTTP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/http%E7%AF%87/"},{"categories":["计算机网络"],"content":"Websocket 见小林coding原文 ","date":"2022-12-13","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/http%E7%AF%87/:3:0","tags":["小林coding系列"],"title":"计算机网络-小林coding-HTTP篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/http%E7%AF%87/"},{"categories":["计算机网络"],"content":"本系列笔记为作者在跟随小林coding学习的时候做的笔记。感谢小林大大。 ","date":"2022-12-13","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/:0:0","tags":["小林coding系列"],"title":"计算机网络-小林coding-基础篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["计算机网络"],"content":"TCP/IP 网络模型有哪几层？ TCP/IP 网络分 4 层：应用层，传输层，网络层和网络接口层 ISO为7层，传统网络架构为5层，将数据链路层的物理层分离了出来单独作为一层。 传统网络分层为5层：应用层，传输层，网络层，数据链路层和物理层 附上网络协议层级图 网络层级图\r","date":"2022-12-13","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/:1:0","tags":["小林coding系列"],"title":"计算机网络-小林coding-基础篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["计算机网络"],"content":"键入网址到网页显示，期间发生了什么 ","date":"2022-12-13","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/:2:0","tags":["小林coding系列"],"title":"计算机网络-小林coding-基础篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["计算机网络"],"content":"HTTP 浏览器解析 URL字符串: 协议类型://域名或者IP:端口号/文件路径 端口号省略时默认是协议对应的默认端口，比如http是80 没有路径名则访问index.html或default.html 根据这些信息生成 HTTP 请求消息 ","date":"2022-12-13","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/:2:1","tags":["小林coding系列"],"title":"计算机网络-小林coding-基础篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["计算机网络"],"content":"DNS查询 应用层，传输层，网络层和网络接口层发送之前需要查询服务器域名对应的 IP 地址。 域名由.分割，越靠右的位置表示其层级越高。域名的层级关系类似一个树状结构： 根 DNS 服务器（.） 顶级域 DNS 服务器（.com） 权威 DNS 服务器（server.com） 域名解析的工作流程 客户端发出 DNS 请求给本地设置的 DNS 服务器地址 本地域名服务器查询缓存，找到 www.server.com，则直接返回 IP 地址。否则本地 DNS 会去问它的根域名服务器 根 DNS 返回给本地域名服务器 .com 顶级域名服务器地址 本地域名服务器和返回的服务器地址重复2，3步，直到找到权威域名服务器。 权威域名服务器直接返回IP给本地域名服务器 本地域名服务器将IP返回给客户端 通常客户端到域名服务器是不可靠无连接的UDP通信，域名服务器之间使用可靠有连接的TCP通信进行迭代查询 ","date":"2022-12-13","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/:2:2","tags":["小林coding系列"],"title":"计算机网络-小林coding-基础篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["计算机网络"],"content":"操作系统协议栈 获取 IP 后，操作系统中的协议栈处理和发送数据包（传统网络架构中的传输层到数据链路层。物理层由网卡驱动接管）。 应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。 ","date":"2022-12-13","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/:2:3","tags":["小林coding系列"],"title":"计算机网络-小林coding-基础篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["计算机网络"],"content":"TCP 源端口号和目标端口号寻址 包的序号解决包乱序的问题 状态位：改变协议状态。 窗口大小做流量控制 协议规定了自己的拥塞控制行为 TCP 传输数据之前，要先三次握手建立连接 查看 TCP 的连接状态：netstat -napt MSS：TCP包载荷的最大长度 MTU：一个IP包的最大长度，一般为1500字节 ","date":"2022-12-13","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/:2:4","tags":["小林coding系列"],"title":"计算机网络-小林coding-基础篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["计算机网络"],"content":"IP 源地址 IP 和 目标地址 IP 传输层协议的协议号 路由数据包时根据路由表规则，来判断哪一个网卡作为源地址 IP route -n 命令查看当前系统的路由表（推荐ip系列的命令 ip routes） 路由数据包流程：路由表从上往下将包目的ip和掩码与运算，结果和目的网段相同就匹配上，使用匹配的网卡（端口）进行转发。通常最后一个条目的目的网段和子网掩码都是0.0.0.0，称为默认网关，当上面的都不匹配的时候就发送到这个网卡接口，该条目的Gateway就是默认网关ip地址。发送出数据包时，当Gateway为0.0.0.0时表示该网段跟主机是直连的，链路层将目的ip对应的MAC作为链路层包头的MAC，否则使用Gateway 的MAC。 ","date":"2022-12-13","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/:2:5","tags":["小林coding系列"],"title":"计算机网络-小林coding-基础篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["计算机网络"],"content":"MAC MAC 包头里需要发送方 MAC 地址和接收方目标 MAC 地址，用于两点之间的传输 MAC 包头的协议类型只使用：0800 ： IP 协议；0806 ： ARP 协议 发送方的 MAC 地址是在网卡生产时写入到 ROM 里的，只需要将这个值读取出来写入到 MAC 头部。 接收方的 MAC 地址需要 ARP 协议来获取。 ARP 协议会在以太网（局域网）中广播ip地址，接收到回应后将MAC写入ARP缓存（缓存时间为几分钟） 发包时： ARP 缓存已经保存了对方的 MAC 地址，直接使用 ARP 缓存中的地址。 ARP 缓存中不存在对方 MAC 地址时，发送 ARP 广播查询。 arp -a查看 ARP 缓存的内容 ","date":"2022-12-13","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/:2:6","tags":["小林coding系列"],"title":"计算机网络-小林coding-基础篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["计算机网络"],"content":"网卡 我们需要将数字信息转换为电信号，才能在网线上传输，由网卡负责。网卡驱动程序控制网卡。 网卡驱动获取网络包之后，会将其复制到网卡内的缓存区中，接着会在其开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列。 起始帧分界符是一个用来表示包起始位置的标记 末尾的 FCS（帧校验序列）用来检查包传输过程是否有损坏 ","date":"2022-12-13","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/:2:7","tags":["小林coding系列"],"title":"计算机网络-小林coding-基础篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["计算机网络"],"content":"交换机 将网络包原样转发到目的地。也称为二层网络设备（即传统网络架构中的数据链路层，不涉及网络层及以上数据包的修改） 交换机的包接收操作：交换机接收电信号，将电信号转换为数字信号，通过包末尾的 FCS 校验错误，如果没问题则放到缓冲区，根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口。当 MAC 地址表找不到指定的 MAC 地址，将包转发到除了源端口之外的所有端口。 交换机的 MAC 地址表主要包含两个信息：一个是设备的 MAC 地址，另一个是该设备连接在交换机的哪个端口上。 对于主机而言，只有目的地址跟自己的MAC一致包才接收，忽略其他包 广播地址（全1）： MAC 地址中的 FF:FF:FF:FF:FF:FF IP 地址中的 255.255.255.255 ","date":"2022-12-13","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/:2:8","tags":["小林coding系列"],"title":"计算机网络-小林coding-基础篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["计算机网络"],"content":"路由器 路由器是基于 IP 设计的，俗称三层网络设备（即传统网络架构中的网络层），路由器的各个端口都具有 MAC 地址和 IP 地址 路由流程见上面IP层 路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃 ","date":"2022-12-13","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/:2:9","tags":["小林coding系列"],"title":"计算机网络-小林coding-基础篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["计算机网络"],"content":"互相扒皮 —— 服务器 与 客户端 逐层协议分析包头。链路层接收和自己的 MAC 地址符合的包。网络层接收和自己的IP地址符合的IP包。根据IP头读取传输层协议。TCP会检查首部校验和序列号并返回ACK，UDP只检查首部校验和。读取传输层端口号，并将传输层载荷发送给进程。 ","date":"2022-12-13","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/:2:10","tags":["小林coding系列"],"title":"计算机网络-小林coding-基础篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["计算机网络"],"content":"Linux 系统是如何收发网络包的？ ","date":"2022-12-13","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/:3:0","tags":["小林coding系列"],"title":"计算机网络-小林coding-基础篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["计算机网络"],"content":"网络模型 OSI7层，传统5层，TCP/IP4层 ","date":"2022-12-13","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/:3:1","tags":["小林coding系列"],"title":"计算机网络-小林coding-基础篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["计算机网络"],"content":"Linux 网络协议栈 应用程序需要通过系统调用，来跟 Socket 层进行数据交互； Socket 层的下面就是传输层、网络层和网络接口层； 最下面的一层，则是网卡驱动程序和硬件网卡设备； ","date":"2022-12-13","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/:3:2","tags":["小林coding系列"],"title":"计算机网络-小林coding-基础篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["计算机网络"],"content":"Linux 接收网络包的流程 当网卡接收到一个网络包后，会通过 DMA 技术，将网络包写入到指定的内存地址，也就是写入到 Ring Buffer，缓存满了就会触发中断唤醒数据接收的服务程序，然后 poll 的方法来轮询数据 硬件中断处理函数：先「暂时屏蔽中断」，表示已经知道内存中有数据了。发起「软中断」，然后恢复刚才屏蔽的硬件中断。 硬件中断处理函数做的事情很少，主要耗时的工作都交给软中断处理函数了。 软中断的处理：当 ksoftirqd 内核线程收到软中断后，就会来轮询处理数据。ksoftirqd 线程会从 Ring Buffer 中获取一个数据帧，用 sk_buff 表示，从而可以作为一个网络包交给网络协议栈进行逐层处理。 发送网络数据的时候，涉及几次内存拷贝操作？ 第一次，调用发送数据的系统调用的时候，内核会申请一个内核态的 sk_buff 内存，将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区。 第二次，在使用 TCP 传输协议的情况下，从传输层进入网络层的时候，每一个 sk_buff 都会被克隆一个新的副本出来。副本 sk_buff 会被送往网络层，等它发送完的时候就会释放掉，然后原始的 sk_buff 还保留在传输层，目的是为了实现 TCP 的可靠传输，等收到这个数据包的 ACK 时，才会释放原始的 sk_buff 。 第三次，当 IP 层发现 sk_buff 大于 MTU 时才需要进行。会再申请额外的 sk_buff，并将原来的 sk_buff 拷贝为多个小的 sk_buff。 ","date":"2022-12-13","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/:3:3","tags":["小林coding系列"],"title":"计算机网络-小林coding-基础篇","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["Golang"],"content":"go官方文档 go语言参考 在写过很多go代码之后，感觉自己并没有完全掌握go语言，还有很多知识盲区，所以有了这个go学习笔记系列，本系列是作者跟着电子书重新复习go语言相关内容的笔记 ","date":"2022-12-12","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91/:0:0","tags":["go学习笔记"],"title":"golang-学习笔记-基于共享变量的并发","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91/"},{"categories":["Golang"],"content":"sync.Mutex互斥锁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import \"sync\" var ( mu sync.Mutex // guards balance balance int ) func Deposit(amount int) { mu.Lock() balance = balance + amount mu.Unlock() } func Balance() int { mu.Lock() b := balance mu.Unlock() return b } 可以和defer一起用： 1 2 3 4 5 func Balance() int { mu.Lock() defer mu.Unlock() return balance } ","date":"2022-12-12","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91/:1:0","tags":["go学习笔记"],"title":"golang-学习笔记-基于共享变量的并发","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91/"},{"categories":["Golang"],"content":"sync.RWMutex读写锁 1 2 3 4 5 6 7 var mu sync.RWMutex var balance int func Balance() int { mu.RLock() // readers lock defer mu.RUnlock() return balance } 它组合了Mutex，Lock()和Unlock()方法会调用Mutex可以看作写锁 ","date":"2022-12-12","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91/:2:0","tags":["go学习笔记"],"title":"golang-学习笔记-基于共享变量的并发","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91/"},{"categories":["Golang"],"content":"sync.Once惰性初始化 1 2 3 4 5 6 7 var loadIconsOnce sync.Once var icons map[string]image.Image // Concurrency-safe. func Icon(name string) image.Image { loadIconsOnce.Do(loadIcons) return icons[name] } ","date":"2022-12-12","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91/:3:0","tags":["go学习笔记"],"title":"golang-学习笔记-基于共享变量的并发","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91/"},{"categories":["Golang"],"content":"竞争条件检测 见原文 Go的runtime和工具链为我们装备了一个复杂但好用的动态分析工具，竞争检查器(the race detector)。 ","date":"2022-12-12","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91/:4:0","tags":["go学习笔记"],"title":"golang-学习笔记-基于共享变量的并发","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91/"},{"categories":["Golang"],"content":"Goroutines和线程 ","date":"2022-12-12","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91/:5:0","tags":["go学习笔记"],"title":"golang-学习笔记-基于共享变量的并发","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91/"},{"categories":["Golang"],"content":"动态栈 每一个OS线程都有一个固定大小的内存块(一般会是2MB)来做栈，这个栈会用来存储当前正在被调用或挂起(指在调用其它函数时)的函数的内部变量。 一个goroutine会以一个很小的栈开始其生命周期，一般只需要2KB。栈的大小会根据需要动态地伸缩。 ","date":"2022-12-12","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91/:5:1","tags":["go学习笔记"],"title":"golang-学习笔记-基于共享变量的并发","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91/"},{"categories":["Golang"],"content":"Goroutine调度 OS线程会被操作系统内核调度。每几毫秒触发硬件中断，调用scheduler内核函数。这个函数会挂起当前执行的线程并将它的寄存器内容保存到内存中，检查线程列表并决定下一次哪个线程可以被运行，并从内存中恢复该线程的寄存器信息，然后恢复执行该线程的现场并开始执行线程。 操作系统线程是被内核所调度，从一个线程向另一个“移动”需要完整的上下文切换，也就是说，保存一个用户线程的状态到内存，恢复另一个线程的到寄存器，然后更新调度器的数据结构。这几步操作很慢，因为其局部性很差需要几次内存访问，并且会增加运行的cpu周期。 Go的运行时包含了其自己的调度器，这个调度器使用了一些技术手段，比如m:n调度，因为其会在n个操作系统线程上多工(调度)m个goroutine。Go调度器的工作和内核的调度是相似的，但是这个调度器只关注单独的Go程序中的goroutine（译注：按程序独立）。 和操作系统的线程调度不同的是，Go调度器并不是用一个硬件定时器，而是被Go语言“建筑”本身进行调度的。这种调度方式不需要进入内核的上下文，所以重新调度一个goroutine比调度一个线程代价要低得多。 ","date":"2022-12-12","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91/:5:2","tags":["go学习笔记"],"title":"golang-学习笔记-基于共享变量的并发","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91/"},{"categories":["Golang"],"content":"GOMAXPROCS Go的调度器使用了一个叫做GOMAXPROCS的变量来决定会有多少个操作系统的线程同时执行Go的代码。其默认的值是运行机器上的CPU的核心数，所以在一个有8个核心的机器上时，调度器一次会在8个OS线程上去调度GO代码。 可以用GOMAXPROCS的环境变量来显式地控制这个参数，或者也可以在运行时用runtime.GOMAXPROCS函数来修改它并返回原来的值（-1不会修改仅返回原来的值）。 ","date":"2022-12-12","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91/:5:3","tags":["go学习笔记"],"title":"golang-学习笔记-基于共享变量的并发","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91/"},{"categories":["Golang"],"content":"Goroutine没有ID号 goroutine没有可以被程序员获取到的身份(id)的概念。 ","date":"2022-12-12","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91/:5:4","tags":["go学习笔记"],"title":"golang-学习笔记-基于共享变量的并发","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91/"},{"categories":["Golang"],"content":"go官方文档 go语言参考 在写过很多go代码之后，感觉自己并没有完全掌握go语言，还有很多知识盲区，所以有了这个go学习笔记系列，本系列是作者跟着电子书重新复习go语言相关内容的笔记 ","date":"2022-12-12","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/goroutines%E5%92%8Cchannels/:0:0","tags":["go学习笔记"],"title":"golang-学习笔记-Goroutines和Channels","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/goroutines%E5%92%8Cchannels/"},{"categories":["Golang"],"content":"Goroutines 1 2 f() // call f(); wait for it to return go f() // create a new goroutine that calls f(); don't wait ","date":"2022-12-12","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/goroutines%E5%92%8Cchannels/:1:0","tags":["go学习笔记"],"title":"golang-学习笔记-Goroutines和Channels","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/goroutines%E5%92%8Cchannels/"},{"categories":["Golang"],"content":"Channels 使用内置的make函数，我们可以创建一个channel： 1 2 3 ch := make(chan int) // ch has type 'chan int' ch = make(chan int, 3) // buffered channel with capacity 3 发送和接受值： 1 2 3 ch \u003c- x // a send statement x = \u003c-ch // a receive expression in an assignment statement \u003c-ch // a receive statement; result is discarded 使用内置的close函数就可以关闭一个channel： 1 close(ch) ","date":"2022-12-12","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/goroutines%E5%92%8Cchannels/:2:0","tags":["go学习笔记"],"title":"golang-学习笔记-Goroutines和Channels","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/goroutines%E5%92%8Cchannels/"},{"categories":["Golang"],"content":"不带缓存的Channels 无缓冲会阻塞单方的读取和写入 基于无缓存Channels的发送和接收操作将导致两个goroutine做一次同步操作。无缓存Channels有时候也被称为同步Channels。 当通过一个无缓存Channels发送数据时，接收者收到数据发生在唤醒发送者goroutine之前（译注：happens before，这是Go语言并发内存模型的一个关键术语！） ","date":"2022-12-12","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/goroutines%E5%92%8Cchannels/:2:1","tags":["go学习笔记"],"title":"golang-学习笔记-Goroutines和Channels","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/goroutines%E5%92%8Cchannels/"},{"categories":["Golang"],"content":"串联的Channels（Pipeline） channel被关闭后，写入数据将导致panic异常。读出数据不再阻塞，会立即返回一个零值。 测试一个channel是否被关闭，多接收一个布尔值ok，ture表示成功从channels接收到值，false表示channels已经被关闭并且里面没有值可接收。 1 2 3 4 5 6 7 8 9 10 11 // Squarer go func() { for { x, ok := \u003c-naturals if !ok { break // channel was closed and drained } squares \u003c- x * x } close(squares) }() Go语言的range循环可直接在channels上面迭代。它依次从channel接收数据，当channel被关闭并且没有值可接收时跳出循环。 并不需要关闭每一个channel。不管一个channel是否被关闭，当它没有被引用时将会被Go语言的垃圾自动回收器回收。 ","date":"2022-12-12","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/goroutines%E5%92%8Cchannels/:2:2","tags":["go学习笔记"],"title":"golang-学习笔记-Goroutines和Channels","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/goroutines%E5%92%8Cchannels/"},{"categories":["Golang"],"content":"单方向的Channel 类型chan\u003c- int表示一个只发送int的channel，只能发送不能接收 类型\u003c-chan int表示一个只接收int的channel，只能接收不能发送 无法使用make创建单向channel（这也不符合常理），可以定义单向channel变量然后将创建的channel赋值给它，通常用于函数传参 ","date":"2022-12-12","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/goroutines%E5%92%8Cchannels/:2:3","tags":["go学习笔记"],"title":"golang-学习笔记-Goroutines和Channels","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/goroutines%E5%92%8Cchannels/"},{"categories":["Golang"],"content":"带缓存的Channels 带缓存的Channel内部持有一个元素队列。队列大小为make的第2个参数。 读空队列阻塞，写满队列阻塞。 channel内部缓存的容量，可以用内置的cap函数获取： 1 fmt.Println(cap(ch)) // \"3\" 内置的len函数返回channel内部缓存队列中有效元素的个数: 1 fmt.Println(len(ch)) // \"2\" ","date":"2022-12-12","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/goroutines%E5%92%8Cchannels/:2:4","tags":["go学习笔记"],"title":"golang-学习笔记-Goroutines和Channels","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/goroutines%E5%92%8Cchannels/"},{"categories":["Golang"],"content":"并发的循环 1 2 3 4 5 6 for _, f := range filenames { go func() { thumbnail.ImageFile(f) // NOTE: incorrect! // ... }() } ","date":"2022-12-12","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/goroutines%E5%92%8Cchannels/:3:0","tags":["go学习笔记"],"title":"golang-学习笔记-Goroutines和Channels","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/goroutines%E5%92%8Cchannels/"},{"categories":["Golang"],"content":"基于select的多路复用 1 2 3 4 5 6 7 8 9 10 select { case \u003c-ch1: // ... case x := \u003c-ch2: // ...use x... case ch3 \u003c- y: // ... default: // ... } select会等待case中有能够执行的case时去执行，当条件满足时，select才会去通信并执行case之后的语句；这时候其它通信是不会执行的 一个没有任何case的select语句写作select{}，会永远地等待下去 如果多个case同时就绪时，select会随机地选择一个执行，这样来保证每一个channel都有平等的被select的机会 default来设置当其它的操作都不能够马上被处理时程序需要执行哪些逻辑，具有default的select不会阻塞 for循环中的select反复地非阻塞读取channel的操作叫做“轮询channel” channel的零值是nil，对一个nil的channel发送和接收操作会永远阻塞 ","date":"2022-12-12","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/goroutines%E5%92%8Cchannels/:4:0","tags":["go学习笔记"],"title":"golang-学习笔记-Goroutines和Channels","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/goroutines%E5%92%8Cchannels/"},{"categories":["Golang"],"content":"并发的退出 读取被关闭channel可以立即被执行，并且会产生零值。不要向channel发送值，而是用关闭一个channel来进行广播。向关闭的channel发送消息会panic ","date":"2022-12-12","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/goroutines%E5%92%8Cchannels/:5:0","tags":["go学习笔记"],"title":"golang-学习笔记-Goroutines和Channels","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/goroutines%E5%92%8Cchannels/"},{"categories":["Golang"],"content":"channel底层 go专家编程 环形队列，sendx，recvx两个uint来指向读写位置，qcount来记录剩余元素个数，buf和dataqsiz字段记录环形队列指针和环形队列长度，recvq和sendq记录等待读和等待写的goroutine队列，lock字段加锁同一时间只能由一个goroutine访问channel 向nil管道读或写数据都会导致goroutine死锁 关闭channel时会把recvq中的G全部唤醒，并给他们nil数据。把sendq中的G全部唤醒，并让这些G触发panic。 其他panic场景： 关闭值为nil的channel 关闭已经被关闭的channel 向已经关闭的channel写数据 ","date":"2022-12-12","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/goroutines%E5%92%8Cchannels/:6:0","tags":["go学习笔记"],"title":"golang-学习笔记-Goroutines和Channels","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/goroutines%E5%92%8Cchannels/"},{"categories":["Golang"],"content":"go官方文档 go语言参考 在写过很多go代码之后，感觉自己并没有完全掌握go语言，还有很多知识盲区，所以有了这个go学习笔记系列，本系列是作者跟着电子书重新复习go语言相关内容的笔记 go-zero微服务实战系列（十一、大结局） github gomock gomock中文示例 csdn 超级强zcq 李文周博客 Go 检查和报告错误条件的惯有方式 产生错误的函数会返回两个变量，一个值和一个错误码；如果后者是 nil 就是成功，非 nil 就是发生了错误。 为了防止发生错误时正在执行的函数（如果有必要的话甚至会是整个程序）被中止，在调用函数后必须检查错误。 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/:0:0","tags":["go学习笔记"],"title":"golang-学习笔记-错误处理与测试","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/"},{"categories":["Golang"],"content":"错误处理 1 2 3 type error interface { Error() string } 当程序处于错误状态时可以用 os.Exit(1) 来中止运行。 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/:1:0","tags":["go学习笔记"],"title":"golang-学习笔记-错误处理与测试","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/"},{"categories":["Golang"],"content":"定义错误 1 err := errors.New(“math - square root of negative number”) 每个包中有自己定义的error ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/:1:1","tags":["go学习笔记"],"title":"golang-学习笔记-错误处理与测试","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/"},{"categories":["Golang"],"content":"用 fmt 创建错误对象 1 err = fmt.Errorf(\"usage: %s infile.txt outfile.txt\", filepath.Base(os.Args[0])) ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/:1:2","tags":["go学习笔记"],"title":"golang-学习笔记-错误处理与测试","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/"},{"categories":["Golang"],"content":"运行时异常和 panic 1 panic(\"A severe error occurred: stopping the program!\") ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/:2:0","tags":["go学习笔记"],"title":"golang-学习笔记-错误处理与测试","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/"},{"categories":["Golang"],"content":"从 panic 中恢复（Recover） 必须为defer语句或者是defer语句调用的匿名函数，不能在defer块里面调用其他函数来recover 1 2 3 4 5 defer func() { if e := recover(); e != nil { fmt.Printf(\"Panicing %s\\r\\n\", e) } }() ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/:3:0","tags":["go学习笔记"],"title":"golang-学习笔记-错误处理与测试","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/"},{"categories":["Golang"],"content":"启动外部命令和程序 os 包有一个 StartProcess 函数可以调用或启动外部系统命令和二进制可执行文件；它的第一个参数是要运行的进程，第二个参数用来传递选项或参数，第三个参数是含有系统环境基本信息的结构体。这个在windows里面用不了。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /* Linux: */ env := os.Environ() procAttr := \u0026os.ProcAttr{ Env: env, Files: []*os.File{ os.Stdin, os.Stdout, os.Stderr, }, } // 1st example: list files pid, err := os.StartProcess(\"/bin/ls\", []string{\"ls\", \"-l\"}, procAttr) if err != nil { fmt.Printf(\"Error %v starting process!\", err) // os.Exit(1) } exec 包中也有同样功能的更简单的结构体和函数；主要是 exec.Command(name string, arg …string) 和 Run() 1 2 3 4 5 6 cmd := exec.Command(\"gedit\") // this opens a gedit-window err = cmd.Run() if err != nil { fmt.Printf(\"Error %v executing command!\", err) os.Exit(1) } ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/:4:0","tags":["go学习笔记"],"title":"golang-学习笔记-错误处理与测试","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/"},{"categories":["Golang"],"content":"Go 中的单元测试和基准测试 _test 程序不会被普通的 Go 编译器编译，所以当放应用部署到生产环境时它们不会被部署；只有 gotest 会编译所有的程序：普通程序和测试程序。 测试函数必须有这种形式的头部： 1 func TestAbcde(t *testing.T) T 是传给测试函数的结构类型，用来管理测试状态，支持格式化测试日志，如 t.Log，t.Error，t.ErrorF 等。在函数的结尾把输出跟想要的结果对比，如果不等就打印一个错误。成功的测试则直接返回。 用下面这些函数来通知测试失败： func (t *T) Fail()标记测试函数为失败，然后继续执行（剩下的测试）。 func (t *T) FailNow()标记测试函数为失败并中止执行；文件中别的测试也被略过，继续执行下一个文件。 func (t *T) Log(args …interface{}) args 被用默认的格式格式化并打印到错误日志中。 func (t *T) Fatal(args …interface{}) 结合 先执行 3），然后执行 2）的效果。 –chatty 或 -v 选项，每个执行的测试函数以及测试状态会被打印。 博客园Otiger基准测试 testing 包中有一些类型和函数可以用来做简单的基准测试；测试代码中必须包含以 BenchmarkZzz 打头的函数并接收一个 *testing.B 类型的参数， 1 2 3 4 5 func BenchmarkReverse(b *testing.B) { for n := 0; n \u003c b.N; n++ { testfunc(xxx) } } 命令 go test –test.bench=.* 会运行所有的基准测试函数；代码中的函数会被调用 N 次（N是非常大的数，如 N = 1000000），并展示 N 的值和函数执行的平均时间，单位为 ns（纳秒，ns/op）。如果是用 testing.Benchmark 调用这些函数，直接运行程序即可。 -benchmem 参数展示内存消耗情况 -cpu 使用几个cpu核心 -count 连续跑N次 -benchtime 指定运行秒数 b.ResetTimer()方法可以重置基准测试定时器，可以用于跳过耗时的初始化操作 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/:5:0","tags":["go学习笔记"],"title":"golang-学习笔记-错误处理与测试","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/"},{"categories":["Golang"],"content":"测试的具体例子 even/even.go： 1 2 3 4 5 6 7 8 9 package even func Even(i int) bool { // Exported function return i%2 == 0 } func Odd(i int) bool { // Exported function return i%2 != 0 } even/oddeven_test.go： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package even import \"testing\" func TestEven(t *testing.T) { if !Even(10) { t.Log(\" 10 must be even!\") t.Fail() } if Even(7) { t.Log(\" 7 is not even!\") t.Fail() } } func TestOdd(t *testing.T) { if !Odd(11) { t.Log(\" 11 must be odd!\") t.Fail() } if Odd(10) { t.Log(\" 10 is not odd!\") t.Fail() } } 由于测试需要具体的输入用例且不可能测试到所有的用例（非常像一个无穷的数），所以我们必须对要使用的测试用例思考再三。 至少应该包括： 正常的用例 反面的用例（错误的输入，如用负数或字母代替数字，没有输入等） 边界检查用例（如果参数的取值范围是 0 到 1000，检查 0 和 1000 的情况） ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/:6:0","tags":["go学习笔记"],"title":"golang-学习笔记-错误处理与测试","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/"},{"categories":["Golang"],"content":"用（测试数据）表驱动测试 把测试的输入数据和期望的结果写在一起组成一个数据表：表中的每条记录都是一个含有输入和期望值的完整测试用例，还可以结合像测试名字这样的额外信息来让测试输出更多的信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var tests = []struct{ // Test table in string out string }{ {“in1”, “exp1”}, {“in2”, “exp2”}, {“in3”, “exp3”}, ... } func TestFunction(t *testing.T) { for i, tt := range tests { s := FuncToBeTested(tt.in) if s != tt.out { t.Errorf(“%d. %q =\u003e %q, wanted: %q”, i, tt.in, s, tt.out) } } } 如果大部分函数都可以写成这种形式，那么写一个帮助函数 verify 对实际测试会很有帮助： 1 2 3 4 5 func verify(t *testing.T, testnum int, testcase, input, output, expected string) { if expected != output { t.Errorf(“%d. %s with input = %s: output %s != %s”, testnum, testcase, input, output, expected) } } TestFunction 则变为： 1 2 3 4 5 6 func TestFunction(t *testing.T) { for i, tt := range tests { s := FuncToBeTested(tt.in) verify(t, i, “FuncToBeTested: “, tt.in, s, tt.out) } } ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/:7:0","tags":["go学习笔记"],"title":"golang-学习笔记-错误处理与测试","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/"},{"categories":["Golang"],"content":"性能调试：分析并优化 Go 程序 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/:8:0","tags":["go学习笔记"],"title":"golang-学习笔记-错误处理与测试","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/"},{"categories":["Golang"],"content":"时间和内存消耗 1 2 #!/bin/sh /usr/bin/time -f '%Uu %Ss %er %MkB %C' \"$@\" ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/:8:1","tags":["go学习笔记"],"title":"golang-学习笔记-错误处理与测试","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/"},{"categories":["Golang"],"content":"用 go test 调试 cpuprofile 和 -memprofile 标志向指定文件写入 CPU 或 内存使用情况报告 1 go test -x -v -cpuprofile=prof.out -file x_test.go ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/:8:2","tags":["go学习笔记"],"title":"golang-学习笔记-错误处理与测试","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/"},{"categories":["Golang"],"content":"用 pprof 调试 1 2 3 4 5 6 7 8 9 10 11 12 13 var cpuprofile = flag.String(\"cpuprofile\", \"\", \"write cpu profile to file\") func main() { flag.Parse() if *cpuprofile != \"\" { f, err := os.Create(*cpuprofile) if err != nil { log.Fatal(err) } pprof.StartCPUProfile(f) defer pprof.StopCPUProfile() } ... 运行程序：progexec -cpuprofile=progexec.prof 使用gopprof工具查看：gopprof progexec progexec.prof 如果开启了 CPU 性能分析，Go 程序会以大约每秒 100 次的频率阻塞，并记录当前执行的 goroutine 栈上的程序计数器样本。 此工具一些有趣的命令： topN:展示分析结果中最频繁的 N 份样本，top5 它会展示在程序运行期间调用最频繁的 5 个函数 web 或 web 函数名：生成一份 SVG 格式的分析数据图表，并在网络浏览器中打开它，函数被表示成不同的矩形（被调用越多，矩形越大），箭头指示函数调用链 list 函数名 或 weblist 函数名，展示对应函数名的代码行列表，第 2 列表示当前行执行消耗的时间，这样就很好地指出了运行过程中消耗最大的代码。需要pprof.WriteHeapProfile(f) ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/:8:3","tags":["go学习笔记"],"title":"golang-学习笔记-错误处理与测试","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/"},{"categories":["Golang"],"content":"覆盖率测试 首先，我们要确保所有的测试都正常通过： -coverprofile标志参数重新运行测试 1 2 $ go test -run=Coverage -coverprofile=c.out gopl.io/ch7/eval ok gopl.io/ch7/eval 0.032s coverage: 68.5% of statements 这里的-run选项对应一个正则表达式，匹配的函数名才会进行测试 查看HTML报告 1 $ go tool cover -html=c.out ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/:9:0","tags":["go学习笔记"],"title":"golang-学习笔记-错误处理与测试","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/"},{"categories":["Golang"],"content":"并行测试 T 和 B 的 Run 方法允许定义子单元测试和子基准测试，而不必为每个子测试和子基准定义单独的函数。 1 2 3 4 5 6 7 8 9 10 func TestGroupedParallel(t *testing.T) { for _, tc := range tests { tc := tc // capture range variable t.Run(tc.Name, func(t *testing.T) { //并行测试 t.Parallel() ... }) } } 并行测试加快测试效率。 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/:10:0","tags":["go学习笔记"],"title":"golang-学习笔记-错误处理与测试","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/"},{"categories":["Golang"],"content":"gomock 基于interface{}的模拟工具 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/:11:0","tags":["go学习笔记"],"title":"golang-学习笔记-错误处理与测试","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/"},{"categories":["Golang"],"content":"mockgen mockgen工具用于根据go文件写好的interface生成相应的mock.go文件。 两种使用方式： mockgen -source=xxxx.go [other options]：源文件模式，将文件中所有interface都生成mock mockgen packagepath Interface1,Interface2…：反射模式，根据需要将包中的指定interface生成mock 常用选项 -package: 指定mock类源文件的包名，默认位mock_输入文件的包名 -destination: mock类代码的输出文件，默认输出到标准输出，所以也可以使用重定向符号来输出到目标文件 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/:11:1","tags":["go学习笔记"],"title":"golang-学习笔记-错误处理与测试","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/"},{"categories":["Golang"],"content":"使用方法 分4步 interface编写 infra/db.go 1 2 3 4 5 6 7 8 package db type Repository interface { Create(key string, value []byte) error Retrieve(key string) ([]byte, error) Update(key string, value []byte) error Delete(key string) error } mock文件生成 1 mockgen -source=./infra/db.go -destination=./mock/mock_repository.go -package=mock 使用mock对象的文件 MySQL.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package MySQL import \"GoExample/GoMock/infra\" type MySQL struct { DB db.Repository } func NewMySQL(db db.Repository) *MySQL { return \u0026MySQL{DB: db} } func (mysql *MySQL) CreateData(key string, value []byte) error { return mysql.DB.Create(key, value) } func (mysql *MySQL) GetData(key string) ([]byte, error) { return mysql.DB.Retrieve(key) } func (mysql *MySQL) DeleteData(key string) error { return mysql.DB.Delete(key) } func (mysql *MySQL) UpdateData(key string, value []byte) error { return mysql.DB.Update(key, value) } 测试用例编写 导入mock相关包 1 2 3 4 5 import ( \"testing\" \"GoExample/GoMock/mock\" \"github.com/golang/mock/gomock\" ) mock控制器 mock控制器通过NewController接口生成，是mock生态系统的顶层控制，定义了mock对象的作用域和生命周期，以及mock对象的期望。当用例结束后，控制器会检查所有剩余期望的调用是否满足条件。 1 2 3 ctrl := NewController(t) //1.5以上版本自动调用finish defer ctrl.Finish() mock对象创建时需要注入控制器 1 mockRepo := mock_db.NewMockRepository(ctrl) mock对象的行为注入 mock对象的行为注入，控制器通过map来维护，一个方法对应map的一项。一个方法在一个用例中可能调用多次，所以map的值类型是数组切片。当mock对象进行行为注入时，控制器会将行为Add。当该方法被调用时，控制器会将该行为Remove。 返回值 Return()：返回指定值 Do(func)：执行操作，忽略返回值 DoAndReturn(func)：执行并返回指定值 Any()函数表示对参数没有要求，其他的还有Equ()函数，其实直接将限制字面量放到参数也可以进行相等限制 1 2 3 mockRepo.EXPECT().Retrieve(Any()).Return(nil, ErrAny) mockRepo.EXPECT().Create(Any(), Any()).Return(nil) mockRepo.EXPECT().Retrieve(Any()).Return(objBytes, nil) 可以使用Times关键字来批量注入行为： 1 mockRepo.EXPECT().Create(Any(), Any()).Return(nil).Times(5) 调用次数 Times() 断言 Mock 方法被调用的次数 MaxTimes() 最大次数 MinTimes() 最小次数 AnyTimes() 任意次数（包括 0 次） 行为调用的保序 默认情况下，行为调用顺序可以和mock对象行为注入顺序不一致，即不保序 通过After关键字来实现保序 1 2 3 retrieveCall := mockRepo.EXPECT().Retrieve(Any()).Return(nil, ErrAny) createCall := mockRepo.EXPECT().Create(Any(), Any()).Return(nil).After(retrieveCall) mockRepo.EXPECT().Retrieve(Any()).Return(objBytes, nil).After(createCall) 通过InOrder函数来实现保序(底层仍然是使用after) 1 2 3 4 5 gomock.InOrder( mockRepo.EXPECT().Retrieve(Any()).Return(nil, ErrAny) mockRepo.EXPECT().Create(Any(), Any()).Return(nil) mockRepo.EXPECT().Retrieve(Any()).Return(objBytes, nil) ) 底层原理 1 2 3 4 5 func InOrder(calls ...*Call) { for i := 1; i \u003c len(calls); i++ { calls[i].After(calls[i-1]) } } mock对象的注入 mock对象的行为都注入到控制器后，要将mock对象注入给interface，使得mock对象在测试中生效。 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/:11:2","tags":["go学习笔记"],"title":"golang-学习笔记-错误处理与测试","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/"},{"categories":["Golang"],"content":"monkey 对函数和方法进行模拟，在运行时通过汇编语言重写可执行文件，将目标函数或方法的实现跳转到桩实现 monkey不支持内联函数，在测试的时候需要通过命令行参数-gcflags=-l关闭Go语言的内联优化 monkey不是线程安全的，所以不要把它用到并发的单元测试中 monkey的使用非常简单 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/:12:0","tags":["go学习笔记"],"title":"golang-学习笔记-错误处理与测试","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/"},{"categories":["Golang"],"content":"对函数打桩 1 monkey.Patch(函数名, 函数定义) main_test.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import ( \"bou.ke/monkey\" \"fmt\" \"testing\" ) func testFunc() {} func TestAAA(t *testing.T) { monkey.Patch(testFunc, func() { fmt.Println(\"test success\") }) testFunc() } 运行测试 1 go test main_test.go -run=AAA -v -gcflags=-l ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/:12:1","tags":["go学习笔记"],"title":"golang-学习笔记-错误处理与测试","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/"},{"categories":["Golang"],"content":"对方法打桩 1 monkey.PatchInstanceMethod(reflect.Type,方法名,方法体) main_test.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \"bou.ke/monkey\" \"fmt\" \"reflect\" \"testing\" ) type User struct { Name string Birthday string } func (*User) CalcAge() int { return 1 } func TestAAA(t *testing.T) { var u = \u0026User{ Name: \"q1mi\", Birthday: \"1990-12-20\", } monkey.PatchInstanceMethod(reflect.TypeOf(u), \"CalcAge\", func(*User) int { fmt.Println(\"test success\") return 0 }) u.CalcAge() } 运行测试 1 go test main_test.go -run=AAA -v -gcflags=-l ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/:12:2","tags":["go学习笔记"],"title":"golang-学习笔记-错误处理与测试","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/"},{"categories":["Golang"],"content":"go官方文档 go语言参考 在写过很多go代码之后，感觉自己并没有完全掌握go语言，还有很多知识盲区，所以有了这个go学习笔记系列，本系列是作者跟着电子书重新复习go语言相关内容的笔记 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/:0:0","tags":["go学习笔记"],"title":"golang-学习笔记-读写数据","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/"},{"categories":["Golang"],"content":"读取用户的输入 从键盘和标准输入 os.Stdin 读取输入 fmt 包提供的 Scan 和 Sscan 开头的函数封装了读取过程 也可以使用 bufio 包提供的缓冲读取（buffered reader）来读取数据 1 2 3 4 5 inputReader = bufio.NewReader(os.Stdin) input, err = inputReader.ReadString('\\n') if err == nil { fmt.Printf(\"The input was: %s\\n\", input) } Unix和Windows的行结束符是不同的 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/:1:0","tags":["go学习笔记"],"title":"golang-学习笔记-读写数据","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/"},{"categories":["Golang"],"content":"文件读写 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/:2:0","tags":["go学习笔记"],"title":"golang-学习笔记-读写数据","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/"},{"categories":["Golang"],"content":"读文件 文件使用指向 os.File 类型的指针来表示的，也叫做文件句柄。标准输入 os.Stdin 和标准输出 os.Stdout，他们的类型都是 *os.File。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 inputFile, inputError := os.Open(\"input.dat\") if inputError != nil { fmt.Printf(\"An error occurred on opening the inputfile\\n\" + \"Does the file exist?\\n\" + \"Have you got acces to it?\\n\") return // exit the function on error } defer inputFile.Close() inputReader := bufio.NewReader(inputFile) for { inputString, readerError := inputReader.ReadString('\\n') fmt.Printf(\"The input was: %s\", inputString) if readerError == io.EOF { return } } 其他类似函数： 将整个文件的内容读到一个字符串里：ioutil.ReadFile() 1 2 3 4 5 6 7 8 9 10 11 12 inputFile := \"products.txt\" outputFile := \"products_copy.txt\" buf, err := ioutil.ReadFile(inputFile) if err != nil { fmt.Fprintf(os.Stderr, \"File Error: %s\\n\", err) // panic(err.Error()) } fmt.Printf(\"%s\\n\", string(buf)) err = ioutil.WriteFile(outputFile, buf, 0644) // oct, not hex if err != nil { panic(err.Error()) } 带缓冲的读取:二进制文件使用bufio.Reader 的 Read() 1 2 3 4 buf := make([]byte, 1024) ... n, err := inputReader.Read(buf) if (n == 0) { break} 按列读取文件中的数据：FScan 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 file, err := os.Open(\"products2.txt\") if err != nil { panic(err) } defer file.Close() var col1, col2, col3 []string for { var v1, v2, v3 string _, err := fmt.Fscanln(file, \u0026v1, \u0026v2, \u0026v3) // scans until newline if err != nil { break } col1 = append(col1, v1) col2 = append(col2, v2) col3 = append(col3, v3) } path 包里包含一个子包叫 filepath，这个子包提供了跨平台的函数，用于处理文件名和路径。 1 2 import \"path/filepath\" filename := filepath.Base(path) ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/:2:1","tags":["go学习笔记"],"title":"golang-学习笔记-读写数据","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/"},{"categories":["Golang"],"content":"compress包：读取压缩文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 fName := \"MyFile.gz\" var r *bufio.Reader fi, err := os.Open(fName) if err != nil { fmt.Fprintf(os.Stderr, \"%v, Can't open %s: error: %s\\n\", os.Args[0], fName, err) os.Exit(1) } fz, err := gzip.NewReader(fi) if err != nil { r = bufio.NewReader(fi) } else { r = bufio.NewReader(fz) } for { line, err := r.ReadString('\\n') if err != nil { fmt.Println(\"Done reading file\") os.Exit(0) } fmt.Println(line) } 相当于对io.Reader进行了一层封装，得到gzip.Reader，之后再用bufio读取。 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/:2:2","tags":["go学习笔记"],"title":"golang-学习笔记-读写数据","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/"},{"categories":["Golang"],"content":"写文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 outputFile, outputError := os.OpenFile(\"output.dat\", os.O_WRONLY|os.O_CREATE, 0666) if outputError != nil { fmt.Printf(\"An error occurred with file opening or creation\\n\") return } defer outputFile.Close() outputWriter := bufio.NewWriter(outputFile) outputString := \"hello world!\\n\" for i:=0; i\u003c10; i++ { outputWriter.WriteString(outputString) } outputWriter.Flush() os.Open()函数内部仍然是调用OpenFile()函数，以只读打开文件。 OpenFile 函数有三个参数：文件名、一个或多个标志（使用逻辑运算符“|”连接），使用的文件权限。常用标志： os.O_RDONLY：只读 os.O_WRONLY：只写 os.O_CREATE：创建：如果指定文件不存在，就创建该文件。 os.O_TRUNC：截断：如果指定文件已存在，就将该文件的长度截为0。 创建一个写入器（缓冲区）对象：outputWriter := bufio.NewWriter(outputFile) 使用一个 for 循环，将字符串写入缓冲区 outputWriter.Flush()将缓存区的内容显示传输过去 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/:2:3","tags":["go学习笔记"],"title":"golang-学习笔记-读写数据","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/"},{"categories":["Golang"],"content":"文件拷贝 io.Copy(dst, src) 1 2 3 4 5 6 7 8 9 10 11 12 13 src, err := os.Open(srcName) if err != nil { return } defer src.Close() dst, err := os.OpenFile(dstName, os.O_WRONLY|os.O_CREATE, 0644) if err != nil { return } defer dst.Close() io.Copy(dst, src) ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/:3:0","tags":["go学习笔记"],"title":"golang-学习笔记-读写数据","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/"},{"categories":["Golang"],"content":"从命令行读取参数 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/:4:0","tags":["go学习笔记"],"title":"golang-学习笔记-读写数据","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/"},{"categories":["Golang"],"content":"os 包 os 包中有一个 string 类型的切片变量 os.Args，用来处理一些基本的命令行参数，它在程序启动后读取命令行输入的参数。os.Args[0] 放的是程序本身的名字。 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/:4:1","tags":["go学习笔记"],"title":"golang-学习笔记-读写数据","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/"},{"categories":["Golang"],"content":"flag 包 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/:4:2","tags":["go学习笔记"],"title":"golang-学习笔记-读写数据","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/"},{"categories":["Golang"],"content":"用 buffer 读取文件 bufio.NewReader(os.Stdin) ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/:5:0","tags":["go学习笔记"],"title":"golang-学习笔记-读写数据","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/"},{"categories":["Golang"],"content":"用切片读写文件 1 2 3 4 5 var buf [NBUF]byte if nw, ew := os.Stdout.Write(buf[0:nr]); nw != nr { fmt.Fprintf(os.Stderr, \"cat: error writing: %s\\n\", ew.Error()) } ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/:6:0","tags":["go学习笔记"],"title":"golang-学习笔记-读写数据","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/"},{"categories":["Golang"],"content":"用 defer 关闭文件 1 2 f, _ := os.OpenFile(name, os.O_RDONLY, 0) defer f.Close() ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/:7:0","tags":["go学习笔记"],"title":"golang-学习笔记-读写数据","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/"},{"categories":["Golang"],"content":"使用接口的实际例子：fmt.Fprintf 1 2 3 4 5 func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) type Writer interface { Write(p []byte) (n int, err error) } ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/:8:0","tags":["go学习笔记"],"title":"golang-学习笔记-读写数据","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/"},{"categories":["Golang"],"content":"JSON 数据格式 一些术语说明: 数据结构 –\u003e 指定格式 = 序列化 或 编码（传输之前） 指定格式 –\u003e 数据格式 = 反序列化 或 解码（传输之后） 1 2 3 func Marshal(v interface{}) ([]byte, error) func Unmarshal(data []byte, v interface{}) error 解码任意的数据： json 包使用 map[string]interface{} 和 []interface{} 储存任意的 JSON 对象和数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 b := []byte(`{\"Name\": \"Wednesday\", \"Age\": 6, \"Parents\": [\"Gomez\", \"Morticia\"]}`) var f interface{} err := json.Unmarshal(b, \u0026f) //f 指向的值是一个 map，key 是一个字符串，value 是自身存储作为空接口类型的值： // map[string]interface{} { // \"Name\": \"Wednesday\", // \"Age\": 6, // \"Parents\": []interface{} { // \"Gomez\", // \"Morticia\", // }, // } //要访问这个数据，我们可以使用类型断言 m := f.(map[string]interface{}) //通过 for range 语法和 type switch 来访问其实际类型： for k, v := range m { switch vv := v.(type) { case string: fmt.Println(k, \"is string\", vv) case int: fmt.Println(k, \"is int\", vv) case []interface{}: fmt.Println(k, \"is an array:\") for i, u := range vv { fmt.Println(i, u) } default: fmt.Println(k, \"is of a type I don’t know how to handle\") } } 解码数据到结构 1 2 3 4 5 6 7 8 type FamilyMember struct { Name string Age int Parents []string } var m FamilyMember err := json.Unmarshal(b, \u0026m) 编码和解码流:把 JSON 直接写入文件 1 2 3 4 5 func NewDecoder(r io.Reader) *Decoder func NewEncoder(w io.Writer) *Encoder func NewDecoder(r io.Reader) *Decoder func (dec *Decoder) Decode(v interface{}) error ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/:9:0","tags":["go学习笔记"],"title":"golang-学习笔记-读写数据","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/"},{"categories":["Golang"],"content":"用 Gob 传输数据 和 JSON 的使用方式一样 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/:10:0","tags":["go学习笔记"],"title":"golang-学习笔记-读写数据","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/"},{"categories":["Golang"],"content":"Go 中的密码学 hash 包：实现了 adler32、crc32、crc64 和 fnv 校验； crypto 包：实现了其它的 hash 算法，比如 md4、md5、sha1 等。以及完整地实现了 aes、blowfish、rc4、rsa、xtea 等加密算法。 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/:11:0","tags":["go学习笔记"],"title":"golang-学习笔记-读写数据","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/"},{"categories":["Golang"],"content":"go官方文档 go语言参考 在写过很多go代码之后，感觉自己并没有完全掌握go语言，还有很多知识盲区，所以有了这个go学习笔记系列，本系列是作者跟着电子书重新复习go语言相关内容的笔记 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A5%E5%8F%A3interfaces%E4%B8%8E%E5%8F%8D%E5%B0%84reflection/:0:0","tags":["go学习笔记"],"title":"golang-学习笔记-接口（Interfaces）与反射（reflection）","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A5%E5%8F%A3interfaces%E4%B8%8E%E5%8F%8D%E5%B0%84reflection/"},{"categories":["Golang"],"content":"接口是什么 1 2 3 4 5 type Namer interface { Method1(param_list) return_type Method2(param_list) return_type ... } 实现接口：定义与接口内部函数签名字段相同的方法。 类型不需要显式声明它实现了某个接口：接口被隐式地实现。多个类型可以实现同一个接口。 实现某个接口的类型（除了实现接口方法外）可以有其他的方法。 一个类型可以实现多个接口。 接口类型可以是一个实例的引用， 该实例的类型实现了此接口（接口是动态类型）。 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A5%E5%8F%A3interfaces%E4%B8%8E%E5%8F%8D%E5%B0%84reflection/:1:0","tags":["go学习笔记"],"title":"golang-学习笔记-接口（Interfaces）与反射（reflection）","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A5%E5%8F%A3interfaces%E4%B8%8E%E5%8F%8D%E5%B0%84reflection/"},{"categories":["Golang"],"content":"接口嵌套接口 一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A5%E5%8F%A3interfaces%E4%B8%8E%E5%8F%8D%E5%B0%84reflection/:2:0","tags":["go学习笔记"],"title":"golang-学习笔记-接口（Interfaces）与反射（reflection）","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A5%E5%8F%A3interfaces%E4%B8%8E%E5%8F%8D%E5%B0%84reflection/"},{"categories":["Golang"],"content":"类型断言：如何检测和转换接口变量的类型 1 2 3 4 5 if v, ok := varI.(T); ok { // checked type assertion Process(v) return } // varI is not of type T varI 必须是一个接口变量，当转换不成功时会给v是T类型的零值，ok为false ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A5%E5%8F%A3interfaces%E4%B8%8E%E5%8F%8D%E5%B0%84reflection/:3:0","tags":["go学习笔记"],"title":"golang-学习笔记-接口（Interfaces）与反射（reflection）","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A5%E5%8F%A3interfaces%E4%B8%8E%E5%8F%8D%E5%B0%84reflection/"},{"categories":["Golang"],"content":"类型判断：type-switch 1 2 3 4 5 6 7 8 9 switch areaIntf.(type) { case *Square: // TODO case *Circle: // TODO ... default: // TODO } 这里的switch不能使用fallthrough ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A5%E5%8F%A3interfaces%E4%B8%8E%E5%8F%8D%E5%B0%84reflection/:4:0","tags":["go学习笔记"],"title":"golang-学习笔记-接口（Interfaces）与反射（reflection）","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A5%E5%8F%A3interfaces%E4%B8%8E%E5%8F%8D%E5%B0%84reflection/"},{"categories":["Golang"],"content":"测试一个值是否实现了某个接口 1 2 3 4 5 6 7 type Stringer interface { String() string } if sv, ok := v.(Stringer); ok { fmt.Printf(\"v implements String(): %s\\n\", sv.String()) // note: sv, not v } 使用接口使代码更具有普适性。 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A5%E5%8F%A3interfaces%E4%B8%8E%E5%8F%8D%E5%B0%84reflection/:5:0","tags":["go学习笔记"],"title":"golang-学习笔记-接口（Interfaces）与反射（reflection）","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A5%E5%8F%A3interfaces%E4%B8%8E%E5%8F%8D%E5%B0%84reflection/"},{"categories":["Golang"],"content":"使用方法集与接口 记住3点即可 go语言里面只有值传递，包括方法接收者 方法接收对象不管是指针类型还是实例都能调用方法，并且被interface认为是实现了相关方法，当接收者是指针类型时自动将接收对象取地址，当接收者是值类型时自动将接收对象转换为原实例 go语言有隐式解引用，即.运算符可以直接作用于指针，编译器会自动转换为*p.xxx ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A5%E5%8F%A3interfaces%E4%B8%8E%E5%8F%8D%E5%B0%84reflection/:6:0","tags":["go学习笔记"],"title":"golang-学习笔记-接口（Interfaces）与反射（reflection）","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A5%E5%8F%A3interfaces%E4%B8%8E%E5%8F%8D%E5%B0%84reflection/"},{"categories":["Golang"],"content":"第一个例子：使用 Sorter 接口排序 实现Len()，Less(i, j)和Swap(i, j)可以直接调用sort.Sort(data Interface) ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A5%E5%8F%A3interfaces%E4%B8%8E%E5%8F%8D%E5%B0%84reflection/:7:0","tags":["go学习笔记"],"title":"golang-学习笔记-接口（Interfaces）与反射（reflection）","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A5%E5%8F%A3interfaces%E4%B8%8E%E5%8F%8D%E5%B0%84reflection/"},{"categories":["Golang"],"content":"第二个例子：读和写 1 2 3 4 5 6 7 type Reader interface { Read(p []byte) (n int, err error) } type Writer interface { Write(p []byte) (n int, err error) } io 包里的 Readers 和 Writers 都是不带缓冲的。bufio 包里提供了对应的带缓冲的操作。 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A5%E5%8F%A3interfaces%E4%B8%8E%E5%8F%8D%E5%B0%84reflection/:8:0","tags":["go学习笔记"],"title":"golang-学习笔记-接口（Interfaces）与反射（reflection）","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A5%E5%8F%A3interfaces%E4%B8%8E%E5%8F%8D%E5%B0%84reflection/"},{"categories":["Golang"],"content":"空接口 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A5%E5%8F%A3interfaces%E4%B8%8E%E5%8F%8D%E5%B0%84reflection/:9:0","tags":["go学习笔记"],"title":"golang-学习笔记-接口（Interfaces）与反射（reflection）","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A5%E5%8F%A3interfaces%E4%B8%8E%E5%8F%8D%E5%B0%84reflection/"},{"categories":["Golang"],"content":"概念 1 type Any interface {} 每个 interface {} 变量在内存中占据两个字长：一个用来存储它包含的类型，另一个用来存储它包含的数据或者指向数据的指针 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A5%E5%8F%A3interfaces%E4%B8%8E%E5%8F%8D%E5%B0%84reflection/:9:1","tags":["go学习笔记"],"title":"golang-学习笔记-接口（Interfaces）与反射（reflection）","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A5%E5%8F%A3interfaces%E4%B8%8E%E5%8F%8D%E5%B0%84reflection/"},{"categories":["Golang"],"content":"构建通用类型或包含不同类型变量的数组 1 2 3 4 5 type Element interface{} type Vector struct { a []Element } ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A5%E5%8F%A3interfaces%E4%B8%8E%E5%8F%8D%E5%B0%84reflection/:9:2","tags":["go学习笔记"],"title":"golang-学习笔记-接口（Interfaces）与反射（reflection）","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A5%E5%8F%A3interfaces%E4%B8%8E%E5%8F%8D%E5%B0%84reflection/"},{"categories":["Golang"],"content":"复制数据切片至空接口切片 1 2 3 4 5 var dataSlice []myType = FuncReturnSlice() var interfaceSlice []interface{} = make([]interface{}, len(dataSlice)) for i, d := range dataSlice { interfaceSlice[i] = d } ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A5%E5%8F%A3interfaces%E4%B8%8E%E5%8F%8D%E5%B0%84reflection/:9:3","tags":["go学习笔记"],"title":"golang-学习笔记-接口（Interfaces）与反射（reflection）","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A5%E5%8F%A3interfaces%E4%B8%8E%E5%8F%8D%E5%B0%84reflection/"},{"categories":["Golang"],"content":"接口到接口 一个接口的值可以赋值给另一个接口变量，只要底层类型实现了必要的方法 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A5%E5%8F%A3interfaces%E4%B8%8E%E5%8F%8D%E5%B0%84reflection/:9:4","tags":["go学习笔记"],"title":"golang-学习笔记-接口（Interfaces）与反射（reflection）","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A5%E5%8F%A3interfaces%E4%B8%8E%E5%8F%8D%E5%B0%84reflection/"},{"categories":["Golang"],"content":"go官方文档 go语言参考 在写过很多go代码之后，感觉自己并没有完全掌握go语言，还有很多知识盲区，所以有了这个go学习笔记系列，本系列是作者跟着电子书重新复习go语言相关内容的笔记 可以通过 new 函数来创建 组成结构体类型的那些数据称为 字段（fields） ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/:0:0","tags":["go学习笔记"],"title":"golang-学习笔记-结构（struct）与方法（method）","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/"},{"categories":["Golang"],"content":"结构体定义 1 2 3 4 5 6 7 type identifier struct { field1 type1 field2 type2 ... } type T struct {a, b int} 结构体里的字段都有 名字，如果字段在代码中从来也不会被用到，那么可以命名它为 _。 结构体的字段可以是任何类型 使用 new 函数给一个新的结构体变量分配内存，它返回指向已分配内存的指针：var t *T = new(T) 使用 fmt.Println 打印一个结构体的默认输出可以很好的显示它的内容，类似使用 %v 选项。 使用点号符给字段赋值：structname.fieldname = value.Go 语言中这叫 选择器（selector）.为选择器符（selector-notation）.指针使用.操作会自动解引用 结构体能够定义在函数中，但是这种情况下只能函数可见，并且该类型不能作为返回值 初始化一个结构体实例： 1 2 3 4 5 6 ms := \u0026struct1{10, 15.5, \"Chris\"} var ms struct1 ms = struct1{10, 15.5, \"Chris\"} intr := Interval{end:5, start:1} 混合字面量语法（composite literal syntax）\u0026struct1{a, b, c} 是一种简写，底层仍然会调用 new ()，这里值的顺序必须按照字段顺序来写。 结构体类型和字段的命名遵循可见性规则 结构体的内存布局：结构体和它所包含的数据在内存中是以连续块的形式存在的，即使结构体中嵌套有其他的结构体 递归结构体： 1 2 3 4 type Node struct { data float64 su *Node } 结构体转换:当为结构体定义了一个 alias 类型时，此结构体类型和它的 alias 类型都有相同的底层类型，它们可以互相转换，使用强制类型转换typeA（b） ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/:1:0","tags":["go学习笔记"],"title":"golang-学习笔记-结构（struct）与方法（method）","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/"},{"categories":["Golang"],"content":"使用自定义包中的结构体 大写字母开头可见 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/:2:0","tags":["go学习笔记"],"title":"golang-学习笔记-结构（struct）与方法（method）","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/"},{"categories":["Golang"],"content":"带标签的结构体 标签的内容不可以在一般的编程中使用，只有包 reflect 能获取它。 1 2 3 4 5 6 7 8 9 10 11 type TagType struct { // tags field1 bool \"An important answer\" field2 string \"The name of the thing\" field3 int \"How much there are\" } tt := TagType{true, \"Barak Obama\", 1} ttType := reflect.TypeOf(tt) ixField := ttType.Field(ix) fmt.Printf(\"%v\\n\", ixField.Tag) ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/:3:0","tags":["go学习笔记"],"title":"golang-学习笔记-结构（struct）与方法（method）","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/"},{"categories":["Golang"],"content":"匿名字段和内嵌结构体 结构体可以包含一个或多个 匿名（或内嵌）字段，即这些字段没有显式的名字，只有字段的类型是必须的，此时类型就是字段的名字。 匿名字段本身可以是一个结构体类型，即 结构体可以包含内嵌结构体。go的继承行为 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 type innerS struct { in1 int in2 int } type outerS struct { b int c float32 int // anonymous field innerS //anonymous field } outer := new(outerS) outer.int = 60 outer.in1 = 5 // 使用结构体字面量 outer2 := outerS{6, 7.5, 60, innerS{5, 10}} 在一个结构体中对于每一种数据类型只能有一个匿名字段 命名冲突 当两个字段拥有相同的名字（可能是继承来的名字）: 外层名字会覆盖内层名字（但是两者的内存空间都保留），这提供了一种重载字段或方法的方式； 如果相同的名字在同一级别出现了两次，如果这个名字被程序使用了，将会引发一个错误（不使用没关系）。没有办法来解决这种问题引起的二义性，必须由程序员自己修正。 1 2 3 4 5 type A struct {a int} type B struct {a, b int} type C struct {A; B} var c C; 使用 c.a 是错误的，到底是 c.A.a 还是 c.B.a 呢？会导致编译器错误 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/:4:0","tags":["go学习笔记"],"title":"golang-学习笔记-结构（struct）与方法（method）","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/"},{"categories":["Golang"],"content":"方法 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/:5:0","tags":["go学习笔记"],"title":"golang-学习笔记-结构（struct）与方法（method）","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/"},{"categories":["Golang"],"content":"方法是什么 1 2 3 func (recv receiver_type) methodName(parameter_list) (return_value_list) { ... } recv.Method1() 如果方法不需要使用 recv 的值，可以用 _ 替换它，比如： 1 func (_ receiver_type) methodName(parameter_list) (return_value_list) { ... } recv 就像是面向对象语言中的 this 或 self，仍然是值拷贝 类型和作用在它上面定义的方法必须在同一个包里定义，这就是为什么不能在 int、float 或类似这些的类型上定义方法。 有一个间接的方式：可以先定义该类型（比如：int 或 float）的别名类型（这里指的是不使用\"=“的类型定义），然后再为别名类型定义方法。 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/:5:1","tags":["go学习笔记"],"title":"golang-学习笔记-结构（struct）与方法（method）","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/"},{"categories":["Golang"],"content":"函数和方法的区别 方法没有和数据定义（结构体）混在一起：它们是正交的类型；表示（数据）和行为（方法）是独立的。 没啥区别，多了个默认参数recv，另外recv可以自动进行取地址，即使用引用可以接收示例 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/:5:2","tags":["go学习笔记"],"title":"golang-学习笔记-结构（struct）与方法（method）","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/"},{"categories":["Golang"],"content":"指针或值作为接收者 鉴于性能的原因，recv 最常见的是一个指向 receiver_type 的指针（因为我们不想要一个实例的拷贝，如果按值调用的话就会是这样），特别是在 receiver 类型是结构体时，就更是如此了。 如果想要方法改变接收者的数据，就在接收者的指针类型上定义该方法。否则，就在普通的值类型上定义方法。 指针方法和值方法都可以在指针或非指针上被调用 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/:5:3","tags":["go学习笔记"],"title":"golang-学习笔记-结构（struct）与方法（method）","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/"},{"categories":["Golang"],"content":"方法和未导出字段 可以给未导出字段添加Getter或Setter方法 并发访问对象：使用sync包进行并发安全控制 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/:5:4","tags":["go学习笔记"],"title":"golang-学习笔记-结构（struct）与方法（method）","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/"},{"categories":["Golang"],"content":"内嵌类型的方法和继承 当一个匿名类型被内嵌在结构体中时，匿名类型的可见方法也同样被内嵌，这在效果上等同于外层类型 继承 了这些方法：将父类型放在子类型中来实现亚型。 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/:5:5","tags":["go学习笔记"],"title":"golang-学习笔记-结构（struct）与方法（method）","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/"},{"categories":["Golang"],"content":"如何在类型中嵌入功能 主要有两种方法来实现在类型中嵌入功能： A：聚合（或组合）：包含一个所需功能类型的具名字段。 B：内嵌：内嵌（匿名地）所需功能类型 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/:5:6","tags":["go学习笔记"],"title":"golang-学习笔记-结构（struct）与方法（method）","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/"},{"categories":["Golang"],"content":"多重继承 但是在 Go 语言中，通过在类型中嵌入所有必要的父类型，可以很简单的实现多重继承 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/:5:7","tags":["go学习笔记"],"title":"golang-学习笔记-结构（struct）与方法（method）","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/"},{"categories":["Golang"],"content":"通用方法和方法命名 约定，鸭形语言 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/:5:8","tags":["go学习笔记"],"title":"golang-学习笔记-结构（struct）与方法（method）","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/"},{"categories":["Golang"],"content":"和其他面向对象语言比较 Go 的类型和方法 总结 类型就是类（数据和关联的方法） 代码复用通过组合和委托实现，多态通过接口的使用来实现：有时这也叫 组件编程（Component Programming） ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/:5:9","tags":["go学习笔记"],"title":"golang-学习笔记-结构（struct）与方法（method）","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/"},{"categories":["Golang"],"content":"类型的 String() 方法和格式化描述符 String() 方法： fmt.Printf() 中生成默认的输出：等同于使用格式化描述符 %v 产生的输出。 fmt.Print() 和 fmt.Println() 也会自动使用 String() 方法。 不要在 String() 方法里面调用涉及 String() 方法的方法，会陷入无限递归。 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/:6:0","tags":["go学习笔记"],"title":"golang-学习笔记-结构（struct）与方法（method）","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/"},{"categories":["Golang"],"content":"垃圾回收和 SetFinalizer Go 运行时中有一个独立的进程，即垃圾收集器（GC），可以通过 runtime 包访问 GC 进程 runtime.GC() 函数显式的触发 GC， 给出已分配内存的总量，单位是 Kb 1 2 3 var m runtime.MemStats runtime.ReadMemStats(\u0026m) fmt.Printf(\"%d Kb\\n\", m.Alloc / 1024) 设置一个对象 obj 被从内存移除前执行一些特殊操作： 1 runtime.SetFinalizer(obj, func(obj *typeObj)) ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/:7:0","tags":["go学习笔记"],"title":"golang-学习笔记-结构（struct）与方法（method）","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/"},{"categories":["Golang"],"content":"go官方文档 go语言参考 在写过很多go代码之后，感觉自己并没有完全掌握go语言，还有很多知识盲区，所以有了这个go学习笔记系列，本系列是作者跟着电子书重新复习go语言相关内容的笔记 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/:0:0","tags":["go学习笔记"],"title":"golang-学习笔记-包","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/"},{"categories":["Golang"],"content":"包和文件 Go语言中的包和其他语言的库或模块的概念类似，目的都是为了支持模块化、封装、单独编译和代码重用。 一个包的源代码保存在一个或多个以.go为文件后缀名的源文件中，通常一个包所在目录路径的后缀是包的导入路径 每个包都对应一个独立的名字空间 包还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息：大写可见 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/:1:0","tags":["go学习笔记"],"title":"golang-学习笔记-包","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/"},{"categories":["Golang"],"content":"包简介 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/:2:0","tags":["go学习笔记"],"title":"golang-学习笔记-包","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/"},{"categories":["Golang"],"content":"导入路径 每个包是由一个全局唯一的字符串所标识的导入路径定位（支持相对路径和绝对路径以及网络资源） 默认的包名就是包导入路径名的最后一段，因此两个包的导入路径不同，可能有一个相同的包名。 也有三种例外情况： main包本身的导入路径是无关紧要的。名字为main的包是给go build（§10.7.3）构建命令一个信息，这个包编译完之后必须调用连接器生成一个可执行程序 以_test为后缀包名的测试外部扩展包都由go test命令独立编译，普通包和测试的外部扩展包是相互独立的。 一些依赖版本号的管理工具会在导入路径后追加版本号信息，例如\"gopkg.in/yaml.v2\"。这种情况下包的名字并不包含版本号后缀，而是yaml。 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/:3:0","tags":["go学习笔记"],"title":"golang-学习笔记-包","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/"},{"categories":["Golang"],"content":"导入声明 1 2 3 4 import ( \"crypto/rand\" mrand \"math/rand\" // alternative name mrand avoids conflict ) 不允许循环导入，比如a导入b，b又导入a ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/:4:0","tags":["go学习笔记"],"title":"golang-学习笔记-包","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/"},{"categories":["Golang"],"content":"包的匿名导入 如果只是导入一个包而并不使用导入的包将会导致一个编译错误。匿名导入执行包级变量的初始化表达式和执行导入包的init初始化函数。 1 import _ \"image/png\" // register PNG decoder ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/:5:0","tags":["go学习笔记"],"title":"golang-学习笔记-包","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/"},{"categories":["Golang"],"content":"包和命名 包名一般采用单数的形式。标准库的bytes、errors和strings使用了复数形式，这是为了避免和预定义的类型冲突，同样还有go/types是为了避免和type关键字冲突。 当设计一个包的时候，需要考虑包名和成员名两个部分如何很好地配合。下面有一些例子： bytes.Equal flag.Int http.Get json.Marshal ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/:6:0","tags":["go学习笔记"],"title":"golang-学习笔记-包","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/"},{"categories":["Golang"],"content":"工具 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/:7:0","tags":["go学习笔记"],"title":"golang-学习笔记-包","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/"},{"categories":["Golang"],"content":"工作区结构 GOPATH/\rsrc/\rgopl.io/\r.git/\rch1/\rhelloworld/\rmain.go\rdup/\rmain.go\r...\rgolang.org/x/net/\r.git/\rhtml/\rparse.go\rnode.go\r...\rbin/\rhelloworld\rdup\rpkg/\rdarwin_amd64/\r... go mod 包管理方式使用同一个GOPATH变量存储下载的包和编译的可执行文件，并支持在任意位置创建项目。 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/:7:1","tags":["go学习笔记"],"title":"golang-学习笔记-包","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/"},{"categories":["Golang"],"content":"internal包 Go语言1.4版本后增加了 Internal packages 特征用于控制包的导入，即internal package只能被特定的包导入。 内部包的规范约定：导入路径包含internal关键字的包，只允许internal的父级目录及父级目录的子包导入，其它包无法导入。 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/:8:0","tags":["go学习笔记"],"title":"golang-学习笔记-包","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/"},{"categories":["Golang"],"content":"标准库概述 unsafe: 包含了一些打破 Go 语言“类型安全”的命令，一般的程序中不会被使用，可用在 C/C++ 程序的调用中。 syscall-os-os/exec： os:提供给我们一个平台无关性的操作系统功能接口 os/exec: 提供我们运行外部操作系统命令和程序的方式 syscall: 底层的外部包，提供了操作系统底层调用的基本接口 archive/tar 和 /zip-compress：压缩(解压缩)文件功能 fmt-io-bufio-path/filepath-flag fmt: 提供了格式化输入输出功能 io: 提供了基本输入输出功能 bufio: 缓冲输入输出功能的封装 path/filepath: 用来操作在当前系统中的目标文件名路径 flag: 对命令行参数的操作 strings-strconv-unicode-regexp-bytes strings: 提供对字符串的操作 strconv: 提供将字符串转换为基础类型的功能 unicode: 为 unicode 型的字符串提供特殊的功能 regexp: 正则表达式功能 bytes: 提供对字符型分片的操作 math-math/cmath-math/big-math/rand-sort math: 基本的数学函数 math/rand: 伪随机数生成 sort: 为数组排序和自定义集合 math/big: 大数的实现和计算 container-/list-ring-heap list: 双链表 遍历一个链表(当 l 是 *List) 1 2 3 for e := l.Front(); e != nil; e = e.Next() { //do something with e.Value } ring: 环形链表 heap：二叉堆 time-log time: 日期和时间的基本操作。 log: 记录程序运行时产生的日志,我们将在后面的章节使用它 encoding/json-encoding/xml-text/template net-net/http-html runtime: Go 程序运行时的交互操作，例如垃圾回收和协程创建 reflect: 实现通过程序运行时反射，让程序操作任意类型的变量 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/:9:0","tags":["go学习笔记"],"title":"golang-学习笔记-包","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/"},{"categories":["Golang"],"content":"使用github开发自己的模块并发布 在本地新建项目，模块名为github.com/username/modelname，开发完后发布到github上 尽量不要在模块中使用-符号，如果使用了上传包到github没问题，引入包的时候必须得给包起别名，不然无法使用 1 import Oublie \"github.com/oublie6/Oublie-Go/v2\" 阿里云开发者社区 Golang模块版本管理 本地模块版本号与git tag相关联 CSDN ITqingliang 发布breaking changes 通过创建version分支和tag进行版本升级，直接创建一个新的分支，在新的分支中将go.mod文件的模块名修改为xxx/v2，xxx是原来的模块名，然后打上标签v2.x.x，再推送到远程仓库即可 CSDN 倦~ Go的多模块开发 本地开发多模块项目时，本地依赖的项目需要推送到远程仓库才能得到更新，相当于推送到仓库再下载到pkg里面 后来有了go mod replace，可以在开发时先将本地依赖修改为本地的包，后面再吧go.sum里面的replace删掉再发布 go1.18推出了go work，workspace空目录里面新建的模块，然后再workspace目录使用go work init初始化，并使用go work use 模块名添加需要本地开发的多模块，之后加入work的模块都会本地引用，goland也会自动识别。开发和发布可以无缝衔接。 无忌 github pages博客 go 官方博客go work最佳实践 在工作区目录（通常是GOPATH目录，因为其实工作区类似于开启一个新的GOPATH）维护一个go.work文件来管理所有依赖。go.work里的use和replace指令会覆盖工作区里指定的Go Module的go.mod文件，因此就无需修改Go Module的go.mod文件了。 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/:10:0","tags":["go学习笔记"],"title":"golang-学习笔记-包","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/"},{"categories":["Golang"],"content":"go work 命令 go work init：创建一个go.work go work use [-r] moddir：将本地模块添加到go.work，-r会递归添加，另外这个命令会对已经删除的模块取消use go work sync：把go.work文件里的依赖同步到workspace包含的Module的go.mod文件中 go work edit：提供了用于修改go.work的命令行接口，常用选项有-use和-dropuse 还可以通过修改go.work文件来，go.work里面的内容有 go:go的版本 use:添加的本地模块，use的顺序表示上游模块到下游模块的 replace:和go.mod里面的replace类似，它会覆盖或添加到本地模块的go.mod ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/:10:1","tags":["go学习笔记"],"title":"golang-学习笔记-包","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/"},{"categories":["Golang"],"content":"无法加载第三方包 polarisxu 通过一个例子让你彻底掌握 Go 工作区模式 使用go work sync命令 其实gowork仅仅是通过GOWORK这个环境变量来查看是否使用gowork，所以当我们想不使用gowork时可以将环境变量GOWORK设置为off linux里面可以仅对一个命令传入环境变量：GOWORK=off go run main.go windows里面使用set来设置在当前终端有效的临时环境变量：set GOWORK=off 或者显示环境变量：set GOWORK 或者取消环境变量：set GOWORK= 之后就可以：go run main.go ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/:10:2","tags":["go学习笔记"],"title":"golang-学习笔记-包","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/"},{"categories":["Golang"],"content":"go mod包管理 脚本之家 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/:11:0","tags":["go学习笔记"],"title":"golang-学习笔记-包","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/"},{"categories":["Golang"],"content":"历史 使用go path问题 代码开发必须在go path src目录下，不然，就有问题。 依赖手动管理 依赖包没有版本可言 go path不算包管理工具 govendor 解决了包依赖，一个配置文件就管理 依赖包全都下载到项目vendor下，每个项目都把有一份。 CSDN 想变厉害的大白菜 从Go1.6起，默认开启 vendor 目录查找，vendor 机制就是在包中引入 vendor 目录，将依赖的外部包复制到 vendor 目录下，编译器在查找外部依赖包时，优先在 vendor 目录下查找 govendor add/update 命令从 $GOPATH 中复制依赖包 govendor fetch 添加或更新依赖包 govendor migrate 从其他 vendor 包管理工具中一键迁移到 govendor gomod go modules 是 golang 1.11 新加的特性 模块是相关Go包的集合。modules是源代码交换和版本控制的单元。 go命令直接支持使用modules，包括记录和解析对其他模块的依赖性。modules替换旧的基于GOPATH的方法来指定在给定构建中使用哪些源文件。 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/:11:1","tags":["go学习笔记"],"title":"golang-学习笔记-包","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/"},{"categories":["Golang"],"content":"配置 GO111MODULE 有三个值：off, on和auto（默认值）。 GO111MODULE=off，go命令行将不会支持module功能，寻找依赖包的方式将会沿用旧版本那种通过vendor目录或者GOPATH模式来查找。 GO111MODULE=on，go命令行会使用modules，而一点也不会去GOPATH目录下查找。 GO111MODULE=auto，默认值，go命令行将会根据当前目录来决定是否启用module功能。这种情况下可以分为两种情形：当前目录在GOPATH/src之外且该目录包含go.mod文件，当前文件在包含go.mod文件的目录下面。 当modules功能启用时，依赖包的存放位置变更为$GOPATH/pkg，允许同一个package多个版本并存，且多个项目可以共享缓存的 module ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/:11:2","tags":["go学习笔记"],"title":"golang-学习笔记-包","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/"},{"categories":["Golang"],"content":"go mod命令 完整见原文或go官网 常用的有： init，初始化项目 tidy，自动清除不用的依赖添加使用的依赖 edit，编辑go.mod文件 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/:11:3","tags":["go学习笔记"],"title":"golang-学习笔记-包","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/"},{"categories":["Golang"],"content":"使用replace替换无法直接获取的package 由于某些已知的原因，并不是所有的package都能成功下载，modules 可以通过在 go.mod 文件中使用 replace 指令替换成其他的库： 1 2 3 replace ( golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a =\u003e github.com/golang/crypto v0.0.0-20190313024323-a1f597ede03a ) 使用命令： 1 go mod edit -replace [old git package]@[version]=[new git package]@[version] 本地开发库的时候可以使用这个命令将导入包改为本地包，或者用上面说的go work ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/:11:4","tags":["go学习笔记"],"title":"golang-学习笔记-包","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/"},{"categories":["Golang"],"content":"清理go mod的缓存 1 go clean -modcache ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/:11:5","tags":["go学习笔记"],"title":"golang-学习笔记-包","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%85/"},{"categories":["Golang"],"content":"在写过很多go代码之后，感觉自己并没有完全掌握go语言，还有很多知识盲区，所以有了这个go学习笔记系列，本系列是作者跟着电子书重新复习go语言相关内容的笔记 go专家编程 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/:0:0","tags":["go学习笔记"],"title":"golang-学习笔记-Map","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/"},{"categories":["Golang"],"content":"声明、初始化和 make ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/:1:0","tags":["go学习笔记"],"title":"golang-学习笔记-Map","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/"},{"categories":["Golang"],"content":"概念 1 2 var map1 map[keytype]valuetype var map1 map[string]int 未初始化的 map 的值是 nil。 key 可以是任意可以用 == 或者 != 操作符比较的类型，比如 string、int、float。数组、切片不能作为 key。含有数组切片的结构体不能作为 key，只包含内建类型的 struct 是可以作为 key 的。指针和接口类型可以。如果要用自定义结构体作为 key 需要提供 Key() 和 Hash() 方法，这样可以通过结构体的域计算出唯一的数字或者字符串的 key。 value 可以是任意类型的；通过使用空接口类型，我们可以存储任意值，但是使用这种类型作为值时需要先做一次类型断言 map 传递给函数是引用传递：在 32 位机器上占 4 个字节，64 位机器上占 8 个字节，无论实际上存储了多少数据。通过 key 在 map 中寻找值是很快的，比线性查找快得多，但是仍然比从数组和切片的索引中直接读取要慢 100 倍；所以如果你很在乎性能的话还是建议用切片来解决问题。 map 也可以用函数作为自己的值，这样就可以用来做分支结构 map 是 引用类型 的： 内存用 make 方法来分配。 map 的初始化： 1 2 3 var map1 = make(map[keytype]valuetype) map1 := make(map[keytype]valuetype) 不要使用 new，永远用 make 来构造 map。如果你错误的使用 new() 分配了一个引用对象，你会获得一个空引用的指针，相当于声明了一个未初始化的变量并且取了它的地址。 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/:1:1","tags":["go学习笔记"],"title":"golang-学习笔记-Map","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/"},{"categories":["Golang"],"content":"map 容量 make(map[keytype]valuetype, cap) ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/:1:2","tags":["go学习笔记"],"title":"golang-学习笔记-Map","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/"},{"categories":["Golang"],"content":"用切片作为 map 的值 1 2 mp1 := make(map[int][]int) mp2 := make(map[int]*[]int) ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/:1:3","tags":["go学习笔记"],"title":"golang-学习笔记-Map","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/"},{"categories":["Golang"],"content":"测试键值对是否存在及删除元素 1 2 3 4 5 6 7 8 val1, isPresent = map1[key1] _, ok := map1[key1] // 如果key1存在则ok == true，否则ok为false if _, ok := map1[key1]; ok { // ... } 删除 key1：delete(map1, key1) 如果 key1 不存在，该操作不会产生错误。 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/:2:0","tags":["go学习笔记"],"title":"golang-学习笔记-Map","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/"},{"categories":["Golang"],"content":"for-range 的配套用法 1 2 3 4 5 6 7 for key := range map1 { ... } for key, value := range map1 { ... } ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/:3:0","tags":["go学习笔记"],"title":"golang-学习笔记-Map","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/"},{"categories":["Golang"],"content":"map 类型的切片 想获取一个 map 类型的切片，我们必须使用两次 make() 函数，第一次分配切片，第二次分配 切片中每个 map 元素 1 2 3 4 5 items := make([]map[int]int, 5) for i:= range items { items[i] = make(map[int]int, 1) items[i][1] = 2 } ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/:4:0","tags":["go学习笔记"],"title":"golang-学习笔记-Map","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/"},{"categories":["Golang"],"content":"map 的排序 map 默认是无序的 想为 map 排序，需要将 key（或者 value）拷贝到一个切片，再对切片排序（使用 sort 包），然后可以使用切片的 for-range 方法打印出所有的 key 和 value。 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/:5:0","tags":["go学习笔记"],"title":"golang-学习笔记-Map","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/"},{"categories":["Golang"],"content":"将 map 的键值对调 1 2 3 4 invMap := make(map[int]string, len(barVal)) for k, v := range barVal { invMap[v] = k } ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/:6:0","tags":["go学习笔记"],"title":"golang-学习笔记-Map","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/"},{"categories":["Golang"],"content":"map有容量限制吗 map没有容量限制，在达到容量上限后会自动扩容 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/:7:0","tags":["go学习笔记"],"title":"golang-学习笔记-Map","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/"},{"categories":["Golang"],"content":"map底层实现 存放buckets存放hash值的低位 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/:8:0","tags":["go学习笔记"],"title":"golang-学习笔记-Map","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/"},{"categories":["Golang"],"content":"哈希冲突 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/:9:0","tags":["go学习笔记"],"title":"golang-学习笔记-Map","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/"},{"categories":["Golang"],"content":"负载因子 负载因子 = 键数量/bucket数量 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/:9:1","tags":["go学习笔记"],"title":"golang-学习笔记-Map","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/"},{"categories":["Golang"],"content":"渐进式扩容 触发条件 负载因子 \u003e 6.5时 overflow数量 \u003e 2^15 增量扩容 当负载因子过大时，就新建一个bucket，新的bucket长度是原来的2倍，然后旧bucket数据搬迁到新的bucket。 等量扩容 buckets数量不变，重新做一遍类似增量扩容的搬迁动作，把松散的键值对重新排列一次 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/:9:2","tags":["go学习笔记"],"title":"golang-学习笔记-Map","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/"},{"categories":["Golang"],"content":"查找过程 算出查询key的hash值 取低位找到bucket位置 取高位在tophash中找存储key对应的位置 比较存储key和查询key，如果不相等到下一个overflow bucket中找 搬迁过程从oldbuckets找 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/:9:3","tags":["go学习笔记"],"title":"golang-学习笔记-Map","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/"},{"categories":["Golang"],"content":"插入过程 算出插入key的hash值 查询是否有该值，有就修改value，没有就插入新的kv对 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/:9:4","tags":["go学习笔记"],"title":"golang-学习笔记-Map","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/"},{"categories":["Golang"],"content":"对不存在的key查询 当map的key不存在的时候，它的返回值为这个类型的默认返回值。 由此可以引申出，对于查询kv对后在原来的基础上进行修改的map，可以不判断是否存在直接赋值 比如统计一串数字中每种数字的个数 1 2 3 m:=map[int]int for _,v := range nums{m[v]++} ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/:10:0","tags":["go学习笔记"],"title":"golang-学习笔记-Map","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/"},{"categories":["Golang"],"content":"map不能直接等号比较 map不能直接等号比较，但是可以使用reflect.DeepEqual函数进行逐个元素比较 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/:11:0","tags":["go学习笔记"],"title":"golang-学习笔记-Map","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/"},{"categories":["Golang"],"content":"获取所有的key 1 2 3 4 5 keys := make([]int,0, len(m)) for k := range m { keys = a j++ } ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/:12:0","tags":["go学习笔记"],"title":"golang-学习笔记-Map","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/map/"},{"categories":["Golang"],"content":"go官方文档 go语言参考 在写过很多go代码之后，感觉自己并没有完全掌握go语言，还有很多知识盲区，所以有了这个go学习笔记系列，本系列是作者跟着电子书重新复习go语言相关内容的笔记 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:0:0","tags":["go学习笔记"],"title":"golang-学习笔记-数组与切片","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["Golang"],"content":"声明和初始化 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:1:0","tags":["go学习笔记"],"title":"golang-学习笔记-数组与切片","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["Golang"],"content":"概念 注意事项 如果我们想让数组元素类型为任意类型的话可以使用空接口作为类型。当使用值时我们必须先做一个类型判断。 数组元素可以通过 索引（位置）来读取（或者修改），索引从 0 开始。数组长度最大为 2Gb。对于数组的指针也可以进行索引，go会自动解引用，但是对于切片的指针是不允许的 1 var identifier [len]type 数组是 可变的。 通过 for 遍历数组: 1 2 3 4 5 6 7 for i:=0; i \u003c len(arr1); i++{ arr1[i] = ... } for i,_:= range arr1 { ... } Go 语言中的数组是一种 值类型（不像 C/C++ 中是指向首元素的指针），可以通过 new() 来创建： var arr1 = new([5]int)。 那么这种方式和 var arr2 [5]int 的区别是什么呢？arr1 的类型是 *[5]int，而 arr2的类型是 [5]int。 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:1:1","tags":["go学习笔记"],"title":"golang-学习笔记-数组与切片","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["Golang"],"content":"初始化 注意可以通过声明索引来初始化部分值，声明索引后面的元素从索引开始往后计数，即[6]int{4:1,5}中索引为5的元素为5 1 2 3 4 5 var arrAge = [5]int{18, 20, 15, 22, 16} var arrLazy = [...]int{5, 6, 7, 8, 22} var arrKeyValue = [5]string{3: \"Chris\", 4: \"Ron\"} ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:1:2","tags":["go学习笔记"],"title":"golang-学习笔记-数组与切片","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["Golang"],"content":"多维数组 1 [3][5]int ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:1:3","tags":["go学习笔记"],"title":"golang-学习笔记-数组与切片","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["Golang"],"content":"将数组传递给函数 把一个大数组传递给函数会消耗很多内存。有两种方法可以避免这种现象： 传递数组的指针 使用数组的切片(推荐) ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:1:4","tags":["go学习笔记"],"title":"golang-学习笔记-数组与切片","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["Golang"],"content":"切片 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:2:0","tags":["go学习笔记"],"title":"golang-学习笔记-数组与切片","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["Golang"],"content":"概念 切片（slice）是对数组一个连续片段的引用（该数组我们称之为相关数组，通常是匿名的），所以切片是一个引用类型。 切片是一个 长度可变的数组。 切片是可索引的，并且可以由 len() 函数获取长度。 切片提供了计算容量的函数 cap() 可以测量切片最长可以达到多少：它等于切片的长度 + 数组除切片之外的长度。 多个切片如果表示同一个数组的片段，它们可以共享数据 1 var identifier []type 与数组的不同是不写明长度 一个切片在未初始化之前默认为 nil，长度为 0。 初始化格式 1 var slice1 []type = arr1[start:end] start:end 被称为 slice 表达式，start省略表示0，end省略表示len函数 一个切片 s 可以这样扩展到它的大小上限：s = s[:cap(s)] 对于每一个切片（包括 string），以下状态总是成立的： 1 2 s == s[:i] + s[i:] // i是一个整数且: 0 \u003c= i \u003c= len(s) len(s) \u003c= cap(s) 切片也可以用类似数组的方式初始化：var x = []int{2, 3, 5, 7, 11}。这样就创建了一个长度为 5 的数组并且创建了一个相关切片。 切片在内存中的组织方式实际上是一个有 3 个域的结构体：指向相关数组的指针，切片 长度以及切片容量。 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:2:1","tags":["go学习笔记"],"title":"golang-学习笔记-数组与切片","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["Golang"],"content":"将切片传递给函数 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:2:2","tags":["go学习笔记"],"title":"golang-学习笔记-数组与切片","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["Golang"],"content":"用 make() 创建一个切片 1 2 3 4 5 var slice1 []type = make([]type, len) slice1 := make([]type, len) slice1 := make([]type, len, cap) 下面两种方法可以生成相同的切片: 1 2 make([]int, 50, 100) new([100]int)[0:50] ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:2:3","tags":["go学习笔记"],"title":"golang-学习笔记-数组与切片","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["Golang"],"content":"new() 和 make() 的区别 new(T) 为每个新的类型T分配一片内存，初始化为 0 并且返回类型为*T的内存地址：这种方法 返回一个指向类型为 T，值为 0 的地址的指针，它适用于值类型如数组和结构体；它相当于 \u0026T{}。 make(T) 返回一个类型为 T 的初始值，它只适用于3种内建的引用类型：切片、map 和 channel。 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:2:4","tags":["go学习笔记"],"title":"golang-学习笔记-数组与切片","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["Golang"],"content":"多维 切片 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:2:5","tags":["go学习笔记"],"title":"golang-学习笔记-数组与切片","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["Golang"],"content":"bytes 包 Buffer Buffer 可以这样定义： var buffer bytes.Buffer var r *bytes.Buffer = new(bytes.Buffer) func NewBuffer(buf []byte) *Buffer， 通过 buffer 串联字符串:buffer.WriteString(s) 输出内容:buffer.String() 这种实现方式比使用 += 要更节省内存和 CPU，尤其是要串联的字符串数目特别多的时候。 strings.Builder和bytes.Buffer的用法一模一样 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:2:6","tags":["go学习笔记"],"title":"golang-学习笔记-数组与切片","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["Golang"],"content":"For-range 结构 1 2 3 for ix, value := range slice1 { ... } ix,value是仅在 for 循环内部可见的局部变量。value 只是 slice1 某个索引位置的值的一个拷贝。 如果你只需要索引，你可以忽略第二个变量 多维切片下的 for-range： 1 2 3 4 5 for row := range screen { for column := range screen[row] { screen[row][column] = 1 } } 对于确定初始索引的正向顺序遍历都可以使用range结构 1 2 3 for ix, value := range slice1[k:] { ... } ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:3:0","tags":["go学习笔记"],"title":"golang-学习笔记-数组与切片","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["Golang"],"content":"切片重组（reslice） 改变切片长度的过程称之为切片重组 reslicing。 简单版重切片 a[low:high] 1 2 3 slice1 = slice1[0:end] //将切片扩展 1 位 sl = sl[0:len(sl)+1] 其中 end 是新的末尾索引（即长度） 完整版重切片 a[low:high:max] 第三个max表示cap为max-low ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:4:0","tags":["go学习笔记"],"title":"golang-学习笔记-数组与切片","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["Golang"],"content":"切片的复制与追加 想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来 append内置函数将 0 个或多个具有相同类型 s 的元素追加到切片后面并且返回新的切片。底层数组容量不够时创建新数组并拷贝切片元素。append 方法总是返回成功，除非系统内存耗尽了。 将切片 y 追加到切片 x 后面：x = append(x, y...) func copy(dst, src []T) int 将类型为 T 的切片从源地址 src 拷贝到目标地址 dst，覆盖 dst 的相关元素，并且返回拷贝的元素个数。拷贝内容不能超过源地址内存大小。 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:5:0","tags":["go学习笔记"],"title":"golang-学习笔记-数组与切片","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["Golang"],"content":"字符串、数组和切片的应用 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:6:0","tags":["go学习笔记"],"title":"golang-学习笔记-数组与切片","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["Golang"],"content":"从字符串生成字节切片 1 2 3 c := []byte(s) copy(dst []byte, src string) byte可以直接转化为rune ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:6:1","tags":["go学习笔记"],"title":"golang-学习笔记-数组与切片","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["Golang"],"content":"获取字符串的某一部分 字符串使用索引按字节数计算相对位置 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:6:2","tags":["go学习笔记"],"title":"golang-学习笔记-数组与切片","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["Golang"],"content":"字符串和切片的内存结构 在内存中，一个字符串实际上是一个双字结构，即一个指向实际数据的指针和记录字符串长度的整数。 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:6:3","tags":["go学习笔记"],"title":"golang-学习笔记-数组与切片","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["Golang"],"content":"修改字符串中的某个字符 Go 语言中的字符串是不可变的，str[index] 这样的表达式是不可以被放在等号左侧的。 因此，您必须先将字符串转换成字节数组，然后再通过修改数组中的元素值来达到修改字符串的目的，最后将字节数组转换回字符串格式。 s := \"hello\"\rc := []byte(s)\rc[0] = ’c’\rs2 := string(c) // s2 == \"cello\" ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:6:4","tags":["go学习笔记"],"title":"golang-学习笔记-数组与切片","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["Golang"],"content":"搜索及排序切片和数组 sort.Ints(arri) sort.IntsAreSorted(a []int) bool ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:6:5","tags":["go学习笔记"],"title":"golang-学习笔记-数组与切片","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["Golang"],"content":"append 函数常见操作 将切片 b 的元素追加到切片 a 之后:a = append(a, b...) 复制切片 a 的元素到新的切片 b 上： b = make([]T, len(a))\rcopy(b, a) 删除位于索引 i 的元素:a = append(a[:i], a[i+1:]...) 切除切片 a 中从索引 i 至 j 位置的元素:a = append(a[:i], a[j:]...) 为切片 a 扩展 j 个元素长度：a = append(a, make([]T, j)...) 在索引 i 的位置插入元素 x：a = append(a[:i], append([]T{x}, a[i:]...)...) 在索引 i 的位置插入长度为 j 的新切片：a = append(a[:i], append(make([]T, j), a[i:]...)...) 在索引 i 的位置插入切片 b 的所有元素：a = append(a[:i], append(b, a[i:]...)...) 取出位于切片 a 最末尾的元素 x：x, a = a[len(a)-1], a[:len(a)-1] 将元素 x 追加到切片 a：a = append(a, x) ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:6:6","tags":["go学习笔记"],"title":"golang-学习笔记-数组与切片","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["Golang"],"content":"切片和垃圾回收 切片的底层指向一个数组，该数组的实际容量可能要大于切片所定义的容量。在没有任何切片指向的时候，底层的数组内存才会被释放，这种特性有时会导致程序占用多余的内存。 想要避免这个问题，可以通过拷贝我们需要的部分到一个新的切片中。 ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:6:7","tags":["go学习笔记"],"title":"golang-学习笔记-数组与切片","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["Golang"],"content":"多维数组或切片初始化 可以直接在初始化语句里面初始化元素 1 dirs:=[][]int{{0,1},{1,0},{0,-1},{-1,0}} ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:7:0","tags":["go学习笔记"],"title":"golang-学习笔记-数组与切片","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["Golang"],"content":"深拷贝 博客园BeifangCc slice,map,channel都是浅拷贝。 深拷贝可以使用for循环复制或者使用copy，copy时需要注意被拷贝对象必须容量大于等于拷贝对象。 1 2 to:=make([]int,len(from)) copy(to,from) ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:8:0","tags":["go学习笔记"],"title":"golang-学习笔记-数组与切片","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["Golang"],"content":"数组相等比较 数组元素可以进行相等比较时，数组也可以进行相等比较，这在做算法题时很好用，因为map不支持相等比较 1 2 3 4 5 6 7 8 9 10 11 12 package main import \"fmt\" type kk struct { a, b int } func main() { a, b := [1]kk{kk{1, 2}}, [1]kk{kk{1, 2}} fmt.Println(a == b) } ","date":"2022-12-11","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/:9:0","tags":["go学习笔记"],"title":"golang-学习笔记-数组与切片","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"categories":["Golang"],"content":"go官方文档 go语言参考 在写过很多go代码之后，感觉自己并没有完全掌握go语言，还有很多知识盲区，所以有了这个go学习笔记系列，本系列是作者跟着电子书重新复习go语言相关内容的笔记 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/:0:0","tags":["go学习笔记"],"title":"golang-学习笔记-函数","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/"},{"categories":["Golang"],"content":"介绍 Go 里面有三种类型的函数 普通的带有名字的函数 匿名函数或者lambda函数 方法 Methods 如果需要申明一个在外部定义的函数，你只需要给出函数名与函数签名，不需要给出函数体： func flushICache(begin, end uintptr) // implemented externally 函数也可以以申明的方式被使用，作为一个函数类型，就像： type binOp func(int, int) int 函数是一等值（first-class value）：它们可以赋值给变量，就像 add := binOp 一样。 这个变量知道自己指向的函数的签名，所以给它赋一个具有不同签名的函数值是不可能的。 函数值（functions value）之间可以相互比较：如果它们引用的是相同的函数或者都是 nil 的话，则认为它们是相同的函数。 在函数中定义函数必须使用匿名函数 1 2 3 4 fn:=func () { ... fn() } CSDN 「已注销」 Go语言匿名函数的递归写法 如果要定义递归匿名函数： 1 2 3 4 5 6 7 var fn func() fn=func (){ ... fn() ... } ... ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/:1:0","tags":["go学习笔记"],"title":"golang-学习笔记-函数","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/"},{"categories":["Golang"],"content":"函数参数与返回值 可以返回一组值 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/:2:0","tags":["go学习笔记"],"title":"golang-学习笔记-函数","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/"},{"categories":["Golang"],"content":"按值传递（call by value） 按引用传递（call by reference） Go 默认使用按值传递来传递参数，也就是传递参数的副本。如果希望函数可以直接修改参数的值，而不是对参数的副本进行操作，需要将参数的地址（变量名前面添加\u0026符号，比如 \u0026variable）传递给函数，这就是按引用传递（译者注：指针也是变量类型，有自己的地址和值，通常指针的值指向一个变量的地址。所以，按引用传递也是按值传递。） 几乎在任何情况下，传递指针（一个32位或者64位的值）的消耗都比传递副本来得少。 切片（slice）、字典（map）、接口（interface）、通道（channel）这样的引用类型都是默认使用引用传递（即使没有显式的指出指针），应该是因为底层结构本来就是一个类似指针的结构。 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/:2:1","tags":["go学习笔记"],"title":"golang-学习笔记-函数","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/"},{"categories":["Golang"],"content":"命名的返回值（named return variables） 即使函数使用了命名返回值，你依旧可以无视它而返回明确的值。 尽量使用命名返回值：会使代码更清晰、更简短，同时更加容易读懂。 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/:2:2","tags":["go学习笔记"],"title":"golang-学习笔记-函数","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/"},{"categories":["Golang"],"content":"空白符（blank identifier） _空白符用来匹配一些不需要的值，然后丢弃掉 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/:2:3","tags":["go学习笔记"],"title":"golang-学习笔记-函数","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/"},{"categories":["Golang"],"content":"改变外部变量（outside variable） 指针解引用 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/:2:4","tags":["go学习笔记"],"title":"golang-学习笔记-函数","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/"},{"categories":["Golang"],"content":"传递变长参数 变长参数在函数里面就是一个切片 1 func myFunc(a, b, arg ...int) {} 如果参数被存储在一个数组 arr 中，则可以通过 arr… 的形式来传递参数调用变参函数。 1 2 arr := []int{7,9,3,5,1} x = min(arr...) 使用空接口可以接受任意类型 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/:3:0","tags":["go学习笔记"],"title":"golang-学习笔记-函数","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/"},{"categories":["Golang"],"content":"defer 和追踪 defer语句在函数返回之前（执行 return 语句之后）执行。 具有返回值x的函数return yy时会隐式执行x=yy。defer在其之后执行，并在返回值给调用者前执行 defer函数定义时会压栈，其接收的参数是值传递的，形参的值在压栈的时候已经确定，但是defer函数捕获的外部变量是以地址传递给函数的，即其值不是在定义的时候确定的而是在最后调用defer函数的时候确定的。所以，下面的代码会输出0 1 1 2 3 4 5 6 7 8 9 10 11 package main import \"fmt\" func main() { param, capture := 0, 0 defer func(p int) { fmt.Println(p,capture) }(param) param, capture = 1, 1 } 当有多个 defer 行为被注册时，它们会以逆序执行（类似栈，即后进先出） 关键字 defer 允许我们进行一些函数执行完成后的收尾工作，例如： 关闭文件流 1 2 // open a file defer file.Close() 解锁一个加锁的资源 1 2 mu.Lock() defer mu.Unlock() 打印最终报告 1 2 printHeader() defer printFooter() 关闭数据库链接 1 2 // open a database connection defer disconnectFromDB() 使用 defer 语句实现代码追踪 1 2 3 4 5 6 7 8 func trace(s string) { fmt.Println(\"entering:\", s) } func untrace(s string) { fmt.Println(\"leaving:\", s) } func a() { trace(\"a\") defer untrace(\"a\") fmt.Println(\"in a\") } 使用 defer 语句来记录函数的参数与命名返回值（可修改） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import ( \"io\" \"log\" ) func func1(s string) (n int, err error) { defer func() { log.Printf(\"func1(%q) = %d, %v\", s, n, err) }() return 7, io.EOF } func main() { func1(\"Go\") } ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/:4:0","tags":["go学习笔记"],"title":"golang-学习笔记-函数","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/"},{"categories":["Golang"],"content":"内置函数 见原文 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/:5:0","tags":["go学习笔记"],"title":"golang-学习笔记-函数","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/"},{"categories":["Golang"],"content":"递归函数 当一个函数在其函数体内调用自身，则称之为递归。 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/:6:0","tags":["go学习笔记"],"title":"golang-学习笔记-函数","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/"},{"categories":["Golang"],"content":"将函数作为参数 函数可以作为其它函数的参数进行传递，然后在其它函数内调用执行，一般称之为回调。 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/:7:0","tags":["go学习笔记"],"title":"golang-学习笔记-函数","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/"},{"categories":["Golang"],"content":"闭包 1 fn:=func(参数) 返回值 { 函数体 }。 应用闭包：将函数作为返回值 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/:8:0","tags":["go学习笔记"],"title":"golang-学习笔记-函数","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/"},{"categories":["Golang"],"content":"使用闭包调试 包 runtime 中的函数 Caller() 返回当前指向函数的信息，因此可以在需要的时候实现一个 where() 闭包函数来打印函数执行的位置： where := func() {\r_, file, line, _ := runtime.Caller(1)\rlog.Printf(\"%s:%d\", file, line)\r} ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/:9:0","tags":["go学习笔记"],"title":"golang-学习笔记-函数","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/"},{"categories":["Golang"],"content":"计算函数执行时间 使用 time 包中的 Now() 和 Sub 函数： start := time.Now()\rlongCalculation()\rend := time.Now()\rdelta := end.Sub(start)\rfmt.Printf(\"longCalculation took this amount of time: %s\\n\", delta) ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/:10:0","tags":["go学习笔记"],"title":"golang-学习笔记-函数","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/"},{"categories":["Golang"],"content":"通过内存缓存来提升性能 备忘录优化 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/:11:0","tags":["go学习笔记"],"title":"golang-学习笔记-函数","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/"},{"categories":["Golang"],"content":"go官方文档 go语言参考 在写过很多go代码之后，感觉自己并没有完全掌握go语言，还有很多知识盲区，所以有了这个go学习笔记系列，本系列是作者跟着电子书重新复习go语言相关内容的笔记 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/:0:0","tags":["go学习笔记"],"title":"golang-学习笔记-控制结构","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"},{"categories":["Golang"],"content":"if-else 结构 1 2 3 4 5 6 7 if condition1 { // do something } else if condition2 { // do something else }else { // catch-all or default } 1 2 3 if initialization; condition { // do something } ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/:1:0","tags":["go学习笔记"],"title":"golang-学习笔记-控制结构","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"},{"categories":["Golang"],"content":"switch 结构 1 2 3 4 5 6 7 8 switch var1 { case val1: ... case val2: ... default: ... } 不需要特别使用 break 语句来表示结束。 如果在执行完每个分支的代码后，还希望继续执行后续分支的代码，可以使用 fallthrough 关键字来达到目的。 当代码块只有一行时，可以直接放置在 case 语句之后 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/:2:0","tags":["go学习笔记"],"title":"golang-学习笔记-控制结构","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"},{"categories":["Golang"],"content":"for 结构 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/:3:0","tags":["go学习笔记"],"title":"golang-学习笔记-控制结构","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"},{"categories":["Golang"],"content":"基于计数器的迭代 1 for 初始化语句; 条件语句; 修饰语句 {} ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/:3:1","tags":["go学习笔记"],"title":"golang-学习笔记-控制结构","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"},{"categories":["Golang"],"content":"基于条件判断的迭代 1 for 条件语句 {}。 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/:3:2","tags":["go学习笔记"],"title":"golang-学习笔记-控制结构","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"},{"categories":["Golang"],"content":"无限循环 1 2 3 for { } for true { } ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/:3:3","tags":["go学习笔记"],"title":"golang-学习笔记-控制结构","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"},{"categories":["Golang"],"content":"for-range 结构 1 for ix, val := range coll { } coll会进行值拷贝然后遍历拷贝数组的索引ix和值val，所以下面的代码会输出不符合常理的结果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \"fmt\" func main() { arr := [3]int{1, 2, 3} for i, v := range arr { if i == 0 { arr[1] = 100 } fmt.Println(i, v) } } /*输出 0 1 1 2 2 3 而不是 0 1 1 100 2 3 */ 一种解决办法是对于数组使用切片重组来避免数组拷贝 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import \"fmt\" func main() { arr := [3]int{1, 2, 3} for i, v := range arr[:] { if i == 0 { arr[1] = 100 } fmt.Println(i, v) } } /*输出 0 1 1 100 2 3 */ val 始终为集合中对应索引的值拷贝，如果 val 为指针，则会产生指针的拷贝，依旧可以修改集合中的原值 一个字符串是 Unicode 编码的字符（或称之为 rune）（4字节）集合，字符串中对存储进行了优化常用英文字符使用 1 个字节表示，而汉字（译者注：严格来说，“Chinese: 日本語”的Chinese应该是Japanese）使用 3 个字符表示。因此您也可以用它迭代字符串，迭代的char为4字节： 1 2 3 for pos, char := range str { ... } ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/:3:4","tags":["go学习笔记"],"title":"golang-学习笔记-控制结构","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"},{"categories":["Golang"],"content":"Break 与 continue break跳出最近的循环，另外该指令能跳出switch或select代码块 continue跳过剩余的循环体，不是无条件执行下一次循环，执行之前依旧需要满足循环的判断条件 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/:4:0","tags":["go学习笔记"],"title":"golang-学习笔记-控制结构","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"},{"categories":["Golang"],"content":"标签与 goto 某一行第一个以冒号（:）结尾的单词 package main\rimport \"fmt\"\rfunc main() {\rLABEL1:\rfor i := 0; i \u003c= 5; i++ {\rfor j := 0; j \u003c= 5; j++ {\rif j == 4 {\rcontinue LABEL1\r}\rfmt.Printf(\"i is: %d, and j is: %d\\n\", i, j)\r}\r}\r} 特别注意 使用标签和 goto 语句是不被鼓励的 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/:5:0","tags":["go学习笔记"],"title":"golang-学习笔记-控制结构","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"},{"categories":["Golang"],"content":"go官方文档 go语言参考 在写过很多go代码之后，感觉自己并没有完全掌握go语言，还有很多知识盲区，所以有了这个go学习笔记系列，本系列是作者跟着电子书重新复习go语言相关内容的笔记 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:0:0","tags":["go学习笔记"],"title":"golang-学习笔记-基本概念","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Golang"],"content":"go程序基本结构和要素 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:1:0","tags":["go学习笔记"],"title":"golang-学习笔记-基本概念","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Golang"],"content":"包的概念、导入与可见性 go项目中每一个文件夹都是一个包包名为文件夹名。文件夹里面的.go文件都属于一个包。 标准库：go内置的库 go语言中文网 如果对一个包进行更改或重新编译，所有引用了这个包的客户端程序都必须全部重新编译。 每一段代码只会被编译一次 可见性规则：大写字幕开头的标识符可以被外部包使用 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:1:1","tags":["go学习笔记"],"title":"golang-学习笔记-基本概念","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Golang"],"content":"函数 1 func functionName() ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:1:2","tags":["go学习笔记"],"title":"golang-学习笔记-基本概念","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Golang"],"content":"注释 与C++一致//或者/* */ ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:1:3","tags":["go学习笔记"],"title":"golang-学习笔记-基本概念","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Golang"],"content":"类型 类型可以是基本类型，如：int、float、bool、string；结构化的（复合的），如：struct、array、slice、map、channel；只描述类型的行为的，如：interface。 结构化的类型没有真正的值，它使用 nil 作为默认值。 函数也可以是一个确定的类型。 type 关键字可以定义你自己的类型，详见下面的类型定义 强制类型转换 1 2 var a int=10 var b float64=float64(a) ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:1:4","tags":["go学习笔记"],"title":"golang-学习笔记-基本概念","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Golang"],"content":"Go 程序的一般结构 Go 程序的执行（程序启动）顺序如下： 按顺序导入所有被 main 包引用的其它包，然后在每个包中执行如下流程： 如果该包又导入了其它的包，则从第一步开始递归执行，但是每个包只会被导入一次。 然后以相反的顺序在每个包中初始化常量和变量，如果该包含有 init 函数的话，则调用该函数。 在完成这一切之后，main 也执行同样的过程，最后调用 main 函数开始执行程序。 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:1:5","tags":["go学习笔记"],"title":"golang-学习笔记-基本概念","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Golang"],"content":"类型转换 在必要以及可行的情况下，一个类型的值可以被转换成另一种类型的值。所有的转换都必须显式说明，就像调用一个函数一样（类型在这里的作用可以看作是一种函数）： 1 valueOfTypeB = typeB(valueOfTypeA) 具有相同底层类型的变量之间可以相互转换： ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:1:6","tags":["go学习笔记"],"title":"golang-学习笔记-基本概念","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Golang"],"content":"常量 const 定义:const Pi = 3.14159 常量的值必须是能够在编译时就能够确定的。 常量命名通常使用大驼峰命名 常量还可以用作枚举： 1 2 3 4 5 const ( Unknown = 0 Female = 1 Male = 2 ) iota 可以被用作枚举值： 1 2 3 4 5 const ( a = iota b = iota c = iota ) 第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a=0, b=1, c=2 可以简写为如下形式： 1 2 3 4 5 const ( a = iota b c ) iota 也可以用在表达式中1\u003c\u003ciota 在每遇到一个新的常量块或单个常量声明时， iota 都会重置为 0（ 简单地讲，每遇到一次 const 关键字，iota 就重置为 0 ）。 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:2:0","tags":["go学习笔记"],"title":"golang-学习笔记-基本概念","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Golang"],"content":"变量 var identifier type或者var identifier=value定义变量，var主要用于函数外包级别的全局变量，函数体内更推荐使用:=让编译器自己去推导变量类型 多个var也可以用括号进行简写 同一类型的多个变量可以声明在同一行 变量的命名规则遵循骆驼命名法 当变量a和变量b之间类型相同时，才能进行如a = b的赋值 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:3:0","tags":["go学习笔记"],"title":"golang-学习笔记-基本概念","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Golang"],"content":"值类型和引用类型 引用类型并不直接表示值内存，而是一小块指向值内存地址的内存，值类型直接指向值内存 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:3:1","tags":["go学习笔记"],"title":"golang-学习笔记-基本概念","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Golang"],"content":"打印 fmt包 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:3:2","tags":["go学习笔记"],"title":"golang-学习笔记-基本概念","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Golang"],"content":"使用 := 赋值操作符 只能被用在函数体内，而不可以用于全局变量的声明与赋值，不可以多次对于相同名称的变量使用初始化声明 多变量可以在同一行进行赋值，这被称为 并行 或 同时 赋值。 空白标识符 _ 被用于抛弃值，如值 5 在：_, b = 5, 7 中被抛弃。_ 实际上是一个只写变量，你不能得到它的值。 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:3:3","tags":["go学习笔记"],"title":"golang-学习笔记-基本概念","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Golang"],"content":"init 函数 变量除了可以在全局声明中初始化，也可以在 init 函数中初始化。这是一类非常特殊的函数，它不能够被人为调用，而是在每个包完成初始化后自动执行，并且执行优先级比 main 函数高。 每一个源文件都可以包含一个或多个 init 函数。初始化总是以单线程执行，并且按照包的依赖关系顺序执行。 一个可能的用途是在开始执行程序之前对数据进行检验或修复，以保证程序状态的正确性。 init 函数也经常被用在当一个程序开始之前调用后台执行的 goroutine，如下面这个例子当中的 backend()： 1 2 3 4 func init() { // setup preparations go backend() } ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:3:4","tags":["go学习笔记"],"title":"golang-学习笔记-基本概念","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Golang"],"content":"基本类型和运算符 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:4:0","tags":["go学习笔记"],"title":"golang-学习笔记-基本概念","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Golang"],"content":"布尔类型 bool 1 2 var b bool = true b:=true 可以使用相等 == 或者不等 != 运算符来进行比较并获得一个布尔型的值。 只有在两个的值的类型相同的情况下才可以使用。 如果值的类型是接口，它们也必须都实现了相同的接口。 布尔型的常量和变量也可以通过和逻辑运算符（非 !、和 \u0026\u0026、或 ||）结合来产生另外一个布尔值 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:4:1","tags":["go学习笔记"],"title":"golang-学习笔记-基本概念","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Golang"],"content":"数字类型 整型 int 和浮点型 float 格式化说明符 数字值转换:当进行类似 a32bitInt = int32(a32Float) 的转换时，小数点后的数字将被丢弃。 复数 Go 拥有以下复数类型： complex64 (32 位实数和虚数) complex128 (64 位实数和虚数) 复数使用 re+imI 来表示，其中 re 代表实数部分，im 代表虚数部分，I 代表根号负 1。 1 2 3 var c1 complex64 = 5 + 10i fmt.Printf(\"The value is: %v\", c1) // 输出： 5 + 10i 如果 re 和 im 的类型均为 float32，那么类型为 complex64 的复数 c 可以通过以下方式来获得： 1 c = complex(re, im) 函数 real(c) 和 imag(c) 可以分别获得相应的实数和虚数部分。 位运算 二元运算符: 按位与 \u0026： 按位或 |： 按位异或 ^： 位清除 \u0026^：a \u0026^ b 的效果近似于 a \u0026 (^b)将b中为1的位置的位在a中置零 一元运算符： 按位补足 ^： 位左移 «： 位右移 »： 位左移常见实现存储单位的用例，使用位左移与 iota 计数配合可优雅地实现存储单位的常量枚举： 1 2 3 4 5 6 7 8 9 10 11 12 type ByteSize float64 const ( _ = iota // 通过赋值给空白标识符来忽略值 KB ByteSize = 1\u003c\u003c(10*iota) MB GB TB PB EB ZB YB ) 逻辑运算符 Go 中拥有以下逻辑运算符：==、!=、\u003c、\u003c=、\u003e、\u003e=。 算术运算符 整数和浮点数的二元运算符有 +、-、* 和 / Go 在进行字符串拼接时允许使用对运算符 + 的重载，但 Go 本身不允许开发者进行自定义的运算符重载 / 对于整数运算而言，结果依旧为整数 取余运算符只能作用于整数 整数除以 0 可能导致程序崩溃，将会导致运行时的恐慌状态 浮点数除以 0.0 会返回一个无穷尽的结果，使用 +Inf 表示。 随机数 函数 rand.Float32() 和 rand.Float64() 返回介于 [0.0, 1.0) 之间的伪随机数，其中包括 0.0 但不包括 1.0。函数 rand.Intn(n int) 返回介于 [0, n) 之间的伪随机数。 使用 Seed(value) 函数来提供伪随机数的生成种子，一般情况下都会使用当前时间的纳秒级数字。 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:4:2","tags":["go学习笔记"],"title":"golang-学习笔记-基本概念","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Golang"],"content":"运算符与优先级 优先级 运算符 7 ^ ! 6 * / % « » \u0026 \u0026^ 5 + - | ^ 4 == != \u003c \u003c= \u003e= \u003e 3 \u003c- 2 \u0026\u0026 1 || ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:4:3","tags":["go学习笔记"],"title":"golang-学习笔记-基本概念","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Golang"],"content":"类型别名 type实现类型定义和类型别名 1 2 3 4 5 //类型定义 type B A //类型别名 type B=A 定义的类型不具有原类型的方法，但具有相同的底层结构，所以可以相互转换，但是必须进行显式转换 1 2 b:=B{} var a A=A(b) 类型别名则表示两个类型具有相同的方法和相同的底层结构，甚至你在B定义的新方法也是A的新方法，a的实例对象可以直接调用 1 2 3 4 5 6 7 8 9 10 11 12 type A struct{} type B = A func (receiver B) b() { fmt.Println(\"b被调用\") } func main() { i := A{} i.b() } ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:4:4","tags":["go学习笔记"],"title":"golang-学习笔记-基本概念","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Golang"],"content":"字符类型 'x'为字符字面量，字符字面量可以对byte和rune进行赋值 byte 类型是 uint8 的类型定义，表示只占用 1 字节的传统 ASCII 编码的字符。可以用'括起来的ascii字符或者数字赋值 Go 默认 Unicode（UTF-8）编码，字符为 Unicode 代码点或者 runes，并在内存中使用 int 来表示。rune 是 是 int32 的类型定义。 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:4:5","tags":["go学习笔记"],"title":"golang-学习笔记-基本概念","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Golang"],"content":"字符串 字符串是 UTF-8 字符的一个序列（当字符为 ASCII 码时则占用 1 个字节，其它字符根据需要占用 2-4 个字节）。 字符串是一种值类型，且值不可变。 Go 支持以下 2 种形式的字面值： 解释字符串：使用双引号\"括起来，其中的相关的转义字符将被替换，这些转义字符包括：\\n：换行符，\\r：回车符，\\t：tab 键，\\u 或 \\U：Unicode 字符，\\\\：反斜杠自身 非解释字符串：该类字符串使用反引号`括起来，支持换行，例如： `This is a raw string \\n` 中的 `\\n\\` 会被原样输出。 和 C/C++不一样，Go 中的字符串是根据长度限定，而非特殊字符\\0。 string 类型的零值为长度为零的字符串，即空字符串 \"\" 一般的比较运算符（==、!=、\u003c、\u003c=、\u003e=、\u003e）通过在内存中按字节比较来实现字符串的对比。你可以通过函数 len() 来获取字符串所占的字节长度，例如：len(str)。 字符串的内容（纯字节）可以通过标准索引法来获取，在中括号 [] 内写入索引，索引从 0 开始计数： 字符串 str 的第 1 个字节：str[0] 第 i 个字节：str[i - 1] 最后 1 个字节：str[len(str)-1] 这种转换方案只对纯 ASCII 码的字符串有效，对于具有非ascii字符(如中文)的字符串使用for range遍历，每次遍历一个rune。 获取字符串中某个字节的地址的行为是非法的，例如：\u0026str[i] 字符串拼接符 + 可以通过以下方式来对代码中多行的字符串进行拼接： 1 2 str := \"Beginning of the string \" + \"second part of the string\" 由于编译器行尾自动补全分号的缘故，加号 + 必须放在第一行末尾 拼接的简写形式 += 也可以用于字符串： 在循环中使用加号 + 拼接字符串并不是最高效的做法，更好的办法是使用函数 strings.Join()，有没有更好地办法了？有！使用bytes.Buffer拼接更加给力 CSDN 机器铃砍菜刀 string和[]byte转换 字符串字面量可以转换成各种类型的切片比如： 1 2 []byte(\"你好\") []rune(\"你好\") []rune， []bytes， string可以直接使用强制类型转换，这样的转换是副本 字符串转换成[]rune的好处是通过下标访问时返回rune字符，这样可以直接用unicode包的字符 如果你要多次对字符串中的字符取rune格式且不是按顺序取（顺序取可以用for range），那么你最好是把string直接转换为[]rune再访问： 1 2 s:=\"hello world\" rs:=[]rune(s) ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:5:0","tags":["go学习笔记"],"title":"golang-学习笔记-基本概念","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Golang"],"content":"给字符串追加一个字符 主函数编程网 使用string()强制转换字符为字符串然后直接+连接 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:5:1","tags":["go学习笔记"],"title":"golang-学习笔记-基本概念","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Golang"],"content":"指针 取地址符和反向引用符号与C++一致，但是不支持指针运算 一个指针变量可以指向任何一个值的内存地址 它指向那个值的内存地址，在 32 位机器上占用 4 个字节，在 64 位机器上占用 8 个字节，并且与它所指向的值的大小无关。 你不能得到一个文字或常量的地址 空指针的反向引用会使程序崩溃 获取的地址属于逻辑地址 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:6:0","tags":["go学习笔记"],"title":"golang-学习笔记-基本概念","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["Golang"],"content":"go官方文档 go语言参考 在写过很多go代码之后，感觉自己并没有完全掌握go语言，还有很多知识盲区，所以有了这个go学习笔记系列，本系列是作者跟着电子书重新复习go语言相关内容的笔记 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/go%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86/:0:0","tags":["go学习笔记"],"title":"golang-学习笔记-Go背景知识","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/go%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86/"},{"categories":["Golang"],"content":"语言的特性 Go 语言从本质上（程序和结构方面）来实现并发编程。 Go 语言没有类和继承的概念通过接口（interface）的概念来实现多态性。 函数是 Go 语言中的基本构件，它们的使用方法非常灵活。 Go 语言使用静态类型，隐式的类型转换是不被允许的 Go 语言其实也有一些动态语言的特性（通过关键字 var） Go 语言支持交叉编译 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/go%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86/:1:0","tags":["go学习笔记"],"title":"golang-学习笔记-Go背景知识","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/go%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86/"},{"categories":["Golang"],"content":"Go 环境变量 go env命令查看 几个重要的环境变量： $GOROOT 表示 Go 在你的电脑上的安装位置 $GOARCH 表示目标机器的处理器架构 $GOOS 表示目标机器的操作系统 $GOBIN 表示编译器和链接器的安装位置 go env -w xxx=xxx设置环境变量 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/go%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86/:2:0","tags":["go学习笔记"],"title":"golang-学习笔记-Go背景知识","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/go%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86/"},{"categories":["Golang"],"content":"在 Linux 上安装 Go 设置 Go 环境变量 新版本使用go mod管理包，可以不用在每个项目设置gopath 1 2 3 export GOROOT=$HOME/go export PATH=$PATH:$GOROOT/bin export GOPATH=$HOME/Applications/Go 安装 C 工具 1 sudo apt-get install bison ed gawk gcc libc6-dev make 获取 Go 源代码 1 2 3 wget https://storage.googleapis.com/golang/go\u003cVERSION\u003e.src.tar.gz tar -zxvf go\u003cVERSION\u003e.src.tar.gz sudo mv go $GOROOT 构建 Go 1 2 cd $GOROOT/src ./all.bash 测试安装 helloworld 6. 验证安装版本 go version 7. 更新版本 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/go%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86/:3:0","tags":["go学习笔记"],"title":"golang-学习笔记-Go背景知识","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/go%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86/"},{"categories":["Golang"],"content":"调试器 fmt包打印信息 %+v 打印包括字段在内的实例的完整信息 %#v 打印包括字段和限定类型名称在内的实例的完整信息 %T 打印某个类型的完整说明 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/go%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86/:4:0","tags":["go学习笔记"],"title":"golang-学习笔记-Go背景知识","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/go%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86/"},{"categories":["Golang"],"content":"构建并运行 Go 程序 go build 编译并安装自身包和依赖包 go install 安装自身包和依赖包 ","date":"2022-12-10","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/go%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86/:5:0","tags":["go学习笔记"],"title":"golang-学习笔记-Go背景知识","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/go%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86/"},{"categories":["数据库"],"content":"本系列笔记为作者在跟随小林coding学习的时候做的笔记。感谢小林大大。 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E9%94%81%E7%AF%87/:0:0","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-锁篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E9%94%81%E7%AF%87/"},{"categories":["数据库"],"content":"MySQL 有哪些锁 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E9%94%81%E7%AF%87/:1:0","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-锁篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E9%94%81%E7%AF%87/"},{"categories":["数据库"],"content":"全局锁 开启全局锁 1 flush tables with read lock 整个数据库就处于只读状态了 释放全局锁 unlock tables 当会话断开了，全局锁也会被自动释放。 全局锁用于全库逻辑备份 全局锁会暂停业务，可以使用可重复读的隔离级别在备份数据库之前开启事务进行备份。 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E9%94%81%E7%AF%87/:1:1","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-锁篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E9%94%81%E7%AF%87/"},{"categories":["数据库"],"content":"表级锁 表锁 1 2 3 4 5 //表级别的共享锁，也就是读锁； lock tables t_student read; //表级别的独占锁，也就是写锁； lock tables t_stuent write; 要释放表锁，可以使用下面这条命令，会释放当前会话的所有表锁： unlock tables 另外，当会话退出后，也会释放所有表锁。 不过尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能，InnoDB 牛逼的地方在于实现了颗粒度更细的行级锁。 元数据锁（MDL） 我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL： 对一张表进行 CRUD 操作时，加的是 MDL 读锁； 对一张表做结构变更操作的时候，加的是 MDL 写锁； MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。 MDL 是在事务提交后才会释放，这意味着事务执行期间，MDL 是一直持有的。 长事务的MDL可能会对性能造成影响，还可能会导致数据库线程耗尽，例子见原文 意向锁 对记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」； 对记录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」； 意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，意向锁之间也不会发生冲突，只会和共享表锁（lock tables … read）和独占表锁（lock tables … write）发生冲突。 意向锁的目的是为了快速判断表里是否有记录被加锁 AUTO-INC 锁 执行完插入语句后就会立即释放AUTO-INC锁。 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种轻量级的锁来实现自增。在插入数据的时候，会为被 AUTO_INCREMENT 修饰的字段加上轻量级锁，然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁。 InnoDB 存储引擎提供了个 innodb_autoinc_lock_mode 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。 当 innodb_autoinc_lock_mode = 0，就采用 AUTO-INC 锁，语句执行结束后才释放锁； 当 innodb_autoinc_lock_mode = 2，就采用轻量级锁，申请自增主键后就释放锁，并不需要等语句执行后才释放。 当 innodb_autoinc_lock_mode = 1： 普通 insert 语句，自增锁在申请之后就马上释放； 类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放； 当 innodb_autoinc_lock_mode = 2 是性能最高的方式，但是当搭配 binlog 的日志格式是 statement 一起使用的时候，在「主从复制的场景」中会发生数据不一致的问题，例子见原文。 当 innodb_autoinc_lock_mode = 2 时，并且 binlog_format = row，既能提升并发性，又不会出现数据一致性问题。 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E9%94%81%E7%AF%87/:1:2","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-锁篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E9%94%81%E7%AF%87/"},{"categories":["数据库"],"content":"行级锁 普通的 select 语句是不会对记录加锁的，因为它属于快照读。如果要在查询时对记录加行锁，可以使用下面这两个方式，这种查询会加锁的语句称为锁定读。 //对读取的记录加共享锁\rselect ... lock in share mode;\r//对读取的记录加独占锁\rselect ... for update; 这两条语句必须在一个事务中，当事务提交了，锁就会被释放 行级锁的类型主要有三类： Record Lock，记录锁，也就是仅仅把一条记录锁上； Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身； Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。 Record Lock Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的 Gap Lock Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。 间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的。 Next-Key Lock Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。 next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的。 插入意向锁 一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。 如果有的话，插入操作就会发生阻塞，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个插入意向锁，表明有事务想在某个区间插入新记录，但是现在处于等待状态。例子见原文 插入意向锁名字虽然有意向锁，但是它并不是意向锁，它是一种特殊的间隙锁，属于行级别锁。如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E9%94%81%E7%AF%87/:1:3","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-锁篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E9%94%81%E7%AF%87/"},{"categories":["数据库"],"content":"本系列笔记为作者在跟随小林coding学习的时候做的笔记。感谢小林大大。 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E4%BA%8B%E5%8A%A1%E7%AF%87/:0:0","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-事务篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E4%BA%8B%E5%8A%A1%E7%AF%87/"},{"categories":["数据库"],"content":"事务隔离级别是怎么实现的 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E4%BA%8B%E5%8A%A1%E7%AF%87/:1:0","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-事务篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E4%BA%8B%E5%8A%A1%E7%AF%87/"},{"categories":["数据库"],"content":"事务有哪些特性 ACID 原子性（Atomicity）：一个事务中的所有操作，要么全部完成，要么全部不完成。undo log（回滚日志）保证 一致性（Consistency）：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。通过持久性+原子性+隔离性来保证 隔离性（Isolation）：数据库允许多个并发事务同时对其数据进行读写和修改的能力。通过 MVCC（多版本并发控制） 或锁机制来保证的 持久性（Durability）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。redo log （重做日志）保证 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E4%BA%8B%E5%8A%A1%E7%AF%87/:1:1","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-事务篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E4%BA%8B%E5%8A%A1%E7%AF%87/"},{"categories":["数据库"],"content":"并行事务会引发什么问题 脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read） 脏读：一个事务「读到」了另一个「未提交事务修改过的数据」 不可重复读：在一个事务内多次读取同一个数据，出现前后两次读到的数据不一样的情况，重在数值。 幻读：在一个事务内多次查询某个符合查询条件的「记录数量」，出现前后两次查询到的记录数量不一样的情况，重在数量。 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E4%BA%8B%E5%8A%A1%E7%AF%87/:1:2","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-事务篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E4%BA%8B%E5%8A%A1%E7%AF%87/"},{"categories":["数据库"],"content":"事务的隔离级别有哪些 并发问题严重性排序 读未提交（read uncommitted），事务还没提交时，它做的变更就能被其他事务看到； 读提交（read committed），事务提交之后，它做的变更才能被其他事务看到； 可重复读（repeatable read），事务执行过程中看到的数据，跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别； 串行化（serializable ）；对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行； 按隔离水平高低排序 针对不同的隔离级别，并发事务时可能发生的现象也会不同 MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了，详见这篇文章） 针对快照读（普通 select 语句），通过 MVCC 方式解决了幻读。 针对当前读（select … for update 等语句），是通过 next-key lock（临界锁=记录锁+间隙锁）方式解决了幻读。 四种隔离级别具体是如何实现 「读未提交」：直接读取最新的数据就好了 「读提交」和「可重复读」：通过 Read View 来实现的，区别在于创建 Read View 的时机不同，「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View 「串行化」：加读写锁的方式来避免并行访问 注意，执行「开始事务」命令，并不意味着启动了事务。在 MySQL 有两种开启事务的命令，分别是： begin/start transaction：需要执行增删改查命令才开始事务 start transaction with consistent snapshot 命令：直接开启事务 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E4%BA%8B%E5%8A%A1%E7%AF%87/:1:3","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-事务篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E4%BA%8B%E5%8A%A1%E7%AF%87/"},{"categories":["数据库"],"content":"Read View 在 MVCC 里如何工作的 InnoDB 存储引擎的数据库表的聚簇索引记录中包含下面两个隐藏列： trx_id，上一次改变该记录的事务id roll_pointer，undolog中上一次改变之前的记录 在创建 Read View 后，我们可以将记录中的 trx_id 划分这三种情况： 一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况，不可见时查询上一个版本： 记录的 trx_id \u003c Read View 中的 min_trx_id，可见。 记录的 trx_id \u003e Read View 中的 max_trx_id，不可见。 记录的 trx_id 值在 Read View 的 min_trx_id 和 max_trx_id 之间： 记录的 trx_id 在 m_ids 列表中，不可见。 记录的 trx_id 不在 m_ids列表中，可见。 这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制） ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E4%BA%8B%E5%8A%A1%E7%AF%87/:1:4","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-事务篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E4%BA%8B%E5%8A%A1%E7%AF%87/"},{"categories":["数据库"],"content":"可重复读是如何工作的 可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View。 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E4%BA%8B%E5%8A%A1%E7%AF%87/:1:5","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-事务篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E4%BA%8B%E5%8A%A1%E7%AF%87/"},{"categories":["数据库"],"content":"读提交是如何工作的 读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View。 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E4%BA%8B%E5%8A%A1%E7%AF%87/:1:6","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-事务篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E4%BA%8B%E5%8A%A1%E7%AF%87/"},{"categories":["数据库"],"content":"MySQL 可重复读隔离级别，完全解决幻读了吗 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E4%BA%8B%E5%8A%A1%E7%AF%87/:2:0","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-事务篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E4%BA%8B%E5%8A%A1%E7%AF%87/"},{"categories":["数据库"],"content":"快照读是如何避免幻读的 MVCC（多版本并发控制） ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E4%BA%8B%E5%8A%A1%E7%AF%87/:2:1","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-事务篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E4%BA%8B%E5%8A%A1%E7%AF%87/"},{"categories":["数据库"],"content":"当前读是如何避免幻读的 MySQL 里除了普通查询是快照读，其他都是当前读，比如 update、insert、delete next-key lock。 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E4%BA%8B%E5%8A%A1%E7%AF%87/:2:2","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-事务篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E4%BA%8B%E5%8A%A1%E7%AF%87/"},{"categories":["数据库"],"content":"幻读被完全解决了吗 可重复读隔离级别下虽然很大程度上避免了幻读，但是还是没有能完全解决幻读。 场景：A进行快照读-\u003eB插入记录-\u003eA当前读插入的数据 要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select … for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E4%BA%8B%E5%8A%A1%E7%AF%87/:2:3","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-事务篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E4%BA%8B%E5%8A%A1%E7%AF%87/"},{"categories":["数据库"],"content":"本系列笔记为作者在跟随小林coding学习的时候做的笔记。感谢小林大大。 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E7%B4%A2%E5%BC%95%E7%AF%87/:0:0","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-索引篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E7%B4%A2%E5%BC%95%E7%AF%87/"},{"categories":["数据库"],"content":"索引常见面试题 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E7%B4%A2%E5%BC%95%E7%AF%87/:1:0","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-索引篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E7%B4%A2%E5%BC%95%E7%AF%87/"},{"categories":["数据库"],"content":"什么是索引 索引是数据的目录，位于存储引擎中 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E7%B4%A2%E5%BC%95%E7%AF%87/:1:1","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-索引篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E7%B4%A2%E5%BC%95%E7%AF%87/"},{"categories":["数据库"],"content":"索引的分类 按「数据结构」分类：B+tree索引、Hash索引、Full-text索引。 按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。 按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。 按「字段个数」分类：单列索引、联合索引。 按数据结构分类 创建的聚簇索引和二级索引默认使用的是 B+Tree 索引： 即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4次。 支持范围查询 通过二级索引查询到主键后使用查到的主键查询聚簇索引的过程叫「回表」，也就是说要查两个 B+Tree 才能查到数据 覆盖索引：当查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到时就不用再查主键索引，也就是只需要查一个 B+Tree 就能找到数据。 按物理存储分类 聚簇索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里； 二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。 按字段特性分类 主键索引 建立在主键字段上的索引，一张表最多只有一个主键索引，索引列的值不允许有空值。 唯一索引 建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。 普通索引 建立在普通字段上的索引 前缀索引 对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。 按字段个数分类 建立在单列上的索引称为单列索引，比如主键索引； 建立在多列上的索引称为联合索引； 使用联合索引时，存在最左匹配原则，不一定每个索引字段都会用到 范围查询（如 \u003e、\u003c）会停止匹配，\u003e=、\u003c=、BETWEEN、like 可以继续匹配，即得有等值判断才能继续匹配 索引下推：innodb默认只判断一个条件，如果有联合索引且另一个条件为联合索引最左匹配的下一个字段的等值条件，总结一下就是server层的判断下推到db引擎对联合索引的判断。 当查询语句的执行计划里，出现了 Extra 为 Using index condition，那么说明使用了索引下推的优化。 索引区分度：区分度就是某个字段 column 不同值的个数「除以」表的总行数。建立联合索引把区分度大的字段排在前面。 对于排序order by语句可以将排序字段和条件字段创建一个联合索引 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E7%B4%A2%E5%BC%95%E7%AF%87/:1:2","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-索引篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E7%B4%A2%E5%BC%95%E7%AF%87/"},{"categories":["数据库"],"content":"什么时候需要 / 不需要创建索引 索引的缺点 占用空间； 增删改操作维护索引时间开销大； 什么时候适用索引 唯一性限制的字段； 经常用于 WHERE 查询条件的字段，多个字段用联合索引。 经常用于 GROUP BY 和 ORDER BY 的字段，多个字段用联合索引。 什么时候不需要创建索引 WHERE 条件，GROUP BY，ORDER BY 里用不到的字段。 字段中存在大量重复数据，比如性别字段。查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。 表数据太少的时候； 经常更新的字段。 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E7%B4%A2%E5%BC%95%E7%AF%87/:1:3","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-索引篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E7%B4%A2%E5%BC%95%E7%AF%87/"},{"categories":["数据库"],"content":"有什么优化索引的方法 前缀索引优化；字段中字符串的前几个字符建立索引 覆盖索引优化；将查询和查到的字段都建立为联合索引 主键索引最好是自增的 索引设置为 NOT NULL 防止索引失效：索引失效见下文，执行计划详见基础篇 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E7%B4%A2%E5%BC%95%E7%AF%87/:1:4","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-索引篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E7%B4%A2%E5%BC%95%E7%AF%87/"},{"categories":["数据库"],"content":"从数据页的角度看 B+ 树 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E7%B4%A2%E5%BC%95%E7%AF%87/:2:0","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-索引篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E7%B4%A2%E5%BC%95%E7%AF%87/"},{"categories":["数据库"],"content":"InnoDB 是如何存储数据的 数据页物理结构\r数据页逻辑结构\r链表结构\rB+树\r第一个分组中的记录只能有 1 条记录； 最后一个分组中的记录条数范围只能在 1-8 条之间； 剩下的分组中记录条数范围只能在 4-8 条之间。 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E7%B4%A2%E5%BC%95%E7%AF%87/:2:1","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-索引篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E7%B4%A2%E5%BC%95%E7%AF%87/"},{"categories":["数据库"],"content":"B+ 树是如何进行查询的 和搜索树一样 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E7%B4%A2%E5%BC%95%E7%AF%87/:2:2","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-索引篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E7%B4%A2%E5%BC%95%E7%AF%87/"},{"categories":["数据库"],"content":"聚簇索引和二级索引 如果有主键，默认会使用主键作为聚簇索引的索引键； 如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键； 在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键； ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E7%B4%A2%E5%BC%95%E7%AF%87/:2:3","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-索引篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E7%B4%A2%E5%BC%95%E7%AF%87/"},{"categories":["数据库"],"content":"MySQL 单表不要超过 2000W 行 见原文 x为一页能放下的页号数（最大是x叉树），y为一页能放下的记录数，z为树高，total为全部记录数量 total=x^(z-1)*y 页大小为16kb，算15kb存数据，页号大小为12byte（主键8byte，页号4byte（地址）），那么x=15*1024/12≈1280 记录大小算1kb，那么y为15，z=2时total=19200，z=3时total=2.45kw 所以主要原因就是超过2000W行（小林大大算出来是2.45kw）后，B+树会变成4层，增加的查询的时间算小头，大头是由于索引树太庞大，内存无法一次全部装入会缺页中断导致的磁盘IO的开销。 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E7%B4%A2%E5%BC%95%E7%AF%87/:3:0","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-索引篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E7%B4%A2%E5%BC%95%E7%AF%87/"},{"categories":["数据库"],"content":"索引失效有哪些 对索引使用左或者左右模糊匹配(%) 对索引进行了运算或使用了函数 联合索引非最左匹配 索引条件 OR 其他条件 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E7%B4%A2%E5%BC%95%E7%AF%87/:4:0","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-索引篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E7%B4%A2%E5%BC%95%E7%AF%87/"},{"categories":["数据库"],"content":"MySQL 使用 like “%x“，索引一定会失效吗？ 对于可以使用覆盖索引的情况，会直接查二级索引树，由于叶子节点更小遍历速度比直接查询主键索引更快 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E7%B4%A2%E5%BC%95%E7%AF%87/:5:0","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-索引篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E7%B4%A2%E5%BC%95%E7%AF%87/"},{"categories":["数据库"],"content":"count(*) 和 count(1) 有什么区别？哪个性能最好 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E7%B4%A2%E5%BC%95%E7%AF%87/:6:0","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-索引篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E7%B4%A2%E5%BC%95%E7%AF%87/"},{"categories":["数据库"],"content":"如何优化 count(*) 第一种，近似值 执行 explain 命令效率是很高的，因为它并不会真正的去查询，下图中的 rows 字段值就是 explain 命令对表 t_order 记录的估算值。 第二种，额外表保存计数值 当我们在数据表插入一条记录的同时，将计数表中的计数字段 + 1。也就是说，在新增和删除操作时，我们需要额外维护这个计数表。 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E7%B4%A2%E5%BC%95%E7%AF%87/:6:1","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-索引篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E7%B4%A2%E5%BC%95%E7%AF%87/"},{"categories":["数据库"],"content":"MySQL 自增主键不连续情况 微信文章原文 auto_increment_offset自增初始值和auto_increment_increment自增步长设置不为 1 唯一键冲突，+1后不减回 事务回滚，不回滚自增值 批量插入（如 insert…select 语句），多轮插入，第一轮使用1个id，后面每一轮id数是前一轮的两倍，多用了不减回 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E7%B4%A2%E5%BC%95%E7%AF%87/:7:0","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-索引篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E7%B4%A2%E5%BC%95%E7%AF%87/"},{"categories":["数据库"],"content":"本系列笔记为作者在跟随小林coding学习的时候做的笔记。感谢小林大大。 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/:0:0","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-基础篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["数据库"],"content":"MySQL 执行流程 分为server层和存储引擎层 Server 层负责建立连接、分析和执行 SQL。 存储引擎层负责数据的存储和提取 流程： ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/:1:0","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-基础篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["数据库"],"content":"1. 连接器 连接数据库，MySQL 是基于 TCP 协议进行传输（TCP 三次握手） 1 2 3 4 # -h 指定 MySQL 服务得 IP 地址，如果是连接本地的 MySQL服务，可以不用这个参数； # -u 指定用户名，管理员角色名为 root； # -p 指定密码，如果命令行中不填写密码（为了密码安全，建议不要在命令行写密码），就需要在交互对话里面输入密码 mysql -h $ip -u $user -p 验证用户名和密码，并读取权限，管理员修改的权限对已连接用户不起作用，权限只能应用于该用户下一次连接。 查看 MySQL 服务被多少个客户端连接: 1 show processlist 空闲连接 wait_timeout变量控制空闲连接最大时间 1 show variables like 'wait_timeout'; 手动断开空闲连接kill connection + id 1 kill connection +6; 连接数限制 最大连接数由 max_connections 参数控制 MySQL 的连接也跟 HTTP 一样，有短连接和长连接的概念， 长连接占用内存问题 定期断开长连接或者客户端主动重置连接 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/:1:1","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-基础篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["数据库"],"content":"2. 查询缓存 MySQL 8.0 版本直接将查询缓存删掉了，也就是说 MySQL 8.0 开始，执行一条 SQL 查询语句，不会再走到查询缓存这个阶段了。 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/:1:2","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-基础篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["数据库"],"content":"3. 解析 SQL 由解析器完成 词法分析，语法分析 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/:1:3","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-基础篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["数据库"],"content":"4. 执行 SQL 每条SELECT 查询语句流程主要可以分为下面这三个阶段：prepare 预处理阶段；optimize 优化阶段；execute 执行阶段； 预处理 检查语句中的表或者字段是否存在 将 select * 中的 * 符号，扩展为表上的所有列 优化 将 SQL 查询语句的执行方案确定下来 explain 命令会输出这SQL 语句的执行计划 CSDN AllenGd 执行计划中： possible_key是可以选择的索引； key指的是使用的索引，null值表示不使用索引； Extra表示额外信息，using index表示覆盖索引，using index condition表示用到了索引下推优化，Using filesort表示文件排序效率很低，Using temporary表示使用临时表保存中间结果 rows是循环的次数，可以用于估计查询结果的记录数； type表示数据扫描类型：All（全表扫描）；index（全索引扫描）；range（索引范围扫描）；ref（非唯一索引扫描）；eq_ref（唯一索引扫描）；const（结果只有一条的主键或唯一索引扫描），效率一次递增； key_len是使用的索引的长度，可以用于判断联合索引使用的字段数 执行器 执行器和存储引擎都是一个记录一个记录地进行查询。 存储引擎给执行器发送的记录会在执行器中再检查是否符合条件然后发送给客户端（Server 层每从存储引擎读到一条记录就会发送给客户端，客户端会等查询语句查询完成后显示出所有的记录）。 二级索引B+树定位符合条件的主键后使用主键去主键索引查询完整记录的过程叫回表。 索引下推：减少二级索引（辅助索引）的回表操作，将 Server 层部分负责的事情，交给存储引擎层去处理。联合索引可以过滤的记录就不回表了。执行计划里的 Extr 部分显示了 “Using index condition”，说明使用了索引下推。 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/:1:4","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-基础篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["数据库"],"content":"MySQL 一行记录是怎么存储的 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/:2:0","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-基础篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["数据库"],"content":"MySQL 的数据存放在哪个文件 db.opt：存储当前数据库的默认字符集和字符校验规则 表名字.frm：表结构 表名字.ibd：表数据 表空间由段（segment）、区（extent）、页（page）、行（row）组成 行（row）：记录 页（page）：InnoDB 的数据是按「页」为单位来读写的。默认每个页的大小为 16KB。 区（extent）：在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了。 段（segment）：表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。索引段：存放 B + 树的非叶子节点的区的集合；数据段：存放 B + 树的叶子节点的区的集合；回滚段：存放的是回滚数据的区的集合，之前讲事务隔离 (opens new window)的时候就介绍到了多版本并发控制（MVCC）利用了回滚段实现了多版本查询数据。 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/:2:1","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-基础篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["数据库"],"content":"InnoDB 行格式有哪些 InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。 Redundant 是很古老的行格式了， MySQL 5.0 版本之前用的行格式，现在基本没人用了。 Compact 是一种紧凑的行格式，设计的初衷就是为了让一个数据页中可以存放更多的行记录，从 MySQL 5.1 版本之后，行格式默认设置成 Compact。 Dynamic 和 Compressed 两个都是紧凑的行格式，它们的行格式都和 Compact 差不多，因为都是基于 Compact 改进一点东西。从 MySQL5.7 版本之后，默认使用 Dynamic 行格式。 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/:2:2","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-基础篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["数据库"],"content":"COMPACT 行格式 额外信息 变长字段长度列表： varchar， 顺序和后面的真是信息顺序相反，即逆序存放，因为指向记录的指针指的是记录头信息和真实数据直接的位置，向左就是记录头信息向右就是真实数据，使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率，同样的道理， NULL 值列表的信息也需要逆序存放。 另外NULL 是不会存放在行格式中记录的真实数据部分里的，所以这里不会存放值为null的变长字段（在NULL 值列表中标记）。 当数据表没有变长字段的时候，比如全部都是 int 类型的字段，这时候表里的行格式就不会有「变长字段长度列表」了 NULL 值列表 如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。 值为1时，代表该列的值为NULL。 值为0时，代表该列的值不为NULL。 当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了。 「NULL 值列表」的空间不是固定 1 字节的。当一条记录有 9 个字段值都是 NULL，那么就会创建 2 字节空间的「NULL 值列表」，以此类推。 记录头信息 记录头信息中包含的内容很多，说几个比较重要的： delete_mask ：标识此条数据是否被删除。 next_record：下一条记录的位置。记录与记录之间是通过链表组织的。指向的是下一条记录的「记录头信息」和「真实数据」之间的位置。 record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录。 真实数据 记录真实数据部分除了定义的字段，还有三个隐藏字段，分别为：row_id、trx_id、roll_pointer row_id：如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id不是必需的，占用 6 个字节。 trx_id：事务id，表示这个数据是由哪个事务生成的。 trx_id是必需的，占用 6 个字节。 roll_pointer：这条记录上一个版本的指针。roll_pointer 是必需的，占用 7 个字节。 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/:2:3","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-基础篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["数据库"],"content":"varchar(n) 中 n 最大取值为多少 MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节。 单字段的情况 一行数据的最大字节数是 65535（不包含 TEXT、BLOBs 这种大对象类型），其中包含了 storage overhead（「变长字段长度列表」和 「NULL 值列表」） 多字段的情况 如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 \u003c= 65535。 ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/:2:4","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-基础篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["数据库"],"content":"行溢出后，MySQL 是怎么处理的 一些大对象如 TEXT、BLOB发生行溢出，多的数据就会存到另外的「溢出页」中。真实数据处用 20 字节存储指向溢出页的地址。 Compressed 和 Dynamic 这两个行格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。实际的数据都存储在溢出页中： ","date":"2022-12-07","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/:2:5","tags":["mysql","小林coding系列"],"title":"数据库-mysql-小林coding-基础篇","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%B0%8F%E6%9E%97coding/%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"categories":["Golang"],"content":"go语言中文网 godoc go语言中文网有很多文档缺少内容比如string.Builder就没有，godoc绝对详尽，推荐阅读godoc 博客园 itbsl ","date":"2022-12-04","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/reflect/:0:0","tags":["go标准库"],"title":"go标准库-Reflect","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/reflect/"},{"categories":["Golang"],"content":"常用函数 func DeepEqual(a1, a2 interface{}) bool：用来判断两个值是否深度一致：除了类型相同；在可以时（主要是基本类型）会使用==；但还会比较array、slice的成员，map的键值对，结构体字段进行深入比对。map的键值对，对键只使用==，但值会继续往深层比对。DeepEqual函数可以正确处理循环的类型。函数类型只有都会nil时才相等；空切片不等于nil切片；还会考虑array、slice的长度、map键值对数。 ","date":"2022-12-04","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/reflect/:1:0","tags":["go标准库"],"title":"go标准库-Reflect","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/reflect/"},{"categories":["Golang"],"content":"go语言中文网 godoc go语言中文网有很多文档缺少内容比如string.Builder就没有，godoc绝对详尽，推荐阅读godoc godoc sort ","date":"2022-12-04","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/sort/:0:0","tags":["go标准库"],"title":"go标准库-Sort","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/sort/"},{"categories":["Golang"],"content":"type Interface 具有这三个方法的结构体可以使用这个库的所有函数 1 2 3 4 5 6 7 8 type Interface interface { // Len方法返回集合中的元素个数 Len() int // Less方法报告索引i的元素是否比索引j的元素小 Less(i, j int) bool // Swap方法交换索引i和j的两个元素 Swap(i, j int) } ","date":"2022-12-04","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/sort/:1:0","tags":["go标准库"],"title":"go标准库-Sort","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/sort/"},{"categories":["Golang"],"content":"常用函数 func Sort(data Interface)：Sort排序data。 func Stable(data Interface)：相当于稳定的Sort func IsSorted(data Interface) bool：报告data是否已经被排序。 func Reverse(data Interface) Interface：Reverse包装一个Interface接口并返回一个新的Interface接口，对该接口排序可生成递减序列。常用方法：sort.Sort(sort.Reverse(sort.IntSlice(s))) func Ints(a []int)：将a排序为递增顺序 func Float64s(a []float64)：将a排序为递增顺序 func Strings(a []string)：将a排序为递增顺序 func SearchInts(a []int, x int) int：返回a中最左x值索引或者插入点 ","date":"2022-12-04","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/sort/:2:0","tags":["go标准库"],"title":"go标准库-Sort","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/sort/"},{"categories":["Golang"],"content":"type IntSlice 1 type IntSlice []int 除了Interface的三个方法外，还有2个方法 func (p IntSlice) Sort() func (p IntSlice) Search(x int) int ","date":"2022-12-04","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/sort/:3:0","tags":["go标准库"],"title":"go标准库-Sort","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/sort/"},{"categories":["Golang"],"content":"type Float64Slice 1 type Float64Slice []float64 func (p Float64Slice) Sort() func (p Float64Slice) Search(x float64) int ","date":"2022-12-04","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/sort/:4:0","tags":["go标准库"],"title":"go标准库-Sort","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/sort/"},{"categories":["Golang"],"content":"type StringSlice 1 type StringSlice []string func (p StringSlice) Sort() func (p StringSlice) Search(x string) int ","date":"2022-12-04","objectID":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/sort/:5:0","tags":["go标准库"],"title":"go标准库-Sort","uri":"/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/sort/"},{"categories":["P4"],"content":"P4-learning wiki ","date":"2022-12-01","objectID":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:0:0","tags":["P4"],"title":"P4-学习资料","uri":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["P4"],"content":"入门 ","date":"2022-12-01","objectID":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:1:0","tags":["P4"],"title":"P4-学习资料","uri":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["P4"],"content":"将此存储库克隆到您的机器中: 1 git clone https://github.com/nsg-ethz/p4-learning.git ","date":"2022-12-01","objectID":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:1:1","tags":["P4"],"title":"P4-学习资料","uri":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["P4"],"content":"所需软件 PI为P4Runtime服务器提供了一个实现框架。只有涉及P4Runtime交换机的拓扑才需要它。 behavioral Model(BMv2)包含行为模型的几种变体（例如simple_switch和simple_switch_grpc）的软件实现。 P4C是支持P4_14和P4_16的 P4 编程语言的参考编译器。 Mininet允许在单个机器（VM、云或本机）上创建一个真实的虚拟网络，运行真实的内核、交换机和应用程序代码。 FRRouting是适用于 Linux 和 Unix 平台的免费开源 Internet 路由协议套件。它实现了 BGP、OSPF、RIP、IS-IS、PIM、LDP、BFD、Babel、PBR、OpenFabric 和 VRRP，并支持 EIGRP 和 NHRP。P4-Utils中的路由器节点基于FRRouting。没有路由器的拓扑不需要它。 P4-Utils是支持 P4 设备的Mininet的扩展它受到p4lang存储库中原始p4app的强烈启发。 ","date":"2022-12-01","objectID":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:1:2","tags":["P4"],"title":"P4-学习资料","uri":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["P4"],"content":"迁移到新版本 ","date":"2022-12-01","objectID":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:2:0","tags":["P4"],"title":"P4-学习资料","uri":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["P4"],"content":"新特性 P4-Utils是一个框架，它可以创建带有 P4 设备的虚拟网络 现在完全基于 Python 3。 用于启动网络的遗留 JSON 配置文件已得到简化。 现在也可以使用 Python 脚本和新的NetworkAPI. P4Runtime目前可以使用新的 API。 出于兼容性原因，保留了遗留的Thrift API 和客户端。 ","date":"2022-12-01","objectID":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:2:1","tags":["P4"],"title":"P4-学习资料","uri":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["P4"],"content":"如何迁移到新版本？ 见官网 ","date":"2022-12-01","objectID":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:2:2","tags":["P4"],"title":"P4-学习资料","uri":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["P4"],"content":"BMv2 simple swich ","date":"2022-12-01","objectID":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:3:0","tags":["P4"],"title":"P4-学习资料","uri":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["P4"],"content":"介绍 Simple Switch是 P4 开发中使用的实际架构。Simple Switch架构是P4_14规范（P4 语言的第一版）中提出的抽象交换机模型的实现。Simple Switch使用行为模型 (BMv2) 库实现，这是一个允许开发人员实现自己的软件 P4 target的框架。 BMv2 存储库实现了两个不同版本的Simple Switch，它们具有不同的控制平面接口。 |目标target|控制平面| |:=:|:=:| |simple_switch|Thrift| |simple_switch_grpc|P4Runtime,Thrift| 对于控制平面，下表显示了配置Simple Switch的不同方法。 |控制平面|方法| |:=:|:=:| |Thrift|SimpleSwitchThriftAPI,simple_switch_CLI| |P4Runtime|SimpleSwitchP4RuntimeAPI| v1model架构（我们在每个程序开始时导入的架构）是Simple Switch的架构库目标。它包括所有标准元数据和内部元数据字段、外部函数和交换机架构（或管道）包描述的声明。 现在，P4_16语言也有自己的规范中定义的便携式交换架构（PSA）。截至 2018 年 9 月，PSA 架构的部分实现已经完成，但尚未完成。它将在名为psa_switch的单独可执行程序中实现，与此处描述的simple_switch程序不同。 ","date":"2022-12-01","objectID":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:3:1","tags":["P4"],"title":"P4-学习资料","uri":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["P4"],"content":"标准元数据 通过standard_metadata_t类型结构体访问以下字段 ingress_port (bit\u003c9\u003e)：数据包到达设备的入口端口号。只读。对于重新提交和重新循环的数据包ingress_port 是0。 packet_length (bit\u003c32\u003e)：来自端口的新数据包或再循环数据包的长度（以字节为单位）。对于克隆或重新提交的数据包，您可能需要将其包含在要保留的字段列表中，否则其值将变为0. egress_spec (bit\u003c9\u003e)可以在ingress入口代码中分配一个值，以控制数据包将转到哪个输出端口。mark_to_drop函数为该字段分配实现特定值DROP_PORT. egress_port (bit\u003c9\u003e)：仅在出口处理期间访问，只读。此数据包的目标输出端口。 instance_type (bit\u003c32\u003e)：入口代码中用于区分数据包是从端口新到达的（NORMAL），重新提交原语操作的结果（RESUBMIT），还是再循环原语操作的结果（RECIRC）。出口处理中用于确定数据包是否作为入口到出口克隆原语操作 ( INGRESS_CLONE)、出口到出口克隆原语操作 ( EGRESS_CLONE)、入口处理期间指定的多播复制 ( REPLICATION)、或者来自入口 ( NORMAL) 的普通单播数据包。 parser_error：该值指示解析期间发生的错误： 1 2 3 4 5 6 7 8 error { NoError, /// No error. PacketTooShort, /// Not enough bits in packet for 'extract'. NoMatch, /// 'select' expression has no matches. StackOutOfBounds, /// Reference to invalid element of a header stack. HeaderTooShort, /// Extracting too many bits into a varbit field. ParserTimeout /// Parser execution time limit exceeded. } 排队元数据 当从入口到出口管道时，由交换机填充队列元数据。因此，只能从出口管道访问，并且它们是只读的。通过standard_metadata_t类型结构体访问以下字段 enq_timestamp (bit\u003c32\u003e): 在数据包首次入队时设置的时间戳，以微秒为单位。 enq_qdepth (bit\u003c19\u003e): 数据包首次入队时的队列深度。 deq_timedelta (bit\u003c32\u003e): 数据包在队列中花费的时间，以微秒为单位。 deq_qdepth (bit\u003c19\u003e): 数据包出队时的队列深度。 qid (bit\u003c5\u003e)：当有多个队列为每个出口端口提供服务时（例如，启用优先级排队时），每个队列都会分配一个固定的唯一 ID，该 ID 将写入该字段。qid当前不是v1modelstandard_metadata_t中类型的一部分。也许应该添加？ 内在元数据 特定于体系结构的元数据字段，内部元数据是standard_metadata_t类型结构体的一部分. 这些字段中的大多数，对于位宽没有严格的要求，但我们建议您遵循我们的以下建议。其中一些固有元数据字段可以直接访问（读和/或写），其他的只能通过原语操作访问。 ingress_global_timestamp (bit\u003c48\u003e)：一个时间戳，以微秒为单位，当数据包出现在入口时设置。每次交换机启动时，时钟都设置为 0。该字段可以直接从入口和出口读取，不应写入。 egress_global_timestamp (bit\u003c48\u003e)：一个时间戳，以微秒为单位，在数据包出现出口处理时设置。该字段只能从出口管道中读取，不应写入。 mcast_grp (bit\u003c16\u003e): 希望多播数据包时，在入口管道中写入此字段。值为 0 表示没有多播。此值必须是通过 BMv2 运行时接口配置的有效多播组之一。 egress_rid (bit\u003c16\u003e): 在出口管道只读。唯一标识同一个入口数据包的多播副本。 checksum_error (bit\u003c1\u003e)： 只读。verify_checksum调用后为 1则错误。调用verify_checksum应该在v1model的VerifyChecksum控件中，它在解析器之后和入口之前执行。 priority (bit\u003c3\u003e): 优先级队列中的数据包优先级。可能的优先级介于 0（最低优先级）和 7（最高优先级）之间。 ","date":"2022-12-01","objectID":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:3:2","tags":["P4"],"title":"P4-学习资料","uri":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["P4"],"content":"Externs v1model.p4架构文件描述中定义的外部类型、函数和对象。 counter(bit\u003c32\u003e size, CounterType type)：计数器数组。 void count(in bit\u003c32\u003e index): 将索引为index的计数器增加1或数据包中的字节数。 direct_counter(CounterType type)：直接计数器，用表引用它。每次匹配表时，匹配项条目位置的计数器都会增加1或者数据包字节数。 void count()：在给定引用表的匹配操作期间自动调用。 meter(bit\u003c32\u003e size, MeterType type)：间接meter仪表数组，跟踪数据包或字节速率。 void execute_meter(in bit\u003c32\u003e index, out T result)：给定index并返回meter的颜色状态。 direct_meter(MeterType Type)：直接仪表，用表引用。每次匹配表时，匹配项的条目位置的计量器就会增加1或者数据包字节数。 void read(out T result)：返回最后执行的条目的颜色。 register(bit size)：数组或寄存器，大小为size，元素位数为T（例如bit\u003c8\u003e）。 void read(out T result, in bit\u003c32\u003e index): 读取index元素的内容。将输出（位数一致）存储在变量 result 中。 void write(in bit\u003c32\u003e index, in T value)value: 在index元素写入T（位数一致）。 void random(out T result, in T lo, in T hi): 在lo和hi之间生成一个随机值并将其存储在result，三个变量位数相同。 void digest(in bit\u003c32\u003e receiver, in T data): 摘要小块信息并将它们发送到控制器。用于发送摘要消息的通道取决于交换机架构。在Simple Switch中，摘要是使用nanomsg套接字库实现的。与simple_switch一起使用时，可以将接收方字段始终设置为1。摘要是变量、标头或元数据的一个结构体。 void mark_to_drop(inout standard_metadata_t standard_metadata)：将standard_metadata.egress_spec设置为一个特殊值指示丢弃数据包。如果程序在离开ingress或egress管道之前更改egress_spec数据包将不会被丢弃。 void hash\u003cO, T, D, M\u003e(out O result, in HashAlgorithm algo, in T base, in D data, in M max): 对data执行algo哈希算法并将输出存储在result. 输出值将介于base和max之间。v1model.p4描述了不同的算法。 void verify_checksum\u003cT, O\u003e(in bool condition, in T data, in O checksum, HashAlgorithm algo): condition为时对data结构体执行algo哈希算法并将值与checksum进行比较。然后将输出存储在standard_metadata.checksum_error（0 有效，1 无效）中。 void update_checksum\u003cT, O\u003e(in bool condition, in T data, inout O checksum, HashAlgorithm algo): condition为真，则使用algo算法对data结构体进行哈希处理并存储在您选择的checksum字段中。比如ipv4.checksum字段。 void verify_checksum_with_payload\u003cT, O\u003e(in bool condition, in T data, in O checksum, HashAlgorithm algo): 与verify_checksum相同，输入是data和有效载荷。 void resubmit(in T data): 将（未修改的）original数据包重新提交给parser。只能在入口处调用。在入口结束时，original数据包将再次提交给解析器，data中的所有字段将被保留入口结束时的值。对一个数据包执行多个重新提交操作，仅使用最后一次重新提交操作的字段列表，仅重新提交一个数据包。 void recirculate(in T data)：将修改后的数据包重新循环到ingress。只能在出口处调用。在deparser后重新循环数据包，对数据包所做的所有更改都将保留在重新循环的数据包中。可以使用data参数保留一些元数据字段。 void clone(in CloneType type, in bit\u003c32\u003e session)：创建数据包克隆，后文详细介绍。 void clone3(in CloneType type, in bit\u003c32\u003e session, in T data)：将一些元数据字段复制到克隆的数据包。 void truncate(in bit\u003c32\u003e length)：截断数据包，只保留length指定的字节数。可以在入口或出口处执行，但只会在deparser生效。 ","date":"2022-12-01","objectID":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:3:3","tags":["P4"],"title":"P4-学习资料","uri":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["P4"],"content":"高级功能示例 创建组播组 为了使用Simple Switch的数据包复制引擎，需要在 P4 程序和使用运行时接口 ( SimpleSwitchThriftAPI, SimpleSwitchP4RuntimeAPI) 或simple_switch_CLI完成几件事. SimpleSwitchP4RuntimeAPI无法控制simple_switch 首先，您需要创建多播组、多播节点并将它们关联到端口和组。这可以使用P4-Utils提供的API 或 simple_switch_CLI 来完成： 创建多播组： 1 mc_mgrp_create \u003cid\u003e 创建具有复制 ID ( rid) 的多播节点： 1 2 3 mc_node_create \u003crid\u003e \u003cport_number\u003e # 创建具有多个端口的节点 mc_node_create 0 1 2 3 每个多播节点对应一个或多个物理port，带有一个rid信息，并返回一个handle_id。默认情况下，创建的第一个节点handle_id返回 0，下一个节点返回 1，依此类推。只需要记住我们添加它们的顺序。rid和handle_id是不一样的。rid 只是标识符，可以设置相同的rid，rid 将附加到使用此mc_node进行多播的每个数据包。可以在出口处通过读取standard_metadata.egress_rid找到该值。 关联节点和多播组： 1 mc_node_associate \u003cmcast_grp_id\u003e \u003cnode_handle_id\u003e 1 2 3 mc_mgrp_create 1 mc_node_create 0 1 2 3 mc_node_associate 1 0 在入口管道中给standard_metadata.mcast_grp写入要用于多播的多播组 ID 的值。示例中要将数据包发送到端口 1、2 和 3，需要设置standard_metadata.mcast_grp = 1. 克隆数据包 克隆用于创建数据包副本并将它们发送到其他地方。可用于监控、将数据发送到控制平面等。 simple Switch提供了两个可用于克隆数据包的extern函数： clone(in CloneType type, in bit\u003c32\u003e session) clone3(in CloneType type, in bit\u003c32\u003e session, in T data) 第一个参数是类型，CloneType.I2E将orignal数据包的副本发送到出口管道，CloneType.E2E将出口数据包的副本发送到缓冲区机制。 第二个参数是镜像 id或session id。指定克隆端口。需要使用控制平面或客户端API配置此映射 1 mirroring_add \u003csession\u003e \u003coutput_port\u003e 使用clone3时，可以复制一些元数据值，以便克隆的数据包能够访问它们。 使用该standard_metadata.instance_type字段区分普通数据包和克隆数据包。 数据包摘要 digest外部函数将一些小信息（摘要）发送到控制器的方法。摘要数据包是和原始数据包一起发送的，因此不需要克隆任何东西。Simple Switch摘要是使用套接字库Nanomsg实现的。digest必须从入口管道调用。 假设我们在 p4 代码中定义了这个元数据结构： 1 2 3 4 5 6 7 8 9 10 11 struct digest_data_t { bit\u003c8\u003e a; bit\u003c8\u003e b; } struct metadata { /* empty */ digest_data_t digest_data; } 然后我们可以在入口管道中调用摘要： 1 digest(1, meta.digest_data); //assume that metadata is called meta in the ingress parameters digest 的第一个参数总是1. 交换机添加了一些需要解析的控制标头，对于每个摘要数据包，交换机都需要一个确认消息（用于过滤重复项）。 ","date":"2022-12-01","objectID":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:3:4","tags":["P4"],"title":"P4-学习资料","uri":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["P4"],"content":"使用严格的优先级队列 Simple Switch允许每个输出端口使用多个队列。但是，为了使用它们，需要做一些小的修改。 在bmv2/targets/simple_switch/simple_switch.h文件中取消注释#define SSWITCH_PRIORITY_QUEUEING_ON。 将这两个元数据字段添加到v1model.p4文件中： 1 2 3 //Priority queueing @alias(\"queueing_metadata.qid\") bit\u003c5\u003e qid; @alias(\"intrinsic_metadata.priority\") bit\u003c3\u003e priority; 将修改后的v1model.p4文件复制到/usr/local/share/p4c/p4include/： 1 cp v1model.p4 /usr/local/share/p4c/p4include/ 重新编译 BMv2，以便添加多个队列。 默认情况下，有 8 个严格优先级队列，0 为最高优先级，7 为最低优先级。较高优先级队列中的数据包将始终比较低优先级队列中的数据包先传输。将standard_metadata.priority字段设置为0-7来选择队列。 ","date":"2022-12-01","objectID":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:3:5","tags":["P4"],"title":"P4-学习资料","uri":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["P4"],"content":"入口和出口管道 入口管道 在本节中，我们将展示在执行了来自入口控制的所有逻辑之后数据包会发生什么。 如果clone或clone3被调用，数据包将使用镜像 ID 克隆到您指定的egress_port位置。这会将入口数据包复制到出口管道，而无需所有入口控制修改。如果是clone3，数据包还将保留指定的元数据字段。最后将standard_metadata.instance_type修改为相应的值。 如果有digest的调用，交换机将向控制器发送带有指定字段的控制平面消息。 1和2可以并行执行。一些相互排斥的动作，如果一个发生，另一个就不会发生。同时为真交换机仅执行顺序靠前的动作： resubmit 多播 丢弃 单播 出口管道 在本节中，我们将展示在执行了出口控制的所有逻辑后数据包会发生什么。 如果在出口管道中调用clone或clone3被调用，数据包将使用镜像 ID 克隆到您指定的egress_port位置（有关更多信息，请参阅克隆部分）。这会将出口数据包的副本和被clone3指定的元数据发送到出口控制块。 一些相互排斥的动作，如果一个发生，另一个就不会发生。同时为真交换机仅执行顺序靠前的动作： 丢弃 Recirculate Send Packet Out ","date":"2022-12-01","objectID":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:3:6","tags":["P4"],"title":"P4-学习资料","uri":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["P4"],"content":"控制平面 ","date":"2022-12-01","objectID":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:4:0","tags":["P4"],"title":"P4-学习资料","uri":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["P4"],"content":"控制交换机 |目标target|控制平面| |:=:|:=:| |simple_switch|Thrift| |simple_switch_grpc|P4Runtime,Thrift| |控制平面|方法| |:=:|:=:| |Thrift|SimpleSwitchThriftAPI,simple_switch_CLI| |P4Runtime|SimpleSwitchP4RuntimeAPI| ","date":"2022-12-01","objectID":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:4:1","tags":["P4"],"title":"P4-学习资料","uri":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["P4"],"content":"simple switch CLI 运行客户端 simple_switch_CLI --thrift-port \u003cport\u003e 客户端连接到在每个交换机进程中运行的Thrift服务器。9090是默认端口号。一个客户端实例只能连接到一台交换机设备。 填表 table_set_default \u003ctable_name\u003e \u003caction_name\u003e \u003caction_parameters\u003e用于设置表的默认动作（即没有找到匹配时执行的动作）。 table_add \u003ctable_name\u003e \u003caction_name\u003e \u003cmatch_fields\u003e =\u003e \u003caction_parameters\u003e用于设置与表中特定匹配项相关的操作。 例如： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 action drop(){ // drops packet mark_to_drop(standard_metadata); } action action_name(bit\u003c8\u003e action_parameter){ ... } table table_name { key = { standard_metadata.ingress_port: exact; } actions = { drop; action_name; } } 1 2 table_set_default table_name drop table_add table_name action_name 1 =\u003e 5 将客户端输入写入文件 直接在文本文件中写入命令，然后提供给客户端： 1 simple_switch_CLI --thrift-port \u003cport\u003e \u003c command_file.txt 使用P4-Utils配置文件 在p4app.json中为每个交换机设置一个配置文件。 1 2 3 4 5 \"switches\": { \"s1\": { \"cli_input\": \"\u003cpath_to_cli_commands_file\u003e\" } } 您可以p4app.json在官方P4-Utils文档中找到有关的所有文档。 ","date":"2022-12-01","objectID":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:4:2","tags":["P4"],"title":"P4-学习资料","uri":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["P4"],"content":"Thrift API 使用python与交换机内置的Thrift服务器通信以执行命令。在此处阅读更多有关信息。 ","date":"2022-12-01","objectID":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:4:3","tags":["P4"],"title":"P4-学习资料","uri":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["P4"],"content":"P4Runtime API P4Runtime是一种控制平面规范，直接与交换机通信。这样控制平面程序也与目标无关。 P4-Utils引入了P4Runtime API。包名为SimpleSwitchP4RuntimeAPI并，提供与SimpleSwitchThriftAPI相似的方法。在此处阅读有关此 API的更多信息。 ","date":"2022-12-01","objectID":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:4:4","tags":["P4"],"title":"P4-学习资料","uri":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["P4"],"content":"调试和故障排除 ","date":"2022-12-01","objectID":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:5:0","tags":["P4"],"title":"P4-学习资料","uri":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["P4"],"content":"监控流量 在调试 P4 程序时，Sniffing traffic嗅探流量是一个非常强大的工具。仅通过观察流量就可以轻松实现验证流量是否穿过特定路径，或者标头字段是否符合预期等基本操作。为此，可以使用多种工具。 .pcap文件 simple_switch的--pcap=\u003coutput_dir\u003e选项将通过其接口的所有流量保存在一个.pcap文件中： 1 sudo simple_switch -i 0@\u003ciface0\u003e -i 1@\u003ciface1\u003e --pcap=\u003coutput_dir\u003e \u003cpath to JSON file\u003e 数据包日志记录文件命名规则：\u003csw_name\u003e-\u003cintf_num\u003e_\u003cin|out\u003e.pcap 在p4app.json配置文件或网络配置脚本中启用.pcap文件，交换机将使用该–pcap选项启动并用./pcap作输出目录。 Wireshark和TShark 另一种选择是在流量流动时观察流量。可以使用TShark及其 GUI 版本Wireshark等工具 1 sudo tshark -i \u003cinterface_name\u003e Tcpdump 同样，可以使用tcpdump 捕获流量，显示链路层信息并且不解析地址： 1 sudo tcpdump -l -enn -i \u003cinterface_name\u003e ","date":"2022-12-01","objectID":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:5:1","tags":["P4"],"title":"P4-学习资料","uri":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["P4"],"content":"Logging记录 要启用日志记录，请确保在编译bmv2之前配置启用--with-nanomsg标志。 控制台记录 要在启动交换机时启用控制台日志记录，请使用--log-console命令行选项。例如： 1 sudo simple_switch -i 0@\u003ciface0\u003e -i 1@\u003ciface1\u003e --log-console \u003cpath to JSON file\u003e 将打印终端中的所有消息 还可以将其重定向到日志文件 1 sudo simple_switch -i 0@\u003ciface0\u003e -i 1@\u003ciface1\u003e --log-console \u003cpath to JSON file\u003e \u003e/path_to_file/sw.log 在p4app.json配置文件中启用日志记录，交换机会自动将所有控制台日志记录写入./log目录下的一个文件中，后缀为\u003csw_name\u003e.log 客户端记录 .p4app启用了日志记录，并且在启动拓扑时使用了simple_switch_CLI，则cli输出也将记录在日志文件夹中的\u003csw_name\u003e_cli_output.log文件 事件记录 使用--nanolog命令行选项在启动交换机时启用事件日志记录。例如，要使用ipc地址ipc:///tmp/bm-log.ipc： 1 sudo ./simple_switch -i 0@\u003ciface0\u003e -i 1@\u003ciface1\u003e --nanolog ipc:///tmp/bm-log.ipc \u003cpath to JSON file\u003e 在交换机运行时使用tools/nanomsg_client.py如下： 1 sudo ./nanomsg_client.py [--thrift-port \u003cport\u003e] 该脚本将为每个数据包显示重要事件（表命中/未命中、解析器转换）。 使用P4-Utils创建拓扑时，每个交换机都会自动分配一个Thrift端口。查看p4run显示的print消息找到交换机和端口之间的映射： 1 s1 -\u003e Thrift port: 9090 ","date":"2022-12-01","objectID":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:5:2","tags":["P4"],"title":"P4-学习资料","uri":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["P4"],"content":"调试器 要启用调试器，编译bmv2前配置--enable-debugger. 启动交换机时，使用命令行标志--debugger。 在交换机运行时使用tools/p4dbg.py将调试器附加到交换机： 1 sudo ./p4dbg.py [--thrift-port \u003cport\u003e] 您可以在BMv2 文档中找到 P4 调试器用户指南。 ","date":"2022-12-01","objectID":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:5:3","tags":["P4"],"title":"P4-学习资料","uri":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["P4"],"content":"将信息附加到数据包 可以通过仅根据执行代码的哪一部分修改标头字段来了解代码的作用，并在数据包离开交换机时检查该值。当然，可以做一些更复杂的事情，使用多个字段，读取寄存器的值并将其保存在标头中，等等。 ","date":"2022-12-01","objectID":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:5:4","tags":["P4"],"title":"P4-学习资料","uri":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["P4"],"content":"使用 P4 表检查标题/元数据值 使用 P4 表并exact匹配您要跟踪的所有字段。每次执行表时，如果启用了 BMv2 调试，交换机会将用于匹配表条目的每个字段的值写入交换机日志文件中。有关详细信息，请参阅示例。 ","date":"2022-12-01","objectID":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:5:5","tags":["P4"],"title":"P4-学习资料","uri":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["P4"],"content":"如果以上没有解决你的问题 首先，检查P4-16 规范对此的说明。 检查p4-org邮件列表。可能您不是第一个遇到此问题的人，并且已经有人在邮件列表中询问您需要什么。谷歌搜索：site:http://lists.p4.org/ 。 检查BMv2和P4C存储库的GitHub issue部分。 如果你在任何地方都找不到解决方案，你可以自己写邮件，或者在 GitHub 中打开一个问题。 ","date":"2022-12-01","objectID":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:5:6","tags":["P4"],"title":"P4-学习资料","uri":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["P4"],"content":"Scapy 正如官网所写，Scapy是一个强大的交互式数据包操作程序。它能够伪造或解码大量协议的数据包、在线发送它们、捕获它们、匹配请求和回复等等。它可以轻松处理大多数经典任务，如扫描、跟踪路由、探测、单元测试、攻击或网络发现。 链接 Scapy 最新文档 基本备忘单 ","date":"2022-12-01","objectID":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:6:0","tags":["P4"],"title":"P4-学习资料","uri":"/posts/p4/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["Python"],"content":"mininet官网 mininet官网文档 mininet官网api mininet简介 github ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/:0:0","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Mininet简介","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"什么是迷你网？ Mininet 是一个网络仿真器，或者更准确地说是一个 网络仿真编排系统。 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/:1:0","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Mininet简介","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"为什么 Mininet 很酷？ 它很快——启动一个简单的网络只需几秒钟。 可以创建自定义拓扑：单个交换机、更大的类似 Internet 的拓扑、斯坦福骨干网、数据中心或其他任何东西。 可以运行真正的程序：任何在 Linux 上运行的程序都可以运行，从 Web 服务器到 TCP 窗口监控工具再到 Wireshark。 可以自定义数据包转发：Mininet 的交换机可以使用 OpenFlow 协议进行编程。在 Mininet 中运行的自定义软件定义网络设计可以轻松转移到硬件 OpenFlow 交换机以进行线速数据包转发。 可以在笔记本电脑、服务器、虚拟机、本地 Linux 机器（Ubuntu 12.10+ 中包含 Mininet！）或云（例如 Amazon EC2）上运行 Mininet。 可以共享代码和复现结果。 可以通过编写简单（或必要时复杂）Python 脚本来创建和运行 Mininet 实验。 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/:2:0","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Mininet简介","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"Mininet 的局限性是什么？ 尽管我们认为 Mininet 很棒，但它确实有一些局限性。例如， 在单个系统上运行很方便，但它施加了资源限制： CPU 和 带宽 将需要在您的虚拟主机和交换机之间进行平衡和共享。 Mininet 为所有虚拟主机使用单个 Linux 内核；不能运行依赖于 BSD、Windows 或其他操作系统内核的软件。 Mininet 不会为您编写 OpenFlow 控制器；如果您需要自定义路由器或交换机行为，则需要查找或开发具有所需功能的控制器。 默认情况下，Mininet 网络与您的 LAN 和 Internet 隔离。可以使用 NAT对象和/或–nat选项通过网络地址转换将 Mininet 网络连接到 LAN。可以将真实（或虚拟）硬件接口附加到您的 Mininet 网络。 默认情况下，所有 Mininet 主机共享主机文件系统和 PID 空间；如果正在运行需要在 /etc 中配置的守护进程，必须小心不要错误地杀死错误的进程。 与模拟器不同，Mininet 没有强烈的虚拟时间概念；时序测量将基于实时，并且无法轻易模拟比实时更快的结果（例如 100 Gbps 网络）。 关于性能的旁白：对于网络受限的实验，您必须牢记的主要事情是您可能需要使用较慢的链接，例如 10 或 100 Mb/秒而不是 10 Gb/秒，因为数据包由一组共享 CPU 和内存资源的软件交换机（例如 Open vSwitch）转发，通常性能低于专用交换硬件。对于 CPU 限制的实验，您还需要确保仔细限制 Mininet 主机的 CPU 带宽。如果您主要关心功能的正确性，则可以在没有特定带宽限制的情况下运行 Mininet - 这是运行 Mininet 的快速简便的方法，并且它还以牺牲负载下的计时精度为代价提供最高的性能。 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/:3:0","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Mininet简介","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"使用 Mininet ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/:4:0","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Mininet简介","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"创建拓扑 Mininet 支持参数化拓扑，根据您传递给它的参数进行配置，并可重复用于多个实验。 例如，这是一个简单的网络拓扑（基于mininet/topo.py:SingleSwitchTopo），它由连接到单个交换机（s1）的指定数量的主机（h1通过hN）组成。 请注意，这是 Mininet 2.2 中引入的推荐（简化）拓扑语法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #!/usr/bin/python from mininet.topo import Topo from mininet.net import Mininet from mininet.util import dumpNodeConnections from mininet.log import setLogLevel class SingleSwitchTopo(Topo): \"Single switch connected to n hosts.\" def build(self, n=2): switch = self.addSwitch('s1') # Python's range(N) generates 0..N-1 for h in range(n): host = self.addHost('h%s' % (h + 1)) self.addLink(host, switch) def simpleTest(): \"Create and test a simple network\" topo = SingleSwitchTopo(n=4) net = Mininet(topo) net.start() print( \"Dumping host connections\" ) dumpNodeConnections(net.hosts) print( \"Testing network connectivity\" ) net.pingAll() net.stop() if __name__ == '__main__': # Tell mininet to print useful information setLogLevel('info') simpleTest() 上述代码中重要的类、方法、函数和变量包括： Topo: Mininet 拓扑的基类 build(): 在拓扑类中重写的方法。构造函数参数 (n) 将由Topo.init()自动传递给它。此方法创建一个模板（基本上是一个节点名称图和一个配置信息数据库），然后使用它来创建Mininet实际拓扑。 addSwitch(): 添加一个交换机到拓扑并返回交换机名称 addHost(): 将主机添加到拓扑并返回主机名 addLink()：添加双向链接到拓扑（并返回链接键，但这并不重要）。除非另有说明，否则 Mininet 中的链接是双向的。 Mininet: 创建和管理网络的主类 start(): 启动你的网络 pingAll()：通过尝试让所有节点相互 ping 来测试连通性 stop(): 停止你的网络 net.hosts：网络中的所有主机 dumpNodeConnections()：dumps（打印） connections to/from a set of nodes. setLogLevel( ‘info’ | ‘debug’ | ‘output’ ): 设置 Mininet 的默认输出电平；建议使用“info”，因为它提供了有用的信息。 可以在mininet/examples中找到其他示例代码。 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/:4:1","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Mininet简介","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"注意：Mininet()和构造函数 Mininet()是创建并返回网络对象的构造函数。Mininet它需要一些配置参数，特别是： topo：拓扑对象（不是构造函数或模板 - 实际对象！） host：用于在拓扑中创建Host元素的构造函数 switch：用于在拓扑中创建Switch元素的构造函数 controller：用于在拓扑中创建Controller元素的构造函数 link: 用于在拓扑中创建 Link s 的构造函数 构造函数可以使用functools.partial生成： 1 2 3 from functools import partial net = Mininet( topo=SingleSwitchTopo(), link=partial(TCLink,delay='30ms', bw=100) ... ) 您还可以创建自己的构造函数或子类。请记住，为拓扑中的每个网络元素调用构造函数。 Mininet 允许传入一个controller 对象或对象列表。 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/:4:2","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Mininet简介","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"脚本输出 运行此脚本应该会产生类似于以下内容的结果： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 $ sudo python simpletest.py *** Creating network *** Adding controller *** Adding hosts: h1 h2 h3 h4 *** Adding switches: s1 *** Adding links: (h1, s1) (h2, s1) (h3, s1) (h4, s1) *** Configuring hosts h1 h2 h3 h4 *** Starting controller c0 *** Starting 1 switches s1 ... Dumping host connections h1 h1-eth0:s1-eth1 h2 h2-eth0:s1-eth2 h3 h3-eth0:s1-eth3 h4 h4-eth0:s1-eth4 Testing network connectivity *** Ping: testing ping reachability h1 -\u003e h2 h3 h4 h2 -\u003e h1 h3 h4 h3 -\u003e h1 h2 h4 h4 -\u003e h1 h2 h3 *** Results: 0% dropped (12/12 received) *** Stopping 1 controllers c0 *** Stopping 4 links .... *** Stopping 1 switches s1 *** Stopping 4 hosts h1 h2 h3 h4 *** Done ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/:4:3","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Mininet简介","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"设置性能参数 除了基本的行为网络之外，Mininet 还通过CPULimitedHost和TCLink 类提供性能限制和隔离功能。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #!/usr/bin/python from mininet.topo import Topo from mininet.net import Mininet from mininet.node import CPULimitedHost from mininet.link import TCLink from mininet.util import dumpNodeConnections from mininet.log import setLogLevel class SingleSwitchTopo( Topo ): \"Single switch connected to n hosts.\" def build( self, n=2 ): switch = self.addSwitch( 's1' ) for h in range(n): # Each host gets 50%/n of system CPU host = self.addHost( 'h%s' % (h + 1), cpu=.5/n ) # 10 Mbps, 5ms delay, 2% loss, 1000 packet queue self.addLink( host, switch, bw=10, delay='5ms', loss=2, max_queue_size=1000, use_htb=True ) def perfTest(): \"Create network and run simple performance test\" topo = SingleSwitchTopo( n=4 ) net = Mininet( topo=topo, host=CPULimitedHost, link=TCLink ) net.start() print( \"Dumping host connections\" ) dumpNodeConnections( net.hosts ) print( \"Testing network connectivity\" ) net.pingAll() print( \"Testing bandwidth between h1 and h4\" ) h1, h4 = net.get( 'h1', 'h4' ) net.iperf( (h1, h4) ) net.stop() if __name__ == '__main__': setLogLevel( 'info' ) perfTest() 重要方法和参数： self.addHost(name, cpu=f):这允许您指定将分配给虚拟主机的整个系统 CPU 资源的一部分。 self.addLink( node1, node2, bw=10, delay=‘5ms’, max_queue_size=1000, loss=10, use_htb=True)：添加具有带宽、延迟和丢失特性的双向链接，使用分层令牌桶速率限制器和 netem 延迟/丢失模拟器，队列最大为 1000 个数据包。bw参数是Mbit为单位的数字表示；delay表示为带有单位的字符串（例如“5ms”、“100us”、“1s”）；loss以百分比表示（介于 0 和 100 之间）；max_queue_size以数据包表示。 使用 Python 字典来复用相同的参数，例如： 1 2 3 linkopts = dict(bw=10, delay='5ms', loss=10, max_queue_size=1000, use_htb=True) # (or you can use brace syntax: linkopts = {'bw':10, 'delay':'5ms', ... } ) self.addLink(node1, node2, **linkopts) net.get()：按名称检索节点（主机或交换机）对象。可以通过节点对象向主机发送命令（例如使用 host.cmd()）并获取其输出。 另外，可以简单地使用中括号（例如net[‘h1’]）按名称检索给定的节点。 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/:4:4","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Mininet简介","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"在主机中运行程序 cmd()方法在主机中运行命令并获取输出。 1 2 3 h1 = net.get('h1') result = h1.cmd('ifconfig') print( result ) 在后台运行命令一段时间，然后停止该命令，并将其输出保存到一个文件中： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from time import sleep ... print( \"Starting test...\" ) h1.cmd('while true; do date; sleep 1; done \u003e /tmp/date.out \u0026') sleep(10) print( \"Stopping test\" ) h1.cmd('kill %while') print( \"Reading output\" ) f = open('/tmp/date.out') lineno = 1 for line in f.readlines(): print( \"%d: %s\" % ( lineno, line.strip() ) ) lineno += 1 f.close() 使用 shell 的输出重定向功能将输出发送到/tmp/date.out，使用 shell 的后台执行功能在后台\u0026运行命令，并使用作业控制kill %while关闭在后台运行的程序。后台运行的作业不能保证在 Mininet 退出时停止（无论是有意还是由于错误）。定期使用 ps 命令来确保没有僵尸作业。 拥有一个 shell 进程可以让您轻松执行其他任务。例如，可以使用以下命令找出后台命令的 PID 1 pid = int( h1.cmd('echo $!') ) 然后你可以使用 wait 等待特定进程完成执行，例如： 1 h1.cmd('wait', pid) 这仅适用于 UNIX 命令，不适用于内置于 bash shell 本身（并且没有单独的 pid！）的命令（例如while，cd）。 这些命令中的每一个都在前台执行（没有\u0026）而不是后台 (\u0026)，因为要在python中获得输出。 除了使用 shell 的等待机制之外，Mininet 本身还允许使用以下命令启动前台命令sendCmd()，然后等待它在稍后的某个时间完成waitOutput()： 1 2 3 4 5 6 for h in hosts: h.sendCmd('sleep 20') … results = {} for h in hosts: results[h.name] = h.waitOutput() 如果将输出发送到文件，可能希望在测试运行时以交互方式监视该文件的内容。 examples/multipoll.py 示例提供了一个monitorFiles()函数，实现了一种可能的机制来监视多个输出文件。这简化了交互式监视来自多个主机的输出的测试的实现： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def monitorTest( N=3, seconds=3 ): \"Run pings and monitor multiple hosts\" topo = SingleSwitchTopo( N ) net = Mininet( topo ) net.start() hosts = net.hosts print( \"Starting test...\" ) server = hosts[ 0 ] outfiles, errfiles = {}, {} for h in hosts: # Create and/or erase output files outfiles[ h ] = '/tmp/%s.out' % h.name errfiles[ h ] = '/tmp/%s.err' % h.name h.cmd( 'echo \u003e', outfiles[ h ] ) h.cmd( 'echo \u003e', errfiles[ h ] ) # Start pings h.cmdPrint('ping', server.IP(), '\u003e', outfiles[ h ], '2\u003e', errfiles[ h ], '\u0026' ) print( \"Monitoring output for\", seconds, \"seconds\" ) for h, line in monitorFiles( outfiles, seconds, timeoutms=500 ): if h: print( '%s: %s' % ( h.name, line ) ) for h in hosts: h.cmd('kill %ping') net.stop() 这相当于通过monitorFiles监听outfiles列表中的文件，然后统一输出到bash中 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/:4:5","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Mininet简介","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"新：popen()/pexec()界面 除了cmd()/sendCmd()的基于 shell 的机制之外，Mininet 现在还支持返回标准 Python Popen()对象的基于管道的接口（有关详细信息，请参阅 Python 的 subprocess 模块。）该机制较新且没有经过充分测试cmd()，但您可能会发现在后台运行多个进程并监视它们的输出很方便。提供了一个pmonitor()函数，Popen()可以更轻松地监视多个对象。 examples/popenpoll.py中的代码使用popen()接口和pmonitor()辅助函数实现与上述类似的功能： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def pmonitorTest( N=3, seconds=10 ): \"Run pings and monitor multiple hosts using pmonitor\" topo = SingleSwitchTopo( N ) net = Mininet( topo ) net.start() hosts = net.hosts print( \"Starting test...\" ) server = hosts[ 0 ] popens = {} for h in hosts: popens[ h ] = h.popen('ping', server.IP() ) print( \"Monitoring output for\", seconds, \"seconds\" ) endTime = time() + seconds for h, line in pmonitor( popens, timeoutms=500 ): if h: print( '%s: %s' % ( h.name, line ), ) if time() \u003e= endTime: for p in popens.values(): p.send_signal( SIGINT ) net.stop() 请注意，此实现略有不同，因为它将时间管理从pmonitor()辅助函数中提取出来，但这使得ping能够在它被中断后捕获它的输出。 当然，您不必使用pmonitor()- 您可以使用 Popen.communicate()（只要您没有太多文件描述符）或select.poll()以及任何其他有效的机制。 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/:4:6","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Mininet简介","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"重要：共享文件系统！ 要记住的一件事是，默认情况下 Mininet 主机共享底层服务器的根文件系统。 共享根文件系统还意味着不需要在 Mininet 主机之间复制数据，因为可以直接访问。 然而，一个副作用是主机共享 Mininet 服务器的 /etc目录。、如果您需要对程序进行特定配置（例如httpd），那么您可能需要为每个 Mininet 主机创建不同的配置文件，并将它们指定为您正在运行的程序的启动选项。 另一个副作用是，尝试在多个主机上的同一目录中创建同一文件，会发生文件冲突。 如果需要每个主机的私有目录，将它们指定为Host的选项，例如： 1 h = Host( 'h1', privateDirs=[ '/some/directory' ] ) ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/:4:7","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Mininet简介","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"主机配置方法 Mininet hosts 提供了一些方便的网络配置方法： IP(): 返回主机或特定接口的 IP 地址。 MAC()：返回主机或特定接口的 MAC 地址。 setARP(): 将静态 ARP 条目添加到主机的 ARP 缓存中。 setIP()：设置主机或特定接口的 IP 地址。 setMAC()：设置主机或特定接口的MAC地址 例如： 1 print( \"Host\", h1.name, \"has IP address\", h1.IP(), \"and MAC address\", h1.MAC() ) 在任何情况下，如果您不提供特定接口（例如h1-eth0 或接口对象），该方法将使用主机的默认接口。 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/:4:8","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Mininet简介","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"在 Mininet 中命名 主机被称为h1..hN，交换机被称为s1..sN。属于节点的接口以节点名称开头命名，例如h1-eth0是主机h1的默认接口，s1-eth1是交换机s1的第一个数据端口。主机接口仅在主机内部可见，交换机数据端口在“root”命名空间中可见。因此，很容易检查交换机接口，但检查主机接口有点棘手（主要使用host.cmd())。 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/:4:9","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Mininet简介","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"命令行界面 Mininet 包括一个可以在网络上调用的命令行界面 (CLI)，并提供各种有用的命令，以及显示 xterm 窗口和在网络中的各个节点上运行命令的能力。可以通过将网络对象传递给CLI()构造函数来在网络上调用 CLI： 1 2 3 4 5 6 7 8 from mininet.topo import SingleSwitchTopo from mininet.net import Mininet from mininet.cli import CLI net = Mininet(SingleSwitchTopo(2)) net.start() CLI(net) net.stop() 启动 CLI 可用于调试网络，因为它允许您查看网络拓扑（使用net命令）、测试连接性（使用pingall命令）以及向各个主机发送命令。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 *** Starting CLI: mininet\u003e net c0 s1 lo: s1-eth1:h1-eth0 s1-eth2:h2-eth0 h1 h1-eth0:s1-eth1 h2 h2-eth0:s1-eth2 mininet\u003e pingall *** Ping: testing ping reachability h1 -\u003e h2 h2 -\u003e h1 *** Results: 0% dropped (0/2 lost) mininet\u003e h1 ip link show 746: lo: \u003cLOOPBACK,UP,LOWER_UP\u003e mtu 16436 qdisc noqueue state UNKNOWN link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 749: h1-eth0: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 qdisc pfifo_fast state UP qlen 1000 link/ether d6:13:2d:6f:98:95 brd ff:ff:ff:ff:ff:ff ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/:4:10","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Mininet简介","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"mn使用–custom文件自定义 建议直接写python文件，详见官网 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/:4:11","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Mininet简介","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"其他示例 Mininet 脚本的其他示例可以在mininet/examples. 这些示例旨在提供教育意义，因为它们展示了可以使用 Mininet API 的不同方式。我们鼓励您尝试阅读Python 代码并自己运行示例。如果它们由于某种原因不起作用，看看您是否能找出原因！ consoles.py可以构建的有趣演示。 miniedit.py 对于 Mininet 的简单实验来说是一个特别有用的 GUI。 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/:4:12","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Mininet简介","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"了解 Mininet API Mininet 的 API 构建在三个主要级别： 低级 API：低级 API 由基本节点和链接类（例如Host、Switch和Link及其子类）组成，它们实际上可以单独实例化并用于创建网络，但有点笨拙。 中级API：中级API 添加Mininet对象作为节点和链接的容器。它提供了多种方法（例如addHost()、addSwitch()和addLink()）用于向网络添加节点和链接，以及网络配置、启动和关闭（特别是start()和stop()。） 高级 API：高级 API 添加拓扑模板抽象Topo类，它提供创建可重用的参数化拓扑模板的能力。这些模板可以传递给mn命令（通过–custom选项）并从命令行使用。 了解每个 API 级别很有价值。一般来说，当你想直接控制节点和交换机时，你会使用低级 API。当您想要启动或停止网络时，通常使用中级 API（尤其是Mininet类）。 当您开始考虑创建完整的网络时，通常会希望选择中级 API（例如Mininet.add*()）或高级 API ( Topo.add*()) 来创建您的网络。 低级 API：节点和链接 1 2 3 4 5 6 7 8 9 10 11 12 13 h1 = Host( 'h1' ) h2 = Host( 'h2' ) s1 = OVSSwitch( 's1', inNamespace=False ) c0 = Controller( 'c0', inNamespace=False ) Link( h1, s1 ) Link( h2, s1 ) h1.setIP( '10.1/8' ) h2.setIP( '10.2/8' ) c0.start() s1.start( [ c0 ] ) print( h1.cmd( 'ping -c1', h2.IP() ) ) s1.stop() c0.stop() 中级 API：网络对象 1 2 3 4 5 6 7 8 9 10 11 net = Mininet() h1 = net.addHost( 'h1' ) h2 = net.addHost( 'h2' ) s1 = net.addSwitch( 's1' ) c0 = net.addController( 'c0' ) net.addLink( h1, s1 ) net.addLink( h2, s1 ) net.start() print( h1.cmd( 'ping -c1', h2.IP() ) ) CLI( net ) net.stop() 高级 API：拓扑模板 1 2 3 4 5 6 7 8 9 10 11 12 13 class SingleSwitchTopo( Topo ): \"Single Switch Topology\" def build( self, count=1 ): hosts = [ self.addHost( 'h%d' % i ) for i in range( 1, count + 1 ) ] s1 = self.addSwitch( 's1' ) for h in hosts: self.addLink( h, s1 ) net = Mininet( topo=SingleSwitchTopo( 3 ) ) net.start() CLI( net ) net.stop() 如您所见，中级 API 对于本示例实际上是最简单和最简洁的，不需要创建拓扑类。低级和中级 API 灵活而强大，但与高级TopoAPI 及其拓扑模板相比，重用起来可能不太方便。 另请注意，在 2.2.0 之前的 Mininet 版本中，高层Topo不支持节点之间的多链接，但低层 API 支持。目前Topo也不关心哪些坏过压保护由哪些控制器控制（您可以使用自定义Switch子类来执行此操作，如上所述。）使用中级和低级 API，您可以根据需要手动启动交换机，将适当的控制器列表传递给每个交换机。 Mininet API 文档 Mininet 包含每个模块和 API 调用的 Python 文档字符串。这些可以从 Python 的常规help()机制访问。例如， 1 2 3 4 5 6 \u003e\u003e\u003e from mininet.node import Host \u003e\u003e\u003e help(Host.IP) Help on method IP in module mininet.node: IP(self, intf=None) unbound mininet.node.Host method Return IP address of a node or specific interface. 同样的文档也可以在 Mininet 网站上找到。 测试性能 这些是推荐的工具。 带宽 ( bwm-ng, ethstats) 延迟（使用ping） 队列（使用tc包含在monitor.py） TCPCWND统计信息（tcp_probe，也许我们应该将其添加到monitor.py） CPU 使用率（全局：top或每个容器cpuacct） ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/:4:13","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Mininet简介","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"OpenFlow 和自定义路由 Mininet 最强大和最有用的功能之一是它使用 软件定义网络。 使用OpenFlow协议和相关工具，可以对交换机进行编程，以对进入它们的数据包执行几乎任何您想要的操作。 OpenFlow 使像 Mininet 这样的仿真器变得更加有用，因为网络系统设计（包括使用 OpenFlow 的自定义数据包转发）可以轻松地转移到硬件 OpenFlow 交换机以进行线速操作。 Mininet OpenFlow 教程 OpenFlow控制器 如果你想使用你自己的控制器，你可以很容易地创建一个自定义的子类Controller()并将它传递到 Mininet 中。可以在mininet.controller.NOX()中看到一个示例，它使用一组作为选项传入的模块调用 NOX classic。 下面是创建和使用自定义 POXController子类的简单示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/usr/bin/python from mininet.net import Mininet from mininet.node import Controller from mininet.topo import SingleSwitchTopo from mininet.log import setLogLevel import os class POXBridge( Controller ): \"Custom Controller class to invoke POX forwarding.l2_learning\" def start( self ): \"Start POX learning switch\" self.pox = '%s/pox/pox.py' % os.environ[ 'HOME' ] self.cmd( self.pox, 'forwarding.l2_learning \u0026' ) def stop( self ): \"Stop POX\" self.cmd( 'kill %' + self.pox ) controllers = { 'poxbridge': POXBridge } if __name__ == '__main__': setLogLevel( 'info' ) net = Mininet( topo=SingleSwitchTopo( 2 ), controller=POXBridge ) net.start() net.pingAll() net.stop() 外部 OpenFlow 控制器 自定义Controller()子类是自动启动和关闭控制器的最方便的方法。创建start()和stop()方法很容易，这样 Mininet 将根据需要自动启动和停止您的控制器。 可以使用RemoteController将 Mininet 连接到已经在其他地方运行的现有控制器，例如 LAN 上的某个地方、另一个 VM 中或笔记本电脑上。 1 2 from functools import partial net = Mininet( topo=topo, controller=partial( RemoteController, ip='127.0.0.1', port=6633 ) ) 或者 1 net = Mininet( topo=topo, controller=lambda name: RemoteController( name, ip='127.0.0.1' ) ) 甚至 1 2 net = Mininet( topo=topo, controller=None) net.addController( 'c0', controller=RemoteController, ip='127.0.0.1', port=6633 ) 请注意，在这种情况下， controller（如host和switch）是一个构造函数，而不是一个对象（但请参阅下面的附加信息！）您可以使用partial或lambda在线创建自定义构造函数，或者您可以传入自己的函数（必须采用name参数并返回控制器对象）或类（例如RemoteController的子类） 您还可以创建多个控制器并创建一个自定义Switch()子类，根据需要连接到不同的控制器： 1 2 3 4 5 6 7 8 c0 = Controller( 'c0' ) # local controller c1 = RemoteController( 'c1', ip='127.0.0.2' ) # external controller cmap = { 's1': c0, 's2': c1, 's3': c1 } class MultiSwitch( OVSSwitch ): \"Custom Switch() subclass that connects to different controllers\" def start( self, controllers ): return OVSSwitch.start( self, [ cmap[ self.name ] ] ) 通过传入控制器对象调用 API 在 Mininet 2.2.0 及更高版本中，您可以选择传入Controller 对象而不是构造函数（甚至是对象列表）。添加此选项是因为尽管 API 明确指定需要构造函数，但人们仍在这样做. 这使您可以执行以下操作： 1 net = Mininet( topo, controller=RemoteController( 'c0', ip='127.0.0.1' ) ) 多路径路由 重要的是要记住，以太网桥（也称为学习交换机）会淹没在其 MAC 表中丢失的数据包。它们还会像 ARP 和 DHCP 请求一样泛滥广播。这意味着，如果您的网络中有环路或多条路径，它无法将默认ovs-controller与充当学习交换机/以太网桥的controller控制器|NOX的pyswitch|POX的l2_learning一起使用。 更新（和更复杂）的 OpenFlow 控制器确实支持多路径路由 - 请查阅控制器的文档以确定是否需要任何特殊配置。 如果您正在构建类似胖树的拓扑结构，您可能希望查看 RipLPOX，这是一个使用 POX 实现的基本数据中心控制器。您可以将其用作您自己的自定义多路径路由的起点。 为了方便起见，您可能还希望实现一个自定义Controller()子类来调用 RipLPOX。 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/:4:14","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Mininet简介","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"更新 Mininet 两种方式 使用指向 Mininet 源代码树的符号链接更新（使更新 Mininet 的 python 代码变得容易）。 1 2 3 4 5 cd ~/mininet git checkout master # assuming you want to update to the current master branch sudo make develop # this only needs to be done initially and when mnexec.c changes git fetch git pull --rebase 将 Mininet 源代码复制到 /usr/lib/python…（允许您删除或移动 Mininet 源代码树）： 1 2 3 4 5 cd ~/mininet git checkout master # assuming you want to update to the current master branch git fetch git pull --rebase sudo make install ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/:4:15","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Mininet简介","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"学习Python 详见Python教程 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/:4:16","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Mininet简介","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"它是如何工作的 Mininet 背后的魔力是 Linux 中内置的一组功能，允许将单个系统拆分为一堆较小的“容器”，每个容器具有固定份额的处理能力，并结合允许链接准确的虚拟链接代码延迟和速度。 在内部，Mininet 采用 Linux 内核中的轻量级虚拟化功能，包括进程组、CPU 带宽隔离和网络命名空间，并将它们与链接调度程序和虚拟以太网链接相结合。与使用完整虚拟机的仿真器相比，这些功能产生的系统启动速度更快，可扩展到更多主机。 Mininet 网络由以下组件组成： 孤立的主机。Mininet 中的模拟主机是一组移动到网络命名空间中的用户级进程 - 网络状态的容器。网络名称空间为进程组提供接口、端口和路由表（例如 ARP 和 IP）的独占所有权。例如，两个网络命名空间中的两个 Web 服务器可以在一个系统中共存，它们都监听端口 80 上的私有 eth0 接口。Mininet 使用 CPU 带宽限制来限制每个进程组可用的 CPU 比例。 模拟链接。每个链路的数据速率由 Linux 流量控制 ( tc) 强制执行，它有许多数据包调度程序来将流量调整为配置的速率。每个模拟主机都有自己的虚拟以太网接口（使用 ip link add/set 创建和安装）。虚拟以太网（或veth）对，就像连接两个虚拟接口或虚拟交换机端口的电线一样；通过一个接口发送的数据包被传送到另一个接口，每个接口对所有系统和应用程序软件来说都是一个功能齐全的以太网端口。 仿真交换机。Mininet 通常使用在内核模式下运行的默认 Linux 网桥或 Open vSwitch 来跨接口交换数据包。交换机和路由器可以在内核中运行（为了速度）或在用户空间中运行（因此我们可以轻松修改它们）。 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/:4:17","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Mininet简介","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"mininet官网 mininet官网文档 mininet官网api Mininet演练 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/:0:0","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-mininet演练","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/"},{"categories":["Python"],"content":"第 1 部分：Mininet 的日常使用 首先，关于本演练的命令语法的（可能是显而易见的）注释： $ 是 shell 提示符 mininet\u003e 是 Mininet CLI # 是 root shell 提示符 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/:1:0","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-mininet演练","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/"},{"categories":["Python"],"content":"显示启动选项 键入以下命令以显示描述 Mininet 启动选项的帮助消息： 1 $ sudo mn -h ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/:1:1","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-mininet演练","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/"},{"categories":["Python"],"content":"启动 Wireshark 要使用 OpenFlow Wireshark dissector 查看控制流量，首先在后台打开 wireshark： 1 $ sudo wireshark \u0026 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/:1:2","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-mininet演练","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/"},{"categories":["Python"],"content":"与主机和交换机交互 启动最小拓扑并输入 CLI： 1 $ sudo mn 默认拓扑是minimal拓扑结构，包括一个OpenFlow内核交换机连接到两个主机，加上OpenFlow参考控制器。此拓扑也可以在命令行上使用–topo=minimal. 开箱即用的其他拓扑也可用；请参阅–topo的输出中的部分mn -h。 如果没有特定的测试作为参数传递，Mininet CLI 就会出现。 在 Wireshark 窗口中，您应该看到内核交换机连接到参考控制器。 显示 Mininet CLI 命令： 1 mininet\u003e help 显示节点： 1 mininet\u003e nodes 显示链接： 1 mininet\u003e net 转储(打印)有关所有节点的信息： 1 mininet\u003e dump 应该会看到列出的交换机和两台主机。 如果在 Mininet CLI 中输入的第一个字符串是主机、交换机或控制器名称，则该命令将在该节点上执行： 1 mininet\u003e h1 ifconfig -a 会看到主机h1-eth0和环回 ( lo) 接口。 h1-eth0 在运行时不会被主 Linux 系统看到，因为它特定于主机进程的网络命名空间。相比之下，交换机默认运行在根网络命名空间中，因此在“交换机”上运行命令与从常规终端运行命令相同： 1 mininet\u003e s1 ifconfig -a 这将显示交换机接口，以及 VM 的连接输出( eth0)。 –innamespace选项可以将每个主机、交换机和控制器都放在自己独立的网络名称空间中，常用于构建复杂的多控制器网络 只有网络是虚拟化的；每个主机可以看到同一组进程和使用同一个文件目录（即python脚本运行的目录或者运行mn命令行所在的目录） Linux 容器可以使用单独的进程空间，但目前 Mininet 不这样做。让一切都在“根”进程命名空间中运行便于调试，因为它允许您使用ps、kill等从控制台查看所有进程。 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/:1:3","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-mininet演练","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/"},{"categories":["Python"],"content":"测试主机之间的连通性 1 mininet\u003e h1 ping -c 1 h2 如果命令后面出现一个字符串和节点名称，则该节点名称将替换为它的 IP 地址；这发生在 h2 上。 您应该看到 OpenFlow 控制流量。第二个 MAC 地址的第一个主机 ARP，这会导致packet_in消息转到控制器。然后，控制器发送一条packet_out消息，将广播数据包泛洪到交换机上的其他端口（在本例中，是唯一的其他数据端口）。第二台主机看到 ARP 请求并发送回复。该回复到达控制器，控制器将其发送到第一台主机并下推流条目。 由于ovs的地址是127.0.0.1属于回环地址，所以wireshark监听lo就可以看到openflow发出去的数据包。 现在第一台主机知道第二台主机的 MAC 地址，并且可以通过 ICMP Echo Request 发送它的 ping。该请求及其来自第二台主机的相应回复都进入控制器并导致流条目被下推（连同实际数据包被发送出去）。 第一次ping\r重复上一个ping： 1 mininet\u003e h1 ping -c 1 h2 第二次尝试的时间应该短得多ping(\u003c 100us)。之前在交换机中安装了涵盖ICMPping流量的流表项，因此没有产生控制流量，数据包立即通过交换机。 第二次ping\r运行此测试的更简单方法是使用 Mininet CLI 内置pingall命令，该命令执行所有主机对ping： 1 mininet\u003e pingall ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/:1:4","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-mininet演练","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/"},{"categories":["Python"],"content":"运行一个简单的 Web 服务器和客户端 ping不是您可以在主机上运行的唯一命令，Mininet 主机可以运行底层 Linux 系统（或 VM）及其文件系统可用的任何命令或应用程序。还可以输入任何bash命令，包括作业控制（\u0026、jobs、kill等。） 尝试在 h1 上启动一个简单的 HTTP 服务器，从 h2 发出请求，然后关闭 Web 服务器： 1 2 3 4 mininet\u003e h1 python -m http.server 80 \u0026 mininet\u003e h2 wget -O - h1 ... mininet\u003e h1 kill %python 注意：对于 Python 3，HTTP 服务器称为http.server; 对于 Python 2，它被称为SimpleHTTPServer。 退出 CLI： 1 mininet\u003e exit ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/:1:5","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-mininet演练","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/"},{"categories":["Python"],"content":"清理 如果 Mininet 由于某种原因崩溃，请清理它： 1 $ sudo mn -c ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/:1:6","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-mininet演练","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/"},{"categories":["Python"],"content":"第 2 部分：高级启动选项 以下内容都是通过选项来修改默认mn命令的高级用法，但是这些高级用法可以在python里面有对应的api，推荐直接使用python脚本，不要或较少使用选项方式 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/:2:0","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-mininet演练","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/"},{"categories":["Python"],"content":"运行回归测试 您不需要进入 CLI；Mininet 也可用于运行独立的回归测试。 运行回归测试： 1 $ sudo mn --test pingpair 该命令创建了一个最小拓扑，启动了 OpenFlow 参考控制器，运行了所有对ping测试，并拆除了拓扑和控制器。 另一个有用的测试是iperf（给它大约 10 秒来完成）： 1 $ sudo mn --test iperf 此命令创建相同的 Mininet，在一台主机上运行 iperf 服务器，在第二台主机上运行 iperf 客户端，并解析所达到的带宽。 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/:2:1","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-mininet演练","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/"},{"categories":["Python"],"content":"更改拓扑大小和类型 默认拓扑是连接到两个主机的单个交换机。您可以使用–topo将其更改为不同的拓扑，并为该拓扑的创建传递参数。例如，验证一台交换机和三台主机的所有对 ping 连接： 运行回归测试： 1 $ sudo mn --test pingall --topo single,3 另一个示例，使用线性拓扑（其中每个交换机都有一个主机，并且所有交换机连接成一条线）： 1 $ sudo mn --test pingall --topo linear,4 参数化拓扑是 Mininet 最有用和最强大的特性之一。 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/:2:2","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-mininet演练","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/"},{"categories":["Python"],"content":"链接变体 Mininet 2.0 允许您设置链接参数，这些甚至可以从命令行自动设置： 1 2 3 4 $ sudo mn --link tc,bw=10,delay=10ms mininet\u003e iperf ... mininet\u003e h1 ping -c10 h2 如果每条链路的延迟为 10 毫秒，则往返时间 (RTT) 应约为 40 毫秒，因为 ICMP 请求遍历两条链路（一条到交换机，一条到目的地）并且 ICMP 回复遍历两条返回的链路. 您可以使用Mininet 的 Python API自定义每个链接 ，但现在您可能想要继续演练。 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/:2:3","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-mininet演练","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/"},{"categories":["Python"],"content":"可调输出粒度 默认的详细级别是info，它打印 Mininet 在启动和拆卸期间正在做什么。将此与带有参数-v的完整debug输出进行比较： 1 2 3 $ sudo mn -v debug ... mininet\u003e exit 将打印出许多额外的细节。现在试试output，一个打印 CLI 输出的设置，除此之外别无其他： 1 2 $ sudo mn -v output mininet\u003e exit 在 CLI 之外，可以使用其他详细级别，例如warning，它与回归测试一起使用以隐藏不需要的函数输出。 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/:2:4","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-mininet演练","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/"},{"categories":["Python"],"content":"自定义拓扑 也可以使用简单的 Python API 轻松定义自定义拓扑，并且在custom/topo-2sw-2host.py. 此示例直接连接两个交换机，每个交换机有一个主机 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \"\"\"Custom topology example Two directly connected switches plus a host for each switch: host --- switch --- switch --- host Adding the 'topos' dict with a key/value pair to generate our newly defined topology enables one to pass in '--topo=mytopo' from the command line. \"\"\" from mininet.topo import Topo class MyTopo( Topo ): \"Simple topology example.\" def build( self ): \"Create custom topo.\" # Add hosts and switches leftHost = self.addHost( 'h1' ) rightHost = self.addHost( 'h2' ) leftSwitch = self.addSwitch( 's3' ) rightSwitch = self.addSwitch( 's4' ) # Add links self.addLink( leftHost, leftSwitch ) self.addLink( leftSwitch, rightSwitch ) self.addLink( rightSwitch, rightHost ) topos = { 'mytopo': ( lambda: MyTopo() ) } 当提供自定义 mininet 文件时，它可以向命令行添加新拓扑、交换机类型和测试。例如： 1 $ sudo mn --custom ~/mininet/custom/topo-2sw-2host.py --topo mytopo --test pingall ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/:2:5","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-mininet演练","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/"},{"categories":["Python"],"content":"ID = MAC 默认情况下，主机以随机分配的 MAC 地址开头。这会使调试变得困难，因为每次创建 Mininet 时，MAC 都会发生变化，因此很难将控制流量与特定主机相关联。 该–mac选项非常有用，它将主机 MAC 和 IP 地址设置为小的、唯一的、易于阅读的 ID。 1 2 3 4 5 6 7 8 9 10 11 $ sudo mn ... mininet\u003e h1 ifconfig h1-eth0 Link encap:Ethernet HWaddr f6:9d:5a:7f:41:42 inet addr:10.0.0.1 Bcast:10.255.255.255 Mask:255.0.0.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:6 errors:0 dropped:0 overruns:0 frame:0 TX packets:6 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:392 (392.0 B) TX bytes:392 (392.0 B) mininet\u003e exit 1 2 3 4 5 6 7 8 9 10 11 $ sudo mn --mac ... mininet\u003e h1 ifconfig h1-eth0 Link encap:Ethernet HWaddr 00:00:00:00:00:01 inet addr:10.0.0.1 Bcast:10.255.255.255 Mask:255.0.0.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B) mininet\u003e exit 相反，Linux 报告的交换机数据端口的 MAC 将保持随机。这是因为您可以使用 OpenFlow 将 MAC“分配”到数据端口，如常见问题解答中所述。这是一个有点微妙的问题，您现在可以忽略它。 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/:2:6","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-mininet演练","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/"},{"categories":["Python"],"content":"XTerm 显示 其实更推荐使用命令mx：mx h1。这个命令能快速登录一个host的root用户。 对于更复杂的调试，您可以启动 Mininet 以便它生成一个或多个 xterms。 要为每个主机和交换机启动一个xterm，请传递以下-x选项： 1 $ sudo mn -x 一秒钟后，xterms 将弹出，并自动设置窗口名称。 或者，您可以调出额外的 xterms，如下所示。 默认情况下，只有主机被放在一个单独的命名空间中；每个交换机的窗口都是不必要的（即，相当于一个常规终端），但可以方便地运行和离开交换机调试命令，例如流计数器转储。 Xterms 对于运行您可能需要取消的交互式命令也很有用，您希望看到这些命令的输出。 例如：在标有“switch: s1 (root)”的 xterm 中，运行： 1 # ovs-ofctl dump-flows tcp:127.0.0.1:6654 什么都不会打印出来；交换机没有添加流。要ovs-ofctl与其他交换机使用，请以详细模式启动 mininet，并在创建交换机时查看交换机的被动侦听端口。 现在，在标有“host: h1”的 xterm 中，运行： 1 # ping 10.0.0.2 返回s1并转储流：# ovs-ofctl dump-flows tcp:127.0.0.1:6654 您现在应该看到多个流条目。或者（通常更方便），您可以使用Mininet CLI 中内置的命令dpctl，而无需任何 xterms 或手动指定交换机的 IP 和端口。 您可以通过检查 ifconfig 来判断 xterm 是否在根名称空间中；如果显示所有接口（包括eth0），则它位于根名称空间中。此外，其标题应包含“(root)”。 从 Mininet CLI 关闭设置： 1 mininet\u003e exit xterms 应该会自动关闭。 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/:2:7","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-mininet演练","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/"},{"categories":["Python"],"content":"其他交换机类型 可以使用其他交换机类型。例如，要运行用户空间交换机： 1 $ sudo mn --switch user --test iperf 请注意，与之前使用内核开关看到的相比，TCP iperf 报告的带宽要低得多。 如果您进行前面所示的 ping 测试，您应该注意到更高的延迟，因为现在数据包必须经受额外的内核到用户空间的转换。ping 时间将更加可变，因为代表主机的用户空间进程可能由操作系统安排进出。 另一方面，用户空间切换可以是实现新功能的一个很好的起点，尤其是在软件性能不重要的情况下。 另一个示例交换机类型是 Open vSwitch (OVS)，它预装在 Mininet VM 上。iperf 报告的 TCP 带宽应该类似于 OpenFlow 内核模块，并且可能更快： 1 $ sudo mn --switch ovsk --test iperf ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/:2:8","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-mininet演练","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/"},{"categories":["Python"],"content":"mininet基准 要记录设置和拆除拓扑的时间，请使用测试“none”： 1 $ sudo mn --test none ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/:2:9","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-mininet演练","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/"},{"categories":["Python"],"content":"一切都在自己的命名空间中（仅限用户切换） 默认情况下，主机位于它们自己的命名空间中，而交换机和控制器位于根命名空间中。要将交换机放在它们自己的命名空间中，请传递以下–innamespace选项： 1 $ sudo mn --innamespace --switch user 交换机将通过单独的桥接控制连接与控制器通信，而不是使用环回。这个选项本身并不是很有用，但它确实提供了一个如何隔离不同交换机的示例。 请注意，此选项（自 2012 年 11 月 19 日起）不适用于 Open vSwitch。 1 mininet\u003e exit ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/:2:10","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-mininet演练","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/"},{"categories":["Python"],"content":"第 3 部分：Mininet 命令行界面 (CLI) 命令 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/:3:0","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-mininet演练","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/"},{"categories":["Python"],"content":"显示选项 要查看命令行界面 (CLI) 选项列表，请启动最小拓扑并使其保持运行状态。构建迷你网： 1 $ sudo mn 显示选项： 1 mininet\u003e help ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/:3:1","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-mininet演练","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/"},{"categories":["Python"],"content":"Python解释器 如果 Mininiet 命令行上的第一个短语是py，那么该命令将使用 Python 执行。这可能对扩展 Mininet 以及探索其内部工作机制很有用。每个主机、交换机和控制器都有一个关联的节点对象。 在 Mininet CLI 中，运行： 1 mininet\u003e py 'hello ' + 'world' 打印可访问的局部变量： 1 mininet\u003e py locals() 接下来，使用 dir() 函数查看节点可用的方法和属性： 1 mininet\u003e py dir(s1) 您可以使用 help() 函数阅读节点上可用方法的联机文档： 1 mininet\u003e py help(h1) (Press \"q\" to quit reading the documentation.) 您还可以评估变量的方法： 1 mininet\u003e py h1.IP() ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/:3:2","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-mininet演练","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/"},{"categories":["Python"],"content":"链接up/down 开启关闭 对于容错测试，打开和关闭链接会很有帮助。 要禁用虚拟以太网对： 1 mininet\u003e link s1 h1 down 这里h1和h2能ping通s1，原因是s1转换的ip地址是127.0.0.1所以他们相当于给自己发包（回环），所以能通。 您应该会看到生成了 OpenFlow 端口状态更改通知。要恢复链接： 1 mininet\u003e link s1 h1 up ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/:3:3","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-mininet演练","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/"},{"categories":["Python"],"content":"XTerm 显示 显示 h1 和 h2 的 xterm： 1 mininet\u003e xterm h1 h2 也可以使用mx命令直接登录h1和h2 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/:3:4","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-mininet演练","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/"},{"categories":["Python"],"content":"第 4 部分：Python API 示例 Mininet 源代码树中的示例目录包括如何使用 Mininet 的 Python API 的示例，以及尚未集成到主代码库中的潜在有用代码。 注意：如开头所述，本演练假定您正在使用 Mininet VM，其中包括您需要的一切，或者使用所有相关工具的本机安装，包括参考控制器controller，它是 OpenFlow 参考实现的一部分install.sh -f如果尚未安装，则可以使用安装。 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/:4:0","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-mininet演练","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/"},{"categories":["Python"],"content":"每个主机的 SSH 守护进程 建议使用mx命令 一个可能特别有用的示例在每台主机上运行 SSH 守护进程： 1 $ sudo ~/mininet/examples/sshd.py 从另一个终端，您可以通过 ssh 连接到任何主机并运行交互式命令： 1 2 3 4 $ ssh 10.0.0.1 $ ping 10.0.0.2 ... $ exit 退出 SSH 示例 mininet： 1 $ exit 在阅读介绍 Python API 的Mininet 简介后，您将希望重新访问这些示例 。 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/:4:1","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-mininet演练","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/"},{"categories":["Python"],"content":"第 5 部分：演练完成！ 恭喜！您已经完成了 Mininet 演练。随意尝试新的拓扑结构和控制器或查看源代码。 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/:5:0","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-mininet演练","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/"},{"categories":["Python"],"content":"掌握 Mininet 的后续步骤 虽然您可以使用 Mininet 的 CLI 走得相当远，但是当您掌握了它的 Python API 后，Mininet 会变得更加有用和强大。Mininet 简介 介绍了 Mininet 及其 Python API。 如果您想知道如何使用远程控制器（例如在 Mininet 的控制之外运行的远程控制器），下面将对此进行解释。 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/:5:1","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-mininet演练","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/"},{"categories":["Python"],"content":"附录：补充信息 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/:6:0","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-mininet演练","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/"},{"categories":["Python"],"content":"使用控制器 注意：此步骤不是默认演练的一部分；如果您有一个在 VM 外部运行的控制器，例如在 VM 主机或不同的物理 PC 上，它主要有用。OpenFlow 教程controller –remote用于启动您使用 POX、NOX、Beacon 或 Floodlight 等控制器框架创建的简单学习交换机。 当你启动一个 Mininet 网络时，每个交换机都可以连接到一个远程控制器——它可以在 VM 中、VM 外部和你的本地机器上，或者在世界的任何地方。 如果你想尝试这个，填写主机 IP 和/或监听端口： 1 $ sudo mn --controller=remote,ip=[controller IP],port=[controller listening port] 例如，要运行 POX 的示例学习开关，您可以执行类似 1 2 $ cd ~/pox $ ./pox.py forwarding.l2_learning 在一个窗口中，在另一个窗口中，启动 Mininet 以连接到“远程”控制器（它实际上在本地运行，但不受 Mininet 的控制）： 1 $ sudo mn --controller=remote,ip=127.0.0.1,port=6633 请注意，POX 使用旧的 OpenFlow 端口 6633，该端口未注册，后来被 Cisco 占用。OpenFlow 的当前注册/规范端口是端口 6653。请为您的控制器使用适当的端口号。 默认情况下，–controller=remote将使用127.0.0.1并将尝试端口6653和6633。 如果您生成一些流量（例如h1 ping h2），您应该能够在 POX 窗口中观察到一些输出，表明交换机已连接并且一些流表条目已安装。 许多 OpenFlow 控制器框架很容易获得，只要您启动它们并使用 remote控制器运行所在机器的正确 IP 地址和它正在侦听的正确端口指定控制器选项，就应该很容易与 Mininet 一起工作。 有许多可用的 OpenFlow 控制器，您可以使用 Google 或您最喜欢的搜索引擎轻松找到更多控制器。一些流行的包括（按代码大小、功能和复杂性的近似顺序）： Ryu，一个用 Python 编写的基本（有点像 POX）OpenFlow 控制器框架 FAUCET，一个控制器（也是用 Python 编写的，基于 Ryu 框架），通过一个简单的 YML 配置文件支持以太网交换和 IP 路由以及其他功能 ONOS，一个功能齐全的网络操作系统，用 Java 编写 OpenDaylight，“最大的开源 SDN 控制器” 所有这些控制器都可以与 Mininet 或硬件网络一起使用。 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/:6:1","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-mininet演练","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/"},{"categories":["Python"],"content":"Ryu Ryu是一个用 Python 编写的基本 OpenFlow 控制器框架。它在 Mininet 中是开箱即用的： 1 2 $ sudo pip3 install ryu # install ryu if it's not already installed $ sudo mn --controller ryu 这将运行ryu.app.simple_switch。 您还可以在mn命令行中指定 Ryu 应用程序： 1 $ sudo mn --controller,ryu.app.simple_switch_13 您还可以将 Ryu 作为远程控制器运行。 在一个窗口中： 1 $ ryu run ryu.app.simple_switch 然后在另一个窗口中： 1 $ sudo mn --controller remote ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/:6:2","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-mininet演练","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E6%BC%94%E7%BB%83/"},{"categories":["Python"],"content":"mininet官网 mininet官网文档 mininet官网api mininet官网工作流 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%A4%BA%E4%BE%8B%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/:0:0","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Mininet示例工作流程","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%A4%BA%E4%BE%8B%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"},{"categories":["Python"],"content":"创建网络 使用单个命令创建网络 在 OpenFlow/Stanford 参考控制器的控制下使用 Open vSwitch 交换机启动深度为 2 和扇出为 8 的树状拓扑结构的网络（即 64 台主机连接到 9 台交换机），并运行pingall测试以检查每对节点之间的连接性. sudo mn --switch ovs --controller ref --topo tree,depth=2,fanout=8 --test pingall ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%A4%BA%E4%BE%8B%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/:1:0","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Mininet示例工作流程","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%A4%BA%E4%BE%8B%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"},{"categories":["Python"],"content":"与网络互动 Mininet 的 CLI 允许您从单个控制台控制和管理整个虚拟网络 告诉主机h2 ping 主机h3的 IP 地址。 mininet\u003e h2 ping h3 任何可用的 Linux 命令或程序都可以在任何虚拟主机上运行。您可以轻松地在一台主机上启动 Web 服务器并从另一台主机发出 HTTP 请求： mininet\u003e h2 python -m SimpleHTTPServer 80 \u003e\u0026 /tmp/http.log \u0026\rmininet\u003e h3 wget -O - h2 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%A4%BA%E4%BE%8B%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/:2:0","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Mininet示例工作流程","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%A4%BA%E4%BE%8B%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"},{"categories":["Python"],"content":"自定义网络 Mininet 的 API 允许您使用几行 Python 创建自定义网络。例如，下面的脚本 from mininet.net import Mininet\rfrom mininet.topolib import TreeTopo\rtree4 = TreeTopo(depth=2,fanout=2)\rnet = Mininet(topo=tree4)\rnet.start()\rh1, h4 = net.hosts[0], net.hosts[3]\rprint h1.cmd('ping -c1 %s' % h4.IP())\rnet.stop() 创建一个小型网络（4 台主机，3 台交换机），并从一台主机 ping 另一台主机 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%A4%BA%E4%BE%8B%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/:3:0","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Mininet示例工作流程","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%A4%BA%E4%BE%8B%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"},{"categories":["Python"],"content":"共享网络 Mininet 作为虚拟机 (VM) 映像分发，所有依赖项均已预安装，可在 VMware、Xen 和 VirtualBox 等常见虚拟机监视器上运行。这为分发提供了一个方便的容器；一旦原型被开发出来，VM 映像就可以分发给其他人运行、检查和修改。 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%A4%BA%E4%BE%8B%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/:4:0","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Mininet示例工作流程","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%A4%BA%E4%BE%8B%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"},{"categories":["Python"],"content":"在硬件上运行 一旦设计在 Mininet 上运行，就可以将其部署在硬件上以供实际使用、测试和测量。 为了在第一次尝试时成功移植到硬件，每个 Mininet 仿真组件必须以与其对应的物理组件相同的方式运行。虚拟拓扑应该与物理拓扑相匹配；虚拟以太网对必须替换为链路级以太网连接。模拟为进程的主机应替换为具有自己的操作系统映像的主机。此外，每个模拟的 OpenFlow 交换机都应替换为配置为指向控制器的物理交换机。但是，控制器不需要更改。当 Mininet 运行时，控制器“看到”一个物理交换机网络，这是通过具有明确定义的状态语义的接口实现的。 ","date":"2022-11-29","objectID":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%A4%BA%E4%BE%8B%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/:5:0","tags":["mininet","Python第三方库"],"title":"Python-第三方库-mininet-Mininet示例工作流程","uri":"/posts/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/mininet/mininet%E7%A4%BA%E4%BE%8B%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"},{"categories":["通用技术"],"content":"知乎文章 127.0.0.1 是一个环回地址。并不表示“本机”。0.0.0.0才是真正表示“本网络中的本机”。 一台服务器，一个外放地址A,一个内网地址B， 绑定的端口指定了0.0.0.0，那么通过内网地址或外网地址都可以访问我的应用 绑定了内网地址，那么通过外网地址就不能访问 127.0.0.1只到内核的协议栈，0000要走一趟网卡，网卡中断 ","date":"2022-11-15","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%9C%AC%E5%9C%B0%E6%B5%8B%E8%AF%95%E5%9C%B0%E5%9D%80%E5%8C%BA%E5%88%AB/:0:0","tags":[],"title":"通用技术-本地测试地址区别","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%9C%AC%E5%9C%B0%E6%B5%8B%E8%AF%95%E5%9C%B0%E5%9D%80%E5%8C%BA%E5%88%AB/"},{"categories":["Golang"],"content":"本系列为作者跟着Mikaelemmmm的b站教学视频学习时做的笔记 go zero 为一个微服务框架 比gin web框架更强大。 必看资料： 公众号：微服务实践 go-zero-example: https://github.com/zeromicro/zero-examples zero-contrib: https://github.com/zeromicro/zero-contrib 微信社区群 go-zero-issue: https://github.com/zeromicro/go-zero/issues ","date":"2022-11-14","objectID":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:0:0","tags":["go-zero"],"title":"golang-go-zero-个人笔记","uri":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["Golang"],"content":"指令 指令页面 指令大全 ","date":"2022-11-14","objectID":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:1:0","tags":["go-zero"],"title":"golang-go-zero-个人笔记","uri":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["Golang"],"content":"API 1 goctl api go -api user.api -dir ../ -style goZero ","date":"2022-11-14","objectID":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:1:1","tags":["go-zero"],"title":"golang-go-zero-个人笔记","uri":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["Golang"],"content":"RPC 1 2 3 goctl rpc template -o=user.proto goctl rpc protoc user.proto --go_out=../ --go-grpc_out=../ --zrpc_out=../ --style=goZero ","date":"2022-11-14","objectID":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:1:2","tags":["go-zero"],"title":"golang-go-zero-个人笔记","uri":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["Golang"],"content":"MODEL 1 2 3 goctl model mysql ddl -src=\"./*.sql\" -dir=\"./sql/model\" -c $ goctl model mysql datasource -url=\"user:password@tcp(127.0.0.1:3306)/database\" -table=\"*\" -dir=\"./model\" ","date":"2022-11-14","objectID":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:1:3","tags":["go-zero"],"title":"golang-go-zero-个人笔记","uri":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["Golang"],"content":"TEMPLATE 1 2 3 goctl template init --home $HOME/template goctl rpc new greet --home $HOME/template ","date":"2022-11-14","objectID":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:1:4","tags":["go-zero"],"title":"golang-go-zero-个人笔记","uri":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["Golang"],"content":"docker 1 goctl docker -go hello.go ","date":"2022-11-14","objectID":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:1:5","tags":["go-zero"],"title":"golang-go-zero-个人笔记","uri":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["Golang"],"content":"protoc 1 protoc -I ./ --go_out=paths=source_relative:. --go-grpc_out=paths=source_relative:. userModel.proto ","date":"2022-11-14","objectID":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:1:6","tags":["go-zero"],"title":"golang-go-zero-个人笔记","uri":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["Golang"],"content":"小技巧 很多不知道咋写的地方可以直接进入对象源码里面去看看，特别是zero内置的置对象，源码里面有注释，没注释的看看名称也知道是什么 ","date":"2022-11-14","objectID":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:2:0","tags":["go-zero"],"title":"golang-go-zero-个人笔记","uri":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["Golang"],"content":"threading包 使用threading包，不要使用原生goroutine，如果goroutine出现panic是无法recover的。而threading会自动在goroutine启动时使用recover。threading包还有很多安全的api，不要自己使用go原生的，如waitgroup等。 ","date":"2022-11-14","objectID":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:3:0","tags":["go-zero"],"title":"golang-go-zero-个人笔记","uri":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["Golang"],"content":"proto文件注意事项 微服务时间戳可以直接用int64，使用time.Unix()来转换，没有必要使用第三方库。该什么类型就使用什么类型，把proto文件尽量简化（就像看文档一样）。any也尽量少用，类型尽量是具体的。 goland中proto文件import标红时选择它默认的解决办法（小灯泡）就行了。多个proto导入时，先将没有service的用protoc语句先自己生成：protoc -I ./ --go_out=paths=source_relative:. --go-grpc_out=paths=source_relative:. userModel.proto 然后有service的使用goctl生成：goctl.exe rpc protoc .\\user.proto --go_out=../ --go-grpc_out=../ --zrpc_out=../ --style=goZero 坑：yaml里面需要配置Mode:dev才能使用grpcui 微服务一般把model放到rpc里面，api里面只调用接口。如果规模变大，可以把model放外面，api调rpc接口，rpc调model接口。如果想约束数据库操作可以将model放到rpc的internal里面。 api与rpc连接方式：直连，etcd，k8s ","date":"2022-11-14","objectID":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:4:0","tags":["go-zero"],"title":"golang-go-zero-个人笔记","uri":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["Golang"],"content":"template goctl源码里面有使用templete生成代码，默认使用的是goctl里面tmpl里面的文件，你可以使用命令goctl templete init --home=xxx 来生成自己的tmpl，它会把goctl里面的文件复制到xxx下，如果不使用–home选项默认会生成到用户目录下的.goctl文件夹下，并且在后面如果goctl生成代码时不指定home选项就会使用该文件夹下的tmpl文件。之后就可以修改自己的tmpl文件。注意由于使用的是tmplete包的excute函数，所以每个文件能使用的变量都是不一样的，不要自己造变量。通常情况下这个用法可以解决引入包，或者添加校验等问题。使用的goctl版本号要和tmpl所在文件目录名对应。 ","date":"2022-11-14","objectID":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:5:0","tags":["go-zero"],"title":"golang-go-zero-个人笔记","uri":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["Golang"],"content":"go-zero超时配置 超时有三个地方配置： api，rpc的server还有rpc的client ","date":"2022-11-14","objectID":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:6:0","tags":["go-zero"],"title":"golang-go-zero-个人笔记","uri":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["Golang"],"content":"NonBlock 另外rpc的client的NonBlock选项默认为false，必须等依赖的rpc启动后自己才能启动，设置为true后可以不等依赖启动 ","date":"2022-11-14","objectID":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:7:0","tags":["go-zero"],"title":"golang-go-zero-个人笔记","uri":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["Golang"],"content":"yaml文件格式 yaml文件与config.go对应规则遵循匿名字段的规则，及匿名字段的属性可以在结构体上直接访问，另外yaml的短横线-表示切片的元素 ","date":"2022-11-14","objectID":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:8:0","tags":["go-zero"],"title":"golang-go-zero-个人笔记","uri":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["Golang"],"content":"Postman的example Postman的example可以记录一对请求和响应结果 ","date":"2022-11-14","objectID":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:9:0","tags":["go-zero"],"title":"golang-go-zero-个人笔记","uri":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["Golang"],"content":"go-zero负载均衡 go-zero底层负载均衡使用p2c算法，使用EWMA计算服务器繁忙负载率 p2c：Pick of 2 choices，从可用节点列表中随机选择两个节点，选择负载率较低的进行请求 简书 千杉沐雪 ","date":"2022-11-14","objectID":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:10:0","tags":["go-zero"],"title":"golang-go-zero-个人笔记","uri":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["Golang"],"content":"sqlx中timestamp的空值问题 博客园 jackluo 对应go中的time.Time，空值为nil，但是nil可能会报错，可以直接去掉这个字段。另外通过字段上面加上 .omitempty 标签也可以解决这个问题。 ","date":"2022-11-14","objectID":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:11:0","tags":["go-zero"],"title":"golang-go-zero-个人笔记","uri":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["Golang"],"content":"mysql注意事项 一定要配置utf8mb4 1 root:password@/name?parseTime=True\u0026loc=Local\u0026charset=utf8mb4\u0026collation=utf8mb4_unicode_ci ","date":"2022-11-14","objectID":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:12:0","tags":["go-zero"],"title":"golang-go-zero-个人笔记","uri":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["Golang"],"content":"关于返回数组 github api语法 go-zero支持保留golang关键字，不支持time.Time数据类型，用int64表示 1 2 3 4 5 6 7 8 9 10 RecommendRequest { Cursor int64 `json:\"cursor\"` Ps int64 `form:\"ps,default=20\"` // 每页大小 } RecommendResponse { Products []*Product `json:\"products\"` IsEnd bool `json:\"is_end\"` // 是否最后一页 RecommendTime int64 `json:\"recommend_time\"` // 商品列表最后一个商品的推荐时间 } ","date":"2022-11-14","objectID":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:13:0","tags":["go-zero"],"title":"golang-go-zero-个人笔记","uri":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["Golang"],"content":"dtm dtm官网 Mikealmmmm dtm保姆级教程核心代码 ","date":"2022-11-14","objectID":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:14:0","tags":["go-zero"],"title":"golang-go-zero-个人笔记","uri":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["Golang"],"content":"基础 安装运行DTM docker安装 1 docker run -itd --name dtm -p 36789:36789 -p 36790:36790 yedf/dtm:latest 二进制包下载安装 执行命令./dtm 即可运行 快速开始 DTM是什么：DTM是一款开源的分布式事务管理器，解决跨数据库、跨服务、跨语言栈更新数据的一致性问题。 示例详解 接入代码 1 2 3 4 5 6 7 8 9 10 11 12 // 具体业务微服务地址 const qsBusi = \"http://localhost:8081/api/busi_saga\" req := \u0026gin.H{\"amount\": 30} // 微服务的载荷 // DtmServer为DTM服务的地址，是一个url DtmServer := \"http://localhost:36789/api/dtmsvr\" saga := dtmcli.NewSaga(DtmServer, shortuuid.New()). // 添加一个TransOut的子事务，正向操作为url: qsBusi+\"/TransOut\"， 补偿操作为url: qsBusi+\"/TransOutCompensate\" Add(qsBusi+\"/TransOut\", qsBusi+\"/TransOutCompensate\", req). // 添加一个TransIn的子事务，正向操作为url: qsBusi+\"/TransIn\"， 补偿操作为url: qsBusi+\"/TransInCompensate\" Add(qsBusi+\"/TransIn\", qsBusi+\"/TransInCompensate\", req) // 提交saga事务，dtm会完成所有的子事务/回滚所有的子事务 err := saga.Submit() 时序图： 成功 失败 ","date":"2022-11-14","objectID":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:14:1","tags":["go-zero"],"title":"golang-go-zero-个人笔记","uri":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["Golang"],"content":"接入参考 go-zero对接 dtm配置，在dtm项目文件夹下生成配置文件 1 cp conf.sample.yml conf.yml 如果使用etcd就将配置中的以下代码解开注释 MicroService:\rDriver: 'dtm-driver-gozero' # name of the driver to handle register/discover\rTarget: 'etcd://localhost:2379/dtmservice' # register dtm server to this url\rEndPoint: 'localhost:36790' 开发接入 main.go 1 2 // 下面这行导入gozero的dtm驱动 import _ \"github.com/dtm-labs/driver-gozero\" logic 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // dtm已经通过前面的配置，注册到下面这个地址，因此在dtmgrpc中使用该地址 var dtmServer = \"etcd://localhost:2379/dtmservice\" // 下面从配置文件中Load配置，然后通过BuildTarget获得业务服务的地址 var c zrpc.RpcClientConf conf.MustLoad(*configFile, \u0026c) busiServer, err := c.BuildTarget() // 使用dtmgrpc生成一个消息型分布式事务并提交 gid := dtmgrpc.MustGenGid(dtmServer) msg := dtmgrpc.NewMsgGrpc(dtmServer, gid). // 事务的第一步为调用trans.TransSvcClient.TransOut // 可以从trans.pb.go中找到上述方法对应的Method名称为\"/trans.TransSvc/TransOut\" // dtm需要从dtm服务器调用该方法，所以不走强类型 // 而是走动态的url: busiServer+\"/trans.TransSvc/TransOut\" Add(busiServer+\"/trans.TransSvc/TransOut\", \u0026busi.BusiReq{Amount: 30, UserId: 1}). Add(busiServer+\"/trans.TransSvc/TransIn\", \u0026busi.BusiReq{Amount: 30, UserId: 2}) // 上面这个是两阶段消息的形式，在Mikealm的程序里面的SAGA形式是这么写的： // saga := dtmgrpc.NewSagaGrpc(dtmServer, gid). // Add(orderRpcBusiServer+\"/pb.order/create\", orderRpcBusiServer+\"/pb.order/createRollback\", createOrderReq). // Add(stockRpcBusiServer+\"/pb.stock/deduct\", stockRpcBusiServer+\"/pb.stock/deductRollback\", deductReq) err := msg.Submit() 注意事项 rpc服务的pb路径 在order-api的logic中，调用后端rpc服务时候，找到rpc的pb路径时，一定要找pb.go文件中invoke的路径，因为grpc在生成pb文件时候下方也有一堆有路径的，一定要找到invoke那个路径 正确的 dtm的回滚补偿 在使用dtm的grpc时候，在grpc中的服务发生错误了，希望执行后面的rollback必须返回 ： status.Error(codes.Aborted, dtmcli.ResultFailure) ， 返回其他错误，不会执行你的rollback操作，dtm会一直重试，如下图： barrier的空补偿、悬挂等 barrier库在准备工作中已经建立了 每个与db交互的服务只要用到了barrier，那要给这个服务使用到的mysql账号分配barrier库的权限 barrier在rpc中本地事务 使用了barrier，model中与db交互时候必须要用事务，并且一定要跟barrier用同一个事务 logic： model： ","date":"2022-11-14","objectID":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/:14:2","tags":["go-zero"],"title":"golang-go-zero-个人笔记","uri":"/posts/golang/go-zero/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"},{"categories":["云原生"],"content":"docker 官网 docker 官方文档 docker 参考文档 dockerfile 参考 本文是作者在跟着docker官网go开发学习时做的笔记，可能不够详尽，有需要的同学请自己去官网查看 ","date":"2022-11-08","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/:0:0","tags":["docker"],"title":"云原生-docker-golang开发","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/"},{"categories":["云原生"],"content":"构建你的 Go 镜像 ","date":"2022-11-08","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/:1:0","tags":["docker"],"title":"云原生-docker-golang开发","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/"},{"categories":["云原生"],"content":"为应用程序创建一个 Dockerfile 首先说明使用的基础镜像 1 2 3 # syntax=docker/dockerfile:1 FROM golang:1.16-alpine 在构建的img中创建一个目录。这也指示 Docker 将此目录用作所有后续命令的默认目标，即后续的相对路径都是基于此目录的。 1 WORKDIR /app 安装编译它所需的模块： 将 go.mod和go.sum文件使用COPY命令复制到其中。 1 2 COPY go.mod ./ COPY go.sum ./ 使用RUN命令执行go mod download命令。 1 RUN go mod download 接下来使用COPY将源代码复制到img中。 1 COPY *.go ./ 该COPY命令使用通配符将位于主机当前目录（Dockerfile所在目录）的所有.go扩展名文件复制到映像内的当前目录（WORKDIR）中。 编译我们的应用程序生成可执行文件 1 RUN go build -o /docker-gs-ping 最后使用CMD命令告诉 Docker 当启动镜像容器时在内部执行什么命令： 1 CMD [ \"/docker-gs-ping\" ] Dockerfile注释以#符号开头，必须位于行首。 Dockerfile指令（例如 syntax是我们添加的指令）以#开头位于Dockerfile的最顶部： ","date":"2022-11-08","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/:1:1","tags":["docker"],"title":"云原生-docker-golang开发","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/"},{"categories":["云原生"],"content":"构建图像 1 docker build -f Dockerfile --tag docker-gs-ping . –tag标志给构建结果添加标签，默认值为atest。 ","date":"2022-11-08","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/:1:2","tags":["docker"],"title":"云原生-docker-golang开发","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/"},{"categories":["云原生"],"content":"查看本地img 1 docker image ls 或缩写 1 docker images ","date":"2022-11-08","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/:1:3","tags":["docker"],"title":"云原生-docker-golang开发","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/"},{"categories":["云原生"],"content":"img标签 1 docker image tag docker-gs-ping:latest docker-gs-ping:v1.0 添加标记不会生成新img，生成的标记指向同一个img id 删除标签 1 2 docker image rm docker-gs-ping:v1.0 Untagged: docker-gs-ping:v1.0 当删除只有latest标签的img会直接删除img ","date":"2022-11-08","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/:1:4","tags":["docker"],"title":"云原生-docker-golang开发","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/"},{"categories":["云原生"],"content":"多阶段构建 使用AS关键字标记非部署img，在完成程序编译之后，使用From关键字引入部署img（不需要额外的指示，docker会自动使用最后引入的img作为最终生成img），将非部署img构建的可执行文件使用COPY拷贝到部署img中，完成构建 Dockerfile.multistage： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # syntax=docker/dockerfile:1 ## Build FROM golang:1.16-buster AS build WORKDIR /app COPY go.mod ./ COPY go.sum ./ RUN go mod download COPY *.go ./ RUN go build -o /docker-gs-ping ## Deploy FROM gcr.io/distroless/base-debian10 WORKDIR / COPY --from=build /docker-gs-ping /docker-gs-ping EXPOSE 8080 USER nonroot:nonroot ENTRYPOINT [\"/docker-gs-ping\"] 1 docker build -t docker-gs-ping:multistage -f Dockerfile.multistage . ","date":"2022-11-08","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/:1:5","tags":["docker"],"title":"云原生-docker-golang开发","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/"},{"categories":["云原生"],"content":"将img作为容器运行 ","date":"2022-11-08","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/:2:0","tags":["docker"],"title":"云原生-docker-golang开发","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/"},{"categories":["云原生"],"content":"概述 1 docker run docker-gs-ping –publish选项（简称-p）设置暴露端口。 –p [host_port]:[container_port] ","date":"2022-11-08","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/:2:1","tags":["docker"],"title":"云原生-docker-golang开发","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/"},{"categories":["云原生"],"content":"以分离模式运行 –detachor选项(简称-d)：将容器“分离”并返回到终端提示符，可以理解为在后台运行容器。 1 2 docker run -d -p 8080:8080 docker-gs-ping d75e61fcad1e0c0eca69a3f767be6ba28a66625ce4dc42201a8a323e8313c14e ","date":"2022-11-08","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/:2:2","tags":["docker"],"title":"云原生-docker-golang开发","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/"},{"categories":["云原生"],"content":"列出容器 1 docker ps -a ","date":"2022-11-08","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/:2:3","tags":["docker"],"title":"云原生-docker-golang开发","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/"},{"categories":["云原生"],"content":"重启、停止、启动和命名容器 重启 1 docker restart inspiring_ishizaka 停止 1 2 docker stop inspiring_ishizaka inspiring_ishizaka 删除 1 2 3 4 5 6 docker rm inspiring_ishizaka wizardly_joliot magical_carson gifted_mestorf inspiring_ishizaka wizardly_joliot magical_carson gifted_mestorf 命名：在从img生成容器的时候使用–name选项给容器名称 1 2 docker run -d -p 8080:8080 --name rest-server docker-gs-ping 3bbc6a3102ea368c8b966e1878a5ea9b1fc61187afaac1276c41db22e4b7f48f ","date":"2022-11-08","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/:2:4","tags":["docker"],"title":"云原生-docker-golang开发","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/"},{"categories":["云原生"],"content":"使用容器进行开发 ","date":"2022-11-08","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/:3:0","tags":["docker"],"title":"云原生-docker-golang开发","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/"},{"categories":["云原生"],"content":"本地数据库和容器 存储 卷(volume)是持久化 Docker 容器生成和使用的数据的首选机制。 创建卷： 1 docker volume create roach 查看卷： 1 docker volume list 网络 创建网络 1 docker network create -d bridge mynet bridge表示桥接网络 查看网络 1 docker network list 启动数据库引擎 1 2 3 4 5 6 7 8 9 10 11 docker run -d \\ --name roach \\ --hostname db \\ --network mynet \\ -p 26257:26257 \\ -p 8080:8080 \\ -v roach:/cockroach/cockroach-data \\ cockroachdb/cockroach:latest-v20.1 start-single-node \\ --insecure # ... output omitted ... 配置数据库引擎 容器内执行命令 1 docker exec -it roach ./cockroach sql --insecure ","date":"2022-11-08","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/:3:1","tags":["docker"],"title":"云原生-docker-golang开发","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/"},{"categories":["云原生"],"content":"使用 Docker Compose 提高生产力 Docker Compose 配置编排容器，将所有参数通过文件的方式声明 .env文件:Docker Compose 自动从该文件中读取环境变量 启动 1 docker-compose up --build –build标志编译我们的img然后run。 关闭 1 docker-compose down 分离模式 1 docker-compose up --build -d ","date":"2022-11-08","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/:3:2","tags":["docker"],"title":"云原生-docker-golang开发","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/"},{"categories":["云原生"],"content":"运行测试 ","date":"2022-11-08","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/:4:0","tags":["docker"],"title":"云原生-docker-golang开发","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/"},{"categories":["云原生"],"content":"配置CI/CD ","date":"2022-11-08","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/:5:0","tags":["docker"],"title":"云原生-docker-golang开发","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/"},{"categories":["云原生"],"content":"部署 见官网 ","date":"2022-11-08","objectID":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/:6:0","tags":["docker"],"title":"云原生-docker-golang开发","uri":"/posts/%E4%BA%91%E5%8E%9F%E7%94%9F/docker/golang%E5%BC%80%E5%8F%91/"},{"categories":["Golang"],"content":" golang官网 李文周（Qimi）博客 go标准库 go语言中文网 go语言圣经 Go 学习路线图，包括基础专栏，进阶专栏，源码阅读，实战开发，面试刷题，必读书单等一系列资源。 go网址导航 GVA开源项目 go-by-example go官网维基 go101 github mao888/golang-guide 地鼠文档 golang修养之路 地鼠文档 GO专家编程 地鼠文档 面试题 地鼠文档 萧十一郎 C语言中文网 go语言中文网站长polarisxu的博客 go程序员面试宝典 地鼠文档 go设计模式 github About go-design-pattern设计模式 图解设计模式 ","date":"2022-10-24","objectID":"/posts/golang/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/:0:0","tags":[],"title":"golang-学习资料汇总","uri":"/posts/golang/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"categories":["通用技术"],"content":"本文来源于阮一峰老师的jwt Token教程 JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案 ","date":"2022-10-22","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/jwt/:0:0","tags":["jwt"],"title":"通用技术-Jwt","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/jwt/"},{"categories":["通用技术"],"content":"跨域认证的问题 互联网服务离不开用户认证。一般流程是下面这样。 用户向服务器发送用户名和密码。 服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。 服务器向用户返回一个 session_id，写入用户的 Cookie。 用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。 服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。 这种模式扩展性（scaling）不好。服务器集群，或者是跨域的服务导向架构要求 session 数据共享，每台服务器都能够读取 session。 ","date":"2022-10-22","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/jwt/:1:0","tags":["jwt"],"title":"通用技术-Jwt","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/jwt/"},{"categories":["通用技术"],"content":"JWT 的原理 JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户。 以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。 服务器不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。 ","date":"2022-10-22","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/jwt/:2:0","tags":["jwt"],"title":"通用技术-Jwt","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/jwt/"},{"categories":["通用技术"],"content":"JWT 的数据结构 JWT是一个很长的字符串，中间用点（.）分隔成三个部分。JWT 内部是没有换行的。三个部分依次如下。 Header（头部） Payload（负载） Signature（签名） 写成一行，Header.Payload.Signature ","date":"2022-10-22","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/jwt/:3:0","tags":["jwt"],"title":"通用技术-Jwt","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/jwt/"},{"categories":["通用技术"],"content":"Header Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。 {\r\"alg\": \"HS256\",\r\"typ\": \"JWT\"\r} 上面代码中，alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。 最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。 ","date":"2022-10-22","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/jwt/:3:1","tags":["jwt"],"title":"通用技术-Jwt","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/jwt/"},{"categories":["通用技术"],"content":"Payload Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。 iss (issuer)：签发人 exp (expiration time)：过期时间 sub (subject)：主题 aud (audience)：受众 nbf (Not Before)：生效时间 iat (Issued At)：签发时间 jti (JWT ID)：编号 除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。 {\r\"sub\": \"1234567890\",\r\"name\": \"John Doe\",\r\"admin\": true\r} 注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。 这个 JSON 对象也要使用 Base64URL 算法转成字符串。 ","date":"2022-10-22","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/jwt/:3:2","tags":["jwt"],"title":"通用技术-Jwt","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/jwt/"},{"categories":["通用技术"],"content":"Signature Signature 部分是对前两部分的签名，防止数据篡改。 首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。 HMACSHA256(\rbase64UrlEncode(header) + \".\" +\rbase64UrlEncode(payload),\rsecret) 算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用\"点\"（.）分隔，就可以返回给用户。 ","date":"2022-10-22","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/jwt/:3:3","tags":["jwt"],"title":"通用技术-Jwt","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/jwt/"},{"categories":["通用技术"],"content":"Base64URL 前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。 JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符+、/和=，在 URL 里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成_ 。这就是 Base64URL 算法。 ","date":"2022-10-22","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/jwt/:3:4","tags":["jwt"],"title":"通用技术-Jwt","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/jwt/"},{"categories":["通用技术"],"content":"JWT 的使用方式 客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。 此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面。 Authorization: Bearer \u003ctoken\u003e 另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。 ","date":"2022-10-22","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/jwt/:4:0","tags":["jwt"],"title":"通用技术-Jwt","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/jwt/"},{"categories":["通用技术"],"content":"JWT 的几个特点 JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。 JWT 不加密的情况下，不能将秘密数据写入 JWT。 JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。 JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。 JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。 为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。 ","date":"2022-10-22","objectID":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/jwt/:5:0","tags":["jwt"],"title":"通用技术-Jwt","uri":"/posts/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/jwt/"},{"categories":["Golang"],"content":"godoc 本文为作者在goswag官网学习时做的笔记 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/:0:0","tags":["go第三方库"],"title":"go第三方库-Swagger","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/"},{"categories":["Golang"],"content":"快速开始 将注释添加到API源代码中，请参阅声明性注释格式。 使用如下命令下载swag：$ go install github.com/swaggo/swag/cmd/swag@latest 在包含main.go文件的项目根目录运行swag init。这将会解析注释并生成需要的文件（docs文件夹和docs/docs.go）。确保导入了生成的docs/docs.go文件，这样特定的配置文件才会被初始化。如果通用API注释没有写在main.go中，可以使用-g标识符来告知swag。swag init -g http/api.go (可选) 使用fmt格式化 SWAG 注释。(请先升级到最新版本) swag fmt ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/:1:0","tags":["go第三方库"],"title":"go第三方库-Swagger","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/"},{"categories":["Golang"],"content":"swag cli 见官网 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/:2:0","tags":["go第三方库"],"title":"go第三方库-Swagger","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/"},{"categories":["Golang"],"content":"支持的Web框架 gin echo buffalo net/http net/http gorilla/mux go-chi/chi flamingo fiber atreugo ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/:3:0","tags":["go第三方库"],"title":"go第三方库-Swagger","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/"},{"categories":["Golang"],"content":"如何与Gin集成 使用swag init生成Swagger2.0文档后，导入如下代码包： import \"github.com/swaggo/gin-swagger\" // gin-swagger middleware\rimport \"github.com/swaggo/files\" // swagger embed files 在main.go源代码中添加通用的API注释： // @title Swagger Example API\r// @version 1.0\r// @description This is a sample server celler server.\r// @termsOfService http://swagger.io/terms/\r// @contact.name API Support\r// @contact.url http://www.swagger.io/support\r// @contact.email support@swagger.io\r// @license.name Apache 2.0\r// @license.url http://www.apache.org/licenses/LICENSE-2.0.html\r// @host localhost:8080\r// @BasePath /api/v1\r// @securityDefinitions.basic BasicAuth\rfunc main() {\rr := gin.Default()\rc := controller.NewController()\rv1 := r.Group(\"/api/v1\")\r{\raccounts := v1.Group(\"/accounts\")\r{\raccounts.GET(\":id\", c.ShowAccount)\raccounts.GET(\"\", c.ListAccounts)\raccounts.POST(\"\", c.AddAccount)\raccounts.DELETE(\":id\", c.DeleteAccount)\raccounts.PATCH(\":id\", c.UpdateAccount)\raccounts.POST(\":id/images\", c.UploadAccountImage)\r}\r//...\r}\rr.GET(\"/swagger/*any\", ginSwagger.WrapHandler(swaggerFiles.Handler))\rr.Run(\":8080\")\r}\r//... 此外，可以动态设置一些通用的API信息。生成的代码包docs导出SwaggerInfo变量，使用该变量可以通过编码的方式设置标题、描述、版本、主机和基础路径。使用Gin的示例： package main\rimport (\r\"github.com/gin-gonic/gin\"\r\"github.com/swaggo/files\"\r\"github.com/swaggo/gin-swagger\"\r\"./docs\" // docs is generated by Swag CLI, you have to import it.\r)\r// @contact.name API Support\r// @contact.url http://www.swagger.io/support\r// @contact.email support@swagger.io\r// @license.name Apache 2.0\r// @license.url http://www.apache.org/licenses/LICENSE-2.0.html\rfunc main() {\r// programatically set swagger info\rdocs.SwaggerInfo.Title = \"Swagger Example API\"\rdocs.SwaggerInfo.Description = \"This is a sample server Petstore server.\"\rdocs.SwaggerInfo.Version = \"1.0\"\rdocs.SwaggerInfo.Host = \"petstore.swagger.io\"\rdocs.SwaggerInfo.BasePath = \"/v2\"\rdocs.SwaggerInfo.Schemes = []string{\"http\", \"https\"}\rr := gin.New()\r// use ginSwagger middleware to serve the API docs\rr.GET(\"/swagger/*any\", ginSwagger.WrapHandler(swaggerFiles.Handler))\rr.Run()\r} 在controller代码中添加API操作注释： package controller\rimport (\r\"fmt\"\r\"net/http\"\r\"strconv\"\r\"github.com/gin-gonic/gin\"\r\"github.com/swaggo/swag/example/celler/httputil\"\r\"github.com/swaggo/swag/example/celler/model\"\r)\r// ShowAccount godoc\r// @Summary Show an account\r// @Description get string by ID\r// @Tags accounts\r// @Accept json\r// @Produce json\r// @Param id path int true \"Account ID\"\r// @Success 200 {object} model.Account\r// @Failure 400 {object} httputil.HTTPError\r// @Failure 404 {object} httputil.HTTPError\r// @Failure 500 {object} httputil.HTTPError\r// @Router /accounts/{id} [get]\rfunc (c *Controller) ShowAccount(ctx *gin.Context) {\rid := ctx.Param(\"id\")\raid, err := strconv.Atoi(id)\rif err != nil {\rhttputil.NewError(ctx, http.StatusBadRequest, err)\rreturn\r}\raccount, err := model.AccountOne(aid)\rif err != nil {\rhttputil.NewError(ctx, http.StatusNotFound, err)\rreturn\r}\rctx.JSON(http.StatusOK, account)\r}\r// ListAccounts godoc\r// @Summary List accounts\r// @Description get accounts\r// @Tags accounts\r// @Accept json\r// @Produce json\r// @Param q query string false \"name search by q\" Format(email)\r// @Success 200 {array} model.Account\r// @Failure 400 {object} httputil.HTTPError\r// @Failure 404 {object} httputil.HTTPError\r// @Failure 500 {object} httputil.HTTPError\r// @Router /accounts [get]\rfunc (c *Controller) ListAccounts(ctx *gin.Context) {\rq := ctx.Request.URL.Query().Get(\"q\")\raccounts, err := model.AccountsAll(q)\rif err != nil {\rhttputil.NewError(ctx, http.StatusNotFound, err)\rreturn\r}\rctx.JSON(http.StatusOK, accounts)\r}\r//... swag init 运行程序，然后在浏览器中访问 http://localhost:8080/swagger/index.html 。将看到Swagger 2.0 Api文档，如下所示： ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/:4:0","tags":["go第三方库"],"title":"go第三方库-Swagger","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/"},{"categories":["Golang"],"content":"格式化说明 可以针对Swag的注释自动格式化，就像go fmt。 此处查看格式化结果 here. 示例： swag fmt 排除目录（不扫描）示例： swag fmt -d ./ --exclude ./internal ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/:5:0","tags":["go第三方库"],"title":"go第三方库-Swagger","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/"},{"categories":["Golang"],"content":"开发现状 见官网 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/:6:0","tags":["go第三方库"],"title":"go第三方库-Swagger","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/"},{"categories":["Golang"],"content":"声明式注释格式 见官网 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/:7:0","tags":["go第三方库"],"title":"go第三方库-Swagger","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/"},{"categories":["Golang"],"content":"通用API信息 见官网 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/:8:0","tags":["go第三方库"],"title":"go第三方库-Swagger","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/"},{"categories":["Golang"],"content":"使用Markdown描述 如果文档中的短字符串不足以完整表达，或者需要展示图片，代码示例等类似的内容，则可能需要使用Markdown描述。要使用Markdown描述，请使用一下注释。 见官网 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/:8:1","tags":["go第三方库"],"title":"go第三方库-Swagger","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/"},{"categories":["Golang"],"content":"API操作 见官网 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/:9:0","tags":["go第三方库"],"title":"go第三方库-Swagger","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/"},{"categories":["Golang"],"content":"Mime类型 swag 接受所有格式正确的MIME类型, 即使匹配 /。除此之外，swag还接受某些MIME类型的别名，如下所示： 见官网 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/:10:0","tags":["go第三方库"],"title":"go第三方库-Swagger","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/"},{"categories":["Golang"],"content":"参数类型 query path header body formData ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/:11:0","tags":["go第三方库"],"title":"go第三方库-Swagger","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/"},{"categories":["Golang"],"content":"数据类型 string (string) integer (int, uint, uint32, uint64) number (float32) boolean (bool) user defined struct ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/:12:0","tags":["go第三方库"],"title":"go第三方库-Swagger","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/"},{"categories":["Golang"],"content":"安全性 见官网 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/:13:0","tags":["go第三方库"],"title":"go第三方库-Swagger","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/"},{"categories":["Golang"],"content":"属性 见官网 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/:14:0","tags":["go第三方库"],"title":"go第三方库-Swagger","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/"},{"categories":["Golang"],"content":"当前可用的 见官网 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/:14:1","tags":["go第三方库"],"title":"go第三方库-Swagger","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/"},{"categories":["Golang"],"content":"进一步的 见官网 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/:14:2","tags":["go第三方库"],"title":"go第三方库-Swagger","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/"},{"categories":["Golang"],"content":"样例 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/:15:0","tags":["go第三方库"],"title":"go第三方库-Swagger","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/"},{"categories":["Golang"],"content":"多行的描述 可以在常规api描述或路由定义中添加跨越多行的描述，如下所示： // @description This is the first line\r// @description This is the second line\r// @description And so forth. ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/:15:1","tags":["go第三方库"],"title":"go第三方库-Swagger","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/"},{"categories":["Golang"],"content":"用户自定义的具有数组类型的结构 // @Success 200 {array} model.Account \u003c-- This is a user defined struct. package model\rtype Account struct {\rID int `json:\"id\" example:\"1\"`\rName string `json:\"name\" example:\"account name\"`\r} ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/:15:2","tags":["go第三方库"],"title":"go第三方库-Swagger","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/"},{"categories":["Golang"],"content":"响应对象中的模型组合 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/:15:3","tags":["go第三方库"],"title":"go第三方库-Swagger","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/"},{"categories":["Golang"],"content":"使用多路径参数 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/:15:4","tags":["go第三方库"],"title":"go第三方库-Swagger","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/"},{"categories":["Golang"],"content":"结构体的示例值 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/:15:5","tags":["go第三方库"],"title":"go第三方库-Swagger","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/"},{"categories":["Golang"],"content":"结构体描述 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/:15:6","tags":["go第三方库"],"title":"go第三方库-Swagger","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/"},{"categories":["Golang"],"content":"使用swaggertype标签更改字段类型 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/:15:7","tags":["go第三方库"],"title":"go第三方库-Swagger","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/"},{"categories":["Golang"],"content":"使用swaggerignore标签排除字段 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/:15:8","tags":["go第三方库"],"title":"go第三方库-Swagger","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/"},{"categories":["Golang"],"content":"将扩展信息添加到结构字段 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/:15:9","tags":["go第三方库"],"title":"go第三方库-Swagger","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/"},{"categories":["Golang"],"content":"对展示的模型重命名 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/:15:10","tags":["go第三方库"],"title":"go第三方库-Swagger","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/"},{"categories":["Golang"],"content":"如何使用安全性注释 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/:15:11","tags":["go第三方库"],"title":"go第三方库-Swagger","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/swagger/"},{"categories":["Golang"],"content":"godoc 本系列为作者跟着viper官网学习做的笔记 另外相关阅读还可以查看李文周（qimi）的博客 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/:0:0","tags":["go第三方库"],"title":"go第三方库-viper","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/"},{"categories":["Golang"],"content":"安装 go get github.com/spf13/viper 注意： Viper 使用Go Modules来管理依赖项。 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/:1:0","tags":["go第三方库"],"title":"go第三方库-viper","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/"},{"categories":["Golang"],"content":"什么是Viper？ Viper 是一个完整的 Go 应用程序配置解决方案，包括 12-Factor 应用程序。它旨在在应用程序中工作，并且可以处理所有类型的配置需求和格式。它支持： 设置默认值 从 JSON、TOML、YAML、HCL、envfile 和 Java 属性配置文件读取 实时观看和重新阅读配置文件（可选） 从环境变量中读取 从远程配置系统（etcd 或 Consul）读取，并观察变化 从命令行标志读取 从缓冲区读取 设置显式值 Viper 可以被认为是满足您所有应用程序配置需求的注册表。 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/:2:0","tags":["go第三方库"],"title":"go第三方库-viper","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/"},{"categories":["Golang"],"content":"为什么是Viper？ 在构建现代应用程序时，您不必担心配置文件格式；您想专注于构建出色的软件。Viper 是来帮助解决这个问题的。 Viper 为您执行以下操作： 查找、加载和解组 JSON、TOML、YAML、HCL、INI、envfile 或 Java 属性格式的配置文件。 提供一种机制来为您的不同配置选项设置默认值。 提供一种机制来为通过命令行标志指定的选项设置覆盖值。 提供别名系统以轻松重命名参数而不会破坏现有代码。 便于区分用户何时提供了与默认值相同的命令行或配置文件。 Viper 使用以下优先顺序。每个项目优先于它下面的项目： 显式调用Set flag env config 键/值存储 default 重要提示： Viper 配置键不区分大小写。正在进行关于将其设为可选的讨论。 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/:3:0","tags":["go第三方库"],"title":"go第三方库-viper","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/"},{"categories":["Golang"],"content":"将值存入 Viper ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/:4:0","tags":["go第三方库"],"title":"go第三方库-viper","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/"},{"categories":["Golang"],"content":"建立默认值 一个好的配置系统将支持默认值。密钥不需要默认值，但在尚未通过配置文件、环境变量、远程配置或flag设置密钥的情况下很有用。 例子： viper.SetDefault(\"ContentDir\", \"content\")\rviper.SetDefault(\"LayoutDir\", \"layouts\")\rviper.SetDefault(\"Taxonomies\", map[string]string{\"tag\": \"tags\", \"category\": \"categories\"}) ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/:4:1","tags":["go第三方库"],"title":"go第三方库-viper","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/"},{"categories":["Golang"],"content":"读取配置文件 Viper 需要最少的配置，因此它知道在哪里查找配置文件。Viper 支持 JSON、TOML、YAML、HCL、INI、envfile 和 Java 属性文件。Viper 可以搜索多个路径，但目前单个 Viper 实例仅支持单个配置文件。Viper 不默认任何配置搜索路径，将默认决定留给应用程序。 下面是一个如何使用 Viper 搜索和读取配置文件的示例。不需要任何特定路径，但应至少提供一个路径，其中需要配置文件。 viper.SetConfigName(\"config\") // name of config file (without extension)\rviper.SetConfigType(\"yaml\") // REQUIRED if the config file does not have the extension in the name\rviper.AddConfigPath(\"/etc/appname/\") // path to look for the config file in\rviper.AddConfigPath(\"$HOME/.appname\") // call multiple times to add many search paths\rviper.AddConfigPath(\".\") // optionally look for config in the working directory\rerr := viper.ReadInConfig() // Find and read the config file\rif err != nil { // Handle errors reading the config file\rpanic(fmt.Errorf(\"fatal error config file: %w\", err))\r} 您可以处理找不到配置文件的特定情况，如下所示： if err := viper.ReadInConfig(); err != nil {\rif _, ok := err.(viper.ConfigFileNotFoundError); ok {\r// Config file not found; ignore error if desired\r} else {\r// Config file was found but another error was produced\r}\r}\r// Config file found and successfully parsed 注意 [从 1.6 开始]：您也可以有一个没有扩展名的文件，并以编程方式指定格式。对于那些位于用户Home中没有任何扩展名的配置文件.bashrc ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/:4:2","tags":["go第三方库"],"title":"go第三方库-viper","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/"},{"categories":["Golang"],"content":"编写配置文件 从配置文件中读取很有用，但有时您希望存储在运行时所做的所有修改。为此，可以使用一堆命令，每个命令都有自己的用途： WriteConfig - 将当前 viper 配置写入预定义路径（如果存在）。如果没有预定义的路径，则会出错。如果存在，将覆盖当前配置文件。 SafeWriteConfig - 将当前 viper 配置写入预定义路径。如果没有预定义的路径，则会出错。如果存在，则不会覆盖当前配置文件。 WriteConfigAs - 将当前的 viper 配置写入给定的文件路径。将覆盖给定文件（如果存在）。 SafeWriteConfigAs - 将当前的 viper 配置写入给定的文件路径。不会覆盖给定文件（如果存在）。 根据经验，标有安全的所有文件都不会覆盖任何文件，如果不存在则创建，而默认行为是创建或截断。 一个小例子部分： viper.WriteConfig() // writes current config to predefined path set by 'viper.AddConfigPath()' and 'viper.SetConfigName'\rviper.SafeWriteConfig()\rviper.WriteConfigAs(\"/path/to/my/.config\")\rviper.SafeWriteConfigAs(\"/path/to/my/.config\") // will error since it has already been written\rviper.SafeWriteConfigAs(\"/path/to/my/.other_config\") ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/:4:3","tags":["go第三方库"],"title":"go第三方库-viper","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/"},{"categories":["Golang"],"content":"查看和重新读取配置文件 Viper 支持让您的应用程序在运行时实时读取配置文件的能力。 需要重新启动服务器才能使配置生效的日子已经一去不复返了，viper 驱动的应用程序可以在运行时读取配置文件的更新而不会错过任何一个节拍。 只需告诉 viper 实例 watchConfig。或者，您可以为 Viper 提供一个函数，以便在每次发生更改时运行。 确保在调用WatchConfig()之前添加所有 configPaths viper.OnConfigChange(func(e fsnotify.Event) {\rfmt.Println(\"Config file changed:\", e.Name)\r})\rviper.WatchConfig() ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/:4:4","tags":["go第三方库"],"title":"go第三方库-viper","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/"},{"categories":["Golang"],"content":"从 io.Reader 读取配置 Viper 预定义了许多配置源，例如文件、环境变量、标志和远程 K/V 存储，但您不受它们的约束。您还可以实现自己所需的配置源并将其提供给 viper。 viper.SetConfigType(\"yaml\") // or viper.SetConfigType(\"YAML\")\r// any approach to require this configuration into your program.\rvar yamlExample = []byte(`\rHacker: true\rname: steve\rhobbies:\r- skateboarding\r- snowboarding\r- go\rclothing:\rjacket: leather\rtrousers: denim\rage: 35\reyes : brown\rbeard: true\r`)\rviper.ReadConfig(bytes.NewBuffer(yamlExample))\rviper.Get(\"name\") // this would be \"steve\" ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/:4:5","tags":["go第三方库"],"title":"go第三方库-viper","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/"},{"categories":["Golang"],"content":"设置覆盖 这些可能来自命令行flag，也可能来自您自己的应用程序逻辑。 viper.Set(\"Verbose\", true)\rviper.Set(\"LogFile\", LogFile) ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/:4:6","tags":["go第三方库"],"title":"go第三方库-viper","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/"},{"categories":["Golang"],"content":"注册和使用别名 别名允许多个键引用单个值 viper.RegisterAlias(\"loud\", \"Verbose\")\rviper.Set(\"verbose\", true) // same result as next line\rviper.Set(\"loud\", true) // same result as prior line\rviper.GetBool(\"loud\") // true\rviper.GetBool(\"verbose\") // true ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/:4:7","tags":["go第三方库"],"title":"go第三方库-viper","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/"},{"categories":["Golang"],"content":"使用环境变量 Viper 完全支持环境变量。这使开箱即用的 12 因子应用成为可能。有五种方法可以帮助使用 ENV： AutomaticEnv() BindEnv(string…) : error SetEnvPrefix(string) SetEnvKeyReplacer(string…) *strings.Replacer AllowEmptyEnv(bool) 使用 ENV 变量时，重要的是要认识到 Viper 将 ENV 变量视为区分大小写。 Viper 提供了一种机制来尝试确保 ENV 变量是唯一的。通过使用SetEnvPrefix，您可以告诉 Viper 在读取环境变量时使用前缀。BindEnv和AutomaticEnv两者都将使用此前缀。 BindEnv接受一个或多个参数。第一个参数是键名，其余的是要绑定到该键的环境变量的名称。如果提供了多个，它们将按照指定的顺序优先。环境变量的名称区分大小写。如果未提供 ENV 变量名称，那么 Viper 将自动假定 ENV 变量与以下格式匹配：前缀 + “_” + 全部大写的键名。当您显式提供 ENV 变量名称（第二个参数）时，它不会自动添加前缀。例如，如果第二个参数是“id”，Viper 将查找 ENV 变量“ID”。 使用 ENV 变量时要认识到的一件重要事情是每次访问时都会读取该值。BindEnv调用时，Viper 不固定该值。 AutomaticEnv是一个强大的帮手，尤其是与 SetEnvPrefix一起使用时。 在任何时候viper.Get调用时，Viper 将发出请求时检查环境变量。它将应用以下规则。它将检查名称与键的大写形式匹配环境变量，如果设置了EnvPrefix还会匹配是否有该前缀。 SetEnvKeyReplacer允许您使用strings.Replacer对象在一定程度上重写 Env 键。-如果您想在Get()调用中使用-或某些东西 ，但希望您的环境变量使用_分隔符，这很有用。可以在viper_test.go中找到使用它的示例。 或者，您可以工厂函数NewWithOptions使用EnvKeyReplacer。与SetEnvKeyReplacer不同，它接受一个StringReplacer允许您编写自定义字符串替换逻辑的接口。 默认情况下，空环境变量被视为未设置，并将回退到下一个配置源。要将空环境变量视为已设置，请使用该AllowEmptyEnv方法。 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/:4:8","tags":["go第三方库"],"title":"go第三方库-viper","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/"},{"categories":["Golang"],"content":"环境示例 SetEnvPrefix(\"spf\") // will be uppercased automatically\rBindEnv(\"id\")\ros.Setenv(\"SPF_ID\", \"13\") // typically done outside of the app\rid := Get(\"id\") // 13 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/:4:9","tags":["go第三方库"],"title":"go第三方库-viper","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/"},{"categories":["Golang"],"content":"使用标志 Viper 具有绑定flag的能力。具体来说，Viper 支持Pflags 在Cobra库中使用。 像BindEnv，在调用绑定方法时不会设置该值，而是在访问它时设置该值。这意味着您可以尽可能早地绑定，即使在 init()函数中也是如此。 对于单个flag，该BindPFlag()方法提供此功能。 例子： serverCmd.Flags().Int(\"port\", 1138, \"Port to run Application server on\")\rviper.BindPFlag(\"port\", serverCmd.Flags().Lookup(\"port\")) 您还可以绑定现有的一组 pflags (pflag.FlagSet)： 例子： pflag.Int(\"flagname\", 1234, \"help message for flagname\")\rpflag.Parse()\rviper.BindPFlags(pflag.CommandLine)\ri := viper.GetInt(\"flagname\") // retrieve values from viper instead of pflag 在 Viper 中使用pflag并不排除使用 标准库中使用flag包的其他包。pflag 包可以通过导入这些标志来处理为标志包定义的标志。这是通过调用一个名为 AddGoFlagSet() 的 pflag 包提供的便利函数来完成的。 例子： package main\rimport (\r\"flag\"\r\"github.com/spf13/pflag\"\r)\rfunc main() {\r// using standard library \"flag\" package\rflag.Int(\"flagname\", 1234, \"help message for flagname\")\rpflag.CommandLine.AddGoFlagSet(flag.CommandLine)\rpflag.Parse()\rviper.BindPFlags(pflag.CommandLine)\ri := viper.GetInt(\"flagname\") // retrieve value from viper\r// ...\r} ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/:4:10","tags":["go第三方库"],"title":"go第三方库-viper","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/"},{"categories":["Golang"],"content":"flag接口 Viper 提供了两个 Go 接口来绑定其他flag系统，如果你不使用Pflags. FlagValue表示单个flag。这是一个关于如何实现此接口的非常简单的示例： type myFlag struct {}\rfunc (f myFlag) HasChanged() bool { return false }\rfunc (f myFlag) Name() string { return \"my-flag-name\" }\rfunc (f myFlag) ValueString() string { return \"my-flag-value\" }\rfunc (f myFlag) ValueType() string { return \"string\" } 一旦你的标志实现了这个接口，你可以简单地告诉 Viper 绑定它： viper.BindFlagValue(\"my-flag-name\", myFlag{}) FlagValueSet代表一组标志。这是一个关于如何实现此接口的非常简单的示例： type myFlagSet struct {\rflags []myFlag\r}\rfunc (f myFlagSet) VisitAll(fn func(FlagValue)) {\rfor _, flag := range flags {\rfn(flag)\r}\r} 一旦你的标志集实现了这个接口，你可以简单地告诉 Viper 绑定它： fSet := myFlagSet{\rflags: []myFlag{myFlag{}, myFlag{}},\r}\rviper.BindFlagValues(\"my-flags\", fSet) ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/:4:11","tags":["go第三方库"],"title":"go第三方库-viper","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/"},{"categories":["Golang"],"content":"远程键/值存储支持 要在 Viper 中启用远程支持，请对包进行空白导入viper/remote ： import _ \"github.com/spf13/viper/remote\" Viper 将读取从 Key/Value 存储（如 etcd 或 Consul）中的路径检索到的配置字符串（如 JSON、TOML、YAML、HCL 或 envfile）。这些值优先于默认值，但会被从磁盘、标志或环境变量中检索到的配置值覆盖。 Viper 使用crypt从 K/V 存储中检索配置，这意味着您可以加密存储配置值，如果您拥有正确的 gpg 密钥环，则可以自动解密它们。加密是可选的。 您可以将远程配置与本地配置结合使用，也可以独立使用。 crypt有一个命令行助手，您可以使用它来将配置放入您的 K/V 存储中。crypt默认为http://127.0.0.1:4001上的 etcd 。 $ go get github.com/bketelsen/crypt/bin/crypt\r$ crypt set -plaintext /config/hugo.json /Users/hugo/settings/config.json 确认您的值已设置： $ crypt get -plaintext /config/hugo.json crypt有关如何设置加密值或如何使用 Consul 的示例，请参阅文档。 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/:4:12","tags":["go第三方库"],"title":"go第三方库-viper","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/"},{"categories":["Golang"],"content":"远程键/值存储示例 - 未加密 etcd viper.AddRemoteProvider(\"etcd\", \"http://127.0.0.1:4001\",\"/config/hugo.json\")\rviper.SetConfigType(\"json\") // because there is no file extension in a stream of bytes, supported extensions are \"json\", \"toml\", \"yaml\", \"yml\", \"properties\", \"props\", \"prop\", \"env\", \"dotenv\"\rerr := viper.ReadRemoteConfig() etcd3 viper.AddRemoteProvider(\"etcd3\", \"http://127.0.0.1:4001\",\"/config/hugo.json\")\rviper.SetConfigType(\"json\") // because there is no file extension in a stream of bytes, supported extensions are \"json\", \"toml\", \"yaml\", \"yml\", \"properties\", \"props\", \"prop\", \"env\", \"dotenv\"\rerr := viper.ReadRemoteConfig() Consul 您需要使用包含所需配置的 JSON 值将密钥设置为 Consul 键/值存储。例如，创建一个带有值的Consul键/值存储键MY_CONSUL_KEY： {\r\"port\": 8080,\r\"hostname\": \"myhostname.com\"\r} viper.AddRemoteProvider(\"consul\", \"localhost:8500\", \"MY_CONSUL_KEY\")\rviper.SetConfigType(\"json\") // Need to explicitly set this to json\rerr := viper.ReadRemoteConfig()\rfmt.Println(viper.Get(\"port\")) // 8080\rfmt.Println(viper.Get(\"hostname\")) // myhostname.com Firestore viper.AddRemoteProvider(\"firestore\", \"google-cloud-project-id\", \"collection/document\")\rviper.SetConfigType(\"json\") // Config's format: \"json\", \"toml\", \"yaml\", \"yml\"\rerr := viper.ReadRemoteConfig() 当然，您也可以使用SecureRemoteProvider ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/:4:13","tags":["go第三方库"],"title":"go第三方库-viper","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/"},{"categories":["Golang"],"content":"远程键/值存储示例 - 加密 viper.AddSecureRemoteProvider(\"etcd\",\"http://127.0.0.1:4001\",\"/config/hugo.json\",\"/etc/secrets/mykeyring.gpg\")\rviper.SetConfigType(\"json\") // because there is no file extension in a stream of bytes, supported extensions are \"json\", \"toml\", \"yaml\", \"yml\", \"properties\", \"props\", \"prop\", \"env\", \"dotenv\"\rerr := viper.ReadRemoteConfig() ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/:4:14","tags":["go第三方库"],"title":"go第三方库-viper","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/"},{"categories":["Golang"],"content":"观察 etcd 中的变化 - 未加密 // alternatively, you can create a new viper instance.\rvar runtime_viper = viper.New()\rruntime_viper.AddRemoteProvider(\"etcd\", \"http://127.0.0.1:4001\", \"/config/hugo.yml\")\rruntime_viper.SetConfigType(\"yaml\") // because there is no file extension in a stream of bytes, supported extensions are \"json\", \"toml\", \"yaml\", \"yml\", \"properties\", \"props\", \"prop\", \"env\", \"dotenv\"\r// read from remote config the first time.\rerr := runtime_viper.ReadRemoteConfig()\r// unmarshal config\rruntime_viper.Unmarshal(\u0026runtime_conf)\r// open a goroutine to watch remote changes forever\rgo func(){\rfor {\rtime.Sleep(time.Second * 5) // delay after each request\r// currently, only tested with etcd support\rerr := runtime_viper.WatchRemoteConfig()\rif err != nil {\rlog.Errorf(\"unable to read remote config: %v\", err)\rcontinue\r}\r// unmarshal new config into our runtime config struct. you can also use channel\r// to implement a signal to notify the system of the changes\rruntime_viper.Unmarshal(\u0026runtime_conf)\r}\r}() ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/:4:15","tags":["go第三方库"],"title":"go第三方库-viper","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/"},{"categories":["Golang"],"content":"从 Viper 获取值 在 Viper 中，有几种方法可以根据值的类型获取值。存在以下功能和方法： Get(key string) : interface{} GetBool(key string) : bool GetFloat64(key string) : float64 GetInt(key string) : int GetIntSlice(key string) : []int GetString(key string) : string GetStringMap(key string) : map[string]interface{} GetStringMapString(key string) : map[string]string GetStringSlice(key string) : []string GetTime(key string) : time.Time GetDuration(key string) : time.Duration IsSet(key string) : bool AllSettings() : map[string]interface{} 要认识到的一件重要的事情是，如果没有找到每个 Get 函数，它将返回一个零值。为了检查给定的密钥是否存在，提供了该IsSet()方法。 例子： viper.GetString(\"logfile\") // case-insensitive Setting \u0026 Getting\rif viper.GetBool(\"verbose\") {\rfmt.Println(\"verbose enabled\")\r} ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/:5:0","tags":["go第三方库"],"title":"go第三方库-viper","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/"},{"categories":["Golang"],"content":"访问嵌套键 访问器方法还接受深度嵌套键的格式化路径。例如，如果加载了以下 JSON 文件： {\r\"host\": {\r\"address\": \"localhost\",\r\"port\": 5799\r},\r\"datastore\": {\r\"metric\": {\r\"host\": \"127.0.0.1\",\r\"port\": 3099\r},\r\"warehouse\": {\r\"host\": \"198.0.0.1\",\r\"port\": 2112\r}\r}\r} Viper 可以通过传递键的.分隔路径来访问嵌套字段： GetString(\"datastore.metric.host\") // (returns \"127.0.0.1\") 这符合上面建立的优先规则；对路径的搜索将通过剩余的配置注册表进行级联，直到找到为止。 例如，给定这个配置文件，datastore.metric.host和 datastore.metric.port都已经定义（并且可能被覆盖）。如果另外 datastore.metric.protocol在默认值中定义，Viper 也会找到它。 但是，如果datastore.metric被立即值覆盖（通过标志、环境变量、Set()方法……），则所有datastore.metric的子键都变为未定义，它们被更高优先级的配置级别“遮蔽”。 Viper 可以通过在路径中使用数字来访问数组索引。例如： {\r\"host\": {\r\"address\": \"localhost\",\r\"ports\": [\r5799,\r6029\r]\r},\r\"datastore\": {\r\"metric\": {\r\"host\": \"127.0.0.1\",\r\"port\": 3099\r},\r\"warehouse\": {\r\"host\": \"198.0.0.1\",\r\"port\": 2112\r}\r}\r}\rGetInt(\"host.ports.1\") // returns 6029 最后，如果存在与分隔键路径匹配的键，则将返回其值。例如 {\r\"datastore.metric.host\": \"0.0.0.0\",\r\"host\": {\r\"address\": \"localhost\",\r\"port\": 5799\r},\r\"datastore\": {\r\"metric\": {\r\"host\": \"127.0.0.1\",\r\"port\": 3099\r},\r\"warehouse\": {\r\"host\": \"198.0.0.1\",\r\"port\": 2112\r}\r}\r}\rGetString(\"datastore.metric.host\") // returns \"0.0.0.0\" ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/:5:1","tags":["go第三方库"],"title":"go第三方库-viper","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/"},{"categories":["Golang"],"content":"提取子树 在开发可重用模块时，提取配置的子集并将其传递给模块通常很有用。这样，可以使用不同的配置多次实例化模块。 例如，一个应用程序可能会出于不同目的使用多个不同的缓存存储： cache:\rcache1:\rmax-items: 100\ritem-size: 64\rcache2:\rmax-items: 200\ritem-size: 80 我们可以将缓存名称传递给模块（例如NewCache(“cache1”)），但它需要奇怪的连接来访问配置键，并且与全局配置的分离度较低。 因此，让我们将 Viper 实例传递给代表配置子集的构造函数，而不是这样做： cache1Config := viper.Sub(\"cache.cache1\")\rif cache1Config == nil { // Sub returns nil if the key cannot be found\rpanic(\"cache configuration not found\")\r}\rcache1 := NewCache(cache1Config) 注意：始终检查Sub的返回值。如果找不到密钥，会返回nil。 在内部，该NewCache函数可以直接寻址max-items和item-size键： func NewCache(v *Viper) *Cache {\rreturn \u0026Cache{\rMaxItems: v.GetInt(\"max-items\"),\rItemSize: v.GetInt(\"item-size\"),\r}\r} 生成的代码很容易测试，因为它与主配置结构分离，并且更容易重用（出于同样的原因）。 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/:5:2","tags":["go第三方库"],"title":"go第三方库-viper","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/"},{"categories":["Golang"],"content":"解组 您还可以选择将所有或特定值解组到结构、map等。 有两种方法可以做到这一点： Unmarshal(rawVal interface{}) : error UnmarshalKey(key string, rawVal interface{}) : error 例子： type config struct {\rPort int\rName string\rPathMap string `mapstructure:\"path_map\"`\r}\rvar C config\rerr := viper.Unmarshal(\u0026C)\rif err != nil {\rt.Fatalf(\"unable to decode into struct, %v\", err)\r} 如果要解组键本身包含点（默认键分隔符）的配置，则必须更改分隔符： v := viper.NewWithOptions(viper.KeyDelimiter(\"::\"))\rv.SetDefault(\"chart::values\", map[string]interface{}{\r\"ingress\": map[string]interface{}{\r\"annotations\": map[string]interface{}{\r\"traefik.frontend.rule.type\": \"PathPrefix\",\r\"traefik.ingress.kubernetes.io/ssl-redirect\": \"true\",\r},\r},\r})\rtype config struct {\rChart struct{\rValues map[string]interface{}\r}\r}\rvar C config\rv.Unmarshal(\u0026C) Viper 还支持解组到嵌入式结构： /*\rExample config:\rmodule:\renabled: true\rtoken: 89h3f98hbwf987h3f98wenf89ehf\r*/\rtype config struct {\rModule struct {\rEnabled bool\rmoduleConfig `mapstructure:\",squash\"`\r}\r}\r// moduleConfig could be in a module specific package\rtype moduleConfig struct {\rToken string\r}\rvar C config\rerr := viper.Unmarshal(\u0026C)\rif err != nil {\rt.Fatalf(\"unable to decode into struct, %v\", err)\r} Viper 在后台使用github.com/mitchellh/mapstructure来解组默认使用mapstructure标签的值。 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/:5:3","tags":["go第三方库"],"title":"go第三方库-viper","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/"},{"categories":["Golang"],"content":"解码自定义格式 Viper 经常要求的一个功能是添加更多的值格式和解码器。例如，解析字符（点、逗号、分号等）将字符串分隔为切片。 这已经在 Viper 中使用 mapstructure decode hooks 提供了。 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/:5:4","tags":["go第三方库"],"title":"go第三方库-viper","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/"},{"categories":["Golang"],"content":"编组到字符串 您可能需要将 viper 中保存的所有设置编组为字符串，而不是将它们写入文件。您可以通过调用AllSettings()返回您最喜欢的格式的编组器. import (\ryaml \"gopkg.in/yaml.v2\"\r// ...\r)\rfunc yamlStringSettings() string {\rc := viper.AllSettings()\rbs, err := yaml.Marshal(c)\rif err != nil {\rlog.Fatalf(\"unable to marshal config to YAML: %v\", err)\r}\rreturn string(bs)\r} ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/:5:5","tags":["go第三方库"],"title":"go第三方库-viper","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/"},{"categories":["Golang"],"content":"Viper or Vipers? Viper 开箱即用。开始使用 Viper 无需配置或初始化。由于大多数应用程序都希望使用单个中央存储库进行配置，因此 viper 包提供了这一点。它类似于单例。 在上面的所有示例中，他们都演示了在其单例样式方法中使用 viper。 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/:6:0","tags":["go第三方库"],"title":"go第三方库-viper","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/"},{"categories":["Golang"],"content":"Working with multiple vipers 您还可以创建许多不同的 viper 以在您的应用程序中使用。每个都有自己独特的一组配置和值。每个都可以从不同的配置文件、键值存储等中读取。viper 包支持的所有功能都被镜像为 viper 上的方法。 例子： x := viper.New()\ry := viper.New()\rx.SetDefault(\"ContentDir\", \"content\")\ry.SetDefault(\"ContentDir\", \"foobar\")\r//... 当使用多个Viper时，由用户负责跟踪不同的Viper。 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/:6:1","tags":["go第三方库"],"title":"go第三方库-viper","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/"},{"categories":["Golang"],"content":"问答 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/:7:0","tags":["go第三方库"],"title":"go第三方库-viper","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/"},{"categories":["Golang"],"content":"为什么叫“Viper”蝰蛇？ 答：Viper 旨在成为 Cobra的伴侣。虽然两者都可以完全独立运行，但它们共同构成了强大的组合，可以满足您的大部分应用程序基础需求。 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/:7:1","tags":["go第三方库"],"title":"go第三方库-viper","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/"},{"categories":["Golang"],"content":"为什么叫“cobra”眼镜蛇？ 指挥官有更好的名字吗？ ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/:7:2","tags":["go第三方库"],"title":"go第三方库-viper","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/"},{"categories":["Golang"],"content":"Viper 是否支持区分大小写的键？ tl;博士：不。 Viper 合并了来自各种来源的配置，其中许多要么不区分大小写，要么使用与其他来源不同的大小写（例如 env vars）。为了在使用多个来源时提供最佳体验，已决定使所有键不区分大小写。 已经有几次尝试实现区分大小写，但不幸的是，这并不是那么微不足道。我们可能会尝试在Viper v2中实现它，但尽管有最初的噪音，但似乎并没有太多要求。 您可以通过填写此反馈表来投票支持区分大小写：https ://forms.gle/R6faU74qPRPAzchZ9 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/:7:3","tags":["go第三方库"],"title":"go第三方库-viper","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/"},{"categories":["Golang"],"content":"同时读写viper是否安全？ 不，您需要自己同步对 viper 的访问（例如通过使用sync包）。并发读取和写入可能会导致恐慌。 ","date":"2022-10-21","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/:7:4","tags":["go第三方库"],"title":"go第三方库-viper","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/viper/"},{"categories":["前端"],"content":"reactive和ref都是用来定义响应式数据的。reactive更推荐去定义复杂的数据类型，ref更推荐定义基本类型。 ref和reactive本质我们可以简单地理解为ref是对reactive的二次包装，ref定 义的数据访问的时候要多一个.value 使用ref定义基本数据类型，ref也可以定义数组和对象。 ","date":"2022-10-20","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/ref%E5%92%8Creactive/:0:0","tags":["Vue个人笔记"],"title":"Vue-个人笔记-Ref和reactive","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/ref%E5%92%8Creactive/"},{"categories":["前端"],"content":"本系列是作者在跟着vue-router官网学习时做的笔记，可能并不详尽，读者可以到官网中查看完整内容。 对路由的添加通常是通过 routes 选项来完成的，但是在某些情况下，你可能想在应用程序已经运行的时候添加或删除路由。具有可扩展接口(如 Vue CLI UI )这样的应用程序可以使用它来扩展应用程序。 ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/:0:0","tags":["Vue教程"],"title":"Vue-Router-进阶-动态路由","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/"},{"categories":["前端"],"content":"添加路由 动态路由主要通过两个函数实现。router.addRoute() 和 router.removeRoute()。它们只注册一个新的路由，也就是说，如果新增加的路由与当前位置相匹配，就需要你用 router.push() 或 router.replace() 来手动导航，才能显示该新路由。我们来看一个例子： 想象一下，只有一个路由的以下路由： const router = createRouter({\rhistory: createWebHistory(),\rroutes: [{ path: '/:articleName', component: Article }],\r}) 进入任何页面，/about，/store，或者 /3-tricks-to-improve-your-routing-code 最终都会呈现 Article 组件。如果我们在 /about 上添加一个新的路由： router.addRoute({ path: '/about', component: About }) 页面仍然会显示 Article 组件，我们需要手动调用 router.replace() 来改变当前的位置，并覆盖我们原来的位置（而不是添加一个新的路由，最后在我们的历史中两次出现在同一个位置）： router.addRoute({ path: '/about', component: About })\r// 我们也可以使用 this.$route 或 route = useRoute() （在 setup 中）\rrouter.replace(router.currentRoute.value.fullPath) 记住，如果你需要等待新的路由显示，可以使用 await router.replace()。 ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/:1:0","tags":["Vue教程"],"title":"Vue-Router-进阶-动态路由","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/"},{"categories":["前端"],"content":"在导航守卫中添加路由 如果你决定在导航守卫内部添加或删除路由，你不应该调用 router.replace()，而是通过返回新的位置来触发重定向： router.beforeEach(to =\u003e {\rif (!hasNecessaryRoute(to)) {\rrouter.addRoute(generateRoute(to))\r// 触发重定向\rreturn to.fullPath\r}\r}) 上面的例子有两个假设：第一，新添加的路由记录将与 to 位置相匹配，实际上导致与我们试图访问的位置不同。第二，hasNecessaryRoute() 在添加新的路由后返回 false，以避免无限重定向。 因为是在重定向中，所以我们是在替换将要跳转的导航，实际上行为就像之前的例子一样。而在实际场景中，添加路由的行为更有可能发生在导航守卫之外，例如，当一个视图组件挂载时，它会注册新的路由。 ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/:2:0","tags":["Vue教程"],"title":"Vue-Router-进阶-动态路由","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/"},{"categories":["前端"],"content":"删除路由 有几个不同的方法来删除现有的路由： 通过添加一个名称冲突的路由。如果添加与现有途径名称相同的途径，会先删除路由，再添加路由： router.addRoute({ path: '/about', name: 'about', component: About })\r// 这将会删除之前已经添加的路由，因为他们具有相同的名字且名字必须是唯一的\rrouter.addRoute({ path: '/other', name: 'about', component: Other }) 通过调用 router.addRoute() 返回的回调： const removeRoute = router.addRoute(routeRecord)\rremoveRoute() // 删除路由如果存在的话 当路由没有名称时，这很有用。 通过使用 router.removeRoute() 按名称删除路由： router.addRoute({ path: '/about', name: 'about', component: About })\r// 删除路由\rrouter.removeRoute('about') 需要注意的是，如果你想使用这个功能，但又想避免名字的冲突，可以在路由中使用 Symbol 作为名字。 当路由被删除时，所有的别名和子路由也会被同时删除 ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/:3:0","tags":["Vue教程"],"title":"Vue-Router-进阶-动态路由","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/"},{"categories":["前端"],"content":"添加嵌套路由 要将嵌套路由添加到现有的路由中，可以将路由的 name 作为第一个参数传递给 router.addRoute()，这将有效地添加路由，就像通过 children 添加的一样： router.addRoute({ name: 'admin', path: '/admin', component: Admin })\rrouter.addRoute('admin', { path: 'settings', component: AdminSettings }) 这等效于： router.addRoute({\rname: 'admin',\rpath: '/admin',\rcomponent: Admin,\rchildren: [{ path: 'settings', component: AdminSettings }],\r}) ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/:4:0","tags":["Vue教程"],"title":"Vue-Router-进阶-动态路由","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/"},{"categories":["前端"],"content":"查看现有路由 Vue Router 提供了两个功能来查看现有的路由： router.hasRoute()：检查路由是否存在。 router.getRoutes()：获取一个包含所有路由记录的数组。+ ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/:5:0","tags":["Vue教程"],"title":"Vue-Router-进阶-动态路由","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/"},{"categories":["前端"],"content":"本系列是作者在跟着vue-router官网学习时做的笔记，可能并不详尽，读者可以到官网中查看完整内容。 当使用 router-link 组件时，Vue Router 会自动调用 router.push 来触发一次导航。虽然大多数链接的预期行为是将用户导航到一个新页面，但也有少数情况下用户将留在同一页面上： 用户已经位于他们正在尝试导航到的页面 一个导航守卫通过调用 return false 中断了这次导航 当前的导航守卫还没有完成时，一个新的导航守卫会出现了 一个导航守卫通过返回一个新的位置，重定向到其他地方 (例如，return ‘/login’) 一个导航守卫抛出了一个 Error 如果我们想在一个导航完成后做一些事情，我们需要一个在调用 router.push 后进行等待的方法。想象一下，我们有一个移动手机菜单，它允许我们进入不同的页面，而我们只想在导航到新页面后隐藏菜单，我们可能想这样做： router.push('/my-profile')\rthis.isMenuOpen = false 但是这样做会马上关闭菜单，因为 导航是异步的，我们需要 await router.push 返回的 promise ： await router.push('/my-profile')\rthis.isMenuOpen = false 现在，一旦导航完成，菜单就会关闭，但如果导航被阻止，它也会关闭。我们需要一种方法来检测我们是否真的改变了页面。 ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%AF%BC%E8%88%AA%E6%95%85%E9%9A%9C/:0:0","tags":["Vue教程"],"title":"Vue-Router-进阶-导航故障","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%AF%BC%E8%88%AA%E6%95%85%E9%9A%9C/"},{"categories":["前端"],"content":"检测导航故障 如果导航被阻止，导致用户停留在同一个页面上，由 router.push 返回的 Promise 的解析值将是 Navigation Failure。否则，它将是一个 falsy 值(通常是 undefined)。这样我们就可以区分我们导航是否离开了当前位置： const navigationResult = await router.push('/my-profile')\rif (navigationResult) {\r// 导航被阻止\r} else {\r// 导航成功 (包括重新导航的情况)\rthis.isMenuOpen = false\r} Navigation Failure 是带有一些额外属性的 Error 实例，这些属性为我们提供了足够的信息，让我们知道哪些导航被阻止了以及为什么被阻止了。要检查导航结果的性质，请使用 isNavigationFailure 函数： import { NavigationFailureType, isNavigationFailure } from 'vue-router'\r// 试图离开未保存的编辑文本界面\rconst failure = await router.push('/articles/2')\rif (isNavigationFailure(failure, NavigationFailureType.aborted)) {\r// 给用户显示一个小通知\rshowToast('You have unsaved changes, discard and leave anyway?')\r} 如果你忽略第二个参数： isNavigationFailure(failure)，那么就只会检查这个 failure 是不是一个 Navigation Failure。 ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%AF%BC%E8%88%AA%E6%95%85%E9%9A%9C/:1:0","tags":["Vue教程"],"title":"Vue-Router-进阶-导航故障","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%AF%BC%E8%88%AA%E6%95%85%E9%9A%9C/"},{"categories":["前端"],"content":"鉴别导航故障 正如我们在一开始所说的，有不同的情况会导致导航的中止，所有这些情况都会导致不同的 Navigation Failure。它们可以用 isNavigationFailure 和 NavigationFailureType 来区分。总共有三种不同的类型： aborted：在导航守卫中返回 false 中断了本次导航。 cancelled： 在当前导航还没有完成之前又有了一个新的导航。比如，在等待导航守卫的过程中又调用了 router.push。 duplicated：导航被阻止，因为我们已经在目标位置了。 ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%AF%BC%E8%88%AA%E6%95%85%E9%9A%9C/:2:0","tags":["Vue教程"],"title":"Vue-Router-进阶-导航故障","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%AF%BC%E8%88%AA%E6%95%85%E9%9A%9C/"},{"categories":["前端"],"content":"导航故障的属性 所有的导航失败都会暴露 to 和 from 属性，以反映失败导航的当前位置和目标位置： // 正在尝试访问 admin 页面\rrouter.push('/admin').then(failure =\u003e {\rif (isNavigationFailure(failure, NavigationFailureType.redirected)) {\rfailure.to.path // '/admin'\rfailure.from.path // '/'\r}\r}) 在所有情况下，to 和 from 都是规范化的路由地址。 ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%AF%BC%E8%88%AA%E6%95%85%E9%9A%9C/:3:0","tags":["Vue教程"],"title":"Vue-Router-进阶-导航故障","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%AF%BC%E8%88%AA%E6%95%85%E9%9A%9C/"},{"categories":["前端"],"content":"检测重定向 当在导航守卫中返回一个新的位置时，我们会触发一个新的导航，覆盖正在进行的导航。与其他返回值不同的是，重定向不会阻止导航，而是创建一个新的导航。因此，通过读取路由地址中的 redirectedFrom 属性，对其进行不同的检查： await router.push('/my-profile')\rif (router.currentRoute.value.redirectedFrom) {\r// redirectedFrom 是解析出的路由地址，就像导航守卫中的 to和 from\r} ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%AF%BC%E8%88%AA%E6%95%85%E9%9A%9C/:4:0","tags":["Vue教程"],"title":"Vue-Router-进阶-导航故障","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%AF%BC%E8%88%AA%E6%95%85%E9%9A%9C/"},{"categories":["前端"],"content":"本系列是作者在跟着vue-router官网学习时做的笔记，可能并不详尽，读者可以到官网中查看完整内容。 RouterLink 组件提供了足够的 props 来满足大多数基本应用程序的需求，但它并未尝试涵盖所有可能的用例，在某些高级情况下，你可能会发现自己使用了 v-slot。在大多数中型到大型应用程序中，值得创建一个（如果不是多个）自定义 RouterLink 组件，以在整个应用程序中重用它们。例如导航菜单中的链接，处理外部链接，添加 inactive-class 等。 让我们扩展 RouterLink 来处理外部链接，并在 AppLink.vue 文件中添加一个自定义的 inactive-class： \u003ctemplate\u003e\r\u003ca v-if=\"isExternalLink\" v-bind=\"$attrs\" :href=\"to\" target=\"_blank\"\u003e\r\u003cslot /\u003e\r\u003c/a\u003e\r\u003crouter-link\rv-else\rv-bind=\"$props\"\rcustom\rv-slot=\"{ isActive, href, navigate }\"\r\u003e\r\u003ca\rv-bind=\"$attrs\"\r:href=\"href\"\r@click=\"navigate\"\r:class=\"isActive ? activeClass : inactiveClass\"\r\u003e\r\u003cslot /\u003e\r\u003c/a\u003e\r\u003c/router-link\u003e\r\u003c/template\u003e\r\u003cscript\u003e\rimport { RouterLink } from 'vue-router'\rexport default {\rname: 'AppLink',\rinheritAttrs: false,\rprops: {\r// 如果使用 TypeScript，请添加 @ts-ignore\r...RouterLink.props,\rinactiveClass: String,\r},\rcomputed: {\risExternalLink() {\rreturn typeof this.to === 'string' \u0026\u0026 this.to.startsWith('http')\r},\r},\r}\r\u003c/script\u003e 如果你喜欢使用渲染函数或创建 computed 属性，你可以使用 Composition API 中的 useLink ： import { RouterLink, useLink } from 'vue-router'\rexport default {\rname: 'AppLink',\rprops: {\r// 如果使用 TypeScript，请添加 @ts-ignore\r...RouterLink.props,\rinactiveClass: String,\r},\rsetup(props) {\r// `props` 包含 `to` 和任何其他可以传递给 \u003crouter-link\u003e 的 prop\rconst { navigate, href, route, isActive, isExactActive } = useLink(props)\r// profit!\rreturn { isExternalLink }\r},\r} 在实践中，你可能希望将你的 AppLink 组件用于应用程序的不同部分。例如，使用 Tailwind CSS，你可以用所有的类创建一个 NavLink.vue 组件： \u003ctemplate\u003e\r\u003cAppLink\rv-bind=\"$attrs\"\rclass=\"inline-flex items-center px-1 pt-1 border-b-2 border-transparent text-sm font-medium leading-5 text-gray-500 focus:outline-none transition duration-150 ease-in-out hover:text-gray-700 hover:border-gray-300 focus:outline-none focus:text-gray-700 focus:border-gray-300 transition duration-150 ease-in-out\"\ractive-class=\"border-indigo-500 text-gray-900 focus:border-indigo-700\"\rinactive-class=\"text-gray-500 hover:text-gray-700 hover:border-gray-300 focus:text-gray-700 focus:border-gray-300\"\r\u003e\r\u003cslot /\u003e\r\u003c/AppLink\u003e\r\u003c/template\u003e ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E6%89%A9%E5%B1%95routerlink/:0:0","tags":["Vue教程"],"title":"Vue-Router-进阶-扩展RouterLink","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E6%89%A9%E5%B1%95routerlink/"},{"categories":["前端"],"content":"本系列是作者在跟着vue-router官网学习时做的笔记，可能并不详尽，读者可以到官网中查看完整内容。 当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就会更加高效。 Vue Router 支持开箱即用的动态导入，这意味着你可以用动态导入代替静态导入： // 将\r// import UserDetails from './views/UserDetails'\r// 替换成\rconst UserDetails = () =\u003e import('./views/UserDetails')\rconst router = createRouter({\r// ...\rroutes: [{ path: '/users/:id', component: UserDetails }],\r}) component (和 components) 配置接收一个返回 Promise 组件的函数，Vue Router 只会在第一次进入页面时才会获取这个函数，然后使用缓存数据。这意味着你也可以使用更复杂的函数，只要它们返回一个 Promise ： const UserDetails = () =\u003e\rPromise.resolve({\r/* 组件定义 */\r}) 一般来说，对所有的路由都使用动态导入是个好主意。 不要在路由中使用异步组件。异步组件仍然可以在路由组件中使用，但路由组件本身就是动态导入的。 如果你使用的是 webpack 之类的打包器，它将自动从代码分割中受益。 如果你使用的是 Babel，你将需要添加 syntax-dynamic-import 插件，才能使 Babel 正确地解析语法。 ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD/:0:0","tags":["Vue教程"],"title":"Vue-Router-进阶-路由懒加载","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD/"},{"categories":["前端"],"content":"把组件按组分块 ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD/:1:0","tags":["Vue教程"],"title":"Vue-Router-进阶-路由懒加载","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD/"},{"categories":["前端"],"content":"使用 Vite 在Vite中，你可以在rollupOptions下定义分块： // vite.config.js\rexport default defineConfig({\rbuild: {\rrollupOptions: {\r// https://rollupjs.org/guide/en/#outputmanualchunks\routput: {\rmanualChunks: {\r'group-user': [\r'./src/UserDetails',\r'./src/UserDashboard',\r'./src/UserProfileEdit',\r],\r},\r},\r},\r}) ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD/:1:1","tags":["Vue教程"],"title":"Vue-Router-进阶-路由懒加载","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD/"},{"categories":["前端"],"content":"本系列是作者在跟着vue-router官网学习时做的笔记，可能并不详尽，读者可以到官网中查看完整内容。 使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 vue-router 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。 注意: 这个功能只在支持 history.pushState 的浏览器中可用。 当创建一个 Router 实例，你可以提供一个 scrollBehavior 方法： const router = createRouter({\rhistory: createWebHashHistory(),\rroutes: [...],\rscrollBehavior (to, from, savedPosition) {\r// return 期望滚动到哪个的位置\r}\r}) scrollBehavior 函数接收 to和 from 路由对象，如 Navigation Guards。第三个参数 savedPosition，只有当这是一个 popstate 导航时才可用（由浏览器的后退/前进按钮触发）。 该函数可以返回一个 ScrollToOptions 位置对象: const router = createRouter({\rscrollBehavior(to, from, savedPosition) {\r// 始终滚动到顶部\rreturn { top: 0 }\r},\r}) 你也可以通过 el 传递一个 CSS 选择器或一个 DOM 元素。在这种情况下，top 和 left 将被视为该元素的相对偏移量。 const router = createRouter({\rscrollBehavior(to, from, savedPosition) {\r// 始终在元素 #main 上方滚动 10px\rreturn {\r// 也可以这么写\r// el: document.getElementById('main'),\rel: '#main',\rtop: -10,\r}\r},\r}) 如果返回一个 falsy 的值，或者是一个空对象，那么不会发生滚动。 返回 savedPosition，在按下 后退/前进 按钮时，就会像浏览器的原生表现那样： const router = createRouter({\rscrollBehavior(to, from, savedPosition) {\rif (savedPosition) {\rreturn savedPosition\r} else {\rreturn { top: 0 }\r}\r},\r}) 如果你要模拟 “滚动到锚点” 的行为： const router = createRouter({\rscrollBehavior(to, from, savedPosition) {\rif (to.hash) {\rreturn {\rel: to.hash,\r}\r}\r},\r}) 如果你的浏览器支持滚动行为，你可以让它变得更流畅： const router = createRouter({\rscrollBehavior(to, from, savedPosition) {\rif (to.hash) {\rreturn {\rel: to.hash,\rbehavior: 'smooth',\r}\r}\r}\r}) ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E6%BB%9A%E5%8A%A8%E8%A1%8C%E4%B8%BA/:0:0","tags":["Vue教程"],"title":"Vue-Router-进阶-滚动行为","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E6%BB%9A%E5%8A%A8%E8%A1%8C%E4%B8%BA/"},{"categories":["前端"],"content":"延迟滚动 有时候，我们需要在页面中滚动之前稍作等待。例如，当处理过渡时，我们希望等待过渡结束后再滚动。要做到这一点，你可以返回一个 Promise，它可以返回所需的位置描述符。下面是一个例子，我们在滚动前等待 500ms： const router = createRouter({\rscrollBehavior(to, from, savedPosition) {\rreturn new Promise((resolve, reject) =\u003e {\rsetTimeout(() =\u003e {\rresolve({ left: 0, top: 0 })\r}, 500)\r})\r},\r}) 我们可以将其与页面级过渡组件的事件挂钩，以使滚动行为与你的页面过渡很好地结合起来，但由于使用场景可能存在的差异和复杂性，我们只是提供了这个基础来实现特定的用户场景。 ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E6%BB%9A%E5%8A%A8%E8%A1%8C%E4%B8%BA/:1:0","tags":["Vue教程"],"title":"Vue-Router-进阶-滚动行为","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E6%BB%9A%E5%8A%A8%E8%A1%8C%E4%B8%BA/"},{"categories":["前端"],"content":"本系列是作者在跟着vue-router官网学习时做的笔记，可能并不详尽，读者可以到官网中查看完整内容。 ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E8%BF%87%E6%B8%A1%E5%8A%A8%E6%95%88/:0:0","tags":["Vue教程"],"title":"Vue-Router-进阶-过渡动效","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E8%BF%87%E6%B8%A1%E5%8A%A8%E6%95%88/"},{"categories":["前端"],"content":"本系列是作者在跟着vue-router官网学习时做的笔记，可能并不详尽，读者可以到官网中查看完整内容。 ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E7%BB%84%E5%90%88%E5%BC%8Fapi/:0:0","tags":["Vue教程"],"title":"Vue-Router-进阶-组合式API","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E7%BB%84%E5%90%88%E5%BC%8Fapi/"},{"categories":["前端"],"content":"本系列是作者在跟着vue-router官网学习时做的笔记，可能并不详尽，读者可以到官网中查看完整内容。 有时候，进入某个路由后，需要从服务器获取数据。例如，在渲染用户信息时，你需要从服务器获取用户的数据。我们可以通过两种方式来实现： 导航完成之后获取：先完成导航，然后在接下来的组件生命周期钩子中获取数据。在数据获取期间显示“加载中”之类的指示。 导航完成之前获取：导航完成前，在路由进入的守卫中获取数据，在数据获取成功后执行导航。 从技术角度讲，两种方式都不错 —— 就看你想要的用户体验是哪种。 ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96/:0:0","tags":["Vue教程"],"title":"Vue-Router-进阶-数据获取","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96/"},{"categories":["前端"],"content":"导航完成后获取数据 当你使用这种方式时，我们会马上导航和渲染组件，然后在组件的 created 钩子中获取数据。这让我们有机会在数据获取期间展示一个 loading 状态，还可以在不同视图间展示不同的 loading 状态。 假设我们有一个 Post 组件，需要基于 $route.params.id 获取文章数据： \u003ctemplate\u003e\r\u003cdiv class=\"post\"\u003e\r\u003cdiv v-if=\"loading\" class=\"loading\"\u003eLoading...\u003c/div\u003e\r\u003cdiv v-if=\"error\" class=\"error\"\u003e{{ error }}\u003c/div\u003e\r\u003cdiv v-if=\"post\" class=\"content\"\u003e\r\u003ch2\u003e{{ post.title }}\u003c/h2\u003e\r\u003cp\u003e{{ post.body }}\u003c/p\u003e\r\u003c/div\u003e\r\u003c/div\u003e\r\u003c/template\u003e export default {\rdata() {\rreturn {\rloading: false,\rpost: null,\rerror: null,\r}\r},\rcreated() {\r// watch 路由的参数，以便再次获取数据\rthis.$watch(\r() =\u003e this.$route.params,\r() =\u003e {\rthis.fetchData()\r},\r// 组件创建完后获取数据，\r// 此时 data 已经被 observed 了\r{ immediate: true }\r)\r},\rmethods: {\rfetchData() {\rthis.error = this.post = null\rthis.loading = true\r// replace `getPost` with your data fetching util / API wrapper\rgetPost(this.$route.params.id, (err, post) =\u003e {\rthis.loading = false\rif (err) {\rthis.error = err.toString()\r} else {\rthis.post = post\r}\r})\r},\r},\r} ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96/:1:0","tags":["Vue教程"],"title":"Vue-Router-进阶-数据获取","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96/"},{"categories":["前端"],"content":"在导航完成前获取数据 通过这种方式，我们在导航转入新的路由前获取数据。我们可以在接下来的组件的 beforeRouteEnter 守卫中获取数据，当数据获取成功后只调用 next 方法： export default {\rdata() {\rreturn {\rpost: null,\rerror: null,\r}\r},\rbeforeRouteEnter(to, from, next) {\rgetPost(to.params.id, (err, post) =\u003e {\rnext(vm =\u003e vm.setData(err, post))\r})\r},\r// 路由改变前，组件就已经渲染完了\r// 逻辑稍稍不同\rasync beforeRouteUpdate(to, from) {\rthis.post = null\rtry {\rthis.post = await getPost(to.params.id)\r} catch (error) {\rthis.error = error.toString()\r}\r},\r} 在为后面的视图获取数据时，用户会停留在当前的界面，因此建议在数据获取期间，显示一些进度条或者别的指示。如果数据获取失败，同样有必要展示一些全局的错误提醒。 ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96/:2:0","tags":["Vue教程"],"title":"Vue-Router-进阶-数据获取","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96/"},{"categories":["前端"],"content":"本系列是作者在跟着vue-router官网学习时做的笔记，可能并不详尽，读者可以到官网中查看完整内容。 有时，你可能希望将任意信息附加到路由上，如过渡名称、谁可以访问路由等。这些事情可以通过接收属性对象的meta属性来实现，并且它可以在路由地址和导航守卫上都被访问到。定义路由的时候你可以这样配置 meta 字段： const routes = [\r{\rpath: '/posts',\rcomponent: PostsLayout,\rchildren: [\r{\rpath: 'new',\rcomponent: PostsNew,\r// 只有经过身份验证的用户才能创建帖子\rmeta: { requiresAuth: true }\r},\r{\rpath: ':id',\rcomponent: PostsDetail\r// 任何人都可以阅读文章\rmeta: { requiresAuth: false }\r}\r]\r}\r] 那么如何访问这个 meta 字段呢？ 首先，我们称呼 routes 配置中的每个路由对象为 路由记录。路由记录可以是嵌套的，因此，当一个路由匹配成功后，它可能匹配多个路由记录。 例如，根据上面的路由配置，/posts/new 这个 URL 将会匹配父路由记录 (path: ‘/posts’) 以及子路由记录 (path: ’new’)。 一个路由匹配到的所有路由记录会暴露为 $route 对象(还有在导航守卫中的路由对象)的$route.matched 数组。我们需要遍历这个数组来检查路由记录中的 meta 字段，但是 Vue Router 还为你提供了一个 $route.meta 方法，它是一个非递归合并所有 meta 字段的（从父字段到子字段）的方法。这意味着你可以简单地写 router.beforeEach((to, from) =\u003e {\r// 而不是去检查每条路由记录\r// to.matched.some(record =\u003e record.meta.requiresAuth)\rif (to.meta.requiresAuth \u0026\u0026 !auth.isLoggedIn()) {\r// 此路由需要授权，请检查是否已登录\r// 如果没有，则重定向到登录页面\rreturn {\rpath: '/login',\r// 保存我们所在的位置，以便以后再来\rquery: { redirect: to.fullPath },\r}\r}\r}) ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E8%B7%AF%E7%94%B1%E5%85%83%E4%BF%A1%E6%81%AF/:0:0","tags":["Vue教程"],"title":"Vue-Router-进阶-路由元信息","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E8%B7%AF%E7%94%B1%E5%85%83%E4%BF%A1%E6%81%AF/"},{"categories":["前端"],"content":"TypeScript ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E8%B7%AF%E7%94%B1%E5%85%83%E4%BF%A1%E6%81%AF/:1:0","tags":["Vue教程"],"title":"Vue-Router-进阶-路由元信息","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E8%B7%AF%E7%94%B1%E5%85%83%E4%BF%A1%E6%81%AF/"},{"categories":["前端"],"content":"本系列是作者在跟着vue-router官网学习时做的笔记，可能并不详尽，读者可以到官网中查看完整内容。 正如其名，vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。这里有很多方式植入路由导航中：全局的，单个路由独享的，或者组件级的。 ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/:0:0","tags":["Vue教程"],"title":"Vue-Router-进阶-导航守卫","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/"},{"categories":["前端"],"content":"全局前置守卫 你可以使用 router.beforeEach 注册一个全局前置守卫： const router = createRouter({ ... })\rrouter.beforeEach((to, from) =\u003e {\r// ...\r// 返回 false 以取消导航\rreturn false\r}) 当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于等待中。 每个守卫方法接收两个参数： to: 即将要进入的目标 用一种标准化的方式 from: 当前导航正要离开的路由 用一种标准化的方式 可以返回的值如下: false: 取消当前的导航。如果浏览器的 URL 改变了(可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。 一个路由地址: 通过一个路由地址跳转到一个不同的地址，就像你调用 router.push() 一样，你可以设置诸如 replace: true 或 name: ‘home’ 之类的配置。当前的导航被中断，然后进行一个新的导航，就和 from 一样。 router.beforeEach(async (to, from) =\u003e {\rif (\r// 检查用户是否已登录\r!isAuthenticated \u0026\u0026\r// ❗️ 避免无限重定向\rto.name !== 'Login'\r) {\r// 将用户重定向到登录页面\rreturn { name: 'Login' }\r}\r}) 如果遇到了意料之外的情况，可能会抛出一个 Error。这会取消导航并且调用 router.onError() 注册过的回调。 如果什么都没有，undefined 或返回 true，则导航是有效的，并调用下一个导航守卫 以上所有都同 async 函数 和 Promise 工作方式一样： router.beforeEach(async (to, from) =\u003e {\r// canUserAccess() 返回 `true` 或 `false`\rconst canAccess = await canUserAccess(to)\rif (!canAccess) return '/login'\r}) ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/:1:0","tags":["Vue教程"],"title":"Vue-Router-进阶-导航守卫","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/"},{"categories":["前端"],"content":"可选的第三个参数 next 在之前的 Vue Router 版本中，也是可以使用 第三个参数 next 的。这是一个常见的错误来源，可以通过 RFC 来消除错误。然而，它仍然是被支持的，这意味着你可以向任何导航守卫传递第三个参数。在这种情况下，确保 next 在任何给定的导航守卫中都被严格调用一次。它可以出现多于一次，但是只能在所有的逻辑路径都不重叠的情况下，否则钩子永远都不会被解析或报错。这里有一个在用户未能验证身份时重定向到/login的错误用例： // BAD\rrouter.beforeEach((to, from, next) =\u003e {\rif (to.name !== 'Login' \u0026\u0026 !isAuthenticated) next({ name: 'Login' })\r// 如果用户未能验证身份，则 `next` 会被调用两次\rnext()\r}) 下面是正确的版本: // GOOD\rrouter.beforeEach((to, from, next) =\u003e {\rif (to.name !== 'Login' \u0026\u0026 !isAuthenticated) next({ name: 'Login' })\relse next()\r}) ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/:1:1","tags":["Vue教程"],"title":"Vue-Router-进阶-导航守卫","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/"},{"categories":["前端"],"content":"全局解析守卫 你可以用 router.beforeResolve 注册一个全局守卫。这和 router.beforeEach 类似，因为它在 每次导航时都会触发，但是确保在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被正确调用。这里有一个例子，确保用户可以访问自定义 meta 属性 requiresCamera 的路由： router.beforeResolve(async to =\u003e {\rif (to.meta.requiresCamera) {\rtry {\rawait askForCameraPermission()\r} catch (error) {\rif (error instanceof NotAllowedError) {\r// ... 处理错误，然后取消导航\rreturn false\r} else {\r// 意料之外的错误，取消导航并把错误传给全局处理器\rthrow error\r}\r}\r}\r}) router.beforeResolve 是获取数据或执行任何其他操作（如果用户无法进入页面时你希望避免执行的操作）的理想位置。 ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/:2:0","tags":["Vue教程"],"title":"Vue-Router-进阶-导航守卫","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/"},{"categories":["前端"],"content":"全局后置钩子 你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身： router.afterEach((to, from) =\u003e {\rsendToAnalytics(to.fullPath)\r}) 它们对于分析、更改页面标题、声明页面等辅助功能以及许多其他事情都很有用。 它们也反映了 navigation failures 作为第三个参数： router.afterEach((to, from, failure) =\u003e {\rif (!failure) sendToAnalytics(to.fullPath)\r}) 了解更多关于 navigation failures 的信息在它的指南中。 ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/:3:0","tags":["Vue教程"],"title":"Vue-Router-进阶-导航守卫","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/"},{"categories":["前端"],"content":"路由独享的守卫 你可以直接在路由配置上定义 beforeEnter 守卫： const routes = [\r{\rpath: '/users/:id',\rcomponent: UserDetails,\rbeforeEnter: (to, from) =\u003e {\r// reject the navigation\rreturn false\r},\r},\r] beforeEnter 守卫 只在进入路由时触发，不会在 params、query 或 hash 改变时触发。例如，从 /users/2 进入到 /users/3 或者从 /users/2#info 进入到 /users/2#projects。它们只有在 从一个不同的 路由导航时，才会被触发。 你也可以将一个函数数组传递给 beforeEnter，这在为不同的路由重用守卫时很有用： function removeQueryParams(to) {\rif (Object.keys(to.query).length)\rreturn { path: to.path, query: {}, hash: to.hash }\r}\rfunction removeHash(to) {\rif (to.hash) return { path: to.path, query: to.query, hash: '' }\r}\rconst routes = [\r{\rpath: '/users/:id',\rcomponent: UserDetails,\rbeforeEnter: [removeQueryParams, removeHash],\r},\r{\rpath: '/about',\rcomponent: UserDetails,\rbeforeEnter: [removeQueryParams],\r},\r] 请注意，你也可以通过使用路径 meta 字段和全局导航守卫来实现类似的行为。 ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/:4:0","tags":["Vue教程"],"title":"Vue-Router-进阶-导航守卫","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/"},{"categories":["前端"],"content":"组件内的守卫 最后，你可以在路由组件内直接定义路由导航守卫(传递给路由配置的) ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/:5:0","tags":["Vue教程"],"title":"Vue-Router-进阶-导航守卫","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/"},{"categories":["前端"],"content":"可用的配置 API 你可以为路由组件添加以下配置： beforeRouteEnter beforeRouteUpdate beforeRouteLeave const UserDetails = {\rtemplate: `...`,\rbeforeRouteEnter(to, from) {\r// 在渲染该组件的对应路由被验证前调用\r// 不能获取组件实例 `this` ！\r// 因为当守卫执行时，组件实例还没被创建！\r},\rbeforeRouteUpdate(to, from) {\r// 在当前路由改变，但是该组件被复用时调用\r// 举例来说，对于一个带有动态参数的路径 `/users/:id`，在 `/users/1` 和 `/users/2` 之间跳转的时候，\r// 由于会渲染同样的 `UserDetails` 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。\r// 因为在这种情况发生的时候，组件已经挂载好了，导航守卫可以访问组件实例 `this`\r},\rbeforeRouteLeave(to, from) {\r// 在导航离开渲染该组件的对应路由时调用\r// 与 `beforeRouteUpdate` 一样，它可以访问组件实例 `this`\r},\r} beforeRouteEnter 守卫 不能 访问 this，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建。 不过，你可以通过传一个回调给 next 来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数： beforeRouteEnter (to, from, next) {\rnext(vm =\u003e {\r// 通过 `vm` 访问组件实例\r})\r} 注意 beforeRouteEnter 是支持给 next 传递回调的唯一守卫。对于 beforeRouteUpdate 和 beforeRouteLeave 来说，this 已经可用了，所以不支持 传递回调，因为没有必要了： beforeRouteUpdate (to, from) {\r// just use `this`\rthis.name = to.params.name\r} 这个 离开守卫 通常用来预防用户在还未保存修改前突然离开。该导航可以通过返回 false 来取消。 beforeRouteLeave (to, from) {\rconst answer = window.confirm('Do you really want to leave? you have unsaved changes!')\rif (!answer) return false\r} ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/:5:1","tags":["Vue教程"],"title":"Vue-Router-进阶-导航守卫","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/"},{"categories":["前端"],"content":"使用组合 API 如果你正在使用组合 API 和 setup 函数来编写组件，你可以通过 onBeforeRouteUpdate 和 onBeforeRouteLeave 分别添加 update 和 leave 守卫。 请参考组合 API 部分以获得更多细节。 ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/:5:2","tags":["Vue教程"],"title":"Vue-Router-进阶-导航守卫","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/"},{"categories":["前端"],"content":"完整的导航解析流程 导航被触发。 在失活的组件里调用 beforeRouteLeave 守卫。 调用全局的 beforeEach 守卫。 在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。 在路由配置里调用 beforeEnter。 解析异步路由组件。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫(2.5+)。 导航被确认。 调用全局的 afterEach 钩子。 触发 DOM 更新。 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。 ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/:6:0","tags":["Vue教程"],"title":"Vue-Router-进阶-导航守卫","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E8%BF%9B%E9%98%B6/%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/"},{"categories":["前端"],"content":"本系列是作者在跟着vue-router官网学习时做的笔记，可能并不详尽，读者可以到官网中查看完整内容。 在创建路由器实例时，history 配置允许我们在不同的历史模式中进行选择。 ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E4%B8%8D%E5%90%8C%E7%9A%84%E5%8E%86%E5%8F%B2%E6%A8%A1%E5%BC%8F/:0:0","tags":["Vue教程"],"title":"Vue-Router-基础-不同的历史模式","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E4%B8%8D%E5%90%8C%E7%9A%84%E5%8E%86%E5%8F%B2%E6%A8%A1%E5%BC%8F/"},{"categories":["前端"],"content":"Hash 模式 hash 模式是用 createWebHashHistory() 创建的： import { createRouter, createWebHashHistory } from 'vue-router'\rconst router = createRouter({\rhistory: createWebHashHistory(),\rroutes: [\r//...\r],\r}) 它在内部传递的实际 URL 之前使用了一个哈希字符（#）。由于这部分 URL 从未被发送到服务器，所以它不需要在服务器层面上进行任何特殊处理。不过，它在 SEO 中确实有不好的影响。如果你担心这个问题，可以使用 HTML5 模式。 ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E4%B8%8D%E5%90%8C%E7%9A%84%E5%8E%86%E5%8F%B2%E6%A8%A1%E5%BC%8F/:1:0","tags":["Vue教程"],"title":"Vue-Router-基础-不同的历史模式","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E4%B8%8D%E5%90%8C%E7%9A%84%E5%8E%86%E5%8F%B2%E6%A8%A1%E5%BC%8F/"},{"categories":["前端"],"content":"HTML5 模式 用 createWebHistory() 创建 HTML5 模式，推荐使用这个模式： import { createRouter, createWebHistory } from 'vue-router'\rconst router = createRouter({\rhistory: createWebHistory(),\rroutes: [\r//...\r],\r}) 当使用这种历史模式时，URL 会看起来很 “正常”，例如 https://example.com/user/id。漂亮! 不过，问题来了。由于我们的应用是一个单页的客户端应用，如果没有适当的服务器配置，用户在浏览器中直接访问 https://example.com/user/id，就会得到一个 404 错误。这就丑了。 不用担心：要解决这个问题，你需要做的就是在你的服务器上添加一个简单的回退路由。如果 URL 不匹配任何静态资源，它应提供与你的应用程序中的 index.html 相同的页面。漂亮依旧! ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E4%B8%8D%E5%90%8C%E7%9A%84%E5%8E%86%E5%8F%B2%E6%A8%A1%E5%BC%8F/:2:0","tags":["Vue教程"],"title":"Vue-Router-基础-不同的历史模式","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E4%B8%8D%E5%90%8C%E7%9A%84%E5%8E%86%E5%8F%B2%E6%A8%A1%E5%BC%8F/"},{"categories":["前端"],"content":"服务器配置示例 注意：以下示例假定你正在从根目录提供服务。如果你部署到子目录，你应该使用Vue CLI 的 publicPath 配置和相关的路由器的 base 属性。你还需要调整下面的例子，以使用子目录而不是根目录（例如，将RewriteBase/ 替换为 RewriteBase/name-of-your-subfolder/）。 ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E4%B8%8D%E5%90%8C%E7%9A%84%E5%8E%86%E5%8F%B2%E6%A8%A1%E5%BC%8F/:3:0","tags":["Vue教程"],"title":"Vue-Router-基础-不同的历史模式","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E4%B8%8D%E5%90%8C%E7%9A%84%E5%8E%86%E5%8F%B2%E6%A8%A1%E5%BC%8F/"},{"categories":["前端"],"content":"nginx location / {\rtry_files $uri $uri/ /index.html;\r} ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E4%B8%8D%E5%90%8C%E7%9A%84%E5%8E%86%E5%8F%B2%E6%A8%A1%E5%BC%8F/:3:1","tags":["Vue教程"],"title":"Vue-Router-基础-不同的历史模式","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E4%B8%8D%E5%90%8C%E7%9A%84%E5%8E%86%E5%8F%B2%E6%A8%A1%E5%BC%8F/"},{"categories":["前端"],"content":"本系列是作者在跟着vue-router官网学习时做的笔记，可能并不详尽，读者可以到官网中查看完整内容。 在你的组件中使用 $route 会与路由紧密耦合，这限制了组件的灵活性，因为它只能用于特定的 URL。虽然这不一定是件坏事，但我们可以通过 props 配置来解除这种行为： 我们可以将下面的代码 const User = {\rtemplate: '\u003cdiv\u003eUser {{ $route.params.id }}\u003c/div\u003e'\r}\rconst routes = [{ path: '/user/:id', component: User }] 替换成 const User = {\r// 请确保添加一个与路由参数完全相同的 prop 名\rprops: ['id'],\rtemplate: '\u003cdiv\u003eUser {{ id }}\u003c/div\u003e'\r}\rconst routes = [{ path: '/user/:id', component: User, props: true }] 这允许你在任何地方使用该组件，使得该组件更容易重用和测试。 ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%B0%86props%E4%BC%A0%E9%80%92%E7%BB%99%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6/:0:0","tags":["Vue教程"],"title":"Vue-Router-基础-将props传递给路由组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%B0%86props%E4%BC%A0%E9%80%92%E7%BB%99%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"布尔模式 当 props 设置为 true 时，route.params 将被设置为组件的 props。 ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%B0%86props%E4%BC%A0%E9%80%92%E7%BB%99%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6/:1:0","tags":["Vue教程"],"title":"Vue-Router-基础-将props传递给路由组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%B0%86props%E4%BC%A0%E9%80%92%E7%BB%99%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"命名视图 对于有命名视图的路由，你必须为每个命名视图定义 props 配置： const routes = [\r{\rpath: '/user/:id',\rcomponents: { default: User, sidebar: Sidebar },\rprops: { default: true, sidebar: false }\r}\r] ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%B0%86props%E4%BC%A0%E9%80%92%E7%BB%99%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6/:2:0","tags":["Vue教程"],"title":"Vue-Router-基础-将props传递给路由组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%B0%86props%E4%BC%A0%E9%80%92%E7%BB%99%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"对象模式 当 props 是一个对象时，它将原样设置为组件 props。当 props 是静态的时候很有用。 const routes = [\r{\rpath: '/promotion/from-newsletter',\rcomponent: Promotion,\rprops: { newsletterPopup: false }\r}\r] ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%B0%86props%E4%BC%A0%E9%80%92%E7%BB%99%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6/:3:0","tags":["Vue教程"],"title":"Vue-Router-基础-将props传递给路由组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%B0%86props%E4%BC%A0%E9%80%92%E7%BB%99%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"函数模式 你可以创建一个返回 props 的函数。这允许你将参数转换为其他类型，将静态值与基于路由的值相结合等等。 const routes = [\r{\rpath: '/search',\rcomponent: SearchUser,\rprops: route =\u003e ({ query: route.query.q })\r}\r] URL /search?q=vue 将传递 {query: ‘vue’} 作为 props 传给 SearchUser 组件。 请尽可能保持 props 函数为无状态的，因为它只会在路由发生变化时起作用。如果你需要状态来定义 props，请使用包装组件，这样 vue 才可以对状态变化做出反应。 ","date":"2022-10-17","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%B0%86props%E4%BC%A0%E9%80%92%E7%BB%99%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6/:4:0","tags":["Vue教程"],"title":"Vue-Router-基础-将props传递给路由组件","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%B0%86props%E4%BC%A0%E9%80%92%E7%BB%99%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"本系列是作者在跟着vue-router官网学习时做的笔记，可能并不详尽，读者可以到官网中查看完整内容。 ","date":"2022-10-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E5%88%AB%E5%90%8D/:0:0","tags":["Vue教程"],"title":"Vue-Router-基础-重定向和别名","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E5%88%AB%E5%90%8D/"},{"categories":["前端"],"content":"重定向 重定向也是通过 routes 配置来完成，下面例子是从 /home 重定向到 /： const routes = [{ path: '/home', redirect: '/' }] 重定向的目标也可以是一个命名的路由： const routes = [{ path: '/home', redirect: { name: 'homepage' } }] 甚至是一个方法，动态返回重定向目标： const routes = [\r{\r// /search/screens -\u003e /search?q=screens\rpath: '/search/:searchText',\rredirect: to =\u003e {\r// 方法接收目标路由作为参数\r// return 重定向的字符串路径/路径对象\rreturn { path: '/search', query: { q: to.params.searchText } }\r},\r},\r{\rpath: '/search',\r// ...\r},\r] 请注意，导航守卫并没有应用在跳转路由上，而仅仅应用在其目标上。在上面的例子中，在 /home 路由中添加 beforeEnter 守卫不会有任何效果。 在写 redirect 的时候，可以省略 component 配置，因为它从来没有被直接访问过，所以没有组件要渲染。唯一的例外是嵌套路由：如果一个路由记录有 children 和 redirect 属性，它也应该有 component 属性。 ","date":"2022-10-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E5%88%AB%E5%90%8D/:1:0","tags":["Vue教程"],"title":"Vue-Router-基础-重定向和别名","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E5%88%AB%E5%90%8D/"},{"categories":["前端"],"content":"相对重定向 也可以重定向到相对位置： const routes = [\r{\r// 将总是把/users/123/posts重定向到/users/123/profile。\rpath: '/users/:id/posts',\rredirect: to =\u003e {\r// 该函数接收目标路由作为参数\r// 相对位置不以`/`开头\r// 或 { path: 'profile'}\rreturn 'profile'\r},\r},\r] ","date":"2022-10-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E5%88%AB%E5%90%8D/:1:1","tags":["Vue教程"],"title":"Vue-Router-基础-重定向和别名","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E5%88%AB%E5%90%8D/"},{"categories":["前端"],"content":"别名 重定向是指当用户访问 /home 时，URL 会被 / 替换，然后匹配成 /。那么什么是别名呢？ 将 / 别名为 /home，意味着当用户访问 /home 时，URL 仍然是 /home，但会被匹配为用户正在访问 /。 上面对应的路由配置为： const routes = [{ path: '/', component: Homepage, alias: '/home' }] 通过别名，你可以自由地将 UI 结构映射到一个任意的 URL，而不受配置的嵌套结构的限制。使别名以 / 开头，以使嵌套路径中的路径成为绝对路径。你甚至可以将两者结合起来，用一个数组提供多个别名： const routes = [\r{\rpath: '/users',\rcomponent: UsersLayout,\rchildren: [\r// 为这 3 个 URL 呈现 UserList\r// - /users\r// - /users/list\r// - /people\r{ path: '', component: UserList, alias: ['/people', 'list'] },\r],\r},\r] 如果你的路由有参数，请确保在任何绝对别名中包含它们： const routes = [\r{\rpath: '/users/:id',\rcomponent: UsersByIdLayout,\rchildren: [\r// 为这 3 个 URL 呈现 UserDetails\r// - /users/24\r// - /users/24/profile\r// - /24\r{ path: 'profile', component: UserDetails, alias: ['/:id', ''] },\r],\r},\r] ","date":"2022-10-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E5%88%AB%E5%90%8D/:1:2","tags":["Vue教程"],"title":"Vue-Router-基础-重定向和别名","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E5%88%AB%E5%90%8D/"},{"categories":["前端"],"content":"本系列是作者在跟着vue-router官网学习时做的笔记，可能并不详尽，读者可以到官网中查看完整内容。 有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 sidebar (侧导航) 和 main (主内容) 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 router-view 没有设置名字，那么默认为 default。 \u003crouter-view class=\"view left-sidebar\" name=\"LeftSidebar\"\u003e\u003c/router-view\u003e\r\u003crouter-view class=\"view main-content\"\u003e\u003c/router-view\u003e\r\u003crouter-view class=\"view right-sidebar\" name=\"RightSidebar\"\u003e\u003c/router-view\u003e 一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 components 配置 (带上 s)： const router = createRouter({\rhistory: createWebHashHistory(),\rroutes: [\r{\rpath: '/',\rcomponents: {\rdefault: Home,\r// LeftSidebar: LeftSidebar 的缩写\rLeftSidebar,\r// 它们与 `\u003crouter-view\u003e` 上的 `name` 属性匹配\rRightSidebar,\r},\r},\r],\r}) ","date":"2022-10-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%91%BD%E5%90%8D%E8%A7%86%E5%9B%BE/:0:0","tags":["Vue教程"],"title":"Vue-Router-基础-命名视图","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%91%BD%E5%90%8D%E8%A7%86%E5%9B%BE/"},{"categories":["前端"],"content":"嵌套命名视图 我们也有可能使用命名视图创建嵌套视图的复杂布局。这时你也需要命名用到的嵌套 router-view 组件。我们以一个设置面板为例： /settings/emails /settings/profile\r+-----------------------------------+ +------------------------------+\r| UserSettings | | UserSettings |\r| +-----+-------------------------+ | | +-----+--------------------+ |\r| | Nav | UserEmailsSubscriptions | | +------------\u003e | | Nav | UserProfile | |\r| | +-------------------------+ | | | +--------------------+ |\r| | | | | | | | UserProfilePreview | |\r| +-----+-------------------------+ | | +-----+--------------------+ |\r+-----------------------------------+ +------------------------------+ Nav 只是一个常规组件。 UserSettings 是一个视图组件。 UserEmailsSubscriptions、UserProfile、UserProfilePreview 是嵌套的视图组件。 注意：我们先忘记 HTML/CSS 具体的布局的样子，只专注在用到的组件上。 UserSettings 组件的 \u003ctemplate\u003e 部分应该是类似下面的这段代码: \u003c!-- UserSettings.vue --\u003e\r\u003cdiv\u003e\r\u003ch1\u003eUser Settings\u003c/h1\u003e\r\u003cNavBar /\u003e\r\u003crouter-view /\u003e\r\u003crouter-view name=\"helper\" /\u003e\r\u003c/div\u003e 那么你就可以通过这个路由配置来实现上面的布局： {\rpath: '/settings',\r// 你也可以在顶级路由就配置命名视图\rcomponent: UserSettings,\rchildren: [{\rpath: 'emails',\rcomponent: UserEmailsSubscriptions\r}, {\rpath: 'profile',\rcomponents: {\rdefault: UserProfile,\rhelper: UserProfilePreview\r}\r}]\r} ","date":"2022-10-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%91%BD%E5%90%8D%E8%A7%86%E5%9B%BE/:1:0","tags":["Vue教程"],"title":"Vue-Router-基础-命名视图","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%91%BD%E5%90%8D%E8%A7%86%E5%9B%BE/"},{"categories":["前端"],"content":"本系列是作者在跟着vue-router官网学习时做的笔记，可能并不详尽，读者可以到官网中查看完整内容。 除了 path 之外，你还可以为任何路由提供 name。这有以下优点： 没有硬编码的 URL params 的自动编码/解码。 防止你在 url 中出现打字错误。 绕过路径排序（如显示一个） const routes = [\r{\rpath: '/user/:username',\rname: 'user',\rcomponent: User,\r},\r] 要链接到一个命名的路由，可以向 router-link 组件的 to 属性传递一个对象： \u003crouter-link :to=\"{ name: 'user', params: { username: 'erina' }}\"\u003e\rUser\r\u003c/router-link\u003e 这跟代码调用 router.push() 是一回事： router.push({ name: 'user', params: { username: 'erina' } }) 在这两种情况下，路由将导航到路径 /user/erina。 ","date":"2022-10-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%91%BD%E5%90%8D%E8%B7%AF%E7%94%B1/:0:0","tags":["Vue教程"],"title":"Vue-Router-基础-命名路由","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%91%BD%E5%90%8D%E8%B7%AF%E7%94%B1/"},{"categories":["前端"],"content":"本系列是作者在跟着vue-router官网学习时做的笔记，可能并不详尽，读者可以到官网中查看完整内容。 除了使用 \u003crouter-link\u003e 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现。 ","date":"2022-10-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA/:0:0","tags":["Vue教程"],"title":"Vue-Router-基础-编程式导航","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA/"},{"categories":["前端"],"content":"导航到不同的位置 注意：在 Vue 实例中，你可以通过 $router 访问路由实例。因此你可以调用 this.$router.push。 想要导航到不同的 URL，可以使用 router.push 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，会回到之前的 URL。 当你点击 \u003crouter-link\u003e 时，内部会调用这个方法，所以点击 \u003crouter-link :to=\"...\"\u003e 相当于调用 router.push(…) ： 声明式 编程式 \u003crouter-link :to=\"...\"\u003e router.push(...) 该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如： // 字符串路径\rrouter.push('/users/eduardo')\r// 带有路径的对象\rrouter.push({ path: '/users/eduardo' })\r// 命名的路由，并加上参数，让路由建立 url\rrouter.push({ name: 'user', params: { username: 'eduardo' } })\r// 带查询参数，结果是 /register?plan=private\rrouter.push({ path: '/register', query: { plan: 'private' } })\r// 带 hash，结果是 /about#team\rrouter.push({ path: '/about', hash: '#team' }) 注意：如果提供了 path，params 会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path ： const username = 'eduardo'\r// 我们可以手动建立 url，但我们必须自己处理编码\rrouter.push(`/user/${username}`) // -\u003e /user/eduardo\r// 同样\rrouter.push({ path: `/user/${username}` }) // -\u003e /user/eduardo\r// 如果可能的话，使用 `name` 和 `params` 从自动 URL 编码中获益\rrouter.push({ name: 'user', params: { username } }) // -\u003e /user/eduardo\r// `params` 不能与 `path` 一起使用\rrouter.push({ path: '/user', params: { username } }) // -\u003e /user 当指定 params 时，可提供 string 或 number 参数（或者对于可重复的参数可提供一个数组）。任何其他类型（如 undefined、false 等）都将被自动字符串化。对于可选参数，你可以提供一个空字符串（\"\"）来跳过它。 由于属性 to 与 router.push 接受的对象种类相同，所以两者的规则完全相同。 router.push 和所有其他导航方法都会返回一个 Promise，让我们可以等到导航完成后才知道是成功还是失败。我们将在 Navigation Handling 中详细介绍。 ","date":"2022-10-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA/:1:0","tags":["Vue教程"],"title":"Vue-Router-基础-编程式导航","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA/"},{"categories":["前端"],"content":"替换当前位置 它的作用类似于 router.push，唯一不同的是，它在导航时不会向 history 添加新记录，正如它的名字所暗示的那样——它取代了当前的条目。 声明式 编程式 \u003crouter-link :to=\"...\" replace\u003e router.replace(...) 也可以直接在传递给 router.push 的 routeLocation 中增加一个属性 replace: true ： router.push({ path: '/home', replace: true })\r// 相当于\rrouter.replace({ path: '/home' }) ","date":"2022-10-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA/:2:0","tags":["Vue教程"],"title":"Vue-Router-基础-编程式导航","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA/"},{"categories":["前端"],"content":"横跨历史 该方法采用一个整数作为参数，表示在历史堆栈中前进或后退多少步，类似于 window.history.go(n)。 例子 // 向前移动一条记录，与 router.forward() 相同\rrouter.go(1)\r// 返回一条记录，与 router.back() 相同\rrouter.go(-1)\r// 前进 3 条记录\rrouter.go(3)\r// 如果没有那么多记录，静默失败\rrouter.go(-100)\rrouter.go(100) ","date":"2022-10-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA/:3:0","tags":["Vue教程"],"title":"Vue-Router-基础-编程式导航","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA/"},{"categories":["前端"],"content":"篡改历史 你可能已经注意到，router.push、router.replace 和 router.go 是 window.history.pushState、window.history.replaceState 和 window.history.go 的翻版，它们确实模仿了 window.history 的 API。 因此，如果你已经熟悉 Browser History APIs，在使用 Vue Router 时，操作历史记录就会觉得很熟悉。 值得一提的是，无论在创建路由器实例时传递什么样的 history 配置，Vue Router 的导航方法( push、replace、go )都能始终正常工作。 ","date":"2022-10-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA/:4:0","tags":["Vue教程"],"title":"Vue-Router-基础-编程式导航","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA/"},{"categories":["前端"],"content":"本系列是作者在跟着vue-router官网学习时做的笔记，可能并不详尽，读者可以到官网中查看完整内容。 一些应用程序的 UI 由多层嵌套的组件组成。在这种情况下，URL 的片段通常对应于特定的嵌套组件结构，例如： /user/johnny/profile /user/johnny/posts\r+------------------+ +-----------------+\r| User | | User |\r| +--------------+ | | +-------------+ |\r| | Profile | | +------------\u003e | | Posts | |\r| | | | | | | |\r| +--------------+ | | +-------------+ |\r+------------------+ +-----------------+ 通过 Vue Router，你可以使用嵌套路由配置来表达这种关系。 接着上节创建的 app ： \u003cdiv id=\"app\"\u003e\r\u003crouter-view\u003e\u003c/router-view\u003e\r\u003c/div\u003e const User = {\rtemplate: '\u003cdiv\u003eUser {{ $route.params.id }}\u003c/div\u003e',\r}\r// 这些都会传递给 `createRouter`\rconst routes = [{ path: '/user/:id', component: User }] 这里的 \u003crouter-view\u003e 是一个顶层的 router-view。它渲染顶层路由匹配的组件。同样地，一个被渲染的组件也可以包含自己嵌套的 \u003crouter-view\u003e。例如，如果我们在 User 组件的模板内添加一个 \u003crouter-view\u003e： const User = {\rtemplate: `\r\u003cdiv class=\"user\"\u003e\r\u003ch2\u003eUser {{ $route.params.id }}\u003c/h2\u003e\r\u003crouter-view\u003e\u003c/router-view\u003e\r\u003c/div\u003e\r`,\r} 要将组件渲染到这个嵌套的 router-view 中，我们需要在路由中配置 children： const routes = [\r{\rpath: '/user/:id',\rcomponent: User,\rchildren: [\r{\r// 当 /user/:id/profile 匹配成功\r// UserProfile 将被渲染到 User 的 \u003crouter-view\u003e 内部\rpath: 'profile',\rcomponent: UserProfile,\r},\r{\r// 当 /user/:id/posts 匹配成功\r// UserPosts 将被渲染到 User 的 \u003crouter-view\u003e 内部\rpath: 'posts',\rcomponent: UserPosts,\r},\r],\r},\r] 注意，以 / 开头的嵌套路径将被视为根路径。这允许你利用组件嵌套，而不必使用嵌套的 URL。 如你所见，children 配置只是另一个路由数组，就像 routes 本身一样。因此，你可以根据自己的需要，不断地嵌套视图。 此时，按照上面的配置，当你访问 /user/eduardo 时，在 User 的 router-view 里面什么都不会呈现，因为没有匹配到嵌套路由。也许你确实想在那里渲染一些东西。在这种情况下，你可以提供一个空的嵌套路径： const routes = [\r{\rpath: '/user/:id',\rcomponent: User,\rchildren: [\r// 当 /user/:id 匹配成功\r// UserHome 将被渲染到 User 的 \u003crouter-view\u003e 内部\r{ path: '', component: UserHome },\r// ...其他子路由\r],\r},\r] ","date":"2022-10-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1/:0:0","tags":["Vue教程"],"title":"Vue-Router-基础-嵌套路由","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1/"},{"categories":["前端"],"content":"嵌套的命名路由 在处理命名路由时，你通常会给子路由命名： const routes = [\r{\rpath: '/user/:id',\rcomponent: User,\r// 请注意，只有子路由具有名称\rchildren: [{ path: '', name: 'user', component: UserHome }],\r},\r] 这将确保导航到 /user/:id 时始终显示嵌套路由。 在一些场景中，你可能希望导航到命名路由而不导航到嵌套路由。例如，你想导航 /user/:id 而不显示嵌套路由。那样的话，你还可以命名父路由，但请注意重新加载页面将始终显示嵌套的子路由，因为它被视为指向路径/users/:id 的导航，而不是命名路由： const routes = [\r{\rpath: '/user/:id',\rname: 'user-parent'\rcomponent: User,\rchildren: [{ path: '', name: 'user', component: UserHome }],\r},\r] ","date":"2022-10-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1/:1:0","tags":["Vue教程"],"title":"Vue-Router-基础-嵌套路由","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1/"},{"categories":["前端"],"content":"本系列是作者在跟着vue-router官网学习时做的笔记，可能并不详尽，读者可以到官网中查看完整内容。 大多数应用都会使用 /about 这样的静态路由和 /users/:userId 这样的动态路由，就像我们刚才在动态路由匹配中看到的那样，但是 Vue Router 可以提供更多的方式！ 为了简单起见，所有的路由都省略了 component 属性，只关注 path 值。 ","date":"2022-10-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8C%B9%E9%85%8D%E8%AF%AD%E6%B3%95/:0:0","tags":["Vue教程"],"title":"Vue-Router-基础-路由的匹配语法","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8C%B9%E9%85%8D%E8%AF%AD%E6%B3%95/"},{"categories":["前端"],"content":"在参数中自定义正则 当定义像 :userId 这样的参数时，我们内部使用以下的正则 ([^/]+) (至少有一个字符不是斜杠 / )来从 URL 中提取参数。这很好用，除非你需要根据参数的内容来区分两个路由。想象一下，两个路由 /:orderId 和 /:productName，两者会匹配完全相同的 URL，所以我们需要一种方法来区分它们。最简单的方法就是在路径中添加一个静态部分来区分它们： const routes = [\r// 匹配 /o/3549\r{ path: '/o/:orderId' },\r// 匹配 /p/books\r{ path: '/p/:productName' },\r] 但在某些情况下，我们并不想添加静态的 /o /p 部分。由于，orderId 总是一个数字，而 productName 可以是任何东西，所以我们可以在括号中为参数指定一个自定义的正则： const routes = [\r// /:orderId -\u003e 仅匹配数字\r{ path: '/:orderId(\\\\d+)' },\r// /:productName -\u003e 匹配其他任何内容\r{ path: '/:productName' },\r] 现在，转到 /25 将匹配 /:orderId，其他情况将会匹配 /:productName。routes 数组的顺序并不重要! 确保转义反斜杠( \\ )，就像我们对 \\d (变成\\d)所做的那样，在 JavaScript 中实际传递字符串中的反斜杠字符。 ","date":"2022-10-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8C%B9%E9%85%8D%E8%AF%AD%E6%B3%95/:1:0","tags":["Vue教程"],"title":"Vue-Router-基础-路由的匹配语法","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8C%B9%E9%85%8D%E8%AF%AD%E6%B3%95/"},{"categories":["前端"],"content":"可重复的参数 如果你需要匹配具有多个部分的路由，如 /first/second/third，你应该用 *（0 个或多个）和 +（1 个或多个）将参数标记为可重复： const routes = [\r// /:chapters -\u003e 匹配 /one, /one/two, /one/two/three, 等\r{ path: '/:chapters+' },\r// /:chapters -\u003e 匹配 /, /one, /one/two, /one/two/three, 等\r{ path: '/:chapters*' },\r] 这将为你提供一个参数数组，而不是一个字符串，并且在使用命名路由时也需要你传递一个数组： // 给定 { path: '/:chapters*', name: 'chapters' },\rrouter.resolve({ name: 'chapters', params: { chapters: [] } }).href\r// 产生 /\rrouter.resolve({ name: 'chapters', params: { chapters: ['a', 'b'] } }).href\r// 产生 /a/b\r// 给定 { path: '/:chapters+', name: 'chapters' },\rrouter.resolve({ name: 'chapters', params: { chapters: [] } }).href\r// 抛出错误，因为 `chapters` 为空 这些也可以通过在右括号后添加它们与自定义正则结合使用： const routes = [\r// 仅匹配数字\r// 匹配 /1, /1/2, 等\r{ path: '/:chapters(\\\\d+)+' },\r// 匹配 /, /1, /1/2, 等\r{ path: '/:chapters(\\\\d+)*' },\r] ","date":"2022-10-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8C%B9%E9%85%8D%E8%AF%AD%E6%B3%95/:2:0","tags":["Vue教程"],"title":"Vue-Router-基础-路由的匹配语法","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8C%B9%E9%85%8D%E8%AF%AD%E6%B3%95/"},{"categories":["前端"],"content":"Sensitive 与 strict 路由配置 默认情况下，所有路由是不区分大小写的，并且能匹配带有或不带有尾部斜线的路由。例如，路由 /users 将匹配 /users、/users/、甚至 /Users/。这种行为可以通过 strict 和 sensitive 选项来修改，它们可以既可以应用在整个全局路由上，又可以应用于当前路由上： const router = createRouter({\rhistory: createWebHistory(),\rroutes: [\r// 将匹配 /users/posva 而非：\r// - /users/posva/ 当 strict: true\r// - /Users/posva 当 sensitive: true\r{ path: '/users/:id', sensitive: true },\r// 将匹配 /users, /Users, 以及 /users/42 而非 /users/ 或 /users/42/\r{ path: '/users/:id?' },\r]\rstrict: true, // applies to all routes\r}) ","date":"2022-10-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8C%B9%E9%85%8D%E8%AF%AD%E6%B3%95/:3:0","tags":["Vue教程"],"title":"Vue-Router-基础-路由的匹配语法","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8C%B9%E9%85%8D%E8%AF%AD%E6%B3%95/"},{"categories":["前端"],"content":"可选参数 你也可以通过使用 ? 修饰符(0 个或 1 个)将一个参数标记为可选： const routes = [\r// 匹配 /users 和 /users/posva\r{ path: '/users/:userId?' },\r// 匹配 /users 和 /users/42\r{ path: '/users/:userId(\\\\d+)?' },\r] 请注意，* 在技术上也标志着一个参数是可选的，但 ? 参数不能重复。 ","date":"2022-10-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8C%B9%E9%85%8D%E8%AF%AD%E6%B3%95/:4:0","tags":["Vue教程"],"title":"Vue-Router-基础-路由的匹配语法","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8C%B9%E9%85%8D%E8%AF%AD%E6%B3%95/"},{"categories":["前端"],"content":"调试 如果你需要探究你的路由是如何转化为正则的，以了解为什么一个路由没有被匹配，或者，报告一个 bug，你可以使用路径排名工具。它支持通过 URL 分享你的路由。 ","date":"2022-10-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8C%B9%E9%85%8D%E8%AF%AD%E6%B3%95/:5:0","tags":["Vue教程"],"title":"Vue-Router-基础-路由的匹配语法","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8C%B9%E9%85%8D%E8%AF%AD%E6%B3%95/"},{"categories":["前端"],"content":"本系列是作者在跟着vue-router官网学习时做的笔记，可能并不详尽，读者可以到官网中查看完整内容。 很多时候，我们需要将给定匹配模式的路由映射到同一个组件。例如，我们可能有一个 User 组件，它应该对所有用户进行渲染，但用户 ID 不同。在 Vue Router 中，我们可以在路径中使用一个动态字段来实现，我们称之为 路径参数 ： const User = {\rtemplate: '\u003cdiv\u003eUser\u003c/div\u003e',\r}\r// 这些都会传递给 `createRouter`\rconst routes = [\r// 动态字段以冒号开始\r{ path: '/users/:id', component: User },\r] 现在像 /users/johnny 和 /users/jolyne 这样的 URL 都会映射到同一个路由。 路径参数 用冒号 : 表示。当一个路由被匹配时，它的 params 的值将在每个组件中以 this.$route.params 的形式暴露出来。因此，我们可以通过更新 User 的模板来呈现当前的用户 ID： const User = {\rtemplate: '\u003cdiv\u003eUser {{ $route.params.id }}\u003c/div\u003e',\r} 你可以在同一个路由中设置有多个 路径参数，它们会映射到 $route.params 上的相应字段。 除了 $route.params 之外，$route 对象还公开了其他有用的信息，如 $route.query（如果 URL 中存在参数）、$route.hash 等。你可以在 API 参考中查看完整的细节。 ","date":"2022-10-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D/:0:0","tags":["Vue教程"],"title":"Vue-Router-基础-带参数的动态路由匹配","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D/"},{"categories":["前端"],"content":"响应路由参数的变化 使用带有参数的路由时需要注意的是，当用户从 /users/johnny 导航到 /users/jolyne 时，相同的组件实例将被重复使用。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。不过，这也意味着组件的生命周期钩子不会被调用。 要对同一个组件中参数的变化做出响应的话，你可以简单地 watch $route 对象上的任意属性，在这个场景中，就是 $route.params ： const User = {\rtemplate: '...',\rcreated() {\rthis.$watch(\r() =\u003e this.$route.params,\r(toParams, previousParams) =\u003e {\r// 对路由变化做出响应...\r}\r)\r},\r} 或者，使用 beforeRouteUpdate 导航守卫，它也可以取消导航： const User = {\rtemplate: '...',\rasync beforeRouteUpdate(to, from) {\r// 对路由变化做出响应...\rthis.userData = await fetchUser(to.params.id)\r},\r} ","date":"2022-10-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D/:1:0","tags":["Vue教程"],"title":"Vue-Router-基础-带参数的动态路由匹配","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D/"},{"categories":["前端"],"content":"捕获所有路由或 404 Not found 路由 常规参数只匹配 url 片段之间的字符，用 / 分隔。如果我们想匹配任意路径，我们可以使用自定义的 路径参数 正则表达式，在 路径参数 后面的括号中加入 正则表达式 : const routes = [\r// 将匹配所有内容并将其放在 `$route.params.pathMatch` 下\r{ path: '/:pathMatch(.*)*', name: 'NotFound', component: NotFound },\r// 将匹配以 `/user-` 开头的所有内容，并将其放在 `$route.params.afterUser` 下\r{ path: '/user-:afterUser(.*)', component: UserGeneric },\r] 在这个特定的场景中，我们在括号之间使用了自定义正则表达式，并将pathMatch 参数标记为可选可重复。这样做是为了让我们在需要的时候，可以通过将 path 拆分成一个数组，直接导航到路由： this.$router.push({\rname: 'NotFound',\r// 保留当前路径并删除第一个字符，以避免目标 URL 以 `//` 开头。\rparams: { pathMatch: this.$route.path.substring(1).split('/') },\r// 保留现有的查询和 hash 值，如果有的话\rquery: this.$route.query,\rhash: this.$route.hash,\r}) 更多内容请参见重复参数部分。 如果你正在使用历史模式，请务必按照说明正确配置你的服务器。 ","date":"2022-10-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D/:2:0","tags":["Vue教程"],"title":"Vue-Router-基础-带参数的动态路由匹配","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D/"},{"categories":["前端"],"content":"高级匹配模式 Vue Router 使用自己的路径匹配语法，其灵感来自于 express，因此它支持许多高级匹配模式，如可选的参数，零或多个 / 一个或多个，甚至自定义的正则匹配规则。请查看高级匹配文档来探索它们。 ","date":"2022-10-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D/:3:0","tags":["Vue教程"],"title":"Vue-Router-基础-带参数的动态路由匹配","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D/"},{"categories":["前端"],"content":"本系列是作者在跟着vue-router官网学习时做的笔记，可能并不详尽，读者可以到官网中查看完整内容。 用 Vue + Vue Router 创建单页应用非常简单：通过 Vue.js，我们已经用组件组成了我们的应用。当加入 Vue Router 时，我们需要做的就是将我们的组件映射到路由上，让 Vue Router 知道在哪里渲染它们。下面是一个基本的例子： ","date":"2022-10-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%85%A5%E9%97%A8/:0:0","tags":["Vue教程"],"title":"Vue-Router-基础-入门","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%85%A5%E9%97%A8/"},{"categories":["前端"],"content":"HTML \u003cscript src=\"https://unpkg.com/vue@3\"\u003e\u003c/script\u003e\r\u003cscript src=\"https://unpkg.com/vue-router@4\"\u003e\u003c/script\u003e\r\u003cdiv id=\"app\"\u003e\r\u003ch1\u003eHello App!\u003c/h1\u003e\r\u003cp\u003e\r\u003c!--使用 router-link 组件进行导航 --\u003e\r\u003c!--通过传递 `to` 来指定链接 --\u003e\r\u003c!--`\u003crouter-link\u003e` 将呈现一个带有正确 `href` 属性的 `\u003ca\u003e` 标签--\u003e\r\u003crouter-link to=\"/\"\u003eGo to Home\u003c/router-link\u003e\r\u003crouter-link to=\"/about\"\u003eGo to About\u003c/router-link\u003e\r\u003c/p\u003e\r\u003c!-- 路由出口 --\u003e\r\u003c!-- 路由匹配到的组件将渲染在这里 --\u003e\r\u003crouter-view\u003e\u003c/router-view\u003e\r\u003c/div\u003e ","date":"2022-10-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%85%A5%E9%97%A8/:1:0","tags":["Vue教程"],"title":"Vue-Router-基础-入门","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%85%A5%E9%97%A8/"},{"categories":["前端"],"content":"router-link 请注意，我们没有使用常规的 a 标签，而是使用一个自定义组件 router-link 来创建链接。这使得 Vue Router 可以在不重新加载页面的情况下更改 URL，处理 URL 的生成以及编码。我们将在后面看到如何从这些功能中获益。 ","date":"2022-10-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%85%A5%E9%97%A8/:1:1","tags":["Vue教程"],"title":"Vue-Router-基础-入门","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%85%A5%E9%97%A8/"},{"categories":["前端"],"content":"router-view router-view 将显示与 url 对应的组件。你可以把它放在任何地方，以适应你的布局。 ","date":"2022-10-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%85%A5%E9%97%A8/:1:2","tags":["Vue教程"],"title":"Vue-Router-基础-入门","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%85%A5%E9%97%A8/"},{"categories":["前端"],"content":"JavaScript // 1. 定义路由组件.\r// 也可以从其他文件导入\rconst Home = { template: '\u003cdiv\u003eHome\u003c/div\u003e' }\rconst About = { template: '\u003cdiv\u003eAbout\u003c/div\u003e' }\r// 2. 定义一些路由\r// 每个路由都需要映射到一个组件。\r// 我们后面再讨论嵌套路由。\rconst routes = [\r{ path: '/', component: Home },\r{ path: '/about', component: About },\r]\r// 3. 创建路由实例并传递 `routes` 配置\r// 你可以在这里输入更多的配置，但我们在这里\r// 暂时保持简单\rconst router = VueRouter.createRouter({\r// 4. 内部提供了 history 模式的实现。为了简单起见，我们在这里使用 hash 模式。\rhistory: VueRouter.createWebHashHistory(),\rroutes, // `routes: routes` 的缩写\r})\r// 5. 创建并挂载根实例\rconst app = Vue.createApp({})\r//确保 _use_ 路由实例使\r//整个应用支持路由。\rapp.use(router)\rapp.mount('#app')\r// 现在，应用已经启动了！ 通过调用 app.use(router)，我们可以在任意组件中以 this.$router 的形式访问它，并且以 this.$route 的形式访问当前路由： // Home.vue\rexport default {\rcomputed: {\rusername() {\r// 我们很快就会看到 `params` 是什么\rreturn this.$route.params.username\r},\r},\rmethods: {\rgoToDashboard() {\rif (isAuthenticated) {\rthis.$router.push('/dashboard')\r} else {\rthis.$router.push('/login')\r}\r},\r},\r} 要在 setup 函数中访问路由，请调用 useRouter 或 useRoute 函数。我们将在 Composition API 中了解更多信息。 在整个文档中，我们会经常使用 router 实例，请记住，this.$router 与直接使用通过 createRouter 创建的 router 实例完全相同。我们使用 this.$router 的原因是，我们不想在每个需要操作路由的组件中都导入路由。 ","date":"2022-10-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%85%A5%E9%97%A8/:2:0","tags":["Vue教程"],"title":"Vue-Router-基础-入门","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E5%9F%BA%E7%A1%80/%E5%85%A5%E9%97%A8/"},{"categories":["前端"],"content":"本系列是作者在跟着vue-router官网学习时做的笔记，可能并不详尽，读者可以到官网中查看完整内容。 Vue Router 是 Vue.js 的官方路由。它与 Vue.js 核心深度集成，让用 Vue.js 构建单页应用变得轻而易举。功能包括： 嵌套路由映射 动态路由选择 模块化、基于组件的路由配置 路由参数、查询、通配符 展示由 Vue.js 的过渡系统提供的过渡效果 细致的导航控制 自动激活 CSS 类的链接 HTML5 history 模式或 hash 模式 可定制的滚动行为 URL 的正确编码 ","date":"2022-10-16","objectID":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E4%BB%8B%E7%BB%8D/:0:0","tags":["Vue教程"],"title":"Vue-Router-介绍","uri":"/posts/%E5%89%8D%E7%AB%AF/vue/vuerouter/%E4%BB%8B%E7%BB%8D/"},{"categories":["版本控制"],"content":"git文档 本文来源于labuladong的算法笔记 ","date":"2022-10-15","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%9C%E5%93%A5%E7%AC%94%E8%AE%B0/:0:0","tags":["git"],"title":"版本控制-git-东哥笔记","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%9C%E5%93%A5%E7%AC%94%E8%AE%B0/"},{"categories":["版本控制"],"content":"三个分区:working directory，stage/index area，commit history。 ","date":"2022-10-15","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%9C%E5%93%A5%E7%AC%94%E8%AE%B0/:1:0","tags":["git"],"title":"版本控制-git-东哥笔记","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%9C%E5%93%A5%E7%AC%94%E8%AE%B0/"},{"categories":["版本控制"],"content":"基本操作 查询当前HEAD状态 1 git status 强制修改分支指向 1 git branch -f xxx zzz xxx是分支名，zzz是提交hash或者其他分支名 强制push： 1 git push orign main -f ","date":"2022-10-15","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%9C%E5%93%A5%E7%AC%94%E8%AE%B0/:2:0","tags":["git"],"title":"版本控制-git-东哥笔记","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%9C%E5%93%A5%E7%AC%94%E8%AE%B0/"},{"categories":["版本控制"],"content":"需求一，如何把 work dir 中的修改加入 stage。 1 git add xxx 风险等级：无风险。 理由：不会改变任或撤销任何已作出的修改，而且还会将 work dir 中未追踪的修改（Untracked file）添加到暂存区 stage 中进行追踪。 ","date":"2022-10-15","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%9C%E5%93%A5%E7%AC%94%E8%AE%B0/:2:1","tags":["git"],"title":"版本控制-git-东哥笔记","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%9C%E5%93%A5%E7%AC%94%E8%AE%B0/"},{"categories":["版本控制"],"content":"需求二，如何把 stage 中的修改还原到 work dir 中。 1 git checkout xxx 风险等级：中风险。 理由：在 work dir 做出的「修改」会被 stage 覆盖，无法恢复。所以使用该命令你应该确定 work dir 中的修改可以抛弃。 ","date":"2022-10-15","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%9C%E5%93%A5%E7%AC%94%E8%AE%B0/:2:2","tags":["git"],"title":"版本控制-git-东哥笔记","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%9C%E5%93%A5%E7%AC%94%E8%AE%B0/"},{"categories":["版本控制"],"content":"需求三，将 stage 区的文件添加到 history 区。 1 git commit -m '一些描述' commit 完之后，突然发现一些错别字需要修改，又不想为改几个错别字而新开一个 commit 到 history 区，那么就可以使用下面这个命令： 1 git commit --amend 这样就是把错别字的修改和之前的那个 commit 中的修改合并，作为一个 commit 提交到 history 区。 风险等级：无风险。 理由：不会改变任或撤销任何已作出的修改，而且还会将 stage 区的修改加入 history 区并分配一个 Hash 值。只要不乱动本地的 .git 文件夹，进入 history 的修改就永远不会丢失。 ","date":"2022-10-15","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%9C%E5%93%A5%E7%AC%94%E8%AE%B0/:2:3","tags":["git"],"title":"版本控制-git-东哥笔记","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%9C%E5%93%A5%E7%AC%94%E8%AE%B0/"},{"categories":["版本控制"],"content":"需求四，将 history 区的文件还原到 stage 区。 1 git reset --mixed HEAD a.txt 其中，mixed 是一个模式（mode）参数，如果 reset 省略这个选项的话默认是 mixed 模式；HEAD 指定了一个历史提交的 hash 值；a.txt 指定了一个或者多个文件。 该命令的自然语言描述是：不改变 work dir 中的任何数据，将 stage 区域中的 a.txt 文件还原成 HEAD 指向的 commit history 中的样子。就相当于把对 a.txt 的修改从 stage 区撤销，但依然保存在 work dir 中，变为 unstage 的状态。 风险等级：低风险。 理由：不会改变 work dir 中的数据，会改变 stage 区的数据，所以应确保 stage 中被改动数据是可以抛弃的。 ","date":"2022-10-15","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%9C%E5%93%A5%E7%AC%94%E8%AE%B0/:2:4","tags":["git"],"title":"版本控制-git-东哥笔记","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%9C%E5%93%A5%E7%AC%94%E8%AE%B0/"},{"categories":["版本控制"],"content":"需求五，将 work dir 的修改提交到 history 区。 先 git add 然后 git commit 就行了，或者一个快捷方法是使用命令 git commit -a。 风险等级：无风险。 理由：显而易见。 ","date":"2022-10-15","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%9C%E5%93%A5%E7%AC%94%E8%AE%B0/:2:5","tags":["git"],"title":"版本控制-git-东哥笔记","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%9C%E5%93%A5%E7%AC%94%E8%AE%B0/"},{"categories":["版本控制"],"content":"需求六，将 history 区的历史提交还原到 work dir 中。 git checkout HEAD . work dir 和 stage 中所有的「修改」都会被撤销，恢复成 HEAD 指向的那个 history commit。 类似之前通过 stage 恢复 work dir 的 checkout 命令，这里撤销的也只是修改，新增的文件不会被撤销。 只要找到任意一个 commit 的 HASH 值，checkout 命令可就以将文件恢复成任一个 history commit 中的样子： git checkout 2bdf04a some_test.go 风险等级：高风险。 理由：这个操作会将指定文件在 work dir 的数据恢复成指定 commit 的样子，且会删除该文件在 stage 中的数据，都无法恢复，所以应该慎重使用。 ","date":"2022-10-15","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%9C%E5%93%A5%E7%AC%94%E8%AE%B0/:2:6","tags":["git"],"title":"版本控制-git-东哥笔记","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%9C%E5%93%A5%E7%AC%94%E8%AE%B0/"},{"categories":["版本控制"],"content":"其他技巧 ","date":"2022-10-15","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%9C%E5%93%A5%E7%AC%94%E8%AE%B0/:3:0","tags":["git"],"title":"版本控制-git-东哥笔记","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%9C%E5%93%A5%E7%AC%94%E8%AE%B0/"},{"categories":["版本控制"],"content":"需求一，合并多个 commit。 比如说我本地从 17bd20c 到 HEAD 有多个 commit，但我希望把他们合并成一个 commit 推到远程仓库，这时候就可以使用 reset 命令： $ git reset 17bd20c\r$ git add .\r$ git commit -m 'balabala' 回顾一下刚才说的 reset 命令的作用，相当于把 HEAD 移到了 17bd20c 这个 commit，而且不会修改 work dir 中的数据，所以只要 add 再 commit，就相当于把中间的多个 commit 合并到一个了。 ","date":"2022-10-15","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%9C%E5%93%A5%E7%AC%94%E8%AE%B0/:3:1","tags":["git"],"title":"版本控制-git-东哥笔记","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%9C%E5%93%A5%E7%AC%94%E8%AE%B0/"},{"categories":["版本控制"],"content":"需求二，由于 HEAD 指针的回退，导致有的 commit 在 git log 命令中无法看到，怎么得到它们的 Hash 值呢？ 再重复一遍，只要你不乱动本地的 .git 文件夹，任何修改只要提交到 commit history 中，都永远不会丢失，看不到某些 commit 只是因为它们不是我们当前 HEAD 位置的「历史」提交，我们可以使用如下命令查看操作记录： git reflog 比如 reset，checkout 等等关键操作都会在这里留下记录，所有 commit 的 Hash 值都能在这里找到，所以如果你发现有哪个 commit 突然找不到了，一定都可以在这里找到。 ","date":"2022-10-15","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%9C%E5%93%A5%E7%AC%94%E8%AE%B0/:3:2","tags":["git"],"title":"版本控制-git-东哥笔记","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%9C%E5%93%A5%E7%AC%94%E8%AE%B0/"},{"categories":["版本控制"],"content":"需求三，怎么解决冲突？ 记住，Git 虽然高大上，但也不要迷恋，一定要懂得借助先进的工具。 比较流行的代码编辑器或者 IDE 都会集成方便的可视化 Git 工具，至于解决冲突，可视化的表现方式不是比你在命令行里 git diff 看半天要清晰明了得多？只需要点点点就行了。 所以说，只要明白本文讲的这些基本操作，够你用的了，平时能用图形化工具就多用图形化工具，毕竟工具都是为人服务的。 ","date":"2022-10-15","objectID":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%9C%E5%93%A5%E7%AC%94%E8%AE%B0/:3:3","tags":["git"],"title":"版本控制-git-东哥笔记","uri":"/posts/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/git/%E4%B8%9C%E5%93%A5%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"本系列为作者在官网学习python时做的笔记，详见python官网 python标准库官方文档，查阅标准库相关的内容 python语言参考，查看python语法，该文档是简洁的，但试图做到准确和完整。非必要的内建对象类型和内建函数、模块的语义描述在 Python 标准库 中。 标准库和语言参考涵盖了python的所有内容，他们是互补的，如果在语言参考中没有找到需要的内容那么就一定在便准库文档中。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%92%8C%E5%8C%85/:0:0","tags":["Python教程"],"title":"Python教程-虚拟环境和包","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%92%8C%E5%8C%85/"},{"categories":["Python"],"content":"概述 Python应用程序通常会使用不在标准库内的软件包和模块。应用程序有时需要特定版本的库，因为应用程序可能需要修复特定的错误，或者可以使用库的过时版本的接口编写应用程序。 这意味着一个Python安装可能无法满足每个应用程序的要求。如果应用程序A需要特定模块的1.0版本但应用程序B需要2.0版本，则需求存在冲突，安装版本1.0或2.0将导致某一个应用程序无法运行。 这个问题的解决方案是创建一个 virtual environment，一个目录树，其中安装有特定Python版本，以及许多其他包。 然后，不同的应用将可以使用不同的虚拟环境。 要解决先前需求相冲突的例子，应用程序 A 可以拥有自己的 安装了 1.0 版本的虚拟环境，而应用程序 B 则拥有安装了 2.0 版本的另一个虚拟环境。 如果应用程序 B 要求将某个库升级到 3.0 版本，也不会影响应用程序 A 的环境。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%92%8C%E5%8C%85/:1:0","tags":["Python教程"],"title":"Python教程-虚拟环境和包","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%92%8C%E5%8C%85/"},{"categories":["Python"],"content":"创建虚拟环境 该部分为venv的使用，详见原文，更推荐使用anaconda来管理多版本的python。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%92%8C%E5%8C%85/:2:0","tags":["Python教程"],"title":"Python教程-虚拟环境和包","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%92%8C%E5%8C%85/"},{"categories":["Python"],"content":"使用pip管理包 未安装pip解决办法 1 python -m ensurepip --default-pip 默认情况下 pip 将从 Python Package Index安装软件包 pip 有许多子命令: “install”, “uninstall”, “freeze” 等等。 （请在 安装 Python 模块 指南页查看完整的 pip 文档。） pip下载的包位置位于：${PYTHON_HOME}\\Lib\\site-packages，当安装包出现问题时可以直接去这个文件夹删除包再重新安装，这个目录类似于golang 在 go mod 包管理下的${GOROOT}/pkg/mod目录 通过指定包的名称来安装最新版本的包： 1 pip install novas 通过提供包名称后跟 == 和版本号来安装特定版本的包： 1 pip install requests==2.6.0 编程之家 离线安装本地的whl文件也使用pip install 1 pip install xxx.whl 重复运行install命令，pip 会注意到已经安装了所请求的版本并且什么都不做。 添加 --upgrade 选项将软件包升级到最新版本或者替换版本（使用 == 标记版本）： 1 2 3 pip install --upgrade requests pip install --upgrade requests==x.x.x pip uninstall 后跟一个或多个包名称将从虚拟环境中删除包。 pip show 将显示有关特定包的信息： 1 pip show requests pip list 显示虚拟环境中安装的所有软件包： pip freeze 使用 pip install 期望的格式输出一个类似的已安装包列表。一个常见的约定是将此列表放在 requirements.txt 文件中： 1 2 3 4 5 (tutorial-env) $ pip freeze \u003e requirements.txt (tutorial-env) $ cat requirements.txt novas==3.1.1.3 numpy==1.9.2 requests==2.7.0 可以将 requirements.txt 提交给版本控制并作为应用程序的一部分。然后用户可以使用 install -r 安装所有必需的包： 1 pip install -r requirements.txt ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%92%8C%E5%8C%85/:3:0","tags":["Python教程"],"title":"Python教程-虚拟环境和包","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%92%8C%E5%8C%85/"},{"categories":["Python"],"content":"上传自己的python包 python官网教程 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%92%8C%E5%8C%85/:4:0","tags":["Python教程"],"title":"Python教程-虚拟环境和包","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%92%8C%E5%8C%85/"},{"categories":["Python"],"content":"准备工作 更新pip:python -m pip install --upgrade pip 创建包文件 1 2 3 4 5 6 7 8 9 packaging_tutorial/ ├── LICENSE ├── pyproject.toml ├── README.md ├── src/ │ └── example_package_YOUR_USERNAME_HERE/ # 导入包名，和toml配置里的name对应 │ ├── __init__.py │ └── example.py # 导入的模块，可以有多个，后续直接通过`from 包名 import 模块名`导入 └── tests/ example.py是包内模块的示例 配置 pyproject.toml 构建工具 1 2 3 [build-system] requires = [\"hatchling\"] build-backend = \"hatchling.build\" 元数据 详细元数据项见官网文档 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 [project] # 后续导入名称，和src里面的文件夹对应 name = \"example_package_YOUR_USERNAME_HERE\" # 版本号 version = \"0.0.1\" authors = [ { name=\"Example Author\", email=\"author@example.com\" }, ] description = \"A small example package\" readme = \"README.md\" requires-python = \"\u003e=3.7\" classifiers = [ \"Programming Language :: Python :: 3\", \"License :: OSI Approved :: MIT License\", \"Operating System :: OS Independent\", ] # 依赖项，安装包之前自动安装下面的包 dependencies = [ \"networkx\", \"matplotlib\", ] [project.urls] \"Homepage\" = \"https://github.com/pypa/sampleproject\" \"Bug Tracker\" = \"https://github.com/pypa/sampleproject/issues\" 配置README.md 1 2 3 4 5 # Example Package This is a simple example package. You can use [Github-flavored Markdown](https://guides.github.com/features/mastering-markdown/) to write your content. 创建许可证 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Copyright (c) 2018 The Python Packaging Authority Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%92%8C%E5%8C%85/:4:1","tags":["Python教程"],"title":"Python教程-虚拟环境和包","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%92%8C%E5%8C%85/"},{"categories":["Python"],"content":"上传模块 更新build模块:python -m pip install --upgrade build 在项目根目录运行build模块:python -m build 更新twine模块:python -m pip install --upgrade twine 在项目根目录使用twine上传模块到pypi:python -m twine upload dist/* 之后就可以在本地安装自己的模块了:python -m pip install example_package_YOUR_USERNAME_HERE 1 2 3 from example_package_YOUR_USERNAME_HERE import example example.xxx() 后续每次更新模块后需要修改版本号并将dist删掉重新执行上传模块的步骤 为什么会出现“文件名或内容已存在”或“文件名以前已被使用”错误？ PyPI 上的分发文件名由项目名称、版本号和分发类型的组合组成 出于法律考虑，PyPI 不允许重复使用文件名，即使你的模块已经删除或者你的版本已经删除，仍然无法上传相同名字和版本的模块 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%92%8C%E5%8C%85/:4:2","tags":["Python教程"],"title":"Python教程-虚拟环境和包","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%92%8C%E5%8C%85/"},{"categories":["Python"],"content":"pip设置清华镜像源 清华镜像源官网手册 1 pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%92%8C%E5%8C%85/:5:0","tags":["Python教程"],"title":"Python教程-虚拟环境和包","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%92%8C%E5%8C%85/"},{"categories":["Python"],"content":"pip安装包时冲突 有时候你之前装的某些包和后面你想装的包版本不兼容 1 2 3 ERROR: pip's dependency resolver does not currently take into account all the packages that are installed. This behaviour is the source of the following dependency conflicts. requests 2.23.0 requires idna\u003c3,\u003e=2.5, but you have idna 3.4 which is incompatible. requests 2.23.0 requires urllib3!=1.25.0,!=1.25.1,\u003c1.26,\u003e=1.21.1, but you have urllib3 1.26.14 which is incompatible. 虽然你可以使用pip install --upgrade \u003cpackage name\u003e替换模块版本，但是更方便的解决办法还是直接卸载重装，重装过程中会自动安装相应版本的模块 1 2 3 4 pip uninstall requests //xxx为你之前要安装的包，会自动安装requests pip install xxx ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%92%8C%E5%8C%85/:6:0","tags":["Python教程"],"title":"Python教程-虚拟环境和包","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%92%8C%E5%8C%85/"},{"categories":["Python"],"content":"本系列为作者在官网学习python时做的笔记，详见python官网 python标准库官方文档，查阅标准库相关的内容 python语言参考，查看python语法，该文档是简洁的，但试图做到准确和完整。非必要的内建对象类型和内建函数、模块的语义描述在 Python 标准库 中。 标准库和语言参考涵盖了python的所有内容，他们是互补的，如果在语言参考中没有找到需要的内容那么就一定在便准库文档中。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B--%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/:0:0","tags":["Python教程"],"title":"Python教程-标准库简介  第二部分","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B--%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/"},{"categories":["Python"],"content":"格式化输出 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B--%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/:1:0","tags":["Python教程"],"title":"Python教程-标准库简介  第二部分","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B--%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/"},{"categories":["Python"],"content":"模板 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B--%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/:2:0","tags":["Python教程"],"title":"Python教程-标准库简介  第二部分","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B--%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/"},{"categories":["Python"],"content":"使用二进制数据记录格式 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B--%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/:3:0","tags":["Python教程"],"title":"Python教程-标准库简介  第二部分","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B--%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/"},{"categories":["Python"],"content":"多线程 线程是一种对于非顺序依赖的多个任务进行解耦的技术。多线程可以提高应用的响应效率，当接收用户输入的同时，保持其他任务在后台运行。一个有关的应用场景是，将 I/O 和计算运行在两个并行的线程中。 以下代码展示了高阶的 threading 模块如何在后台运行任务，且不影响主程序的继续运行: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import threading, zipfile class AsyncZip(threading.Thread): def __init__(self, infile, outfile): threading.Thread.__init__(self) self.infile = infile self.outfile = outfile def run(self): f = zipfile.ZipFile(self.outfile, 'w', zipfile.ZIP_DEFLATED) f.write(self.infile) f.close() print('Finished background zip of:', self.infile) background = AsyncZip('mydata.txt', 'myarchive.zip') background.start() print('The main program continues to run in foreground.') background.join() # Wait for the background task to finish print('Main program waited until background was done.') 多线程应用面临的主要挑战是，相互协调的多个线程之间需要共享数据或其他资源。为此，threading 模块提供了多个同步操作原语，包括线程锁、事件、条件变量和信号量。 尽管这些工具非常强大，但微小的设计错误却可以导致一些难以复现的问题。因此，实现多任务协作的首选方法是将所有对资源的请求集中到一个线程中，然后使用 queue 模块向该线程供应来自其他线程的请求。 应用程序使用 Queue 对象进行线程间通信和协调，更易于设计，更易读，更可靠。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B--%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/:4:0","tags":["Python教程"],"title":"Python教程-标准库简介  第二部分","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B--%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/"},{"categories":["Python"],"content":"日志记录 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B--%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/:5:0","tags":["Python教程"],"title":"Python教程-标准库简介  第二部分","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B--%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/"},{"categories":["Python"],"content":"弱引用 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B--%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/:6:0","tags":["Python教程"],"title":"Python教程-标准库简介  第二部分","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B--%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/"},{"categories":["Python"],"content":"用于操作列表的工具 许多对于数据结构的需求可以通过内置列表类型来满足。 但是，有时也会需要具有不同效费比的替代实现。 array 模块提供了一种 array() 对象，它类似于列表，但只能存储类型一致的数据且存储密集更高。 下面的例子演示了一个以两个字节为存储单元的无符号二进制数值的数组 (类型码为 “H”)，而对于普通列表来说，每个条目存储为标准 Python 的 int 对象通常要占用16 个字节: 1 2 3 4 5 6 \u003e\u003e\u003e from array import array \u003e\u003e\u003e a = array('H', [4000, 10, 700, 22222]) \u003e\u003e\u003e sum(a) 26932 \u003e\u003e\u003e a[1:3] array('H', [10, 700]) collections 模块提供了一种 deque() 对象，它类似于列表，但从左端添加和弹出的速度较快，而在中间查找的速度较慢。 此种对象适用于实现队列和广度优先树搜索: 1 2 3 4 5 \u003e\u003e\u003e from collections import deque \u003e\u003e\u003e d = deque([\"task1\", \"task2\", \"task3\"]) \u003e\u003e\u003e d.append(\"task4\") \u003e\u003e\u003e print(\"Handling\", d.popleft()) Handling task1 1 2 3 4 5 6 7 unsearched = deque([starting_node]) def breadth_first_search(unsearched): node = unsearched.popleft() for m in gen_moves(node): if is_goal(m): return m unsearched.append(m) 在替代的列表实现以外，标准库也提供了其他工具，例如 bisect 模块具有用于操作有序列表的函数: 1 2 3 4 5 \u003e\u003e\u003e import bisect \u003e\u003e\u003e scores = [(100, 'perl'), (200, 'tcl'), (400, 'lua'), (500, 'python')] \u003e\u003e\u003e bisect.insort(scores, (300, 'ruby')) \u003e\u003e\u003e scores [(100, 'perl'), (200, 'tcl'), (300, 'ruby'), (400, 'lua'), (500, 'python')] heapq 模块提供了基于常规列表来实现堆的函数。 最小值的条目总是保持在位置零。 这对于需要重复访问最小元素而不希望运行完整列表排序的应用来说非常有用: 1 2 3 4 5 6 \u003e\u003e\u003e from heapq import heapify, heappop, heappush \u003e\u003e\u003e data = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0] \u003e\u003e\u003e heapify(data) # rearrange the list into heap order \u003e\u003e\u003e heappush(data, -5) # add a new entry \u003e\u003e\u003e [heappop(data) for i in range(3)] # fetch the three smallest entries [-5, 0, 1] ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B--%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/:7:0","tags":["Python教程"],"title":"Python教程-标准库简介  第二部分","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B--%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/"},{"categories":["Python"],"content":"十进制浮点运算 decimal 模块提供了一种 Decimal 数据类型用于十进制浮点运算。 相比内置的 float 二进制浮点实现，该类特别适用于 财务应用和其他需要精确十进制表示的用途， 控制精度， 控制四舍五入以满足法律或监管要求， 跟踪有效小数位，或 用户期望结果与手工完成的计算相匹配的应用程序。 例如，使用十进制浮点和二进制浮点数计算70美分手机和5％税的总费用，会产生的不同结果。如果结果四舍五入到最接近的分数差异会更大: 1 2 3 4 5 \u003e\u003e\u003e from decimal import * \u003e\u003e\u003e round(Decimal('0.70') * Decimal('1.05'), 2) Decimal('0.74') \u003e\u003e\u003e round(.70 * 1.05, 2) 0.73 Decimal 表示的结果会保留尾部的零，并根据具有两个有效位的被乘数自动推出四个有效位。 Decimal 可以模拟手工运算来避免当二进制浮点数无法精确表示十进制数时会导致的问题。 精确表示特性使得 Decimal 类能够执行对于二进制浮点数来说不适用的模运算和相等性检测: 1 2 3 4 5 6 7 8 9 \u003e\u003e\u003e Decimal('1.00') % Decimal('.10') Decimal('0.00') \u003e\u003e\u003e 1.00 % 0.10 0.09999999999999995 \u003e\u003e\u003e sum([Decimal('0.1')]*10) == Decimal('1.0') True \u003e\u003e\u003e sum([0.1]*10) == 1.0 False decimal 模块提供了运算所需要的足够精度: 1 2 3 \u003e\u003e\u003e getcontext().prec = 36 \u003e\u003e\u003e Decimal(1) / Decimal(7) Decimal('0.142857142857142857142857142857142857') ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B--%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/:8:0","tags":["Python教程"],"title":"Python教程-标准库简介  第二部分","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B--%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/"},{"categories":["Python"],"content":"本系列为作者在官网学习python时做的笔记，详见python官网 python标准库官方文档，查阅标准库相关的内容 python语言参考，查看python语法，该文档是简洁的，但试图做到准确和完整。非必要的内建对象类型和内建函数、模块的语义描述在 Python 标准库 中。 标准库和语言参考涵盖了python的所有内容，他们是互补的，如果在语言参考中没有找到需要的内容那么就一定在便准库文档中。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B/:0:0","tags":["Python教程"],"title":"Python教程-标准库简介","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"操作系统接口 os 模块提供了许多与操作系统交互的函数: 1 2 3 4 5 6 \u003e\u003e\u003e import os \u003e\u003e\u003e os.getcwd() # Return the current working directory 'C:\\\\Python38' \u003e\u003e\u003e os.chdir('/server/accesslogs') # Change current working directory \u003e\u003e\u003e os.system('mkdir today') # Run the command mkdir in the system shell 0 一定要使用 import os 而不是 from os import * 。避免内建的 open() 函数被 os.open() 隐式替换掉。 内置的 dir() 和 help() 函数可用作交互式辅助工具，用于处理大型模块，如 os: 1 2 3 4 5 \u003e\u003e\u003e import os \u003e\u003e\u003e dir(os) \u003creturns a list of all module functions\u003e \u003e\u003e\u003e help(os) \u003creturns an extensive manual page created from the module's docstrings\u003e 对于日常文件和目录管理任务， shutil 模块提供了更易于使用的更高级别的接口: 1 2 3 4 5 \u003e\u003e\u003e import shutil \u003e\u003e\u003e shutil.copyfile('data.db', 'archive.db') 'archive.db' \u003e\u003e\u003e shutil.move('/build/executables', 'installdir') 'installdir' ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B/:1:0","tags":["Python教程"],"title":"Python教程-标准库简介","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"文件通配符 glob 模块提供了一个在目录中使用通配符搜索创建文件列表的函数: 1 2 3 \u003e\u003e\u003e import glob \u003e\u003e\u003e glob.glob('*.py') ['primes.py', 'random.py', 'quote.py'] ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B/:2:0","tags":["Python教程"],"title":"Python教程-标准库简介","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"命令行参数 通用实用程序脚本通常需要处理命令行参数。这些参数作为列表存储在 sys 模块的 argv 属性中。例如，以下输出来自在命令行运行 python demo.py one two three 1 2 3 \u003e\u003e\u003e import sys \u003e\u003e\u003e print(sys.argv) ['demo.py', 'one', 'two', 'three'] argparse 模块提供了一种更复杂的机制来处理命令行参数。 以下脚本可提取一个或多个文件名，并可选择要显示的行数: 1 2 3 4 5 6 7 8 import argparse parser = argparse.ArgumentParser(prog = 'top', description = 'Show top lines from each file') parser.add_argument('filenames', nargs='+') parser.add_argument('-l', '--lines', type=int, default=10) args = parser.parse_args() print(args) 当在通过 python top.py –lines=5 alpha.txt beta.txt 在命令行运行时，该脚本会将 args.lines 设为 5 并将 args.filenames 设为 [‘alpha.txt’, ‘beta.txt’]。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B/:3:0","tags":["Python教程"],"title":"Python教程-标准库简介","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"错误输出重定向和程序终止 sys 模块还具有 stdin ， stdout 和 stderr 的属性。后者对于发出警告和错误消息非常有用，即使在 stdout 被重定向后也可以看到它们: 1 2 \u003e\u003e\u003e sys.stderr.write('Warning, log file not found starting a new one\\n') Warning, log file not found starting a new one 终止脚本的最直接方法是使用 sys.exit() 。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B/:4:0","tags":["Python教程"],"title":"Python教程-标准库简介","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"字符串模式匹配 re 模块为高级字符串处理提供正则表达式工具。对于复杂的匹配和操作，正则表达式提供简洁，优化的解决方案: 1 2 3 4 5 \u003e\u003e\u003e import re \u003e\u003e\u003e re.findall(r'\\bf[a-z]*', 'which foot or hand fell fastest') ['foot', 'fell', 'fastest'] \u003e\u003e\u003e re.sub(r'(\\b[a-z]+) \\1', r'\\1', 'cat in the the hat') 'cat in the hat' 当只需要简单的功能时，首选字符串方法因为它们更容易阅读和调试: 1 2 \u003e\u003e\u003e 'tea for too'.replace('too', 'two') 'tea for two' ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B/:5:0","tags":["Python教程"],"title":"Python教程-标准库简介","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"数学 math 模块提供对浮点数学的底层C库函数的访问: 1 2 3 4 5 \u003e\u003e\u003e import math \u003e\u003e\u003e math.cos(math.pi / 4) 0.70710678118654757 \u003e\u003e\u003e math.log(1024, 2) 10.0 random 模块提供了进行随机选择的工具: 1 2 3 4 5 6 7 8 9 \u003e\u003e\u003e import random \u003e\u003e\u003e random.choice(['apple', 'pear', 'banana']) 'apple' \u003e\u003e\u003e random.sample(range(100), 10) # sampling without replacement [30, 83, 16, 4, 8, 81, 41, 50, 18, 33] \u003e\u003e\u003e random.random() # random float 0.17970987693706186 \u003e\u003e\u003e random.randrange(6) # random integer chosen from range(6) 4 statistics 模块计算数值数据的基本统计属性（均值，中位数，方差等）: 1 2 3 4 5 6 7 8 \u003e\u003e\u003e import statistics \u003e\u003e\u003e data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5] \u003e\u003e\u003e statistics.mean(data) 1.6071428571428572 \u003e\u003e\u003e statistics.median(data) 1.25 \u003e\u003e\u003e statistics.variance(data) 1.3720238095238095 SciPy项目 https://scipy.org 有许多其他模块用于数值计算。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B/:6:0","tags":["Python教程"],"title":"Python教程-标准库简介","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"互联网访问 有许多模块可用于访问互联网和处理互联网协议。其中两个最简单的 urllib.request 用于从URL检索数据，以及 smtplib 用于发送邮件: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u003e\u003e\u003e from urllib.request import urlopen \u003e\u003e\u003e with urlopen('http://tycho.usno.navy.mil/cgi-bin/timer.pl') as response: ... for line in response: ... line = line.decode('utf-8') # Decoding the binary data to text. ... if 'EST' in line or 'EDT' in line: # look for Eastern Time ... print(line) \u003cBR\u003eNov. 25, 09:43:32 PM EST \u003e\u003e\u003e import smtplib \u003e\u003e\u003e server = smtplib.SMTP('localhost') \u003e\u003e\u003e server.sendmail('soothsayer@example.org', 'jcaesar@example.org', ... \"\"\"To: jcaesar@example.org ... From: soothsayer@example.org ... ... Beware the Ides of March. ... \"\"\") \u003e\u003e\u003e server.quit() （请注意，第二个示例需要在localhost上运行的邮件服务器。） ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B/:7:0","tags":["Python教程"],"title":"Python教程-标准库简介","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"日期和时间 datetime 模块提供了以简单和复杂的方式操作日期和时间的类。虽然支持日期和时间算法，但实现的重点是有效的成员提取以进行输出格式化和操作。该模块还支持可感知时区的对象。 1 2 3 4 5 6 7 8 9 10 11 12 13 \u003e\u003e\u003e # dates are easily constructed and formatted \u003e\u003e\u003e from datetime import date \u003e\u003e\u003e now = date.today() \u003e\u003e\u003e now datetime.date(2003, 12, 2) \u003e\u003e\u003e now.strftime(\"%m-%d-%y. %d %b %Y is a %A on the %d day of %B.\") '12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.' \u003e\u003e\u003e # dates support calendar arithmetic \u003e\u003e\u003e birthday = date(1964, 7, 31) \u003e\u003e\u003e age = now - birthday \u003e\u003e\u003e age.days 14368 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B/:8:0","tags":["Python教程"],"title":"Python教程-标准库简介","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"数据压缩 常见的数据存档和压缩格式由模块直接支持，包括：zlib, gzip, bz2, lzma, zipfile 和 tarfile。: 1 2 3 4 5 6 7 8 9 10 11 \u003e\u003e\u003e import zlib \u003e\u003e\u003e s = b'witch which has which witches wrist watch' \u003e\u003e\u003e len(s) 41 \u003e\u003e\u003e t = zlib.compress(s) \u003e\u003e\u003e len(t) 37 \u003e\u003e\u003e zlib.decompress(t) b'witch which has which witches wrist watch' \u003e\u003e\u003e zlib.crc32(s) 226805979 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B/:9:0","tags":["Python教程"],"title":"Python教程-标准库简介","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"性能测量 一些Python用户对了解同一问题的不同方法的相对性能产生了浓厚的兴趣。 Python提供了一种可以立即回答这些问题的测量工具。 例如，元组封包和拆包功能相比传统的交换参数可能更具吸引力。timeit 模块可以快速演示在运行效率方面一定的优势: 1 2 3 4 5 \u003e\u003e\u003e from timeit import Timer \u003e\u003e\u003e Timer('t=a; a=b; b=t', 'a=1; b=2').timeit() 0.57535828626024577 \u003e\u003e\u003e Timer('a,b = b,a', 'a=1; b=2').timeit() 0.54962537085770791 与 timeit 的精细粒度级别相反， profile 和 pstats 模块提供了用于在较大的代码块中识别时间关键部分的工具。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B/:10:0","tags":["Python教程"],"title":"Python教程-标准库简介","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"质量控制 开发高质量软件的一种方法是在开发过程中为每个函数编写测试，并在开发过程中经常运行这些测试。 doctest 模块提供了一个工具，用于扫描模块并验证程序文档字符串中嵌入的测试。测试构造就像将典型调用及其结果剪切并粘贴到文档字符串一样简单。这通过向用户提供示例来改进文档，并且它允许doctest模块确保代码保持对文档的真实: 1 2 3 4 5 6 7 8 9 10 def average(values): \"\"\"Computes the arithmetic mean of a list of numbers. \u003e\u003e\u003e print(average([20, 30, 70])) 40.0 \"\"\" return sum(values) / len(values) import doctest doctest.testmod() # automatically validate the embedded tests unittest 模块不像 doctest 模块那样易于使用，但它允许在一个单独的文件中维护更全面的测试集: 1 2 3 4 5 6 7 8 9 10 11 12 13 import unittest class TestStatisticalFunctions(unittest.TestCase): def test_average(self): self.assertEqual(average([20, 30, 70]), 40.0) self.assertEqual(round(average([1, 5, 7]), 1), 4.3) with self.assertRaises(ZeroDivisionError): average([]) with self.assertRaises(TypeError): average(20, 30, 70) unittest.main() # Calling from the command line invokes all tests ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B/:11:0","tags":["Python教程"],"title":"Python教程-标准库简介","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"自带电池 Python有“自带电池”的理念。通过其包的复杂和强大功能可以最好地看到这一点。例如: xmlrpc.client 和 xmlrpc.server 模块使得实现远程过程调用变成了小菜一碟。 尽管存在于模块名称中，但用户不需要直接了解或处理 XML。 email 包是一个用于管理电子邮件的库，包括MIME和其他符合 RFC 2822 规范的邮件文档。与 smtplib 和 poplib 不同（它们实际上做的是发送和接收消息），电子邮件包提供完整的工具集，用于构建或解码复杂的消息结构（包括附件）以及实现互联网编码和标头协议。 json 包为解析这种流行的数据交换格式提供了强大的支持。 csv 模块支持以逗号分隔值格式直接读取和写入文件，这种格式通常为数据库和电子表格所支持。 XML 处理由 xml.etree.ElementTree ， xml.dom 和 xml.sax 包支持。这些模块和软件包共同大大简化了 Python 应用程序和其他工具之间的数据交换。 sqlite3 模块是 SQLite 数据库库的包装器，提供了一个可以使用稍微非标准的 SQL 语法更新和访问的持久数据库。 国际化由许多模块支持，包括 gettext ， locale ，以及 codecs 包。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B/:12:0","tags":["Python教程"],"title":"Python教程-标准库简介","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B/"},{"categories":["Python"],"content":"本系列为作者在官网学习python时做的笔记，详见python官网 python标准库官方文档，查阅标准库相关的内容 python语言参考，查看python语法，该文档是简洁的，但试图做到准确和完整。非必要的内建对象类型和内建函数、模块的语义描述在 Python 标准库 中。 标准库和语言参考涵盖了python的所有内容，他们是互补的，如果在语言参考中没有找到需要的内容那么就一定在便准库文档中。 类提供了一种组合数据和功能的方法。 创建一个新类意味着创建一个新的对象 类型，从而允许创建一个该类型的新 实例 。 每个类的实例可以拥有保存自己状态的属性。 一个类的实例也可以有改变自己状态的（定义在类中的）方法。 Python 的类提供了面向对象编程的所有标准特性：类继承机制允许多个基类，派生类可以覆盖它基类的任何方法，一个方法可以调用基类中相同名称的的方法。对象可以包含任意数量和类型的数据。和模块一样，类也拥有 Python 天然的动态特性：它们在运行时创建，可以在创建后修改。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/:0:0","tags":["Python教程"],"title":"Python教程-类","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/"},{"categories":["Python"],"content":"名称和对象 多个名称（在多个作用域内）可以绑定到同一个对象。 这在其他语言中称为别名。 因为别名在某些方面表现得像指针。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/:1:0","tags":["Python教程"],"title":"Python教程-类","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/"},{"categories":["Python"],"content":"Python 作用域和命名空间 namespace （命名空间）是一个从名字到对象的映射。 把任何跟在一个点号之后的名称都称为 属性 属性可以是只读或者可写的。如果为后者，那么对属性的赋值是可行的。可写的属性同样可以用 del 语句删除。例如， del modname.the_answer 将会从名为 modname 的对象中移除 the_answer 属性。 在不同时刻创建的命名空间拥有不同的生存期： 包含内置名称的命名空间是在 Python 解释器启动时创建的，永远不会被删除。 模块的全局命名空间在模块定义被读入时创建；模块命名空间也会持续到解释器退出。 被解释器的顶层调用执行的语句，从一个脚本文件读取或交互式地读取，被认为是__main__模块调用的一部分，因此它们拥有自己的全局命名空间。（内置名称实际上也存在于一个模块中；这个模块称作 builtins 。） 函数的本地命名空间在调用该函数时创建，并在函数返回或抛出不在函数内部处理的错误时被删除。 （实际上，用“遗忘”来描述实际发生的情况会更好一些。） 当然，每次递归调用都会有自己的本地命名空间。 一个 作用域 是一个命名空间可直接访问的 Python 程序的文本区域。 虽然作用域是静态地确定的，但它们会被动态地使用。 在执行期间的任何时刻，会有 3 或 4 个命名空间可被直接访问的嵌套作用域: 最先搜索的最内部作用域包含局部名称 从最近的封闭作用域开始搜索的任何封闭函数的作用域包含非局部名称，也包括非全局名称 倒数第二个作用域包含当前模块的全局名称 最外面的作用域（最后搜索）是包含内置名称的命名空间 如果一个名称被声明为全局变量，则所有引用和赋值将直接指向包含该模块的全局名称的中间作用域。 要重新绑定在最内层作用域以外找到的变量，可以使用 nonlocal 语句声明为非本地变量。 如果没有被声明为非本地变量，这些变量将是只读的（尝试写入这样的变量只会在最内层作用域中创建一个 新的 局部变量，而同名的外部变量保持不变）。 通常，当前局部作用域将（按字面文本）引用当前函数的局部名称。 在函数以外，局部作用域将引用与全局作用域相一致的命名空间：模块的命名空间。 类定义将在局部命名空间内再放置另一个命名空间。任何地方的全局命名空间都是模块（py文件）命名空间包括包的__init__.py文件。 作用域是按字面文本来确定的：在一个模块内定义的函数的全局作用域就是该模块的命名空间，无论该函数从什么地方或以什么别名被调用。 另一方面，实际的名称搜索是在运行时动态完成的 如果不存在生效的 global 或 nonlocal 语句 对名称的赋值总是会进入最内层作用域。 删除也是如此：语句 del x 会从局部作用域所引用的命名空间中移除对 x 的绑定。 事实上，所有引入新名称的操作都是使用局部作用域，但是有个例外import 语句和函数定义会在局部作用域中绑定模块或函数名称。 global 语句可被用来表明特定变量生存于全局作用域（py模块最外层）并且应当在其中被重新绑定；nonlocal 语句表明特定变量生存于外层作用域中并且应当在其中被重新绑定（从当前语句所在作用域往外找到的第一个）。可以del绑定的外部变量。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/:2:0","tags":["Python教程"],"title":"Python教程-类","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/"},{"categories":["Python"],"content":"作用域和命名空间示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def scope_test(): def do_local(): spam = \"local spam\" def do_nonlocal(): nonlocal spam spam = \"nonlocal spam\" def do_global(): global spam spam = \"global spam\" spam = \"test spam\" do_local() print(\"After local assignment:\", spam) do_nonlocal() print(\"After nonlocal assignment:\", spam) do_global() print(\"After global assignment:\", spam) scope_test() print(\"In global scope:\", spam) 示例代码的输出是： 1 2 3 4 After local assignment: test spam After nonlocal assignment: nonlocal spam After global assignment: nonlocal spam In global scope: global spam ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/:2:1","tags":["Python教程"],"title":"Python教程-类","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/"},{"categories":["Python"],"content":"初探类 类引入了一些新语法，三种新对象类型和一些新语义。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/:3:0","tags":["Python教程"],"title":"Python教程-类","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/"},{"categories":["Python"],"content":"类定义语法 1 2 3 4 5 6 class ClassName: \u003cstatement-1\u003e . . . \u003cstatement-N\u003e 类定义与函数定义 (def 语句) 一样必须被执行才会起作用 当进入类定义时，将创建一个新的命名空间，并将其用作局部作用域。 当（从结尾处）正常离开类定义时，将创建一个 类对象。 这基本上是一个包围在类定义所创建命名空间内容周围的包装器；原始的（在进入类定义之前起作用的）局部作用域将重新生效，类对象将在这里被绑定到类定义头所给出的类名称 (在这个示例中为 ClassName)。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/:3:1","tags":["Python教程"],"title":"Python教程-类","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/"},{"categories":["Python"],"content":"类对象 类对象支持两种操作：属性引用和实例化。 属性引用 : obj.name。 有效的属性名称是类对象被创建时存在于类命名空间中的所有名称: 1 2 3 4 5 6 class MyClass: \"\"\"A simple example class\"\"\" i = 12345 def f(self): return 'hello world' MyClass.i 和 MyClass.f 就是有效的属性引用，将分别返回一个整数和一个函数对象。 类属性也可以被赋值，因此可以通过赋值来更改 MyClass.i 的值。 __doc__ 属性返回所属类的文档字符串: “A simple example class”。 类的 实例化 :x = MyClass()创建类的新 实例 并将此对象分配给局部变量 x。 类定义包含一个名为 __init__() 的特殊方法: 1 2 def __init__(self): self.data = [] 当一个类定义了 __init__() 方法时，类的实例化操作会自动为新创建的类实例发起调用 __init__()。 提供给类实例化的参数将被传递给 __init__() 1 2 3 4 5 6 7 8 \u003e\u003e\u003e class Complex: ... def __init__(self, realpart, imagpart): ... self.r = realpart ... self.i = imagpart ... \u003e\u003e\u003e x = Complex(3.0, -4.5) \u003e\u003e\u003e x.r, x.i (3.0, -4.5) ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/:3:2","tags":["Python教程"],"title":"Python教程-类","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/"},{"categories":["Python"],"content":"实例对象 实例对象理解的唯一操作是属性引用。 有两种有效的属性名称：数据属性和方法。 数据属性 对应于 C++ 中的“数据成员”。 数据属性不需要声明；像局部变量一样，它们将在第一次被赋值时产生 另一类实例属性引用称为 方法。 方法是“从属于”对象的函数。 实例对象的有效方法名称依赖于其所属的类。 根据定义，一个类中所有是函数对象的属性都是定义了其实例的相应方法。 因为 MyClass.f 是一个函数，所以x.f 是有效的方法引用，而 x.i 不是方法，因为 MyClass.i 不是一个函数。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/:3:3","tags":["Python教程"],"title":"Python教程-类","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/"},{"categories":["Python"],"content":"方法对象 调用方法:x.f() x.f 是一个方法对象，它可以被保存起来以后再调用: 1 2 3 xf = x.f while True: print(xf()) 方法的特殊之处就在于实例对象会作为函数的第一个参数被传入。 调用 x.f() 其实就相当于 MyClass.f(x)。 其实原理就是当在实例本地找不到数据或者函数时会去类对象里面找，如果是函数会把实例自身作为参数self传给函数。所以你修改类对象就可以修改类定义： ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/:3:4","tags":["Python教程"],"title":"Python教程-类","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/"},{"categories":["Python"],"content":"类和实例变量 实例变量用于每个实例的唯一数据，类变量用于类的所有实例共享的属性和方法，共享数据可能在涉及 mutable 对象例如列表和字典的时候导致令人惊讶的结果: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Dog: tricks = [] # mistaken use of a class variable def __init__(self, name): self.name = name def add_trick(self, trick): self.tricks.append(trick) \u003e\u003e\u003e d = Dog('Fido') \u003e\u003e\u003e e = Dog('Buddy') \u003e\u003e\u003e d.add_trick('roll over') \u003e\u003e\u003e e.add_trick('play dead') \u003e\u003e\u003e d.tricks # unexpectedly shared by all dogs ['roll over', 'play dead'] 正确的类设计应该使用实例变量即定义在__init__函数里面的self属性: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Dog: def __init__(self, name): self.name = name self.tricks = [] # creates a new empty list for each dog def add_trick(self, trick): self.tricks.append(trick) \u003e\u003e\u003e d = Dog('Fido') \u003e\u003e\u003e e = Dog('Buddy') \u003e\u003e\u003e d.add_trick('roll over') \u003e\u003e\u003e e.add_trick('play dead') \u003e\u003e\u003e d.tricks ['roll over'] \u003e\u003e\u003e e.tricks ['play dead'] ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/:3:5","tags":["Python教程"],"title":"Python教程-类","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/"},{"categories":["Python"],"content":"补充说明 如果同样的属性名称同时出现在实例和类中，则属性查找会优先选择实例: 在 Python 中没有任何东西能强制隐藏数据 — 它是完全基于约定的 方法的第一个参数常常被命名为 self。 这也不过就是一个约定: self 这一名称在 Python 中绝对没有特殊含义。 任何一个作为类属性的函数都为该类的实例定义了一个相应方法。 函数定义的文本并非必须包含于类定义之内：将一个函数对象赋值给一个局部变量也是可以的。 例如: 1 2 3 4 5 6 7 8 9 10 11 # Function defined outside the class def f1(self, x, y): return min(x, x+y) class C: f = f1 def g(self): return 'hello world' h = g 甚至你可以在定义完类之后修改类的方法 1 2 3 4 5 6 7 8 9 10 11 12 class a: def hello(self): print(\"hello world\") b=a() def hhhhh(self): print(\"hello world2\") a.hello2=hhhhh b.hello2()#输出hello world2 方法可以通过使用 self 参数的方法属性调用其他方法: 1 2 3 4 5 6 7 8 9 10 class Bag: def __init__(self): self.data = [] def add(self, x): self.data.append(x) def addtwice(self, x): self.add(x) self.add(x) 对象的 object.__class__ 属性指向类对象 类对象也可以进行传值 1 2 3 4 5 6 7 8 9 10 11 def f(): class a: def hello(self): print(\"hello world\") return a b=f() c=b() print(c.__class__)#输出\u003cclass '__main__.f.\u003clocals\u003e.a'\u003e ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/:4:0","tags":["Python教程"],"title":"Python教程-类","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/"},{"categories":["Python"],"content":"继承 1 2 3 4 5 6 class DerivedClassName(BaseClassName): \u003cstatement-1\u003e . . . \u003cstatement-N\u003e 名称 BaseClassName 必须定义于包含派生类定义的作用域中。 也允许用其他任意表达式代替基类名称所在的位置。例如，当基类定义在另一个模块中的时候: 1 class DerivedClassName(modname.BaseClassName): 派生类定义的执行过程与基类相同。 当构造类对象时，基类会被记住。 此信息将被用来解析属性引用：如果请求的属性在类中找不到，搜索将转往基类中进行查找。 如果基类本身也派生自其他某个类，则此规则将被递归地应用。 派生类的实例化没有任何特殊之处: DerivedClassName() 会创建该类的一个新实例。 方法引用将按以下方式解析：搜索相应的类属性，如有必要将按基类继承链逐步向下查找，如果产生了一个函数对象则方法引用就生效。 派生类可能会重载其基类的方法。 因为方法在调用同一对象的其他方法时没有特殊权限，调用同一基类中定义的另一方法的基类方法最终可能会调用覆盖它的派生类的方法。 （对 C++ 程序员的提示：Python 中所有的方法实际上都是 virtual 方法。） 在派生类中的重载方法实际上可能想要扩展而非简单地替换同名的基类方法。 有一种方式可以简单地直接调用基类方法：即调用 BaseClassName.methodname(self, arguments)。 Python有两个内置函数可被用于继承机制： 使用 isinstance() 来检查一个实例的类型: isinstance(obj, int) 仅会在 obj.__class__ 为 int 或某个派生自 int 的类时为 True。 使用 issubclass() 来检查类的继承关系: issubclass(bool, int) 为 True，因为 bool 是 int 的子类。 但是，issubclass(float, int) 为 False，因为 float 不是 int 的子类。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/:5:0","tags":["Python教程"],"title":"Python教程-类","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/"},{"categories":["Python"],"content":"多重继承 Python 也支持多重继承。 带有多个基类的类定义语句如下所示: 1 2 3 4 5 6 class DerivedClassName(Base1, Base2, Base3): \u003cstatement-1\u003e . . . \u003cstatement-N\u003e 可以认为搜索从父类所继承属性的操作是深度优先、从左至右的，当层次结构中存在重叠时不会在同一个类中搜索两次。 因此，如果某一属性在 DerivedClassName 中未找到，则会到 Base1 中搜索它，然后（递归地）到 Base1 的基类中搜索，如果在那里未找到，再到 Base2 中搜索，依此类推。 真实情况比这个更复杂一些；方法解析顺序会动态改变以支持对 super() 的协同调用。 这种方式在某些其他多重继承型语言中被称为后续方法调用，它比单继承型语言中的 super 调用更强大。 Python 3 可以使用直接使用 super().xxx 代替 super(Class, self).xxx class.mro()将返回方法搜索顺序表，关于mro相关的C3算法见官网文档以及mozillazg大佬的解析，大佬还解析了super关键字 多继承中调用指定父类的方法可以使用class.method(self,param)格式 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/:6:0","tags":["Python教程"],"title":"Python教程-类","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/"},{"categories":["Python"],"content":"私有变量 那种仅限从一个对象内部访问的“私有”实例变量在 Python 中并不存在。 但是，大多数 Python 代码都遵循这样一个约定：带有一个下划线的名称 (例如 _spam) 应该被当作是 API 的非公有部分 (无论它是函数、方法或是数据成员)。 由于存在对于类私有成员的有效使用场景（例如避免名称与子类所定义的名称相冲突），因此存在对此种机制的有限支持，称为 名称改写。 任何形式为 __spam 的标识符（至少带有两个前缀下划线，至多一个后缀下划线）的文本将被替换为 _classname__spam，其中 classname 为去除了前缀下划线的当前类名称。 这种改写不考虑标识符的句法位置，只要它出现在类定义内部就会进行。 名称改写有助于让子类重载方法而不破坏类内方法调用。例如: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Mapping: def __init__(self, iterable): self.items_list = [] self.__update(iterable) def update(self, iterable): for item in iterable: self.items_list.append(item) __update = update # private copy of original update() method class MappingSubclass(Mapping): def update(self, keys, values): # provides new signature for update() # but does not break __init__() for item in zip(keys, values): self.items_list.append(item) 上面的示例即使在 MappingSubclass 引入了一个 __update 标识符的情况下也不会出错，因为它会在 Mapping 类中被替换为 _Mapping__update 而在 MappingSubclass 类中被替换为 _MappingSubclass__update。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/:7:0","tags":["Python教程"],"title":"Python教程-类","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/"},{"categories":["Python"],"content":"杂项说明 实例方法对象也具有属性: m.__self__ 就是带有 m() 方法的实例对象，而 m.__func__ 则是该方法所对应的函数对象。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/:8:0","tags":["Python教程"],"title":"Python教程-类","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/"},{"categories":["Python"],"content":"迭代器 到目前为止，您可能已经注意到大多数容器对象都可以使用 for 语句: 1 2 3 4 5 6 7 8 9 10 for element in [1, 2, 3]: print(element) for element in (1, 2, 3): print(element) for key in {'one':1, 'two':2}: print(key) for char in \"123\": print(char) for line in open(\"myfile.txt\"): print(line, end='') for 语句会在容器对象上调用 iter()。 该函数返回一个具有 next() 方法的迭代器对象，此方法将逐一访问容器中的元素。 当元素用尽时，next() 将引发 StopIteration 异常来通知终止 for 循环。 可以使用 next() 内置函数来调用 next() 方法；这个例子显示了它的运作方式: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u003e\u003e\u003e s = 'abc' \u003e\u003e\u003e it = iter(s) \u003e\u003e\u003e it \u003citerator object at 0x00A1DB50\u003e \u003e\u003e\u003e next(it) 'a' \u003e\u003e\u003e next(it) 'b' \u003e\u003e\u003e next(it) 'c' \u003e\u003e\u003e next(it) Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e next(it) StopIteration 看过迭代器协议的幕后机制，给你的类添加迭代器行为就很容易了。 定义一个 iter() 方法来返回一个带有 next() 方法的对象。 如果类已定义了 next()，则 iter() 可以简单地返回 self: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Reverse: \"\"\"Iterator for looping over a sequence backwards.\"\"\" def __init__(self, data): self.data = data self.index = len(data) def __iter__(self): self.index = len(self.data) return self def __next__(self): if self.index == 0: raise StopIteration self.index = self.index - 1 return self.data[self.index] 1 2 3 4 5 6 7 8 9 10 \u003e\u003e\u003e rev = Reverse('spam') \u003e\u003e\u003e iter(rev) \u003c__main__.Reverse object at 0x00A1DB50\u003e \u003e\u003e\u003e for char in rev: ... print(char) ... m a p s ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/:9:0","tags":["Python教程"],"title":"Python教程-类","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/"},{"categories":["Python"],"content":"生成器 生成器 是一个用于创建迭代器的简单而强大的工具。 它们的写法类似于标准的函数，但当它们要返回数据时会使用 yield 语句。 每次在生成器上调用 next() 时，它会从上次离开的位置恢复执行（它会记住上次执行语句时的所有数据值）。 一个显示如何非常容易地创建生成器的示例如下: 1 2 3 def reverse(data): for index in range(len(data)-1, -1, -1): yield data[index] 1 2 3 4 5 6 7 \u003e\u003e\u003e for char in reverse('golf'): ... print(char) ... f l o g 可以用生成器来完成的操作同样可以用前一节所描述的基于类的迭代器来完成。 但生成器的写法更为紧凑，因为它会自动创建 iter() 和 next() 方法。 另一个关键特性在于局部变量和执行状态会在每次调用之间自动保存。 这使得该函数相比使用 self.index 和 self.data 这种实例变量的方式更易编写且更为清晰。 除了会自动创建方法和保存程序状态，当生成器终结时，它们还会自动引发 StopIteration。 这些特性结合在一起，使得创建迭代器能与编写常规函数一样容易。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/:10:0","tags":["Python教程"],"title":"Python教程-类","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/"},{"categories":["Python"],"content":"生成器表达式 某些简单的生成器可以写成简洁的表达式代码，所用语法类似列表推导式，但外层为圆括号而非方括号。 这种表达式被设计用于生成器将立即被外层函数所使用的情况。 生成器表达式相比完整的生成器更紧凑但较不灵活，相比等效的列表推导式则更为节省内存。 示例: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u003e\u003e\u003e sum(i*i for i in range(10)) # sum of squares 285 \u003e\u003e\u003e xvec = [10, 20, 30] \u003e\u003e\u003e yvec = [7, 5, 3] \u003e\u003e\u003e sum(x*y for x,y in zip(xvec, yvec)) # dot product 260 \u003e\u003e\u003e unique_words = set(word for line in page for word in line.split()) \u003e\u003e\u003e valedictorian = max((student.gpa, student.name) for student in graduates) \u003e\u003e\u003e data = 'golf' \u003e\u003e\u003e list(data[i] for i in range(len(data)-1, -1, -1)) ['f', 'l', 'o', 'g'] ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/:11:0","tags":["Python教程"],"title":"Python教程-类","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E7%B1%BB/"},{"categories":["Python"],"content":"本系列为作者在官网学习python时做的笔记，详见python官网 python标准库官方文档，查阅标准库相关的内容 python语言参考，查看python语法，该文档是简洁的，但试图做到准确和完整。非必要的内建对象类型和内建函数、模块的语义描述在 Python 标准库 中。 标准库和语言参考涵盖了python的所有内容，他们是互补的，如果在语言参考中没有找到需要的内容那么就一定在便准库文档中。 （至少）有两种可区分的错误：语法错误 和 异常。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8/:0:0","tags":["Python教程"],"title":"Python教程-错误和异常","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["Python"],"content":"语法错误 语法错误又称解析错误，解析器会输出出现语法错误的那一行，并显示一个“箭头”，指向这行里面检测到的第一个错误。 错误是由箭头指示的位置 上面 的 token 引起的（或者至少是在这里被检测出的） ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8/:1:0","tags":["Python教程"],"title":"Python教程-错误和异常","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["Python"],"content":"异常 即使语句或表达式在语法上是正确的，但在尝试执行时，它仍可能会引发错误。 在执行时检测到的错误被称为 异常，异常不一定会导致严重后果。 不被程序处理异常，会直接让终止程序并打印错误信息: 1 2 3 4 \u003e\u003e\u003e 10 * (1/0) Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e ZeroDivisionError: division by zero 错误信息的前一部分以堆栈回溯的形式显示发生异常时的上下文。 内置异常 列出了内置异常和它们的含义。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8/:2:0","tags":["Python教程"],"title":"Python教程-错误和异常","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["Python"],"content":"处理异常 1 2 3 4 5 6 7 \u003e\u003e\u003e while True: ... try: ... x = int(input(\"Please enter a number: \")) ... break ... except ValueError: ... print(\"Oops! That was no valid number. Try again...\") ... try 语句的工作原理如下： 首先，执行 try 子句 （try 和 except 关键字之间的（多行）语句）。 如果没有异常发生，则跳过 except 子句 并完成 try 语句的执行。 如果在执行 try 子句时发生了异常，则跳过该子句中剩下的部分。 然后，如果异常的类型和 except 关键字后面的异常匹配，则执行 except 子句，然后继续执行 try 语句之后的代码。 如果发生的异常和 except 子句中指定的异常不匹配，则将其传递到外部的 try 语句中；如果没有找到处理程序，则它是一个 未处理异常，执行将停止并显示如上所示的消息 一个 try 语句可能有多个 except 子句，以指定不同异常的处理程序。 最多会执行一个处理程序。 处理程序只处理相应的 try 子句中发生的异常，而不处理同一 try 语句内其他处理程序中的异常。 一个 except 子句可以将多个异常命名为带括号的元组，例如: 1 2 ... except (RuntimeError, TypeError, NameError): ... pass 如果发生的异常和 except 子句中的类是同一个类或者是它的基类，则异常和 except 子句中的类是兼容的（反过来则不成立 — 派生类的 except 子句与基类不兼容） 可以使用as关键字给异常一个别名 最后的 except 子句可以省略异常名，以用作通配符。不推荐，该方式很容易掩盖真正的编程错误！不过可用于打印错误消息，然后重新引发异常（同样允许调用者处理异常）: 1 2 3 4 5 6 7 8 9 10 11 12 13 import sys try: f = open('myfile.txt') s = f.readline() i = int(s.strip()) except OSError as err: print(\"OS error: {0}\".format(err)) except ValueError: print(\"Could not convert data to an integer.\") except: print(\"Unexpected error:\", sys.exc_info()[0]) raise try … except 语句有一个可选的 else 子句，在使用时必须放在所有的 except 子句后面。对于在 try 子句不引发异常时必须执行的代码来说很有用。 例如: 1 2 3 4 5 6 7 8 for arg in sys.argv[1:]: try: f = open(arg, 'r') except OSError: print('cannot open', arg) else: print(arg, 'has', len(f.readlines()), 'lines') f.close() 发生异常时，它可能具有关联值，也称为异常 参数 。参数的存在和类型取决于异常类型。 except 子句可以在异常名称后面指定一个变量。这个变量和一个异常实例绑定，它的参数存储在 instance.args 中。为了方便起见，异常实例定义了 str() ，因此可以直接打印参数而无需引用 .args 。也可以在抛出之前首先实例化异常，并根据需要向其添加任何属性。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u003e\u003e\u003e try: ... raise Exception('spam', 'eggs') ... except Exception as inst: ... print(type(inst)) # the exception instance ... print(inst.args) # arguments stored in .args ... print(inst) # __str__ allows args to be printed directly, ... # but may be overridden in exception subclasses ... x, y = inst.args # unpack args ... print('x =', x) ... print('y =', y) ... \u003cclass 'Exception'\u003e ('spam', 'eggs') ('spam', 'eggs') x = spam y = eggs 如果异常有参数，则它们将作为未处理异常的消息的最后一部分（‘详细信息’）打印。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8/:3:0","tags":["Python教程"],"title":"Python教程-错误和异常","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["Python"],"content":"抛出异常 raise 语句允许程序员强制发生指定的异常: 1 2 3 4 \u003e\u003e\u003e raise NameError('HiThere') Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e NameError: HiThere raise 唯一的参数就是要抛出的异常。这个参数必须是一个异常实例或者是一个异常类（派生自 Exception 的类）。 如果你需要确定是否引发了异常但不打算处理它，可以使用更简单的 raise 语句形式重新引发异常 1 2 3 4 5 6 7 8 9 10 \u003e\u003e\u003e try: ... raise NameError('HiThere') ... except NameError: ... print('An exception flew by!') ... raise ... An exception flew by! Traceback (most recent call last): File \"\u003cstdin\u003e\", line 2, in \u003cmodule\u003e NameError: HiThere ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8/:4:0","tags":["Python教程"],"title":"Python教程-错误和异常","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["Python"],"content":"用户自定义异常 程序可以通过创建新的异常类来命名它们自己的异常（有关Python 类的更多信息，请参阅 类）。异常通常应该直接或间接地从 Exception 类派生。 在__init__方法里面添加属性 1 2 3 4 5 6 7 8 9 10 11 class InputError(Error): \"\"\"Exception raised for errors in the input. Attributes: expression -- input expression in which the error occurred message -- explanation of the error \"\"\" def __init__(self, expression, message): self.expression = expression self.message = message ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8/:5:0","tags":["Python教程"],"title":"Python教程-错误和异常","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["Python"],"content":"定义清理操作 try 语句有另一个可选finally子句，用于定义必须在所有情况下执行的清理操作: 1 2 3 4 5 6 7 8 9 \u003e\u003e\u003e try: ... raise KeyboardInterrupt ... finally: ... print('Goodbye, world!') ... Goodbye, world! KeyboardInterrupt Traceback (most recent call last): File \"\u003cstdin\u003e\", line 2, in \u003cmodule\u003e 如果存在 finally 子句，则 finally 子句将作为 try 语句结束前的最后一项任务被执行。 finally 子句不论 try 语句是否产生了异常都会被执行： try 子句抛出异常。如果被 except 子句处理，则finally在except子句处理后再执行。否则该异常会在 finally 子句执行后重新引发。 except 或 else 子句抛出异常，该异常会在 finally 子句执行后重新引发。 finally 子句将在 try 语句执行 break, continue 或 return 语句之前被执行。 finally 子句可以return。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8/:6:0","tags":["Python教程"],"title":"Python教程-错误和异常","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["Python"],"content":"预定义的清理操作 with 语句允许像文件这样的对象能够以一种确保它们得到及时和正确的清理的方式使用: 1 2 3 with open(\"myfile.txt\") as f: for line in f: print(line, end=\"\") 执行完语句后，即使在处理行时遇到问题，文件 f 也始终会被关闭。和文件一样，提供预定义清理操作的对象将在其文档中指出这一点。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8/:7:0","tags":["Python教程"],"title":"Python教程-错误和异常","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8/"},{"categories":["Python"],"content":"本系列为作者在官网学习python时做的笔记，详见python官网 python标准库官方文档，查阅标准库相关的内容 python语言参考，查看python语法，该文档是简洁的，但试图做到准确和完整。非必要的内建对象类型和内建函数、模块的语义描述在 Python 标准库 中。 标准库和语言参考涵盖了python的所有内容，他们是互补的，如果在语言参考中没有找到需要的内容那么就一定在便准库文档中。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:0:0","tags":["Python教程"],"title":"Python教程-输入输出","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["Python"],"content":"更漂亮的输出格式 使用 repr() 或 str() 函数将任何值转化为字符串快速显示某些变量以进行调试。 str() 函数是用于返回人类可读的值的表示，repr() 是用于生成解释器可读的表示（如果没有等效的语法，则会强制执行 SyntaxError）对于没有人类可读性的表示的对象， str() 将返回和 repr() 一样的值。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:1:0","tags":["Python教程"],"title":"Python教程-输入输出","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["Python"],"content":"格式化字符串文字 格式化字符串字面值 （常简称为 f-字符串）能让你在字符串前加上 f 和 F 并将表达式写成 {expression} 来在字符串中包含 Python 表达式的值。 可选的格式说明符可以跟在表达式后面。这样可以更好地控制值的格式化方式。以下示例将pi舍入到小数点后三位: 1 2 3 \u003e\u003e\u003e import math \u003e\u003e\u003e print(f'The value of pi is approximately {math.pi:.3f}.') The value of pi is approximately 3.142. 在 ‘:’ 后传递一个整数可以让该字段成为最小字符宽度。这在使列对齐时很有用。: 1 2 3 4 5 6 7 \u003e\u003e\u003e table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678} \u003e\u003e\u003e for name, phone in table.items(): ... print(f'{name:10} ==\u003e {phone:10d}') ... Sjoerd ==\u003e 4127 Jack ==\u003e 4098 Dcab ==\u003e 7678 其他的修饰符可用于在格式化之前转化值。 ‘!a’ 应用 ascii() ，’!s’ 应用 str()，还有 ‘!r’ 应用 repr(): 1 2 3 4 5 \u003e\u003e\u003e animals = 'eels' \u003e\u003e\u003e print(f'My hovercraft is full of {animals}.') My hovercraft is full of eels. \u003e\u003e\u003e print(f'My hovercraft is full of {animals!r}.') My hovercraft is full of 'eels'. Python编程基础：f-字符串格式 f字符串是format方法的格式一致。 可以与r原始字符串一起使用，还可以使用条件表达式 1 2 3 4 5 6 7 8 9 10 parent_dir = rf'D:\\完美Exce1 Python' subfolder ='MyFiles' file_path = 'file01.x1sx print(rf'{fparent_dir}\\{lsubfolder} \\{file_path}') pass_mark = 50 mark_1 =60 mark_2 =49 print(f\"student 1 {'pass'if mark_1 \u003e pass_mark else 'fail'}\") print(f\"student 2 {'pass'if mark_2 \u003e pass_mark else 'fail'}\") ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:1:1","tags":["Python教程"],"title":"Python教程-输入输出","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["Python"],"content":"字符串的 format() 方法 1 2 \u003e\u003e\u003e print('We are the {} who say \"{}!\"'.format('knights', 'Ni')) We are the knights who say \"Ni!\" 花括号中的数字可用来表示传递给 str.format() 方法的对象的位置。 1 2 \u003e\u003e\u003e print('{1} and {0}'.format('spam', 'eggs')) eggs and spam 如果在 str.format() 方法中使用关键字参数，则使用参数的名称引用它们的值 1 2 3 \u003e\u003e\u003e print('This {food} is {adjective}.'.format( ... food='spam', adjective='absolutely horrible')) This spam is absolutely horrible. 位置和关键字参数可以任意组合: 1 2 3 \u003e\u003e\u003e print('The story of {0}, {1}, and {other}.'.format('Bill', 'Manfred', other='Georg')) The story of Bill, Manfred, and Georg. 可以给format传递字典 1 2 3 4 \u003e\u003e\u003e table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678} \u003e\u003e\u003e print('Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; ' ... 'Dcab: {0[Dcab]:d}'.format(table)) Jack: 4098; Sjoerd: 4127; Dcab: 8637678 内置函数 vars() 返回包含所有局部变量的字典。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:1:2","tags":["Python教程"],"title":"Python教程-输入输出","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["Python"],"content":"手动格式化字符串 print函数的sep和end选项，字符串的ljust，rjust，center以及zfill方法 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:1:3","tags":["Python教程"],"title":"Python教程-输入输出","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["Python"],"content":"旧的字符串格式化方法 字符串插值： 1 \u003e\u003e\u003e print('The value of pi is approximately %5.3f.' % math.pi) ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:1:4","tags":["Python教程"],"title":"Python教程-输入输出","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["Python"],"content":"读写文件 open(filename, mode) 返回一个 file object 1 \u003e\u003e\u003e f = open('workfile', 'w') mode 可以是 ‘r’ 只读，‘w’ 只写，‘a’ 追加。‘r+’ 读写。默认为 ‘r’。 默认以 text mode 打开的：以指定的编码方式进行读写。编码格式默认值与平台相关。 在mode 中追加的 ‘b’ 则以 binary mode 打开文件：以字节的形式进行读写的。 在文本模式下读取时，默认会把平台特定的行结束符 (Unix 上的 \\n, Windows 上的 \\r\\n) 转换为 \\n。在文本模式下写入时，默认会把出现的 \\n 转换回平台特定的结束符。这样在幕后修改文件数据对文本文件来说没有问题，但是会破坏二进制数据例如 JPEG 或 EXE 文件中的数据。请一定要注意在读写此类文件时应使用二进制模式。 with 关键字自动在子句结束后关闭文件: 1 2 3 4 5 6 \u003e\u003e\u003e with open('workfile') as f: ... read_data = f.read() \u003e\u003e\u003e # We can check that the file has been automatically closed. \u003e\u003e\u003e f.closed True 没有使用 with 关键字，调用 f.close() 来关闭文件并立即释放它所使用的任何系统资源。 调用 f.write() 时未使用 with 关键字或未调用 f.close() 可能导致 f.write() 的参数没有完全写入到磁盘，即使程序是正常退出的。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:2:0","tags":["Python教程"],"title":"Python教程-输入输出","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["Python"],"content":"文件对象的方法 假定已创建名为 f 的文件对象。 f.read(size)读取一些数据并将其作为字符串（在文本模式下）或字节串对象（在二进制模式下）返回。 size 被省略或者为负数时，将读取并返回整个文件的内容；如果文件的大小是你的机器内存的两倍就会出现问题。 当取其他值时，将读取并返回至多 size 个字符（在文本模式下）或 size 个字节（在二进制模式下）。 如果已到达文件末尾，f.read() 将返回一个空字符串 (’’)。 f.readline() 从文件中读取一行；换行符（\\n）留在字符串的末尾，如果文件不以换行符结尾，则在文件的最后一行省略。空字符串\"“表示已经到达了文件末尾，空行返回’\\n’: 循环遍历文件对象读取行: 1 2 3 4 5 \u003e\u003e\u003e for line in f: ... print(line, end='') ... This is the first line of the file. Second line of the file list(f)或 f.readlines()以列表的形式读取文件中的所有行 f.write(string) 会把 string 的内容写入到文件中，返回写入的字符数 1 2 \u003e\u003e\u003e f.write('This is a test\\n') 15 写入其他类型的对象之前，需要先把它们转化为字符串（在文本模式下）或者字节对象（在二进制模式下）: 1 2 3 4 \u003e\u003e\u003e value = ('the answer', 42) \u003e\u003e\u003e s = str(value) # convert the tuple to string \u003e\u003e\u003e f.write(s) 18 f.tell() 返回二进制模式下从文件开始到当前位置的字节数 f.seek(offset, whence)改变文件对象的位置。offset 来计算位置，whence 参数指定参考点。 whence 的 0 值表示从文件开头起算，1 表示使用当前文件位置，2 表示使用文件末尾作为参考点。 默认值为 0。 1 2 3 4 5 6 7 8 9 10 11 \u003e\u003e\u003e f = open('workfile', 'rb+') \u003e\u003e\u003e f.write(b'0123456789abcdef') 16 \u003e\u003e\u003e f.seek(5) # Go to the 6th byte in the file 5 \u003e\u003e\u003e f.read(1) b'5' \u003e\u003e\u003e f.seek(-3, 2) # Go to the 3rd byte before the end 13 \u003e\u003e\u003e f.read(1) b'd' 在文本文件中，只允许相对于文件开头搜索（使用 seek(0, 2) 搜索到文件末尾是个例外）并且唯一有效的 offset 值是那些能从 f.tell() 中返回的或者是零。其他 offset 值都会产生未定义的行为。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:2:1","tags":["Python教程"],"title":"Python教程-输入输出","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["Python"],"content":"使用 json 保存结构化数据 将对象序列化为json字符串: 1 2 3 \u003e\u003e\u003e import json \u003e\u003e\u003e json.dumps([1, 'simple', 'list']) '[1, \"simple\", \"list\"]' dump() 将对象序列化为 text file : 1 json.dump(x, f) load()解码text file 对象: 1 x = json.load(f) ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:2:2","tags":["Python教程"],"title":"Python教程-输入输出","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["Python"],"content":"Python3 字符串与hex之间的相互转换 bytes.fromhex(a):将十六进制串转换为二进制串 bytes.hex(a):将二进制串转换为十六进制串 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:3:0","tags":["Python教程"],"title":"Python教程-输入输出","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["Python"],"content":"本系列为作者在官网学习python时做的笔记，详见python官网 python标准库官方文档，查阅标准库相关的内容 python语言参考，查看python语法，该文档是简洁的，但试图做到准确和完整。非必要的内建对象类型和内建函数、模块的语义描述在 Python 标准库 中。 标准库和语言参考涵盖了python的所有内容，他们是互补的，如果在语言参考中没有找到需要的内容那么就一定在便准库文档中。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A8%A1%E5%9D%97/:0:0","tags":["Python教程"],"title":"Python教程-模块","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A8%A1%E5%9D%97/"},{"categories":["Python"],"content":"更多有关模块的信息 模块可以包含可执行的语句以及函数定义。这些语句用于初始化模块。它们仅在模块 第一次 在 import 语句中被导入时才执行。(当文件被当作脚本运行时(模块的__name__属性为main)，它们也会执行。) 每个模块都有它自己的私有符号表，不必担心模块内全局变量与用户的全局变量发生意外冲突。另一方面，可以用跟访问模块内的函数的同样标记方法，去访问一个模块的全局变量，modname.itemname。 可以把其他模块导入模块。被导入的模块名存在导入方模块的全局符号表里。 可以把名字从一个被调模块内直接导入到现模块的符号表里。例如: 1 2 from fibo import fib, fib2 fib(500) 这并不会把被调模块名引入到局部变量表里（因此在这个例子里，fibo 是未被定义的）。 还可以导入模块内定义的所有名称: 1 2 3 \u003e\u003e\u003e from fibo import * \u003e\u003e\u003e fib(500) 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 这会调入所有非以下划线（_）开头的名称。不推荐使用，有覆盖你本地变量的风险。在交互式编译器中为了节省打字可以这么用。 如果模块名称之后带有 as，则跟在 as 之后的名称将直接绑定到所导入的模块（原来的模块名不会被导入）。 1 2 3 \u003e\u003e\u003e import fibo as fib \u003e\u003e\u003e fib.fib(500) 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 这种方式也可以在用到 from 的时候使用: 1 2 3 \u003e\u003e\u003e from fibo import fib as fibonacci \u003e\u003e\u003e fibonacci(500) 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 每个模块在每个解释器会话中只被导入一次。如果你更改了你的模块，则必须重新启动解释器。如果它只是一个要交互式地测试的模块，可以使用 importlib.reload() 1 2 import importlib importlib.reload(modulename) ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A8%A1%E5%9D%97/:1:0","tags":["Python教程"],"title":"Python教程-模块","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A8%A1%E5%9D%97/"},{"categories":["Python"],"content":"以脚本的方式执行模块 当你用下面方式运行一个Python模块: 1 python fibo.py \u003carguments\u003e 这项操作将执行模块里的代码，而且会把 __name__ 赋值为 \"__main__\"。 也就是会运行下面的代码： 1 2 3 if __name__ == \"__main__\": import sys fib(int(sys.argv[1])) 如果模块是被导入的，那些代码是不运行的: 1 2 \u003e\u003e\u003e import fibo \u003e\u003e\u003e ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A8%A1%E5%9D%97/:1:1","tags":["Python教程"],"title":"Python教程-模块","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A8%A1%E5%9D%97/"},{"categories":["Python"],"content":"模块搜索路径 当一个名为 spam 的模块被导入的时候，解释器首先寻找具有该名称的内置模块。如果没有找到，然后解释器从 sys.path 变量给出的目录列表里寻找名为 spam.py 的文件。sys.path 初始有这些目录地址: 包含输入脚本的目录（或者未指定文件时的当前目录）。 PYTHONPATH （一个包含目录名称的列表，它和shell变量 PATH 有一样的语法）。 取决于安装的默认设置 在初始化后，Python程序可以更改 sys.path。除非有意更换，否则这是错误。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A8%A1%E5%9D%97/:1:2","tags":["Python教程"],"title":"Python教程-模块","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A8%A1%E5%9D%97/"},{"categories":["Python"],"content":"“编译过的”Python文件 为了加速模块载入，Python在 ${PYTHON_HOME}/Lib/__pycache__ 目录里缓存了每个模块的编译后版本，名称为 module.version.pyc ，其中名称中的版本字段对编译文件的格式进行编码； 它一般使用Python版本号。如telnetlib.cpython-38.pyc Python根据编译版本检查源的修改日期，以查看它是否已过期并需要重新编译。这是一个完全自动化的过程。 编译的模块与平台无关，因此可以在具有不同体系结构的系统之间共享相同的库。 Python在两种情况下不会检查缓存而是直接编译: 从命令行直接载入的模块 没有源模块 给专业人士的一些小建议: 你可以在Python命令中使用 -O 或者 -OO 开关， 以减小编译后模块的大小。 -O 开关去除断言语句，-OO 开关同时去除断言语句和 doc 字符串。 一个从 .pyc 文件读出的程序并不会比它从 .py 读出时运行的更快，.pyc 文件唯一快的地方在于载入速度。 compileall 模块可以为一个目录下的所有模块创建.pyc文件。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A8%A1%E5%9D%97/:1:3","tags":["Python教程"],"title":"Python教程-模块","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A8%A1%E5%9D%97/"},{"categories":["Python"],"content":"标准模块 一些模块内置于解释器中；它们提供对不属于语言核心但仍然内置的操作的访问，以提高效率或提供对系统调用等操作系统原语的访问。这些模块的集合是一个配置选项，它也取决于底层平台。例如，winreg 模块只在Windows操作系统上提供。一个特别值得注意的模块 sys，它被内嵌到每一个Python解释器中。变量 sys.ps1 和 sys.ps2 定义用作主要和辅助提示的字符串: 1 2 3 4 5 6 7 8 9 \u003e\u003e\u003e import sys \u003e\u003e\u003e sys.ps1 '\u003e\u003e\u003e ' \u003e\u003e\u003e sys.ps2 '... ' \u003e\u003e\u003e sys.ps1 = 'C\u003e ' C\u003e print('Yuck!') Yuck! C\u003e 这两个变量只有在编译器是交互模式下才被定义。 sys.path 变量是一个字符串列表，用于确定解释器的模块搜索路径。该变量被初始化为从环境变量 PYTHONPATH 获取的默认路径，或者如果 PYTHONPATH 未设置，则从内置默认路径初始化。可以使用标准列表操作对其进行修改: 1 2 \u003e\u003e\u003e import sys \u003e\u003e\u003e sys.path.append('/ufs/guido/lib/python') ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A8%A1%E5%9D%97/:2:0","tags":["Python教程"],"title":"Python教程-模块","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A8%A1%E5%9D%97/"},{"categories":["Python"],"content":"dir() 函数 内置函数 dir() 用于查找模块定义的名称。 它返回一个排序过的字符串列表: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u003e\u003e\u003e import fibo, sys \u003e\u003e\u003e dir(fibo) ['__name__', 'fib', 'fib2'] \u003e\u003e\u003e dir(sys) ['__displayhook__', '__doc__', '__excepthook__', '__loader__', '__name__', '__package__', '__stderr__', '__stdin__', '__stdout__', '_clear_type_cache', '_current_frames', '_debugmallocstats', '_getframe', '_home', '_mercurial', '_xoptions', 'abiflags', 'api_version', 'argv', 'base_exec_prefix', 'base_prefix', 'builtin_module_names', 'byteorder', 'call_tracing', 'callstats', 'copyright', 'displayhook', 'dont_write_bytecode', 'exc_info', 'excepthook', 'exec_prefix', 'executable', 'exit', 'flags', 'float_info', 'float_repr_style', 'getcheckinterval', 'getdefaultencoding', 'getdlopenflags', 'getfilesystemencoding', 'getobjects', 'getprofile', 'getrecursionlimit', 'getrefcount', 'getsizeof', 'getswitchinterval', 'gettotalrefcount', 'gettrace', 'hash_info', 'hexversion', 'implementation', 'int_info', 'intern', 'maxsize', 'maxunicode', 'meta_path', 'modules', 'path', 'path_hooks', 'path_importer_cache', 'platform', 'prefix', 'ps1', 'setcheckinterval', 'setdlopenflags', 'setprofile', 'setrecursionlimit', 'setswitchinterval', 'settrace', 'stderr', 'stdin', 'stdout', 'thread_info', 'version', 'version_info', 'warnoptions'] 如果没有参数，dir() 会列出你当前定义的名称: 1 2 3 4 5 \u003e\u003e\u003e a = [1, 2, 3, 4, 5] \u003e\u003e\u003e import fibo \u003e\u003e\u003e fib = fibo.fib \u003e\u003e\u003e dir() ['__builtins__', '__name__', 'a', 'fib', 'fibo', 'sys'] 注意：它列出所有类型的名称：变量，模块，函数，等等。 dir() 不会列出内置函数和变量的名称。如果你想要这些，它们的定义是在标准模块 builtins 中: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u003e\u003e\u003e import builtins \u003e\u003e\u003e dir(builtins) ['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FileExistsError', 'FileNotFoundError', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError', 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'ZeroDivisionError', '_', '__build_class__', '__debug__', '__doc__', '__import__', '__name__', '__package__', 'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip'] ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A8%A1%E5%9D%97/:3:0","tags":["Python教程"],"title":"Python教程-模块","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A8%A1%E5%9D%97/"},{"categories":["Python"],"content":"包 包是目录，模块是py文件 包是一种通过用“带点号的模块名”来构造 Python 模块命名空间的方法。 必须要有 __init__.py 文件才能让 Python 将包含该文件的目录当作包。 在最简单的情况下，__init__.py 可以只是一个空文件，但它也可以执行包的初始化代码或设置 __all__ 变量， 包的用户可以从包中导入单个模块，例如: 1 import sound.effects.echo 这会加载子模块 sound.effects.echo ，但引用它时必须使用它的全名。 1 sound.effects.echo.echofilter(input, output, delay=0.7, atten=4) 导入子模块的另一种方法是 1 from sound.effects import echo 这也会加载子模块 echo ，并使其在没有包前缀的情况下可用: 1 echo.echofilter(input, output, delay=0.7, atten=4) 另一种形式是直接导入所需的函数或变量: 1 from sound.effects.echo import echofilter 同样，这也会加载子模块 echo，但函数 echofilter() 直接可用: 1 echofilter(input, output, delay=0.7, atten=4) 请注意，当使用 from package import item 时，item可以是包的子模块（或子包），也可以是包中定义的其他名称，如函数，类或变量。 import 语句首先测试是否在包中定义了item；如果没有，它假定它是一个模块并尝试加载它。如果找不到它，则引发 ImportError 异常。 相反，当使用 import item.subitem.subsubitem 最后一项不能是前一项中定义的类或函数或变量。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A8%A1%E5%9D%97/:4:0","tags":["Python教程"],"title":"Python教程-模块","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A8%A1%E5%9D%97/"},{"categories":["Python"],"content":"从包中导入 * from sound.effects import * 找到包中存在哪些子模块，并将它们全部导入。这可能需要很长时间。 如果一个包的 __init__.py 代码定义的名为 __all__ 的列表会被视为在遇到 from package import * 时应该导入的模块名列表。例如，文件 sound/effects/__init__.py 可以包含以下代码: 1 __all__ = [\"echo\", \"surround\", \"reverse\"] 这意味着 from sound.effects import * 将导入 sound 包的三个命名子模块。 如果没有定义 __all__，from sound.effects import * 语句 不会 从包 sound.effects 中导入所有子模块到当前命名空间；它只确保导入了包 sound.effects 任何在__init__.py中的初始化代码定义的任何名称。 这包括 __init__.py 定义的任何名称（以及显式加载的子模块）: ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A8%A1%E5%9D%97/:4:1","tags":["Python教程"],"title":"Python教程-模块","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A8%A1%E5%9D%97/"},{"categories":["Python"],"content":"子包参考 当包被构造成子包时（与示例中的 sound 包一样），你可以使用绝对导入（相对项目目录而言）来引用兄弟包的子模块。例如，如果模块 sound.filters.vocoder 需要在 sound.effects 包中使用 echo 模块，它可以使用 from sound.effects import echo 。 你还可以使用import语句的 from module import name 形式编写相对导入。这些导入使用前导点来指示相对导入中涉及的当前包和父包。例如，从 surround 模块，你可以使用: 1 2 3 from . import echo from .. import formats from ..filters import equalizer 推荐使用绝对导入 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A8%A1%E5%9D%97/:4:2","tags":["Python教程"],"title":"Python教程-模块","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A8%A1%E5%9D%97/"},{"categories":["Python"],"content":"多个目录中的包 包支持另一个特殊属性， __path__ 。它被初始化为一个列表，其中包含在执行该文件中的代码之前保存包的文件 __init__.py 的目录的名称。这个变量可以修改；这样做会影响将来对包中包含的模块和子包的搜索。 虽然通常不需要此功能，但它可用于扩展程序包中的模块集。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A8%A1%E5%9D%97/:4:3","tags":["Python教程"],"title":"Python教程-模块","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%A8%A1%E5%9D%97/"},{"categories":["Python"],"content":"本系列为作者在官网学习python时做的笔记，详见python官网 python标准库官方文档，查阅标准库相关的内容 python语言参考，查看python语法，该文档是简洁的，但试图做到准确和完整。非必要的内建对象类型和内建函数、模块的语义描述在 Python 标准库 中。 标准库和语言参考涵盖了python的所有内容，他们是互补的，如果在语言参考中没有找到需要的内容那么就一定在便准库文档中。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:0:0","tags":["Python教程"],"title":"Python教程-数据结构","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Python"],"content":"列表的更多特性 列表数据类型还有很多的方法。这里是列表对象方法的清单： list.append(x) 在列表的末尾添加一个元素。相当于 a[len(a):] = [x] 。 list.extend(iterable) 使用可迭代对象中的所有元素来扩展列表。相当于 a[len(a):] = iterable 。 list.insert(i, x) 在给定的位置插入一个元素。第一个参数是要插入的元素的索引，所以 a.insert(0, x) 插入列表头部， a.insert(len(a), x) 等同于 a.append(x) 。 list.remove(x)移除列表中第一个值为 x 的元素。如果没有这样的元素，则抛出 ValueError 异常。 list.pop([i])删除列表中给定位置的元素并返回它。如果没有给定位置，a.pop() 将会删除并返回列表中的最后一个元素。（ 方法签名中 i 两边的方括号表示这个参数是可选的，而不是要你输入方括号。你会在 Python 参考库中经常看到这种表示方法)。 list.clear()移除列表中的所有元素。等价于del a[:] list.index(x[, start[, end]])返回列表中第一个值为 x 的元素的从零开始的索引。如果没有这样的元素将会抛出 ValueError 异常。可选参数 start 和 end 是切片符号，用于将搜索限制为列表的特定子序列。返回的索引是相对于整个序列的开始计算的，而不是 start 参数。 list.count(x)返回元素 x 在列表中出现的次数。 list.sort(*, key=None, reverse=False)对列表中的元素进行排序（key参数可用于自定义排序，它的值应该为一个接收item，并返回一个可比较值的函数）。 list.reverse() 翻转列表中的元素。 list.copy() 返回列表的一个浅拷贝，等价于 a[:]。 修改列表的方法返回默认值 None 。这是Python中所有可变数据结构的设计原则。 不同类型的数据的列表可能无法排序。 例如，[None, ‘hello’, 10] 就不可排序，因为整数不能与字符串比较，而 None 不能与其他类型比较。 并且还存在一些没有定义顺序关系的类型。 例如，3+4j \u003c 5+7j 就不是一个合法的比较。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:1:0","tags":["Python教程"],"title":"Python教程-数据结构","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Python"],"content":"列表作为栈使用 append()添加一个元素到堆栈的顶端 pop()从堆栈顶部取出一个元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u003e\u003e\u003e stack = [3, 4, 5] \u003e\u003e\u003e stack.append(6) \u003e\u003e\u003e stack.append(7) \u003e\u003e\u003e stack [3, 4, 5, 6, 7] \u003e\u003e\u003e stack.pop() 7 \u003e\u003e\u003e stack [3, 4, 5, 6] \u003e\u003e\u003e stack.pop() 6 \u003e\u003e\u003e stack.pop() 5 \u003e\u003e\u003e stack [3, 4] ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:1:1","tags":["Python教程"],"title":"Python教程-数据结构","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Python"],"content":"列表作为队列使用 在列表的末尾添加和弹出元素非常快，在列表的开头插入或弹出元素却很慢，因为所有的其他元素都必须移动一位 列表用作队列相当低效 可使用 collections.deque，它可以快速地从两端添加或弹出元素 1 2 3 4 5 6 7 8 9 10 \u003e\u003e\u003e from collections import deque \u003e\u003e\u003e queue = deque([\"Eric\", \"John\", \"Michael\"]) \u003e\u003e\u003e queue.append(\"Terry\") # Terry arrives \u003e\u003e\u003e queue.append(\"Graham\") # Graham arrives \u003e\u003e\u003e queue.popleft() # The first to arrive now leaves 'Eric' \u003e\u003e\u003e queue.popleft() # The second to arrive now leaves 'John' \u003e\u003e\u003e queue # Remaining queue in order of arrival deque(['Michael', 'Terry', 'Graham']) ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:1:2","tags":["Python教程"],"title":"Python教程-数据结构","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Python"],"content":"列表推导式 列表推导式可以节约循环变量的内存空间 1 2 3 squares = list(map(lambda x: x**2, range(10))) squares = [x**2 for x in range(10)] 上面这种写法更加简洁易读。 列表推导式的结构是由一对方括号所包含的以下内容：一个表达式，后面跟一个 for 子句，然后是零个或多个 for 或 if 子句。 其结果将是一个新列表，由对表达式依据后面的 for 和 if 子句的内容进行求值计算而得出。 举例来说，以下列表推导式会将两个列表中不相等的元素组合起来: 1 2 \u003e\u003e\u003e [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y] [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)] 而它等价于 1 2 3 4 5 6 7 8 \u003e\u003e\u003e combs = [] \u003e\u003e\u003e for x in [1,2,3]: ... for y in [3,1,4]: ... if x != y: ... combs.append((x, y)) ... \u003e\u003e\u003e combs [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)] 注意在上面两个代码片段中， for 和 if 的顺序是相同的。 如果表达式是一个元组（例如上面的 (x, y)），那么就必须加上括号 列表推导式可以使用复杂的表达式和嵌套函数 1 2 3 \u003e\u003e\u003e from math import pi \u003e\u003e\u003e [str(round(pi, i)) for i in range(1, 6)] ['3.1', '3.14', '3.142', '3.1416', '3.14159'] ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:1:3","tags":["Python教程"],"title":"Python教程-数据结构","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Python"],"content":"嵌套的列表推导式 列表推导式中的初始表达式可以是任何表达式，包括另一个列表推导式，这种情况下从外面开始往里面读来理解这个列表推导式 考虑下面这个 3x4的矩阵，它由3个长度为4的列表组成 1 2 3 4 5 \u003e\u003e\u003e matrix = [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... ] 下面的列表推导式将交换其行和列 1 2 \u003e\u003e\u003e [[row[i] for row in matrix] for i in range(4)] [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]] 如上节所示，嵌套的列表推导式是基于跟随其后的 for 进行求值的，所以这个例子等价于: 1 2 3 4 5 6 \u003e\u003e\u003e transposed = [] \u003e\u003e\u003e for i in range(4): ... transposed.append([row[i] for row in matrix]) ... \u003e\u003e\u003e transposed [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]] 反过来说，也等价于 1 2 3 4 5 6 7 8 9 10 \u003e\u003e\u003e transposed = [] \u003e\u003e\u003e for i in range(4): ... # the following 3 lines implement the nested listcomp ... transposed_row = [] ... for row in matrix: ... transposed_row.append(row[i]) ... transposed.append(transposed_row) ... \u003e\u003e\u003e transposed [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]] 实际应用中，你应该会更喜欢使用内置函数去组成复杂的流程语句。 zip() 函数将会很好地处理这种情况 1 2 \u003e\u003e\u003e list(zip(*matrix)) [(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)] ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:1:4","tags":["Python教程"],"title":"Python教程-数据结构","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Python"],"content":"del 语句 del 语句从列表中移除元素，切片或者清空整个列表（等同将一个空列表赋值给指定的切片）。 例如: 1 2 3 4 5 6 7 8 9 10 \u003e\u003e\u003e a = [-1, 1, 66.25, 333, 333, 1234.5] \u003e\u003e\u003e del a[0] \u003e\u003e\u003e a [1, 66.25, 333, 333, 1234.5] \u003e\u003e\u003e del a[2:4] \u003e\u003e\u003e a [1, 66.25, 1234.5] \u003e\u003e\u003e del a[:] \u003e\u003e\u003e a [] del 也可以删除整个变量 1 \u003e\u003e\u003e del a 此后再引用 a 时会报错（直到另一个值被赋给它）。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:2:0","tags":["Python教程"],"title":"Python教程-数据结构","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Python"],"content":"元组和序列 我们看到列表和字符串有很多共同特性，例如索引和切片操作。他们是 序列 数据类型（list, tuple, range）中的两种。 一个元组由几个被逗号隔开的值组成，例如 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u003e\u003e\u003e t = 12345, 54321, 'hello!' \u003e\u003e\u003e t[0] 12345 \u003e\u003e\u003e t (12345, 54321, 'hello!') \u003e\u003e\u003e # Tuples may be nested: ... u = t, (1, 2, 3, 4, 5) \u003e\u003e\u003e u ((12345, 54321, 'hello!'), (1, 2, 3, 4, 5)) \u003e\u003e\u003e # Tuples are immutable: ... t[0] = 88888 Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e TypeError: 'tuple' object does not support item assignment \u003e\u003e\u003e # but they can contain mutable objects: ... v = ([1, 2, 3], [3, 2, 1]) \u003e\u003e\u003e v ([1, 2, 3], [3, 2, 1]) 元组在输出时总是被圆括号包围的。输入时圆括号可有可无，嵌套在其他序列的元组必须有括号。不能修改元组指向的对象，但是元组的可变对象可以进行修改。 元组是 immutable ，其序列通常包含不同种类的元素，通过解包或者索引来访问（ namedtuples 可以通过属性访问）。 空元组可以直接被一对空圆括号创建，含有一个元素的元组可以通过在这个元素后添加一个逗号来构建（圆括号里只有一个值的话不够明确） 元组打包和序列解包 1 2 3 4 5 # 元组打包 t = 12345, 54321, 'hello!' # 序列解包 x, y, z = t 解包操作的右侧可以是任何序列。序列解包要求等号左侧的变量数与右侧序列里所含的元素数相同。 多重赋值其实也只是元组打包和序列解包的组合。 小白学视觉 下划线在 Python 中的特殊含义 可以通过赋值给_来忽略某些值 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:3:0","tags":["Python教程"],"title":"Python教程-数据结构","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Python"],"content":"集合 集合是由不重复元素组成的无序的集。可用于成员检测和消除重复元素。集合对象也支持像 联合，交集，差集，对称差分等数学运算。 花括号或 set() 函数可以用来创建集合。 创建一个空集合你只能用 set() 而不能用 {}，后者是创建一个空字典。 集合也支持推导式形式 1 2 3 \u003e\u003e\u003e a = {x for x in 'abracadabra' if x not in 'abc'} \u003e\u003e\u003e a {'r', 'd'} 以下是一些简单的示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u003e\u003e\u003e basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'} \u003e\u003e\u003e print(basket) # show that duplicates have been removed {'orange', 'banana', 'pear', 'apple'} \u003e\u003e\u003e 'orange' in basket # fast membership testing True \u003e\u003e\u003e 'crabgrass' in basket False \u003e\u003e\u003e # Demonstrate set operations on unique letters from two words ... \u003e\u003e\u003e a = set('abracadabra') \u003e\u003e\u003e b = set('alacazam') \u003e\u003e\u003e a # unique letters in a {'a', 'r', 'b', 'c', 'd'} \u003e\u003e\u003e a - b # letters in a but not in b {'r', 'd', 'b'} \u003e\u003e\u003e a | b # letters in a or b or both {'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'} \u003e\u003e\u003e a \u0026 b # letters in both a and b {'a', 'c'} \u003e\u003e\u003e a ^ b # letters in a or b but not both {'r', 'd', 'b', 'm', 'z', 'l'} ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:4:0","tags":["Python教程"],"title":"Python教程-数据结构","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Python"],"content":"字典 字典 字典是以 key关键字 为索引的，关键字可以是任意不可变类型，通常是字符串或数字。如果一个元组只包含字符串、数字或元组，那么这个元组也可以用作关键字。但如果元组直接或间接地包含了可变对象，那么它就不能用作关键字。 字典是一个 键: 值 对的集合，键必须是唯一的（在一个字典中）。 一对花括号可以创建一个空字典：{} 。可以放置一些以逗号分隔的键值对进行初始化。 可以用 del 语句来删除一个键值对。使用已经存在的关键字来存储值，会替换这个键的旧值。用不存在的键来取值则会报错。 对字典d执行 list(d) 将返回包含该字典中所有键的列表，按插入次序排列 (如需其他排序，则要使用 sorted(d))。 in 关键字检查字典中是否存在一个特定键。 以下是使用字典的一些简单示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u003e\u003e\u003e tel = {'jack': 4098, 'sape': 4139} \u003e\u003e\u003e tel['guido'] = 4127 \u003e\u003e\u003e tel {'jack': 4098, 'sape': 4139, 'guido': 4127} \u003e\u003e\u003e tel['jack'] 4098 \u003e\u003e\u003e del tel['sape'] \u003e\u003e\u003e tel['irv'] = 4127 \u003e\u003e\u003e tel {'jack': 4098, 'guido': 4127, 'irv': 4127} \u003e\u003e\u003e list(tel) ['jack', 'guido', 'irv'] \u003e\u003e\u003e sorted(tel) ['guido', 'irv', 'jack'] \u003e\u003e\u003e 'guido' in tel True \u003e\u003e\u003e 'jack' not in tel False dict() 构造函数可以直接从键值对序列里创建字典。 1 2 \u003e\u003e\u003e dict([('sape', 4139), ('guido', 4127), ('jack', 4098)]) {'sape': 4139, 'guido': 4127, 'jack': 4098} 字典推导式可以从任意的键值表达式中创建字典 1 2 \u003e\u003e\u003e {x: x**2 for x in (2, 4, 6)} {2: 4, 4: 16, 6: 36} 当关键字是简单字符串时，直接通过关键字参数来指定键值对 1 2 \u003e\u003e\u003e dict(sape=4139, guido=4127, jack=4098) {'sape': 4139, 'guido': 4127, 'jack': 4098} ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:5:0","tags":["Python教程"],"title":"Python教程-数据结构","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Python"],"content":"循环的技巧 items() 方法可将关键字和对应的值同时取出 1 2 3 4 5 6 \u003e\u003e\u003e knights = {'gallahad': 'the pure', 'robin': 'the brave'} \u003e\u003e\u003e for k, v in knights.items(): ... print(k, v) ... gallahad the pure robin the brave enumerate() 函数可以将索引位置和其对应的值同时取出 1 2 3 4 5 6 \u003e\u003e\u003e for i, v in enumerate(['tic', 'tac', 'toe']): ... print(i, v) ... 0 tic 1 tac 2 toe 当同时在两个或更多序列中循环时，可以用 zip() 函数将其内元素一一匹配。 1 2 3 4 5 6 7 8 \u003e\u003e\u003e questions = ['name', 'quest', 'favorite color'] \u003e\u003e\u003e answers = ['lancelot', 'the holy grail', 'blue'] \u003e\u003e\u003e for q, a in zip(questions, answers): ... print('What is your {0}? It is {1}.'.format(q, a)) ... What is your name? It is lancelot. What is your quest? It is the holy grail. What is your favorite color? It is blue. 如果要逆向循环一个序列，可以先正向定位序列，然后调用 reversed() 函数 1 2 3 4 5 6 7 8 \u003e\u003e\u003e for i in reversed(range(1, 10, 2)): ... print(i) ... 9 7 5 3 1 如果要按某个指定顺序循环一个序列，可以用 sorted() 函数，它可以在不改动原序列的基础上返回一个新的排好序的序列 1 2 3 4 5 6 7 8 \u003e\u003e\u003e basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana'] \u003e\u003e\u003e for f in sorted(set(basket)): ... print(f) ... apple banana orange pear 有时可能会想在循环时修改列表内容，一般来说改为创建一个新列表是比较简单且安全的 1 2 3 4 5 6 7 8 9 \u003e\u003e\u003e import math \u003e\u003e\u003e raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8] \u003e\u003e\u003e filtered_data = [] \u003e\u003e\u003e for value in raw_data: ... if not math.isnan(value): ... filtered_data.append(value) ... \u003e\u003e\u003e filtered_data [56.2, 51.7, 55.3, 52.5, 47.8] ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:6:0","tags":["Python教程"],"title":"Python教程-数据结构","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Python"],"content":"深入条件控制 while 和 if 条件句中可以使用任意操作，而不仅仅是比较操作。 比较操作符 in 和 not in 校验一个值是否在（或不在）一个序列里。 操作符 is 和 is not 比较两个对象是不是同一个对象。 所有的比较操作符都有相同的优先级，且这个优先级比数值运算符低。 比较操作可以传递。例如 a \u003c b == c 会校验是否 a 小于 b 并且 b 等于 c。 比较操作可以通过布尔运算符 and 和 or 来组合，并且比较操作（或其他任何布尔运算）的结果都可以用 not 来取反。这些操作符的优先级低于比较操作符；在它们之中，not 优先级最高， or 优先级最低。 布尔运算符 and 和 or 也被称为 短路 运算符：它们的参数从左至右解析，一旦可以确定结果解析就会停止。 可以把比较操作或者逻辑表达式的结果赋值给一个变量，这个值不一定是bool类型例如 1 2 3 4 \u003e\u003e\u003e string1, string2, string3 = '', 'Trondheim', 'Hammer Dance' \u003e\u003e\u003e non_null = string1 or string2 or string3 \u003e\u003e\u003e non_null 'Trondheim' 在表达式内部赋值必须显式地使用 海象运算符 := 来完成。 这避免了 C 程序中常见的一种问题：想要在表达式中写 == 时却写成了 =。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:7:0","tags":["Python教程"],"title":"Python教程-数据结构","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Python"],"content":"比较序列和其他类型 序列对象通常可以与相同序列类型的其他对象比较。 字典式顺序进行比较，首先比较开头的两个对应元素，如果两者不相等则比较结果就由此确定；如果两者相等则比较之后的两个元素，以此类推，直到有一个序列被耗尽。 如果两个序列中所有的对应元素都相等，则两个序列也将被视为相等。 如果一个序列是另一个的初始子序列，则较短的序列就被视为较小（较少）。 对于字符串来说，字典式顺序是使用 Unicode 码位序号对单个字符排序。 下面是一些相同类型序列之间比较的例子: 1 2 3 4 5 6 7 (1, 2, 3) \u003c (1, 2, 4) [1, 2, 3] \u003c [1, 2, 4] 'ABC' \u003c 'C' \u003c 'Pascal' \u003c 'Python' (1, 2, 3, 4) \u003c (1, 2, 4) (1, 2) \u003c (1, 2, -1) (1, 2, 3) == (1.0, 2.0, 3.0) (1, 2, ('aa', 'ab')) \u003c (1, 2, ('abc', 'a'), 4) 注意对不同类型对象来说，只要待比较对象提供了合适的比较方法，就可以使用 \u003c 和 \u003e 来比较。例如，混合数值类型是通过他们的数值进行比较的，所以 0 等于 0.0，等等。否则，解释器将抛出一个 TypeError 异常，而不是随便给出一个结果。 ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:8:0","tags":["Python教程"],"title":"Python教程-数据结构","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Python"],"content":"合并两个相同的数据结构 使用构造符号和解构写法比如 1 a={**b,**c} 浅拷贝，a，b，c为互相无关的变量 使用update方法 1 a.update(b) 也是浅拷贝，将b中的元素拷贝到a中，a，b为互相无关的变量 当合并两个dict，同键的值相加 1 2 3 4 5 6 7 8 dict1 = {'a': 1, 'b': 2} dict2 = {'a': 8, 'c': 3} for key, value in dict2.items(): if key in dict1: dict1[key] += value else: dict1[key] = value print(dict1) ","date":"2022-10-12","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:9:0","tags":["Python教程"],"title":"Python教程-数据结构","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Python"],"content":"本系列为作者在官网学习python时做的笔记，详见python官网 python标准库官方文档，查阅标准库相关的内容 python语言参考，查看python语法，该文档是简洁的，但试图做到准确和完整。非必要的内建对象类型和内建函数、模块的语义描述在 Python 标准库 中。 标准库和语言参考涵盖了python的所有内容，他们是互补的，如果在语言参考中没有找到需要的内容那么就一定在便准库文档中。 ","date":"2022-10-11","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/:0:0","tags":["Python教程"],"title":"Python教程-其他流程控制工具","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"},{"categories":["Python"],"content":"if 语句 if 语句包含零个或多个 elif 子句及可选的 else 子句。 ","date":"2022-10-11","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/:1:0","tags":["Python教程"],"title":"Python教程-其他流程控制工具","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"},{"categories":["Python"],"content":"for 语句 python中只有for in 1 2 3 4 5 6 7 8 \u003e\u003e\u003e # Measure some strings: ... words = ['cat', 'window', 'defenestrate'] \u003e\u003e\u003e for w in words: ... print(w, len(w)) ... cat 3 window 6 defenestrate 12 循环遍历该集合的副本或创建新集合 1 2 3 4 5 6 7 8 9 10 # Strategy: Iterate over a copy for user, status in users.copy().items(): if status == 'inactive': del users[user] # Strategy: Create a new collection active_users = {} for user, status in users.items(): if status == 'active': active_users[user] = status ","date":"2022-10-11","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/:2:0","tags":["Python教程"],"title":"Python教程-其他流程控制工具","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"},{"categories":["Python"],"content":"range() 函数 内置函数 range()生成算术级数: 1 2 3 4 5 6 7 8 \u003e\u003e\u003e for i in range(5): ... print(i) ... 0 1 2 3 4 给定的终止数值并不在要生成的序列 两个参数时，第一个参数是开始值，第二个参数是终止值 三个参数时，第三个参数是步长可以是负数 1 2 3 4 5 6 7 8 range(5, 10) 5, 6, 7, 8, 9 range(0, 10, 3) 0, 3, 6, 9 range(-10, -100, -30) -10, -40, -70 range() 所返回的对象在许多方面表现得像一个列表，但实际上却并不是。我们称这样对象为 iterable ","date":"2022-10-11","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/:3:0","tags":["Python教程"],"title":"Python教程-其他流程控制工具","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"},{"categories":["Python"],"content":"break 和 continue 语句，以及循环中的 else 子句 break 语句用于跳出最近的 for 或 while 循环. else 子句在循环耗尽了可迭代对象 (使用 for) 或循环条件变为假值 (使用 while) 时被执行，但不会在循环被 break 语句终止时被执行。 continue 继续循环中的下一次迭代: ","date":"2022-10-11","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/:4:0","tags":["Python教程"],"title":"Python教程-其他流程控制工具","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"},{"categories":["Python"],"content":"pass 语句 pass 语句什么也不做，这通常用于创建最小的类: 1 2 3 \u003e\u003e\u003e class MyEmptyClass: ... pass ... ","date":"2022-10-11","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/:5:0","tags":["Python教程"],"title":"Python教程-其他流程控制工具","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"},{"categories":["Python"],"content":"定义函数 1 2 3 4 5 6 7 8 9 10 11 \u003e\u003e\u003e def fib(n): # write Fibonacci series up to n ... \"\"\"Print a Fibonacci series up to n.\"\"\" ... a, b = 0, 1 ... while a \u003c n: ... print(a, end=' ') ... a, b = b, a+b ... print() ... \u003e\u003e\u003e # Now call the function we just defined: ... fib(2000) 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 关键字 def 引入一个函数 定义。它必须后跟函数名称和带括号的形式参数列表。构成函数体的语句从下一行开始，并且必须缩进。 函数体的第一个语句可以（可选的）是字符串文字；这个字符串文字是函数的文档字符串或 docstring 。 函数的 执行 会引入一个用于函数局部变量的新符号表。函数中所有的变量赋值都将存储在局部符号表中；变量引用会首先在局部符号表中查找，然后是外层函数的局部符号表，再然后是全局符号表，最后是内置名称的符号表。 因此，全局变量和外层函数的变量不能在函数内部直接赋值（除非是在 global 语句中定义的全局变量，或者是在 nonlocal 语句中定义的外层函数的变量），但是它们可以被引用。 在调用函数时会将实际参数（实参）引入到被调用函数的局部符号表中；因此，实参是使用 按值调用 来传递的（其中的 值 始终是对象的 引用 而不是对象的值）。 当一个函数调用另外一个函数时，会为该调用创建一个新的局部符号表。 函数定义会将函数名称与函数对象在当前符号表中进行关联。 解释器会将该名称所指向的对象识别为用户自定义函数。 其他名称也可指向同一个函数对象并可被用来访问访函数: 1 2 3 4 5 \u003e\u003e\u003e fib \u003cfunction fib at 10042ed0\u003e \u003e\u003e\u003e f = fib \u003e\u003e\u003e f(100) 0 1 1 2 3 5 8 13 21 34 55 89 没有 return 语句的函数也会返回一个值，这个值称为 None （它是内置名称），可以通过print打印 1 2 3 \u003e\u003e\u003e fib(0) \u003e\u003e\u003e print(fib(0)) None ","date":"2022-10-11","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/:6:0","tags":["Python教程"],"title":"Python教程-其他流程控制工具","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"},{"categories":["Python"],"content":"函数定义的更多形式 ","date":"2022-10-11","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/:7:0","tags":["Python教程"],"title":"Python教程-其他流程控制工具","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"},{"categories":["Python"],"content":"参数默认值 对一个或多个参数指定一个默认值: 1 2 3 def ask_ok(prompt, retries=4, reminder='Please try again!'): while True: ... 默认值在 定义过程 中在函数定义处计算的，计算默认值只会执行一次（对于引用类型则指向的对象不变），所以下面这个实例会打印 5 1 2 3 4 5 6 7 i = 5 def f(arg=i): print(arg) i = 6 f() 1 2 3 4 5 6 7 def f(a, L=[]): L.append(a) return L print(f(1)) print(f(2)) print(f(3)) 这将打印出 1 2 3 [1] [1, 2] [1, 2, 3] ","date":"2022-10-11","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/:7:1","tags":["Python教程"],"title":"Python教程-其他流程控制工具","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"},{"categories":["Python"],"content":"关键字参数 使用形如 kwarg=value 的 关键字参数 来调用函数。 关键字参数必须跟随在位置参数（非关键字参数）的后面。传递的所有关键字参数必须与函数接受的其中一个参数匹配，它们的顺序并不重要。不能对同一个参数多次赋值。 最后一个形参为 **name 的时，它会接收一个字典 ，包含除了与已有形参相对应的关键字参数以外的所有关键字参数。 它可以与一个形式为 *name，接收一个包含除了已有形参列表以外的位置参数的 元组 的形参组合使用 (*name 必须出现在 **name 之前。) ","date":"2022-10-11","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/:7:2","tags":["Python教程"],"title":"Python教程-其他流程控制工具","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"},{"categories":["Python"],"content":"特殊参数 函数调用时的参数只有位置参数或是显式的关键字参数。 函数的定义看起来可以像是这样： 1 2 3 4 5 6 def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2): ----------- ---------- ---------- | | | | Positional or keyword | | - Keyword only -- Positional only /仅用于分割仅位置参数的形参，*仅用于分割仅关键字形参 *name就是* ","date":"2022-10-11","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/:7:3","tags":["Python教程"],"title":"Python教程-其他流程控制工具","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"},{"categories":["Python"],"content":"任意的参数列表 可变参数 将在形式参数列表的末尾，因为它们收集传递给函数的所有剩余输入参数。出现在 *args 参数之后的任何形式参数都是 ‘仅限关键字参数’，所以通常将 *后面的参数都设置为有默认值的形参: 1 2 3 4 5 6 7 \u003e\u003e\u003e def concat(*args, sep=\"/\"): ... return sep.join(args) ... \u003e\u003e\u003e concat(\"earth\", \"mars\", \"venus\") 'earth/mars/venus' \u003e\u003e\u003e concat(\"earth\", \"mars\", \"venus\", sep=\".\") 'earth.mars.venus' ","date":"2022-10-11","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/:7:4","tags":["Python教程"],"title":"Python教程-其他流程控制工具","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"},{"categories":["Python"],"content":"解包参数列表 参数已经在列表或元组中，使用 * 操作符解包参数: 1 2 3 4 5 \u003e\u003e\u003e list(range(3, 6)) # normal call with separate arguments [3, 4, 5] \u003e\u003e\u003e args = [3, 6] \u003e\u003e\u003e list(range(*args)) # call with arguments unpacked from a list [3, 4, 5] 同样的方式，字典可使用 ** 操作符 来提供关键字参数: 1 2 3 4 5 6 7 8 \u003e\u003e\u003e def parrot(voltage, state='a stiff', action='voom'): ... print(\"-- This parrot wouldn't\", action, end=' ') ... print(\"if you put\", voltage, \"volts through it.\", end=' ') ... print(\"E's\", state, \"!\") ... \u003e\u003e\u003e d = {\"voltage\": \"four million\", \"state\": \"bleedin' demised\", \"action\": \"VOOM\"} \u003e\u003e\u003e parrot(**d) -- This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised ! ","date":"2022-10-11","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/:7:5","tags":["Python教程"],"title":"Python教程-其他流程控制工具","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"},{"categories":["Python"],"content":"Lambda 表达式 可以用 lambda 关键字来创建一个小的匿名函数: 1 2 3 4 5 6 def make_incrementor(n): # 用 ：来分割参数和返回值 return lambda x: x + n f = make_incrementor(42) f(0) ","date":"2022-10-11","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/:7:6","tags":["Python教程"],"title":"Python教程-其他流程控制工具","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"},{"categories":["Python"],"content":"函数标注 函数标注 是用户自定义函数中使用的类型的完全可选元数据信息。以字典的形式存放在函数的 annotations 属性中，并且不会影响函数的任何其他部分。 形参标注的定义方式是在形参名后加冒号，后面跟一个表达式，该表达式会被求值为标注的值。 返回值标注的定义方式是加组合符号 -\u003e，后面跟一个表达式，该标注位于形参列表和表示 def 语句结束的冒号之间 1 2 3 4 5 6 7 8 9 \u003e\u003e\u003e def f(ham: str, eggs: str = 'eggs') -\u003e str: ... print(\"Annotations:\", f.__annotations__) ... print(\"Arguments:\", ham, eggs) ... return ham + ' and ' + eggs ... \u003e\u003e\u003e f('spam') Annotations: {'ham': \u003cclass 'str'\u003e, 'return': \u003cclass 'str'\u003e, 'eggs': \u003cclass 'str'\u003e} Arguments: spam eggs 'spam and eggs' ","date":"2022-10-11","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/:7:7","tags":["Python教程"],"title":"Python教程-其他流程控制工具","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"},{"categories":["Python"],"content":"对于要求传入迭代对象的参数 可以在调用函数的时候在实参中使用推导式以及lambda表达式来现场生成对象，比如 1 nx.draw_networkx(...,labels={n:prefix+n for n in G}) ","date":"2022-10-11","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/:8:0","tags":["Python教程"],"title":"Python教程-其他流程控制工具","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"},{"categories":["Python"],"content":"Functools functools 模块应用于高阶函数，即参数或（和）返回值为其他函数的函数。详见官方文档 ","date":"2022-10-11","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/:9:0","tags":["Python教程"],"title":"Python教程-其他流程控制工具","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"},{"categories":["Python"],"content":"functools.partial(func, /, *args, **keywords) 返回一个新的 部分对象，当被调用时其行为类似于 func 附带位置参数 args 和关键字参数 keywords 被调用。 官方文档 1 2 3 4 def f(m,n): return m*n re=partial(f,3) print(re(4))#12 ","date":"2022-10-11","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/:9:1","tags":["Python教程"],"title":"Python教程-其他流程控制工具","uri":"/posts/python/python%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"},{"categories":["Python"],"content":"本系列为作者在官网学习python时做的笔记，详见python官网 python标准库官方文档，查阅标准库相关的内容 python语言参考，查看python语法，该文档是简洁的，但试图做到准确和完整。非必要的内建对象类型和内建函数、模块的语义描述在 Python 标准库 中。 标准库和语言参考涵盖了python的所有内容，他们是互补的，如果在语言参考中没有找到需要的内容那么就一定在便准库文档中。 Python 注释以 # 开头，直到该物理行结束。 ","date":"2022-10-11","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/python%E9%80%9F%E8%A7%88/:0:0","tags":["Python教程"],"title":"Python教程-Python速览","uri":"/posts/python/python%E6%95%99%E7%A8%8B/python%E9%80%9F%E8%A7%88/"},{"categories":["Python"],"content":"Python 用作计算器 ","date":"2022-10-11","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/python%E9%80%9F%E8%A7%88/:1:0","tags":["Python教程"],"title":"Python教程-Python速览","uri":"/posts/python/python%E6%95%99%E7%A8%8B/python%E9%80%9F%E8%A7%88/"},{"categories":["Python"],"content":"数字 解释器像一个简单的计算器：输入表达式，就会给出答案。表达式的语法很直接：运算符 +、-、*、/ 的用法和其他大部分语言一样（比如，Pascal 或 C）；括号 (()) 用来分组。 整数（如，2、4、20 ）的类型是 int，带小数（如，5.0、1.6 ）的类型是 float。 除法 ( /) 总是返回一个浮点数。要进行地板除法并获得整数结果，您可以使用//运算符；计算你可以使用的余数% Python 用 ** 运算符计算乘方 等号（=）用于给变量赋值。 混合类型运算数的运算会把整数转换为浮点数 Python 还支持 Decimal 或 Fraction， 复数。 ","date":"2022-10-11","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/python%E9%80%9F%E8%A7%88/:1:1","tags":["Python教程"],"title":"Python教程-Python速览","uri":"/posts/python/python%E6%95%99%E7%A8%8B/python%E9%80%9F%E8%A7%88/"},{"categories":["Python"],"content":"字符串 用单引号（’……’）或双引号（\"……\"）标注的结果相同。 反斜杠 \\ 用于转义 默认字符串为utf8字符串，在引号前添加 b 为ascii字符串（每个字符占1个字节） csdn 羽丶千落 字符串和bytes类型相互转换 str.encode():将字符串编码，默认编码为ascii str.decode():将字符串解码为utf8 在引号前添加 r 为原始字符串，不会进行转义 三重引定义多行字符串字面值：\"\"\"…\"\"\" 或 ‘’’…’’’。 字符串将自动包括行结束符，在换行的地方添加一个 \\ 则不包含。 参见以下示例： 字符串可以用 + 合并（粘到一起），也可以用 * 重复 字符串支持 索引 （下标访问），第一个字符的索引是 0。单字符没有专用的类型，就是长度为一的字符串： 索引还支持负数，从右边开始计数：-0 和 0 一样，负数索引从 -1 开始。 字符串支持 切片。切片 提取子字符串：开始索引默认值为 0，结束索引默认为到字符串的结尾：注意，切片输出结果包含开始，但不包含切片结束(左闭右开)。s[:i] + s[i:] 总是等于 s： 索引越界会报错，切片会自动处理越界索引： Python 字符串不能修改，是 immutable 的。为字符串中某个索引位置赋值会报错 内置函数 len() 返回字符串的长度 ","date":"2022-10-11","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/python%E9%80%9F%E8%A7%88/:1:2","tags":["Python教程"],"title":"Python教程-Python速览","uri":"/posts/python/python%E6%95%99%E7%A8%8B/python%E9%80%9F%E8%A7%88/"},{"categories":["Python"],"content":"列表 用方括号标注，逗号分隔的一组值。列表可以包含不同类型的元素，一般情况下，各个元素的类型相同： 列表也支持索引和切片 切片返回原列表的 浅拷贝： 列表支持合并操作： 1 2 \u003e\u003e\u003e squares + [36, 49, 64, 81, 100] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 列表是 mutable 类型，其内容可以改变： append() 方法 在列表结尾添加新元素: 1 2 3 4 \u003e\u003e\u003e cubes.append(216) # add the cube of 6 \u003e\u003e\u003e cubes.append(7 ** 3) # and the cube of 7 \u003e\u003e\u003e cubes [1, 8, 27, 64, 125, 216, 343] 为切片赋值可以改变列表大小，甚至清空整个列表： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u003e\u003e\u003e letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g'] \u003e\u003e\u003e letters ['a', 'b', 'c', 'd', 'e', 'f', 'g'] \u003e\u003e\u003e # replace some values \u003e\u003e\u003e letters[2:5] = ['C', 'D', 'E'] \u003e\u003e\u003e letters ['a', 'b', 'C', 'D', 'E', 'f', 'g'] \u003e\u003e\u003e # now remove them \u003e\u003e\u003e letters[2:5] = [] \u003e\u003e\u003e letters ['a', 'b', 'f', 'g'] \u003e\u003e\u003e # clear the list by replacing all the elements with an empty list \u003e\u003e\u003e letters[:] = [] \u003e\u003e\u003e letters [] 内置函数 len() 支持列表： 1 2 3 \u003e\u003e\u003e letters = ['a', 'b', 'c', 'd'] \u003e\u003e\u003e len(letters) 4 可以嵌套列表（创建包含其他列表的列表） ","date":"2022-10-11","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/python%E9%80%9F%E8%A7%88/:1:3","tags":["Python教程"],"title":"Python教程-Python速览","uri":"/posts/python/python%E6%95%99%E7%A8%8B/python%E9%80%9F%E8%A7%88/"},{"categories":["Python"],"content":"走向编程的第一步 斐波那契数列 的初始子序列，如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u003e\u003e\u003e # Fibonacci series: ... # the sum of two elements defines the next ... a, b = 0, 1 \u003e\u003e\u003e while a \u003c 10: ... print(a) ... a, b = b, a+b ... 0 1 1 2 3 5 8 第一行中 多重赋值：变量 a 和 b 同时获得新值 0 和 1。右表达式在赋值前求值，求值顺序为从左到右。 Python 和 C 一样，任何非零整数都为真，零为假。这个条件也可以是字符串或列表的值，序列也可以；长度非零就为真，空序列为假。 比较操作符的标准写法和 C 语言一样： \u003c （小于）、 \u003e （大于）、 == （等于）、 \u003c= （小于等于)、 \u003e= （大于等于）及 != （不等于）。 循环体 是 缩进的 ：缩进是 Python 组织语句的方式。 print() 函数输出给定参数的值。它能处理多个参数，包括浮点数与字符串。它输出的字符串不带引号，且各参数项之间会插入一个空格： 关键字参数 end , 用另一个字符串替换结尾换行符 关键字参数 sep , 用另一个字符串替换各参数项之间的空格 ","date":"2022-10-11","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/python%E9%80%9F%E8%A7%88/:2:0","tags":["Python教程"],"title":"Python教程-Python速览","uri":"/posts/python/python%E6%95%99%E7%A8%8B/python%E9%80%9F%E8%A7%88/"},{"categories":["Python"],"content":"本系列为作者在官网学习python时做的笔记，详见python官网 python标准库官方文档，查阅标准库相关的内容 python语言参考，查看python语法，该文档是简洁的，但试图做到准确和完整。非必要的内建对象类型和内建函数、模块的语义描述在 Python 标准库 中。 标准库和语言参考涵盖了python的所有内容，他们是互补的，如果在语言参考中没有找到需要的内容那么就一定在便准库文档中。 ","date":"2022-10-11","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/python%E8%A7%A3%E9%87%8A%E5%99%A8/:0:0","tags":["Python教程"],"title":"Python教程-Python解释器","uri":"/posts/python/python%E6%95%99%E7%A8%8B/python%E8%A7%A3%E9%87%8A%E5%99%A8/"},{"categories":["Python"],"content":"调用解释器 1 python3 在主提示符中，输入文件结束符（Unix 里是 Control-D，Windows 里是 Control-Z），或quit()退出。 以文件名参数，或标准输入文件调用时，则读取并执行文件中的 脚本。 Python 模块也可以当作脚本使用（执行时模块的__name__内置属性为\"main\"）。python -m module [arg] ...，会执行 module 的源文件，这跟在命令行把路径写全了一样。 在脚本名称参数前，加上选项 -i 在交互模式下运行脚本文件。 ","date":"2022-10-11","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/python%E8%A7%A3%E9%87%8A%E5%99%A8/:1:0","tags":["Python教程"],"title":"Python教程-Python解释器","uri":"/posts/python/python%E6%95%99%E7%A8%8B/python%E8%A7%A3%E9%87%8A%E5%99%A8/"},{"categories":["Python"],"content":"传入参数 解释器读取命令行参数，把脚本名与其他参数转化为字符串列表存到 sys 模块的 argv 变量里。执行 import sys，可以导入这个模块，并访问该列表。使用选项 -m module时sys.argv[0] 是模块全名。 ","date":"2022-10-11","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/python%E8%A7%A3%E9%87%8A%E5%99%A8/:1:1","tags":["Python教程"],"title":"Python教程-Python解释器","uri":"/posts/python/python%E6%95%99%E7%A8%8B/python%E8%A7%A3%E9%87%8A%E5%99%A8/"},{"categories":["Python"],"content":"交互模式 显示 主提示符，提示输入下一条指令，主提示符通常用三个大于号（»\u003e）表示；输入连续行时，显示 次要提示符，默认是三个点（…）。进入解释器时，首先显示欢迎信息、版本信息、版权声明，然后才是提示符： ","date":"2022-10-11","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/python%E8%A7%A3%E9%87%8A%E5%99%A8/:1:2","tags":["Python教程"],"title":"Python教程-Python解释器","uri":"/posts/python/python%E6%95%99%E7%A8%8B/python%E8%A7%A3%E9%87%8A%E5%99%A8/"},{"categories":["Python"],"content":"解释器的运行环境 ","date":"2022-10-11","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/python%E8%A7%A3%E9%87%8A%E5%99%A8/:2:0","tags":["Python教程"],"title":"Python教程-Python解释器","uri":"/posts/python/python%E6%95%99%E7%A8%8B/python%E8%A7%A3%E9%87%8A%E5%99%A8/"},{"categories":["Python"],"content":"源文件的字符编码 默认情况下，Python 源码文件的编码是 UTF-8。如果不使用默认编码，则要声明文件的编码，文件的 第一 行写成特殊注释。句法如下： 1 # -*- coding: encoding -*- 源码以 UNIX “shebang” 行 开头(启动的shell程序以及python程序)时，编码声明要写在文件的第二行。 1 2 #!/usr/bin/env python3 # -*- coding: cp1252 -*- ","date":"2022-10-11","objectID":"/posts/python/python%E6%95%99%E7%A8%8B/python%E8%A7%A3%E9%87%8A%E5%99%A8/:2:1","tags":["Python教程"],"title":"Python教程-Python解释器","uri":"/posts/python/python%E6%95%99%E7%A8%8B/python%E8%A7%A3%E9%87%8A%E5%99%A8/"},{"categories":["Golang"],"content":"godoc github官网 该库的所有元素都是空接口类型，所以能够适用于任何数据。 一些简单数据结构使用go自带的数据类型即可 栈直接使用slice，优先队列可以用heap包，如果需要随机删除值则使用gods包的treemap（基于红黑树） 队列使用list包 单向hash使用自带map，如果需要双向则使用gods包的hashbidimap或treebidimap ","date":"2022-10-07","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gods/:0:0","tags":["go第三方库"],"title":"go第三方库-Gods","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gods/"},{"categories":["Golang"],"content":"TreeMap TreeMap 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \"github.com/emirpasic/gods/maps/treemap\" func main() { m := treemap.NewWithIntComparator() // empty (keys are of type int) m.Put(1, \"x\") // 1-\u003ex m.Put(2, \"b\") // 1-\u003ex, 2-\u003eb (in order) m.Put(1, \"a\") // 1-\u003ea, 2-\u003eb (in order) _, _ = m.Get(2) // b, true _, _ = m.Get(3) // nil, false _ = m.Values() // []interface {}{\"a\", \"b\"} (in order) _ = m.Keys() // []interface {}{1, 2} (in order) m.Remove(1) // 2-\u003eb m.Clear() // empty m.Empty() // true m.Size() // 0 // Other: m.Min() // Returns the minimum key and its value from map. m.Max() // Returns the maximum key and its value from map. } ","date":"2022-10-07","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gods/:1:0","tags":["go第三方库"],"title":"go第三方库-Gods","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gods/"},{"categories":["Golang"],"content":"HashBidiMap HashBidiMap 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import \"github.com/emirpasic/gods/maps/hashbidimap\" func main() { m := hashbidimap.New() // empty m.Put(1, \"x\") // 1-\u003ex m.Put(3, \"b\") // 1-\u003ex, 3-\u003eb (random order) m.Put(1, \"a\") // 1-\u003ea, 3-\u003eb (random order) m.Put(2, \"b\") // 1-\u003ea, 2-\u003eb (random order) _, _ = m.GetKey(\"a\") // 1, true _, _ = m.Get(2) // b, true _, _ = m.Get(3) // nil, false _ = m.Values() // []interface {}{\"a\", \"b\"} (random order) _ = m.Keys() // []interface {}{1, 2} (random order) m.Remove(1) // 2-\u003eb m.Clear() // empty m.Empty() // true m.Size() // 0 } ","date":"2022-10-07","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gods/:2:0","tags":["go第三方库"],"title":"go第三方库-Gods","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gods/"},{"categories":["Golang"],"content":"TreeBidiMap TreeBidiMap 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \"github.com/emirpasic/gods/maps/treebidimap\" \"github.com/emirpasic/gods/utils\" ) func main() { m := treebidimap.NewWith(utils.IntComparator, utils.StringComparator) m.Put(1, \"x\") // 1-\u003ex m.Put(3, \"b\") // 1-\u003ex, 3-\u003eb (ordered) m.Put(1, \"a\") // 1-\u003ea, 3-\u003eb (ordered) m.Put(2, \"b\") // 1-\u003ea, 2-\u003eb (ordered) _, _ = m.GetKey(\"a\") // 1, true _, _ = m.Get(2) // b, true _, _ = m.Get(3) // nil, false _ = m.Values() // []interface {}{\"a\", \"b\"} (ordered) _ = m.Keys() // []interface {}{1, 2} (ordered) m.Remove(1) // 2-\u003eb m.Clear() // empty m.Empty() // true m.Size() // 0 } ","date":"2022-10-07","objectID":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gods/:3:0","tags":["go第三方库"],"title":"go第三方库-Gods","uri":"/posts/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gods/"},{"categories":["Golang"],"content":"Hugo 配置官网 ","date":"2022-10-05","objectID":"/posts/golang/hugo/hugo%E8%A1%A5%E5%85%85/:0:0","tags":["hugo"],"title":"Hugo-Hugo补充","uri":"/posts/golang/hugo/hugo%E8%A1%A5%E5%85%85/"},{"categories":["Golang"],"content":"1. 关于使用内联Html元素被忽略 \u003c!-- raw HTML omitted --\u003e 需要添加选项 [markup.goldmark.renderer]\runsafe = true 之后就能使用了，详见stackoverflow ","date":"2022-10-05","objectID":"/posts/golang/hugo/hugo%E8%A1%A5%E5%85%85/:1:0","tags":["hugo"],"title":"Hugo-Hugo补充","uri":"/posts/golang/hugo/hugo%E8%A1%A5%E5%85%85/"},{"categories":["Golang"],"content":"2. 关于使用原型archetypes archetype用于hugo new post时使用某模板（包括markdown模板和目录模板），有两种使用方式 直接对content目录下一级目录的文章统一模板。 明确说明某目录使用目录模板或者某文章使用某markdown模板，使用--kind xxx选项 对于第一种情况，举个例子你在archetypes里面添加posts.md，然后content目录下的posts目录中的所有文章在使用hugo new posts/xxx都会应用该模板 对于第二种用法，你可以hugo new xxx --kind yyy 其中xxx是你要在content种新建的目录或者新建的文章，yyy是你要使用的模板格式是archetypes目录中的相对路径，对于文章的模板不需要加.md后缀，比如我要用JavaScript.md的模板，我们只需要使用JavaScript作为模板文件名就行了。对于目录，可以直接使用目录模板，比如我要把\"前端\"模板目录里面的所有文件应用到新建的目录中，我们需要使用\"前端\"作为模板目录。 其他详见hugo官网的说明 ","date":"2022-10-05","objectID":"/posts/golang/hugo/hugo%E8%A1%A5%E5%85%85/:2:0","tags":["hugo"],"title":"Hugo-Hugo补充","uri":"/posts/golang/hugo/hugo%E8%A1%A5%E5%85%85/"},{"categories":["Golang"],"content":"3.扩展Shortcodes ","date":"2022-10-05","objectID":"/posts/golang/hugo/hugo%E8%A1%A5%E5%85%85/:3:0","tags":["hugo"],"title":"Hugo-Hugo补充","uri":"/posts/golang/hugo/hugo%E8%A1%A5%E5%85%85/"},{"categories":["Golang"],"content":"1 style style shortcode 用来在你的文章中插入自定义样式. style shortcode 有两个位置参数. 第一个参数是自定义样式的内容. 它支持 SASS 中的嵌套语法, 并且 \u0026 指代这个父元素. 第二个参数是包裹你要更改样式的内容的 HTML 标签, 默认值是 div. 一个 style 示例: 1 This is a right-aligned paragraph. 1 comment\r","date":"2022-10-05","objectID":"/posts/golang/hugo/hugo%E8%A1%A5%E5%85%85/:3:1","tags":["hugo"],"title":"Hugo-Hugo补充","uri":"/posts/golang/hugo/hugo%E8%A1%A5%E5%85%85/"},{"categories":["Golang"],"content":"3. 目录显示级数设置 markup配置 loveit issue 添加网站设置 # 配置目录记录的等级\r[markup.tableOfContents]\rstartLevel = 2\rendLevel = 6 ","date":"2022-10-05","objectID":"/posts/golang/hugo/hugo%E8%A1%A5%E5%85%85/:4:0","tags":["hugo"],"title":"Hugo-Hugo补充","uri":"/posts/golang/hugo/hugo%E8%A1%A5%E5%85%85/"},{"categories":["Golang"],"content":"4. 代码高亮显示 loveit文档 在代码块```后面填写你需要显示的高亮语言类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ","date":"2022-10-05","objectID":"/posts/golang/hugo/hugo%E8%A1%A5%E5%85%85/:5:0","tags":["hugo"],"title":"Hugo-Hugo补充","uri":"/posts/golang/hugo/hugo%E8%A1%A5%E5%85%85/"},{"categories":["Golang"],"content":"5.搜索引擎检索 Sulv’s Blog Hugo博客seo优化 每篇博客文章设置标题、关键词、描述 config.toml文件设置站点描述 去各个搜索引擎平台进行站点搜索优化，即先添加站点，推荐使用文件添加将文件放到static即可，然后添加sitemap.xml 谷歌搜索，百度搜索，bing搜索可以直接导入谷歌账号 ","date":"2022-10-05","objectID":"/posts/golang/hugo/hugo%E8%A1%A5%E5%85%85/:6:0","tags":["hugo"],"title":"Hugo-Hugo补充","uri":"/posts/golang/hugo/hugo%E8%A1%A5%E5%85%85/"},{"categories":["Golang"],"content":"6.代码块设置 hugo官网 代码行号显示+代码拖动条 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 [markup] [markup.highlight] anchorLineNos = true codeFences = true guessSyntax = true hl_Lines = '' hl_inline = false lineAnchors = '' lineNoStart = 1 lineNos = true lineNumbersInTable = true noClasses = true noHl = false style = 'monokai' tabWidth = 4 ","date":"2022-10-05","objectID":"/posts/golang/hugo/hugo%E8%A1%A5%E5%85%85/:7:0","tags":["hugo"],"title":"Hugo-Hugo补充","uri":"/posts/golang/hugo/hugo%E8%A1%A5%E5%85%85/"},{"categories":["Golang"],"content":"7.博文里面引用static中的图片 将图片放到static目录里面，比如image/1.png，hugo会将static最终放到docs目录下，即直接放到静态文件的根目录下，所以我们引用的时候只需在md中写下： 1 ![](/image/1.png) 注意最开始有一个/ ","date":"2022-10-05","objectID":"/posts/golang/hugo/hugo%E8%A1%A5%E5%85%85/:8:0","tags":["hugo"],"title":"Hugo-Hugo补充","uri":"/posts/golang/hugo/hugo%E8%A1%A5%E5%85%85/"},{"categories":["Golang"],"content":"7.1 图片放大功能 loveit 文档 可以通过给图片加图注使得图片可以放大。 1 ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") 上面的\"The Stormtroopocat\"就是图注 ","date":"2022-10-05","objectID":"/posts/golang/hugo/hugo%E8%A1%A5%E5%85%85/:8:1","tags":["hugo"],"title":"Hugo-Hugo补充","uri":"/posts/golang/hugo/hugo%E8%A1%A5%E5%85%85/"},{"categories":["Golang"],"content":"8.引用站内文章 使用超链接，以根目录相对路径的形式写出目标url，比如文章posts/golang/go-zero/教程/looklook.md，我们的超链接地址写作/posts/golang/go-zero/教程/looklook/，甚至可以在后面添加锚点定位，比如加上#项目架构图和业务架构图。（当一个网页有多个重名锚点时会自动添加-n后缀，n表示第几个重复的锚点） 能这么做的原因是hugo的文章生成静态文件后content文件夹的内容直接生成到根目录。 另外static文件夹直接放到根目录，所以static的文件也可以通过相对路径直接引用在md中。 锚点强制使用小写，且空格使用-代替 ","date":"2022-10-05","objectID":"/posts/golang/hugo/hugo%E8%A1%A5%E5%85%85/:9:0","tags":["hugo"],"title":"Hugo-Hugo补充","uri":"/posts/golang/hugo/hugo%E8%A1%A5%E5%85%85/"},{"categories":["Golang"],"content":"9.评论系统 知乎 后端开发技术 Hugo添加Github评论踩坑指南 这里使用的是gitalk，它使用github issue进行评论存储，使用loveit主题，如果不是用的这个主题你需要按照知乎大佬说的配置 在github个人设置页面中，选择开发者设置 注册OAuth应用程序并填写信息，点击注册应用 记录ClientID和secret并填写到toml配置里面 如果你用的loveit主题那么到这里就结束了，不过需要你用自己的github账户打开博文才能开启issue，否则别人不能评论。 这里有一个大佬写了一个python脚本来实现自动化添加issue，个人博客 萧十一郎 Gitalk 初始化 issue ","date":"2022-10-05","objectID":"/posts/golang/hugo/hugo%E8%A1%A5%E5%85%85/:10:0","tags":["hugo"],"title":"Hugo-Hugo补充","uri":"/posts/golang/hugo/hugo%E8%A1%A5%E5%85%85/"},{"categories":["Golang"],"content":"10. 添加busuanzi访问计数插件 xwi88 博客 非常简单，分3步： 按大佬博客添加busuanzi.html插件 修改config.toml使用busuanzi插件 在single.html或者footer.html添加你要放置访问计数的位置 ","date":"2022-10-05","objectID":"/posts/golang/hugo/hugo%E8%A1%A5%E5%85%85/:11:0","tags":["hugo"],"title":"Hugo-Hugo补充","uri":"/posts/golang/hugo/hugo%E8%A1%A5%E5%85%85/"},{"categories":["Golang"],"content":"超链接注意事项 不要在标题里面使用超链接，这样生成的目录会直接带着超链接，点击目录会直接跳转到超链接无法通过目录定位标题 ","date":"2022-10-05","objectID":"/posts/golang/hugo/hugo%E8%A1%A5%E5%85%85/:12:0","tags":["hugo"],"title":"Hugo-Hugo补充","uri":"/posts/golang/hugo/hugo%E8%A1%A5%E5%85%85/"},{"categories":["Golang"],"content":"markdown语法 loveit官网 markdown官网 ","date":"2022-10-05","objectID":"/posts/golang/hugo/hugo%E8%A1%A5%E5%85%85/:13:0","tags":["hugo"],"title":"Hugo-Hugo补充","uri":"/posts/golang/hugo/hugo%E8%A1%A5%E5%85%85/"},{"categories":["Golang"],"content":"代码块中显示反引号 使用两个或以上反引号围住代码，就可以显示反引号了，需要使用空格间隔围住代码的反引号，且并不会在最后显示空格: 1 `` val=`expr 1 + 2` `` 显示结果为 val=`expr 1 + 2` ","date":"2022-10-05","objectID":"/posts/golang/hugo/hugo%E8%A1%A5%E5%85%85/:13:1","tags":["hugo"],"title":"Hugo-Hugo补充","uri":"/posts/golang/hugo/hugo%E8%A1%A5%E5%85%85/"},{"categories":["Golang"],"content":"使用Hugo + Github Pages搭建自己的博客 hugo官网,LoveIt官网 ","date":"2022-09-26","objectID":"/posts/golang/hugo/hugo%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/:0:0","tags":["hugo"],"title":"Hugo-建站教程","uri":"/posts/golang/hugo/hugo%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/"},{"categories":["Golang"],"content":"1 hugo安装 windows使用chocolatey安装 choco install hugo-extended -confirm 这里需要注意前置条件，要求先安装git，chocolatey和golang ","date":"2022-09-26","objectID":"/posts/golang/hugo/hugo%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/:1:0","tags":["hugo"],"title":"Hugo-建站教程","uri":"/posts/golang/hugo/hugo%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/"},{"categories":["Golang"],"content":"2 新建本地hugo站点 GitHub 页面有两种类型： 用户/组织页面 ( https://\u003cUSERNAME|ORGANIZATION\u003e.github.io/) 项目页面 ( https://\u003cUSERNAME|ORGANIZATION\u003e.github.io//) 一般情况我们都是创建用户/组织页面 ( https://\u003cUSERNAME|ORGANIZATION\u003e.github.io/)即在你的github上使用该格式命名新建一个仓库。 然后克隆到本地。在该仓库中使用如下代码初始化本地站点： hugo new site . --force 之后安装主题，首先到hugo主题官网上去选择一个漂亮的主题，打开主题文档页面，根据提示将主题安装到本地站点中，这里以LoveIt为例子： git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt 这样就能把主题下载到themes文件夹下了。 一般情况下，我们只需要配置config.toml，主题文档或者git仓库里面通常有默认config.toml，可以直接粘贴到你本地站点的config.toml。默认配置里面有详细的注释，你可以按需配置。 下一步就是更新你的博客内容了，使用如下命令添加一个新的文章： hugo new posts/first.md 这个命令会在你的content文件夹下的posts文件夹里创建一个first.md，这样你就成功创建了一个文章，你需要配置文章的属性，包括题目title，作者author，tag标签tags以及类别categories等。这些配置相关的内容你可以在主题文档里面找到示例，直接复制到你的文章下面，按需配置即可。 我们需要在本地启动服务运行一下站点，看看效果，使用如下命令： hugo server 该命令对于 draft=true 的文章并不会渲染，如果使用 hugo server -D 则将 draft=true 的文章也进行渲染，所以你需要将要渲染的文章的 draft 属性改为 false 或者直接使用后面一个命令。启动的服务能够进行热重载，每一次对文件的保存都会重启服务，所以你可以一边运行服务一边修改自己的内容或配置。 ","date":"2022-09-26","objectID":"/posts/golang/hugo/hugo%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/:2:0","tags":["hugo"],"title":"Hugo-建站教程","uri":"/posts/golang/hugo/hugo%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/"},{"categories":["Golang"],"content":"3 将本地站点部署到Github Pages 本地服务运行站点修改好后，在config.toml里面添加一个属性 publishDir = \"docs\" ，将输出的静态页面放置到docs文件夹里面，原因是Github Pages里面设置静态页面位置只能是仓库main分支本身或者main分支里面的docs文件夹，仓库本身存储我们的hugo站点，所以我们需要将输出的静态页面输出到docs文件夹。 还有一个需要修改的属性是 baseurl = \"https://xxx.github.io/\" ，将baseurl设置为自己的github页面url。 然后就可以使用命令输出静态页面： hugo 完成后，直接使用git推送到远程仓库： git push origin main 这里需要注意有一个坑，我们需要在本地站点根目录里面添加一个文件 .nojekyll 否则github将把这个仓库识别为一个jekyll驱动的页面，从而无法解析成功，最后的结果就是你打开你的github页面url展示的是你的readme.md的内容。加入这个空文件后可以避免这个情况。 然后打开git仓库的set页面，选择page选项将 Build and deployment 里 Branch 设置为main分支的docs文件夹。设置完后等一段时间就可以看到github以及帮我们把站点部署好了，你打开你的github页面url就可以看到你的博客。 至此你的个人博客就搭建好了，你可以在本地随时修改内容，之后只需要先使用 hugo 输出静态页面然后使用 git 推送到远程仓库即可。 ","date":"2022-09-26","objectID":"/posts/golang/hugo/hugo%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/:3:0","tags":["hugo"],"title":"Hugo-建站教程","uri":"/posts/golang/hugo/hugo%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"关于 Oublie","date":"2019-08-02","objectID":"/about/","tags":null,"title":"关于 Oublie","uri":"/about/"},{"categories":null,"content":"一个互联网漂泊者，在这个破碎的世界寻找自己的归宿。 ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"关于 Oublie","uri":"/about/"}]